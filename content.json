{"meta":{"title":"vkcya Blog","subtitle":"","description":"","author":"bluedancers","url":"https://bluedancers.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-12-09T01:09:47.587Z","updated":"2022-12-09T01:09:47.587Z","comments":true,"path":"about/index.html","permalink":"https://bluedancers.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233&#123; name: &quot;vkcyan&quot;, age: 24, gender: &quot;男&quot;, profession: &quot;Web Developer Leader &amp; Product Manager&quot;, experience: &quot;4年&quot;, address: &quot;安徽省合肥市&quot;, education: &quot;本科&quot;, github: &quot;https://github.com/vkcyan&quot;, blog: &quot;https://vkcyan.github.io&quot;, email: &quot;wu.vkcyan@gmail.com&quot;, description: &quot;一切都是为了实现技术的价值&quot;, skills: [ [&quot;Html&quot;, &quot;CSS&quot;, &quot;JavaScript&quot;, &quot;TypScript&quot;, &quot;ES6&quot;, &quot;Node&quot;], [&quot;Webpack&quot;, &quot;Vite&quot;], [&quot;Less&quot;, &quot;Sass&quot;], [&quot;Git&quot;], [&quot;Vue2.x&quot;, &quot;Vue3.x&quot;], [&quot;element-ui&quot;, &quot;element-plus&quot;, &quot;AntdV&quot;], [&quot;竞品分析&quot;, &quot;产品规划&quot;, &quot;挖掘用户需求&quot;, &quot;定制产品策略&quot;], ], devTools: [ [&quot;Visual Studio Code&quot;, &quot;Sublime Text&quot;], [&quot;Chrome DevTools&quot;, &quot;Fiddler&quot;], [&quot;SourceTree&quot;], [&quot;SwitchHosts&quot;], [&quot;Navicat&quot;, &quot;&quot;], [&quot;Sketch&quot;], [&quot;Typora&quot;], ],&#125;;"},{"title":"书籍","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"books/index.html","permalink":"https://bluedancers.github.io/books/index.html","excerpt":"","text":""},{"title":"类别","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"categories/index.html","permalink":"https://bluedancers.github.io/categories/index.html","excerpt":"","text":""},{"title":"存储库","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"repository/index.html","permalink":"https://bluedancers.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"links/index.html","permalink":"https://bluedancers.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-09T01:09:47.589Z","updated":"2022-12-09T01:09:47.589Z","comments":true,"path":"tags/index.html","permalink":"https://bluedancers.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue3硬核源码解析系列（6） 100行代码 实现mini版ref","slug":"关于vue3的研究/Vue3硬核源码解析系列（6） 100行代码 实现mini版ref","date":"2023-03-20T16:00:00.000Z","updated":"2023-03-21T07:24:27.993Z","comments":true,"path":"2023/03/21/关于vue3的研究/Vue3硬核源码解析系列（6） 100行代码 实现mini版ref/","link":"","permalink":"https://bluedancers.github.io/2023/03/21/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/","excerpt":"","text":"专栏前言​ 在上一节，我们完成了vue3的ref核心源码解读，其实基础类型的ref的核心逻辑还是非常简单的，但是增加复杂类型的支持后，其逻辑就有点复杂了，所以在我们的简易版源码环节，我们直接切入基础类型，复杂类型仅做支持，不做过多讲解。 ​ 仅保留最核心逻辑，极大减低阅读难度，100行代码实现ref，让我们直接源码实现环节。 ​ 单看基础类型的场景的ref源码，几乎可以说是整个vue3源码中最简单的一部分了，所以这一节的学习难度也可以说是最小的。 简易版vue3仓库地址，还请大家不要吝啬star，留个标记，下次迷路~ 逻辑图（基础类型） 完整版ref逻辑图，请看 Vue3硬核源码解析系列（5） ref源码解析 具体逻辑初始化ref的初始化非常简单，逻辑是这样的 判断传入对象是否已经是ref，如果是，这直接返回，如果不是，继续代码流程 ref的本质就是Class RefImpl 初始化RefImpl的时候将值保存到_value，同时将初始化保存到_rawValue 通过get value实现ref.value的访问 使用set value实现ref.value &#x3D; xx的更新逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 入口函数 */export function ref(value?: unknown) &#123; return createRef(value, false)&#125;function createRef(rawValue: unknown, shallow: boolean) &#123; // 判断是否已经是ref,如果是直接返回其本身 if (isRef(rawValue)) &#123; return rawValue &#125; // ref本质上就是RefImpl的实例 return new RefImpl(rawValue, shallow)&#125;class RefImpl&lt;T = any&gt; &#123; private _value: T // ref每次读取与返回的属性 private _rawValue: T // ref中value的原始属性 public dep: Dep | undefined // 当前ref相关effect public readonly __v_isRef: boolean = true // 标记__v_isRef为true,以后将无法在通过isRef()的判断 constructor(value: T, public readonly __v_isShallow: boolean) &#123; this._rawValue = value // 赋值原始值 // ref API中__v_isShallow,一定为false // 如果value是基础类型,则toReactive返回原值 // 如果value是复杂类型,则toReactive会将其处理成为reactive(proxy)再返回,这就意味着,此时的value是一个proxy this._value = __v_isShallow ? value : toReactive(value) // __v_isShallow 表示是否浅层代理 &#125; // 访问ref.value的时候触发 get value() &#123; // 配合effect阶段保存的activeEffect,将依赖收集到this.dep中 trackRefValue(this) // 返回最新value return this._value &#125; set value(newVal) &#123; // 判断当前set的value是否存在变化, 有变化则进入if if (hasChange(newVal, this._rawValue)) &#123; // 赋值最新原始值 this._rawValue = newVal // 如果value是基础类型, 则toReactive返回原始值 // 如果value是引用类型, 则通过toReactive将新的value其处理为proxy // 新的引用类型的value由于重新赋值, 与原本的effect在WeakMap中断了联系 // 但是马上触发的ref本身的dep依赖中,将会再次将新的value与effect通过WeakMao完成依赖收集 this._value = toReactive(newVal) // 触发get阶段收集在this.dep中的依赖 triggerRefValue(this) &#125; &#125;&#125; 依赖收集这个的参数ref即使上就是RefImpl本身，而RefImpl中确实存在dep，所以依赖收集的逻辑是这样的 每个触发get事件的时候，都会访问trackRefValue 假如是effect中被访问，这effect本身被保存到activeEffect中 假如RefImpl的dep是不存在的，这说明是第一次进行依赖收集，则通过createDep创建new Set() 将activeEffect，也就是当前正在运行的effect，添加到RefImpl的dep中，当前ref完成依赖收集 1234567891011121314151617181920212223/** * ref 依赖收集 */export function trackRefValue(ref: RefImpl) &#123; // 判断当前是否存在需要收集的依赖 if (activeEffect) &#123; // 判断RefImpl的实例中的dep是否被初始化过 if (!ref.dep) &#123; // 如果没有, 则赋值为Set ref.dep = createDep() &#125; // 将当前effect收集到当前RefImpl实例的dep中, 完成依赖收集 trackEffects(ref.dep) &#125;&#125;/** * * @param dep */export function trackEffects(dep: Dep) &#123; dep.add(activeEffect!)&#125; 依赖触发若干时间后，ref的value被更新，则会触发RefImpl的set value方法，在更新value的同时也会执行其内部的triggerRefValue，开始依赖触发逻辑 获取到当前RefImpl中的所有dep（依赖收集阶段收集到的所有依赖） 循环所有effect，并执行其fn，完成依赖触发。 12345678910111213141516171819202122232425262728/** * ref 依赖触发 */export function triggerRefValue(ref: RefImpl) &#123; // 当前当前RefImpl实例中是否存在收集的依赖 if (ref.dep) &#123; // 触发依赖 triggerEffects(ref.dep) &#125;&#125;/** * 处理所有待触发依赖 */export function triggerEffects(dep: Dep) &#123; // const effects = isArray(dep) ? dep : [...dep] const effects = [...dep] for (const effect of effects) &#123; triggerEffect(effect) &#125;&#125;/** * 触发执行依赖 */function triggerEffect(effect: ReactiveEffect) &#123; effect.fn()&#125; 如果传入的是对象？如果传入的是对象的话，其内部的对象将会被reactive处理为proxy，相关逻辑在Vue3硬核源码解析系列（5） ref源码解析有详细解释，有兴趣的小伙伴请去改文章查看吧。","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"chatGPT一些学习记录","slug":"日常/chatGPT一些学习记录","date":"2023-03-20T16:00:00.000Z","updated":"2023-03-21T10:12:22.049Z","comments":true,"path":"2023/03/21/日常/chatGPT一些学习记录/","link":"","permalink":"https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"最早​ 自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段文本做到深入的理解与分析，并生成高质量的语言表达。 ​ 那他究竟是什么原理呢？ ​ 从一段文本中，随机扣掉一部分字，然后模型不断学习此处到底应该填写什么，所谓学习与训练就是从大量的数据中学习理解复杂的上下文关系。 ​ 注：学习 无监督学习 训练 有监督学习 ​ bert的出现推动了自然语言处理领域的发展，在bert出现之前，我们都是基于规则与浅层神经网络（关键字理解）去解决，bert的出现使得深度学习在自然语言处理上得到了更加广泛的使用。 ​ 在bert出现之前，openid就出版了GPT1，GPT1也是基于Transformers进行实现，但是gpt没有走双向Transformers的方向，而是走类似单字接龙的方向，由长文单字接龙的自回归所生成，不过GPT1并没有出现bert的惊人效果，所以早期的GPT没啥热度。 GPT2 GPT3​ 基于bert的成就，大家都看到深度学习在语言模型上的可行性，于是大家都开始各种预训练模型，完形填空，判断题，改错题，GPT2、3也确实是这个思路，开始提升训练数据量，这个成果我们称之为开卷有益（无监督学习）。 ​ 让chatGPT对海量互联网文本做单字接龙，以扩充模型的词汇量、语言只是、世界的信息与知识。是chatGPT从哑巴鹦鹉变成了脑容量超大的懂王鹦鹉，这个和人类的学习其实很相似，小孩刚刚来到这个解释，就是不断的输入信息。 ​ 经过巨量的数据训练之后，我们下一步就需要情景学习（in-context learning），这两个阶段是NLP模型的基础工作流程，简单来说，就是让chatGPT对优质对话范例做单字接龙，以规范回答的对话模式和对话内容。是chatGPT变成懂规矩的博学鹦鹉，这里的场景标记几个就够了，机器一旦学会了规范，便可以应对此类所有问题。 关于强化学习（RL）​ 几年前，alpha go击败了柯洁，几乎说明了，经过强化学习，机器可以做到近乎人类极限的程度，但是这样的场景有一个前提，一个非常明确的奖惩机制，alpha go并不理解围棋规则，但是他可以接收到成功、失败的反馈，模型会根据反馈不断调整策略，已达到更多次成功的目的。 ​ 我们可以看到alpha go的强化学习规则书相对简单的，因为目标明确，而在NLP领域强化学习却很难实现。 ​ 因为NLP是语言，语言是没有固定的对错，这就意味着无法设定奖惩机制，除非人工来做反馈。 ​ openid还就这么干了，这被称之为 RLHF（Reinforcement Learning from Human Feedback） ​ openid公司找了40家外包公司，不断帮助gpt筛选什么是好的，什么是坏的，通过这种方式构建了一个奖励（reward）模型。 ​ 这样训练是为了让他学会举一反三的规律，开始出现类似人类的价值价值观与思考模式。 ​ 于是gpt通过这样奖励模型，开始感知到真实世界，开始了与真实世界的拟合。甚至可以说奖励模型就是gpt的母体，他对人类的理解不取决于世界，而是取决于模型。 ​ 这样引导学习的方式，在超大模型上出现惊人的效果，gpt在巨量的数据与规范 + 手动标注引导下，变成了看起来有心智的超级人工智能，甚至出现了理解、例子、思维链的能力。 ​ 这样的方式也是存在缺点的，比如缺点是可能混淆记忆，无法直接查看个更新所学，并且高度依赖学习材料 GPT对现今社会的可能影响​ chatGPT是里程碑的产品，就像流浪地球里面的行星发动机，刚开始大家都都不知道其潜力，经过验证后，地球上迅速出现了几万座行星发动机，并完成了最后的流浪地球，chatGPT这样大语言模型就像最开始几座行星发动机 ，最终也将会形成改变我们生活的推力 ​ 合理的使用大预言模型，就可以让一个普通人快速准确的触及各行各业的平均知识， 以及具体解法 ​ 所以我们可以畅想，未来我们也许不在需要学习如何打架，只需要对gpt发号施令，让机器去具体的做事即可 ​ 除了chatGPT本身具备对人类的能力输出，chatGPT具备我们人类不具备的一点，那就是他可以在语言中学会世界知识。 ​ 人脑是有限的，寿命是有限，个体死亡，一切都会消失，直到语言的发明，打通了过去与未来，知识以文字作为载体传承至今，一直以来我们通过纸质、或者其他物理形式进行存储，其效率是有限的，直到计算机的出现，我们开始用电子文档替代纸质， 信息传递的效率飞速提升，但是同时也带来了信息处理的巨大成本。 ​ 所以人工智能领域的自然语言技术应运而生（NLP），其目标就是让机器理解人类的语言，协助人类处理工作，这是人工智能领域非常重要的发展方向，虽然这些年发展缓慢，但是依旧被很多公司加以厚望，因为机器不需要作息，没有情绪，效率极高，可以为企业节省大量的成本。 与行业结合的可能性 搜索引擎，帮助用户更加精准的筛选信息 笔记工作结合，辅助阅读与写作 办公软件结合，辅助文字处理，数据分析，演示制作 教育培训结合，指定学习计划，寻找学习资料 开发工具结合，辅助编写业务代码，调试纠错 客服系统结合，全天候问答， 视频会议结合，会议记录，总结，谈话查找 审核机制结合，少选评论，统计舆论，给出提醒 行业顾问，提供法律，医疗，健身等等建议 社交媒体结合，帮助寻找兴趣相投的用户与话题 与视频音乐结合，个性化推荐视频、音乐、小说、动漫 游戏剧情结合，让NPC给玩家带来更加灵活的对话体验 GPT具备对文字行业巨大的改造潜力 学术界 创造知识 教育行业 传承知识 新闻行业 传播知识 ​ 还有对传统教育行业的巨大挑战，不是GPT可以给学生写作业，而是对现有的人才教育模式存在很大的冲击。 ​ 按照现在的教育模式（应试教育，传授既有知识）出来的学生，还能应对未来的5-10年的社会需求吗？ ​ 其实现在已经不太符合了，因为社会变化太快了，以前人们可以通过学习的知识终生受益，现在能满足毕业后5年其实都比较难了，因为知识过时的太快了，人们就需要不断学习新的知识。 ​ 正因如此，随着互联网时代的到来，终生学习的理念开始被人们推崇，同时教育模式也开始以【培养学习能力与创造能力】为主了，只有这样才能适应不断变化的时代。 试想一下你学习了20年，掌握了一些知识，但是GPT却可以瞬间替代你完成你的能力，怎么办？以后人人都有一个熟读人类既有知识的超级大脑，市场不会因为学校的禁用，而集体不使用。 ​ 任何事物都存在两面性，好的一面是，GPT将方便人来对既有知识进行集成，推进教育去培养高层次人才 GPT对网络安全的巨大挑战​ 因为GPT的第一阶段，需要大量录入信息，这其中的信息难免会存在一个坏的信息，亦或者军事机密等等信息，所以国家与国家之间很难愿意共享数据，这也意味着，在不就得将来每个有实力的国家都会自己研发大语言模型 ​ 同时在应用层面，大预言模型将会像口语、文字、电脑、互联网对社会进行再一次改造。 社会影响​ 只有会工具的人取代不会使用工具的人，没有工具取代人的说法，所以真正需要害怕的是，我们成为无法成为使用工具的人，时代的车轮势不可挡，抵触新工具就意味着落后，学20年干一辈子的时代已经逐渐远去，我们身处加速时期，必须学会终生学习 ​ GPT正在改变人类群体应用知识的方式与继承知识的方式，甚至未来可能会形成人机合作的科研，改变人类创造知识的方式，甚至步入下一个文明形态。 ​ 每个人的学习能力与理解能力，将是驾驭这项技术的瓶颈，也意味着是否可以充分发挥这一技术的优势， 名词解释bert（Bidirectional Encoder Representations from Transformers 双向编码变换器） ​ BERT 基于 Transformers 模型架构，使用双向编码器来训练深度双向表示，并在多项自然语言处理任务上实现了最先进的性能 浅层神经网络（Shallow Neural Network） ​ 浅层神经网络是一种神经网络，它只有一层或几层隐层，通常用于浅层特征学习和分类任务。与深层神经网络相比，浅层神经网络的参数量少，计算速度较快，但也可能会受到学习能力和表示能力的限制。 【UL】无监督学习（Unsupervised Learning） ​ 无监督学习是一种机器学习的范畴，其目的是在没有明确的标签或目标函数的情况下，从数据中发现隐藏的结构和规律。在无监督学习中，模型需要从数据中学习如何将数据分组、降维、聚类等。 【SL】有监督学习（Supervised Learning） ​ 有监督学习是一种机器学习的范畴，其目的是在有标签的训练数据上学习一个模型，使其能够预测新的数据。在有监督学习中，模型需要学习如何将输入映射到输出，并根据标签调整模型参数以提高预测性能。（特定的任务上进行微调，例如情感分析、文本分类、命名实体识别） 【RL】情景学习（Reinforcement Learning） ​ 情景学习是一种机器学习的范畴，其目的是通过试错来学习如何在特定的情景下做出正确的决策。在情景学习中，模型需要学习如何在不断尝试和反馈的过程中最大化累计奖励。 【NLP】自然语言处理技术（Natural Language Processing） ​ 自然语言处理技术是一种人工智能技术，旨在让计算机能够理解和生成自然语言。NLP 技术可以应用于文本分类、情感分析、机器翻译、问答系统等领域。 【LLM】大语言模型（Large Language Model） ​ 大语言模型是一种基于神经网络的自然语言处理模型，它可以处理大量的文本数据，并学习语言的语法和语义。目前的大语言模型通常使用预训练加微调的方式进行训练，并在各种自然语言处理任务中取得了很好的表现。 【MLLM】多模态大语言模型（Multi modal Large Language Model） ​ 多模态大语言模型是一种结合了自然语言处理和计算机视觉等多种模态的模型，旨在解决多模态数据的处理和理解问题。与传统的大语言模型不同，多模态大语言模型可以同时处理文字、图片、声音等不同类型的数据，并学习它们之间的交互和关联，从而提高自然语言处理和视觉任务的性能。 RLHF（Reinforcement Learning from Human Feedback 从人类反馈中强化学习） ​ 这是一种机器学习的方法，旨在通过与人类交互来提高强化学习算法的性能。在 RLHF 中，算法会在执行任务的过程中接收人类反馈，并将其作为一种奖励信号来调整自己的策略。与传统的强化学习不同，RLHF 可以在学习过程中快速地获得关于任务的准确信息，并且更容易被应用于实际场景中，如自动驾驶、机器人控制等。","categories":[{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/tags/chatGPT/"}]},{"title":"（3.1）vue3 手摸手实现mini版reactive.md","slug":"关于vue3的研究/Vue3硬核源码解析系列（4） 200行代码 实现mini版reactive + effect","date":"2023-03-12T16:00:00.000Z","updated":"2023-03-20T07:10:25.418Z","comments":true,"path":"2023/03/13/关于vue3的研究/Vue3硬核源码解析系列（4） 200行代码 实现mini版reactive + effect/","link":"","permalink":"https://bluedancers.github.io/2023/03/13/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/","excerpt":"","text":"专栏前言​ 在上一节，我们完成了vue3的reactive的核心源码解读，总的来说还是非常复杂，文章的表现能力有限，我想可能有很多同学无法完全理解其精髓，所以在本节，我将带领大家完成mini版本源码的输出。 ​ 仅保留最核心逻辑，极大减低阅读难度，200行代码实现reactive + effect，话不多说，我们直接开始！ 简易版vue3仓库地址，还请大家不要吝啬star，留个标记，下次迷路~ 逻辑图 逻辑流程reative初始化​ 将reactive处理为proxy，同时预先声明set get方法，赋值、取值均通过Reflect完成，get中存在track（依赖收集），set中存在trigger（依赖触发），完成reactive的初始化。 effect初始化（依赖收集） cb &#x3D; callback &#x3D; 回调函数 effect(() &#x3D;&gt; {}) &#x2F;&#x2F; () &#x3D;&gt; {} 就是cb ​ 初始化effect函数，通过一个类ReactiveEffect运行其cb，同时将当前cb存储到公共变量，cb中读取了reactive的属性，进而触发proxy的get，同时完成track（依赖收集），让reative收集到存储在公共变量中的effect的cb，至此完成依赖收集。 1重点：reactive - key - effect // 依赖收集完成后，将会形成这样的从上到下的可追溯关系 reactive改变（依赖触发）​ 若干时间后，reactive属性发生变化，触发reactive属性的赋值操作，进而触发proxy的set事件，同时完成trigger（依赖触发），根据指定的reative + key，找到特定effect运行，完成依赖触发，形成响应式。 1重点：reactive + key 找到指定effect，进而完成触发 具体逻辑proxy处理​ 经过真实的源码分析之后，我们都知道reactive实际上就是proxy，我们仿照源码的格式，将reactive经过proxy处理后返回就好了。 1234567891011121314151617181920212223// 缓存proxyconst reactiveMap = new WeakMap&lt;object, any&gt;()// 入口函数export function reactive(target: object) &#123; return createReactiveObject(target, mutableHandlers, reactiveMap)&#125;// 处理被代理对象function createReactiveObject( target: object, baseHandlers: ProxyHandler&lt;object&gt;, proxyMap: WeakMap&lt;object, any&gt;) &#123; // 如果已经被代理过,这直接返回结果 const existingProxy = proxyMap.get(target) if (existingProxy) &#123; return existingProxy &#125; const proxy = new Proxy(target, baseHandlers) proxyMap.set(target, proxy) return proxy&#125; get set函数编写​ 以上代码我们完成了变量的proxy处理，为了完成后续的响应式，我们需要预先声明好get set函数，我们依旧仿照源码格式，并只保留核心逻辑，get阶段返回结果，并触发（依赖收集）track，set阶段通过Reflect完成赋值，并触发（依赖触发）trigger 1234567891011121314151617181920212223242526272829export const mutableHandlers: ProxyHandler&lt;object&gt; = &#123; get, set,&#125;const get = createGetter()const set = createSetter()function createGetter() &#123; return function get(target: object, key: string, receiver: object) &#123; const res = Reflect.get(target, key, receiver) // 核心逻辑: 依赖收集 track(target, key) if (isObject(res)) &#123; return reactive(res) &#125; return res &#125;&#125;function createSetter() &#123; return function set(target: object, key: string, newValue: unknown, receiver: object) &#123; const res = Reflect.set(target, key, newValue, receiver) // 核心逻辑: 依赖触发 trigger(target, key, newValue) return res &#125;&#125; effect实现effect的核心的实现，就是在运行effect的时候保存当前的this，以便于后续流程中的依赖收集，所以其核心代码非常简单，保证一下2点即可。 运行effect本身 保存effect的fn到activeEffect即可 123456789101112131415161718export function effect&lt;T = any&gt;(fn: () =&gt; T) &#123; const _effect = new ReactiveEffect(fn) _effect.run()&#125;export let activeEffect: ReactiveEffect | undefinedexport class ReactiveEffect&lt;T = any&gt; &#123; constructor(public fn: () =&gt; T) &#123;&#125; run() &#123; try &#123; activeEffect = this return this.fn() &#125; finally &#123; activeEffect = undefined &#125; &#125;&#125; 依赖收集（track）按照时序，effect函数初始化阶段会执行，effect函数本身也会被保存到activeEffect中，同时触发effect中的reactive中的get事件，进而触发track，我们在track中完成 reactive- key - effect之间关系的构建，确保以后可以在set阶段找到指定的effet的fn即可。 1234567891011121314151617181920export function track(target: object, key: string) &#123; if (!activeEffect) &#123; return &#125; let depsMap = targetMap.get(target) if (!depsMap) &#123; depsMap = new Map() targetMap.set(target, depsMap) &#125; let dep = depsMap.get(key) if (!dep) &#123; dep = createDep() depsMap.set(key, dep) &#125; trackEffects(dep)&#125;function trackEffects(dep: Dep) &#123; dep.add(activeEffect!)&#125; 依赖触发（trigger）若干时间后，reative中的某个属性发生了变化，也就会发生set事件，这时候其实就很简单了，我们只需要通过reactive - key找到对应的effect的fn，然后执行即可。 这就形成了我们看到的“响应式”。 1234567891011121314151617181920212223export function trigger(target: object, key: string, newValue: unknown) &#123; let depsMap = targetMap.get(target) if (!depsMap) &#123; return &#125; const dep: Dep | undefined = depsMap.get(key) if (!dep) &#123; return &#125; triggerEffects(dep)&#125;function triggerEffects(dep: Dep) &#123; const effects = [...dep] for (const effect of effects) &#123; triggerEffect(effect) &#125;&#125;function triggerEffect(effect: ReactiveEffect) &#123; effect.fn()&#125; 最后​ 到此为止，我们简易版的reactive + effect的全部源码就完成了，虽然vue3的源码很复杂，但是我们抽丝剥茧，仅保留核心逻辑，大幅降低vue3源码阅读的难度，让绝大多数的前端开发者都可以读懂核心实现~ ​ 最后，建议大家clone源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，然后在简历上留下浓墨重彩的一笔~","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"","slug":"解决方案/Vue3版后台鉴权之动态路由方案来了！","date":"2023-02-20T03:50:52.159Z","updated":"2023-03-14T10:55:37.269Z","comments":true,"path":"2023/02/20/解决方案/Vue3版后台鉴权之动态路由方案来了！/","link":"","permalink":"https://bluedancers.github.io/2023/02/20/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Vue3%E7%89%88%E5%90%8E%E5%8F%B0%E9%89%B4%E6%9D%83%E4%B9%8B%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%96%B9%E6%A1%88%E6%9D%A5%E4%BA%86%EF%BC%81/","excerpt":"","text":"Vue3版 更简单的后台鉴权-动态路由方案！前言​ 在3年前我发布了一篇vue2后台管理系统动态路由方案，时至今日，vue2已经升级到了vue3，动态路由的实现方案我也做出了一些升级迭代，来帮助开发者更好的完成业务需求。 更加简单的实现逻辑 更加便捷的路由配置 vue2时期采用的技术方案特点 前端只存储基础的路由树 根据不同的登录角色，返回其对应的可访问路由树 前端获取到路由树（JSON）后递归处理，再通过addRouters拼接到基础路由书，完成动态路由 优点 相当安全，不允许访问的路由直接是不存在的。 缺点 代码中仅保存了基础路由，所有的业务路由都需要前端开发人员手动录入到系统之中，非常繁琐 客户端逻辑相对复杂，需要递归路由树、addRouters，技术难度相对较大。 有没有什么办法，可以既保证系统安全性，也保证代码逻辑的简单性，同时保证前端开发者的便捷性呢？ 话都说到这里了，那肯定是有的了。 具体方案​ 通过以上分析，我们首先可以明确一点，动态路由的配置数据是需要放在前端项目中，而不是将路由的全部配置信息录入到系统中， ​ 不过动态路由的树形结构还是需要录入到系统中，并进行维护的。 当我们的路由树交换给前端项目之后，我们也不需要做addRouters了，从开发者的角度来看，这样很不错。 那么在这样的前提下，我们如何实现动态路由的方案呢？ 实现思路​ 首先将我们的全部路由分成2部分，基础路由数组，动态路由数组； ​ 我们项目的pinia中维护一个路由权限数组，如果当前用户访问的路由name在数组中，则允许访问，如果当前路由name不在权限数组中，这认为其没有权限访问。 当触发登录行为的时候，请求服务端，获取当前用户的权限数组（一维），然后权限数组配合动态路由数组，递归出需要显示在侧边栏的路由，同时将权限数组保存到pinia之中。 路由发生跳转的时候，首先判断是否登录状态，如果不是，这直接重定向到登录页面；如果已经登录，则判断当前跳转的路由name是否在权限数组中，如果存在，则正常跳转，如果存在，则直接进入404页面。 刷新页面场景，则会重新获取一次权限数组。 具体实现客户端的录入全部路由服务端返回登录角色权限数组客户端反向for循环，计算出侧边栏菜单每次router.beforeEach的进行权限判断刷新页面重新获取权限数组","categories":[],"tags":[]},{"title":"（7）vue3 runtime-dom源码解析","slug":"关于vue3的研究/（7）vue3 runtime-dom源码解析","date":"2023-02-17T16:00:00.000Z","updated":"2023-02-18T06:21:38.073Z","comments":true,"path":"2023/02/18/关于vue3的研究/（7）vue3 runtime-dom源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/18/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/%EF%BC%887%EF%BC%89vue3%20runtime-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"html叫做DOM节点数 vdom是正式dom的JavaScript数据结构的描述 在运行时runtime中，渲染器rerender会遍历整个虚拟dom树，并根据此结构构建正式dom树，这个过程我们称之为mount 当vnode发生变化的时候，，我们会对比旧的vnode与新的vnode，找出他们的区别，并应用于真实dom上，这个过程我们称之为patch。","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）","slug":"解决方案/webpack、vite在proxy中动态设置headers","date":"2023-02-16T16:00:00.000Z","updated":"2023-02-18T08:16:39.254Z","comments":true,"path":"2023/02/17/解决方案/webpack、vite在proxy中动态设置headers/","link":"","permalink":"https://bluedancers.github.io/2023/02/17/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/webpack%E3%80%81vite%E5%9C%A8proxy%E4%B8%AD%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEheaders/","excerpt":"","text":"通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）前言大家都知道，利用webpack、vite的proxy可以解决开发环境的跨域问题。 但是在真实开发场景下，我们可能不仅要面对跨域问题，还有可能面对动态header的情况。 让我们来看如下案例 案例强盛集团开发了一套多店铺的H5商城系统，此时小安 小龙 小虎，都想利用这个系统开一个线上商城，我们如何区分他们的店铺呢？ 聪明的同学肯定已经想到了答案，用二级域名进行区分 123小安 -&gt; xa.shop.com小龙 -&gt; xl.shop.com小虎 -&gt; xh.shop.com 接下来让我们把视角聚焦到强盛集团的技术部门。 面对这样的多店铺商城系统，开发环境肯定无法用ip直接访问了，因为ip无法识别具体是什么店铺。 这个问题其实也很好解决，修改本地host即可 123127.0.0.1 xa.shop.com127.0.0.1 xl.shop.com127.0.0.1 xh.shop.com 假设我们开发环境的端口是8082，我们想在开发环境访问小安的店铺，则通过xa.shop.com:8082进行访问。 ​ 直到某一天，安全部门发现了沙海集团的的scrf恶意攻击，决定限制该产品请求发起方的Origin Header与Referer Header，并且限制了必须是80端口。 这两个请求头的含义是标记来源域名，可以起到防止scrf攻击的目的。 ​ 此时前端开发就麻烦了，因为在开发环境，我们的Origin Header与Referer Header都是x.shop.com:8082，这会被服务端识别为不合法的请求来源，同时因为浏览器安全限制，前端是不具备直接修改referer头的能力， 除非将项目端口号改为80端口，但是这并不是一个好办法。 如果你是强盛集团的前端开发，你会怎么解决以上问题呢？ 后端高某强提供的思路​ 后端开发高某强这时候提供了一个想法，通过本地nginx代理8082端口就好了呀。 在开发机器本地启动一个nginx 通过nginx将x.shop.com指向127.0.0.1:8082 同时配合host的修改，实现开发环境去端口的诉求。 后续，我尝试了这个方案，确实是可以实现的，也在团队中推广并使用了一段时间； 但是长期使用下就暴露了一些问题 每次新增一个站点，都需要同时增加host、nginx中的配置，流程复杂。 并不是每个前端都了解nginx，初级开发非常容易出问题，增加团队内耗。 proxy解决方案Vite解决方案​ 直到某一天，我在vite的文档中突然发现一个细节，server.proxy的实现依赖node-http-proxy，而这个库具备设置请求头的能力 ​ 如果是这样，我是否可以在开发环境通过proxy代理请求接口，同时覆写Origin Header与Referer Header的方式来解决我们遇到的多域名+端口限制问题呢？进而在开发环境规避掉nginx。 ​ 通过vite的问题可以了解到参数configure可以编写http-proxy相关逻辑，再结合http-proxy文档，我们便可以完成相关代码。 1234567891011121314151617181920server: &#123; // ..... proxy: &#123; &#x27;/client&#x27;: &#123; target: &#x27;https://api.xxxx.com&#x27;, // 需要代理的地址 changeOrigin: true, secure: true, // 如果是https接口，需要配置这个参数 rewrite: (path) =&gt; path.replace(/^\\/client/, &#x27;&#x27;), configure: (proxy) =&gt; &#123; proxy.on(&#x27;proxyReq&#x27;, (proxyReq, req, res) =&gt; &#123; // req是当前真实请求的地址 开发环境为：a.shop.com:8082 let host = req.headers.host!.split(&#x27;:&#x27;)[0] // a.shop.com 动态获取当前请求地址，并去除端口 proxyReq.setHeader(&#x27;referer&#x27;, `http://$&#123;host&#125;`) proxyReq.setHeader(&#x27;origin&#x27;, `http://$&#123;host&#125;`) &#125;) &#125;, &#125;, &#125;, // .....&#125;, ​ 测试结果符合预期，web端请求被proxy代理，并在代理请求中完成了端口的去除，符合了服务端对Origin Header与Referer Header的要求。 Webpack解决方案​ vite测试成功后，我们便开始对webpack的vue2.x项目proxy动态headers进行评估；通过webpack4的文档，我们可以了解到webpack4的proxy是基于http-proxy-middleware 进行实现。 ​ 接下来我们也顺利在http-proxy-middleware文档中找到相关配置 我们基于webpack与http-proxy-middleware的文档，就可以很顺利的做产出了。 1234567891011121314151617devServer: &#123;// .... proxy: &#123; &#x27;/client&#x27;: &#123; target: &#x27;https://api.xxxx.com&#x27;, // 需要代理的地址 changeOrigin: true, //是否跨域 secure: true, // 如果是https接口，需要配置这个参数 pathRewrite: &#123; &#x27;^/client&#x27;: &#x27;&#x27; &#125;, onProxyReq: (proxyReq, req, res) =&gt; &#123; let host = req.headers.host.split(&#x27;:&#x27;)[0] proxyReq.setHeader(&#x27;referer&#x27;, `http://$&#123;host&#125;`) //添加请求头 proxyReq.setHeader(&#x27;origin&#x27;, `http://$&#123;host&#125;`) //添加请求头 &#125;, &#125;, &#125;, // .....&#125;, ​ 项目配置完成后，我们便可以在开发环境利用proxy的动态headers完成a.shop.com:8082正常访问线上端口了，只需要在本地配置host即可。 结语高某强了解到前端部门使用proxy + 动态headers方案后，连连称赞，表示请我去他家吃鱼。 如果你也遇到了类似的问题，快来试试proxy的解决方案吧~","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"关于proxy","slug":"关于proxy","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8Eproxy/"}]},{"title":"（6）vue3 reactivity-watch源码解析","slug":"关于vue3的研究/（6）vue3 reactivity-watch源码解析","date":"2023-02-13T16:00:00.000Z","updated":"2023-03-01T11:59:35.475Z","comments":true,"path":"2023/02/14/关于vue3的研究/（6）vue3 reactivity-watch源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/14/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/%EF%BC%886%EF%BC%89vue3%20reactivity-watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 上一章我们说完了computed的实现逻辑，今天就让我们来看看他的好兄弟，也是我们经常用的另一个api，watch是如何实现的； ​ watch即为监听的意思：监听响应式数据，每当状态发生变化，就会触发回调函数。 ​ 如果大家对之前的源码分析有所理解的话，我相信大家可以简单猜到watch的实现原理，一定是初始化的时候依赖收集，依赖项发生变化的时候依赖触发。 ​ 如果能领悟到这一层，那么对vue3的核心实现你已经有所理解啦。 ​ 接下来就让我们走进watch的世界，让我们看看，vue3是如何实现他的吧。 带着问题看源码起初我刚开始使用vue3 watch的时候，就出现了让我非常迷糊的情况，举个例子 12345678910111213141516171819// reactive的案例const user = reactive(&#123; name: &#x27;卖鱼强&#x27; &#125;)watch(user, (value) =&gt; console.log(&#x27;第一&#x27;, value)) // 有效watch(user.name, (value) =&gt; console.log(&#x27;第二&#x27;, value)) // 无效watch(() =&gt; user, (value) =&gt; console.log(&#x27;第三&#x27;, value))// 无效watch(() =&gt; user.name, (value) =&gt; console.log(&#x27;第四&#x27;, value))// 有效user.name = &#x27;狂飙强&#x27; // 修改reactive 期望触发watch// ref案例const user = ref(&#x27;卖鱼强&#x27;)watch(user, value =&gt; console.log(&#x27;第一个watch&#x27;, value)) // 有效watch(user.value, value =&gt; console.log(&#x27;第二个watch&#x27;, value)) // 无效watch(() =&gt; user, value =&gt; console.log(&#x27;第三次watch&#x27;, value)) // 无效watch(() =&gt; user.value, value =&gt; console.log(&#x27;第四次watch&#x27;, value)) // 有效user.value = &#x27;狂飙强&#x27; // 修改reactive 期望触发watch ​ 以上案例，我相信大部分写vue的同学，都很难在第一时间准确判断有效无效，这样的问题，我们就需要去源码中寻找答案。 正文watch的源码并不在reactivity中，而是在runtime-core中 watch初始化123456789101112export function watch&lt;T = any, Immediate extends Readonly&lt;boolean&gt; = false&gt;( source: T | WatchSource&lt;T&gt;, cb: any, options?: WatchOptions): WatchStopHandle &#123; return doWatch(source as any, cb, options)&#125;export interface WatchOptions &#123; immediate?: boolean deep?: boolean&#125; 通过以上代码，我们可以了解watch是存在三个参数的 source 默认类型为any，这一项就是我们的监听项 cb，也就是我们的watch的回调函数 options 关于watch的设置，内部存在2个参数 immediate boolean类型 是否首次运行 deep boolean类型 是否深度监听 ​ 这些消息和我们通过Vue文档了解到的信息基本一致，然后我们继续往下看，会发现实际返回了一个doWatch函数，并将watch的三个参数传递了进去。 ​ doWatch里面的代码比较复杂，所以我们我们将初始化阶段再分为三个阶段，分别于三个参数对应 监听项分析ref12345if (isRef(source)) &#123; // 如果当前source的值是ref, 则处理为() =&gt; source.value 这里注意const num = ref(1) num是ref，num，value不是ref getter = () =&gt; source.value forceTrigger = isShallow(source) // 判断是否是浅层的监听&#125; reactive123456if (isReactive(source)) &#123; // 如果是reactive则,直接处理成() =&gt; source getter = () =&gt; source // 同时将deep赋值为true 因为reactive可能多层嵌套需要深度递归 deep = true&#125; Array12345678910111213141516171819202122if (isArray(source)) &#123; isMultiSource = true // 标识为多个监听项 forceTrigger = source.some(s =&gt; isReactive(s) || isShallow(s)) // 标识是否是浅层监听 // getter 函数处理为对source的map循环返回结果 getter = () =&gt; source.map(s =&gt; &#123; if (isRef(s)) &#123; return s.value &#125; else if (isReactive(s)) &#123; return traverse(s) &#125; else if (isFunction(s)) &#123; return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER) &#125; else &#123; __DEV__ &amp;&amp; warnInvalidSource(s) &#125; &#125;)&#125;export function callWithErrorHandling(fn,instance,type,) &#123; return fn()&#125; Function1234if (isFunction(source)) &#123; // callWithErrorHandling函数实际上就是返回了source函数本身 getter = () =&gt; callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)&#125; 未知类型123export const NOOP = () =&gt; &#123;&#125;getter = NOOP // 如果watch的第一个参数不是以上类型，这起getter函数为空 第一个参数的目的是为了完成后续的依赖收集，所以getter的返回值必须是proxy对象，不能是基础对象，否则将无法完成期望的依赖收集。 看到这里我们文章开头提出的问题已经有了明确答案，我们回过头来继续看看 12345678910const user = reactive(&#123; name: &#x27;卖鱼强&#x27; &#125;)watch user// user是reactive，将会被处理为（）=&gt; user，同时deep参数设置为true，reactive中的所有依赖都将会触发依赖收集，watch有效watch user.name// name是reactive内的基础对象，将会被识别为未知类型，自然watch无效watch () =&gt; user// 函数直接返回，并未访问proxy的属性，无法完成依赖收集，所以watch无效watch () =&gt; user.name// 函数直接返回 而user.name是proxy下的属性，将会触发get，完成依赖收集，所以watch有效 构建ReactiveEffect 这一小节，我们将了解到watch是如何完成依赖触发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253if (cb &amp;&amp; deep) &#123; // 如果deep为true,则获取到() =&gt; source const baseGetter = getter getter = () =&gt; traverse(baseGetter()) // traverse函数比较复杂，其作用就是深度递归对象，以此触发reactive中每个属性的get行为&#125;// 非数组的情况下isMultiSource一定为false 所以oldValue这里一定是空对象let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE // watch的核心实现const job: SchedulerJob = () =&gt; &#123; // 内部逻辑非常复杂，我们这里简化处理 const newValue = effect.run() // 如果deep为true 或者新旧值不一致则将新旧值传入到cb中（watch的第二个参数） if (deep || hasChange(newValue, oldValue)) &#123; cb(newValue, oldValue) &#125;&#125;let scheduler: EffectScheduler// flush 回调的刷新时机 // 默认pre 即组件更新之前调用 queuePreFlushCb// post 则是组件更新之后调用(可以获取到更新后的dom) queuePostRenderEffect// 如果是sync则异步调用 job本身// queuePreFlushCb queuePostRenderEffect 后续再说if (flush === &#x27;sync&#x27;) &#123; scheduler = job as any // the scheduler function gets called directly&#125; else if (flush === &#x27;post&#x27;) &#123; scheduler = () =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)&#125; else &#123; // default: &#x27;pre&#x27; scheduler = () =&gt; queuePreFlushCb(job)&#125;// getter为具备返回响应式能力的函数 scheduler是确定了执行实际的cb函数const effect = new ReactiveEffect(getter, scheduler)if (cb) &#123; // 如果immediate为true,则代表默认watch初始化阶段自动执行一次 if (immediate) &#123; job() // job内部也会运行一次effect.run 只不过同时也执行了cb函数 完成了第一次watch的触发 &#125; else &#123; // 关键步骤 执行一次proxy的get行为,将当前除触发watch的监听数据的依赖收集，并将ReactiveEffect与watch的依赖项完成绑定 // 同时获取一次oldvalue的值（watch变化之前的值） oldValue = effect.run() &#125;&#125;return () =&gt; &#123; // 返回了effect的stop函数，则意味着，watch api存在返回值，只需要执行一下返回值 就会结束掉watch的监听 effect.stop()&#125; 依赖触发asyncprepost watch初始化，生成ReactiveEffect，并将watch的匿名函数（cb）放入ReactiveEffect的scheduler中 触发一次watch的第一个参数，完成依赖收集（proxy与watch建立联系） proxy发生变化，触发watch的ReactiveEffect的scheduler，也就是watch初始化阶段传入的cb cb按照指定flush开始执行，完成watch监听函数的触发。 ​ 其实通过以上流程我们可以发现watch的原理相对来说竟然是最简单的，watch的复杂并不在于核心逻辑的复杂，而是其内部进行了大量兼容性判断，多种类型的第一参数，多种类型的第三参数，导致整体代码的复杂度极高。 特点 watch的依赖收集是被动触发的 watch的依赖触发，实际上是调度器scheduler，然后通过不同的flush，达到控制执行顺序、规则的目的。","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"Vue3硬核源码解析系列（5）ref源码解析","slug":"关于vue3的研究/Vue3硬核源码解析系列（5） ref源码解析","date":"2023-02-02T16:00:00.000Z","updated":"2023-03-21T09:37:42.175Z","comments":true,"path":"2023/02/03/关于vue3的研究/Vue3硬核源码解析系列（5） ref源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/03/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%20ref%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 本文是Vue3硬核源码解析系列的第五篇文章，在之前文章中，我们了解到了reactive effect的源码实现原理，并抽丝剥茧输出了mini版本的reactive + effect，带领大家充分理解reactive的实现原理，同时我们也发现了reactive在使用上的一些局限性，比如无法代理基础类型。 ​ 正因为此，Vue3提供了另一个API ref，面对proxy无法代理基础类型数据的问题，ref又是如何实现其响应式的呢，本文将带领大家一起走进vue3源码世界，看看ref的实现原理 逻辑图因为ref既可以传入基础类型，也可以传入复杂类型，所以其实现逻辑要比reactive更加复杂，并且依赖reactive。 前置知识 如果关于class get set已经很了解，请跳过前置知识 为了降低大家理解ref源码的难度，我们在正式阅读源码之前，先学习一下JavaScript的 class以及修饰符get set相关知识点 12345678910111213class Obj &#123; _value = &#x27;张三&#x27; get value() &#123; console.log(&#x27;value的get行为触发&#x27;) return this._value &#125; set value(val) &#123; console.log(&#x27;value的set行为触发&#x27;, val) this._value = val &#125;&#125;let obj = new Obj() get： 被get修饰的方法，允许通过属性读取的方式，触发方法 set： 被set修饰的方法，允许通过属性赋值的方式，触发方法 当访问obj.value的时候，会执行被get修饰的value()，打印log，并得到返回值‘张三’ 当我们执行obj.value = ’李四‘，进行赋值的时候，将会执行被set修饰的**value()**方法，打印log，并完成变量_value的赋值 ​ 看到这里，大家是否有点似曾相识的感觉，访问与赋值触发get set，和proxy代理的对象的get set很相似，大家能理解到这一点就足够了。 ​ 因为ref可以代理简单类型，同时也可以代理复杂类型，并且这两种情况下的响应式实现逻辑是完全不同的。 ​ 所以接下来，我们从这两个角度分别解读ref的源码实现，以及其核心逻辑。 ​ 首先我们看相对简单的基础类型场景，从源码的角度去了解ref是如何实现响应式的。 基础类型场景案例12345678910let &#123; ref, effect &#125; = Vueconst name = ref(&#x27;卖鱼强&#x27;)effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = name.value&#125;)setTimeout(() =&gt; &#123; name.value = &#x27;狂飙强&#x27;&#125;, 2000) ​ 上述代码现象： 页面初始化的时候显示“卖鱼强” 2s之后，name发生改变，变成了“狂飙强”。 通过现象与我们之前分析reactive的经验，这个我们可以将ref的实现分为三大模块 初始化 读取（依赖收集） 赋值（依赖触发） 初始化packages/reactivity/src/ref.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export function ref(value?: unknown) &#123; // ref 实际上就是createRef return createRef(value, false)&#125;function createRef(rawValue: unknown, shallow: boolean) &#123; // 如果已经是ref，则直接返回 if (isRef(rawValue)) &#123; return rawValue &#125; // ref API 参数shallow 为 false 含义是 代理是否是浅层的,浅层则只会代理第一层数据 // ref 就是RefImpl的实例 return new RefImpl(rawValue, shallow)&#125;class RefImpl&lt;T&gt; &#123; private _value: T // 被代理对象 private _rawValue: T // 原始对象 public dep?: Dep = undefined // Dep是reative阶段声明的Set, 内部存放的是ReactiveEffect public readonly __v_isRef = true // 将RefImpl实例默认为true, 未来的isRef判断就一定为true constructor(value: T, public readonly __v_isShallow: boolean) &#123; // 寻找原始类型，如果是基础类型不会做任何处理 this._rawValue = toRaw(value) // 如果value是基础类型，toReactive内部不会做任何处理 this._value = toReactive(value) &#125; get value() &#123; return this._value &#125; set value(newVal) &#123; newVal = toRaw(newVal) // 判断新旧值是否一致，不一致进入if if (hasChanged(newVal, this._rawValue)) &#123; // 每次value的值发生修改的时候，都保存一下原始对象 this._rawValue = newVal // 如果value是基础类型 toReactive不会做任何处理 // 如果value是复杂类型，则重新进行proxy处理 this._value = toReactive(newVal) // 依赖触发，后面单独说 &#125; &#125;&#125; 通过源码分析，我们可以发现，ref的本质就是new RefImpl 我们ref传入的参数 原始对象被保存到_rawValue，同时将参数（“卖鱼强”）保存到-value中，便于后续的get set 读取调用name.value的时候，会触发RefImpl的**get value()**，方法内部返回最新的_value，完成读取。 12345get value() &#123; // trackRefValue(this) // 依赖收集，后面单独说 return this._value&#125; 赋值name.value发生赋值的时候，会触发RefImpl的**set value()**方法，方法内部进行_value的赋值，完成数据更新。 123456789set value(newVal) &#123; // 判断新旧值是否一致，不一致进入if if (hasChanged(newVal, this._rawValue)) &#123; // 如果value是基础类型 toReactive不会做任何处理 this._value = toReactive(newVal) // triggerRefValue(this)// 依赖触发，后面单独说 &#125;&#125; 到此为止，ref的基础逻辑就完成，我们已经具备给ref赋值、读取的能力。 但是还不具备响应式的能力，接下来就让我们看看，ref的响应式系统是如何实现的。 依赖收集（trackRefValue）​ 根据我们解读reactive的源码经验，我们可以猜到，ref一定是在get中完成依赖收集的，事实也是如此。 ​ 而第一次ref的get是何时触发的呢？ ​ 答案是初始化时期的effect，effect触发后，内部fn被保存到activeEffect中，并触发fn，fn访问了name.value，触发了ref的get行为，所以接下来我们前往RefImpl的get中，看看ref是如何完成依赖收集的。 12345678910111213141516171819get value() &#123; // 依赖收集函数 将当前RefImpl实例传入方法 trackRefValue(this) return this._value&#125;export function trackRefValue(ref) &#123; // shouldTrack一定为true，activeEffect在effect执行阶段保存了fn，所以一定存在 if (shouldTrack &amp;&amp; activeEffect) &#123; // createDep我们在reactive中见过，含义为创建一个Set // 所以这个实际函数是给RefImpl实例的dep赋值为Set，然后在传入trackEffects方法 trackEffects(ref.dep || (ref.dep = createDep())) &#125;&#125;export function trackEffects(dep: Dep,) &#123; // 将当前activeEffect，也就是effect的fn，保存到当前RefImpl实例的dep中，effect成功被ref依赖收集到实例的dep中 dep.add(activeEffect)&#125; 通过以上源码，我们可以发现，他们都公用了activeEffect部分的逻辑，但是ref收集依赖的方式与reactive是存在一些差别的 reactive的依赖收集通过WeakMap完成，实现属性、变量与effect fn的绑定关系 ref则通过自身实例内部的dep变量来保存所有相关的effect fn 依赖触发（triggerRefValue）若干时间后，name.value的值被修改，触发RefImpl的set value 1234567891011121314151617181920212223242526272829set value(newVal) &#123; // 判断传入值是否与原始值不一致 if (hasChanged(newVal, this._rawValue)) &#123; // 完成赋值 this._value = toReactive(newVal) // 依赖触发 triggerRefValue(this) &#125;&#125;export function triggerRefValue(ref: RefBase&lt;any&gt;) &#123; if (ref.dep) &#123; // dep为依赖收集阶段收集到的依赖，内部为effect的fn triggerEffects(ref.dep) &#125;&#125;export function triggerEffects(dep: Dep) &#123; const effects = isArray(dep) ? dep : [...dep] // 转为数组 for (const effect of effects) &#123; // 进入依赖触发函数 triggerEffect(effect) &#125;&#125;function triggerEffect(effect: ReactiveEffect) &#123; // 依次通过run触发被收集的effect的fn，至此完成依赖触发工作 effect.run()&#125; 依赖触发的逻辑就非常简单了，set value的同时，获取当前ref的dep，并遍历dep中的依赖，依次执行，完成依赖触发。 小结​ 到此为止，我们基础类型场景的ref源码解读就结束了，我们简单做一下总结， ​ 相比较于reactive，该场景下的逻辑要稍微简单一点，相关依赖（effect fn）被实例本身的dep管理，没有构建复杂的WeakMap对象。 ref与reactive的收集与触发的逻辑也不相同 ref实际上是一个class RefImpl的实例 数据响应并不是通过proxy实现，而是通过class 的get set修饰符实现 依赖收集、触发并不是通过WeakMap实现，而是通过RefImpl实例中的变量dep实现 复杂类型场景​ 大家都知道ref不仅可以实现基础类型的响应式，还可以实现复杂类型的响应式，我们可以说ref是reactive的超集，那ref是如何实现既支持基础类型也支持复杂类型的呢？ ​ 接下来就让我们看看复杂类型场景下的ref是如何完成响应式的吧。 案例12345678910111213let &#123; ref, effect &#125; = Vueconst obj = ref(&#123; name: &#x27;卖鱼强&#x27;&#125;)effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = obj.value.name&#125;)setTimeout(() =&gt; &#123; obj.value.name = &#x27;狂飙强&#x27;&#125;, 4000) Ref初始化首先依旧是进入ref函数中，开始new RefImpl，前面流程完全一致，所以直接我们进入RefImpl内部 12345678910111213141516171819class RefImpl&lt;T&gt; &#123; private _value: T // 被代理对象 private _rawValue: T public dep?: Dep = undefined // Dep是reative阶段声明的Set,内部存放的是ReactiveEffect public readonly __v_isRef = true // 将RefImpl的实例全部置为true,下次isRef判断就会为true constructor(value: T, public readonly __v_isShallow: boolean) &#123; this._rawValue = toRaw(value) // toRaw 获取原始数据 this._value = toReactive(value) // 跳转到toReactive函数中 并且最终会获取到一个proxy对象 &#125; get value() &#123;&#125; set value(newVal) &#123;&#125;&#125;export const toReactive = &lt;T extends unknown&gt;(value: T): T =&gt; isObject(value) ? reactive(value) : value // value为object，进入reactive(value)逻辑 最终返回一个proxy的对象 ​ 在constructor逻辑中，我们可以看到this._value &#x3D; toReactive(value)，而toReactive函数中，会首先识别value类型，如果不是object，原路返回，如果是object，将会被reactive函数处理，所以在该场景下，value将被reactive函数处理成proxy对象。 ​ 也就是说，此时ref内部的**_value实际上成了reactive**类型。 读取​ 初始化阶段，effect触发的时候，将会读取obj.value.name，，首先会访问量obj.value，触发ref的get方法。 ​ obj.value获取完成后，继续去获取obj.value.name，而name已经在初始化阶段，被toReactive处理成了proxy，所以接下来，会再触发reactive的get，来获取name ​ 也就是说，读取阶段，实际上触发了2次get，一次是ref的get value，一次是proxy的get，进而完成了变量的读取。 1234get value() &#123; // trackRefValue(this) // 依赖收集，后面单独说 return this._value // 获取到proxy类型的&#123;name: &#x27;张三&#x27;&#125;，进而再次触发proxy的get方法&#125; 赋值若干时间后，obj.value.name发生set行为，首先依旧会触发ref的get，获取obj.value，然后再触发reactive的set方法，完成name的赋值。 整个赋值过程，实际上分别触发了ref的get value，和proxy的set，进而完成变量的赋值 12//ref 本身的set在value为object，并且没有直接修改ref.value的情况下，不会被触发set value(newVal) &#123;&#125; 到此为止，我们了解了ref在处理复杂对象时候的读取与赋值的逻辑。 读取：先触发ref的get，再触发proxy的get 赋值：先触发ref的get，再触发proxy的set 依赖收集依赖收集是在get阶段进行完成，而通过上面的分析我们可以了解到，ref的get实际上其内部是两次get事件，所以我们分开来看。 ref的依赖收集（trackRefValue）effect初始化阶段执行的时候，会读取obj.value.name，首先会触发ref的get方法 12345get value() &#123; // 依赖收集函数 将当前ref本身传入方法 trackRefValue(this) return this._value&#125; ref的get方法触发了trackRefValue，会在当前ref的dep中收集到effect，此处逻辑与ref为基础类型的逻辑一致。 proxy的依赖收集（track）​ ref的的get完成后，紧接着触发了reactive的get，然后get内部通过WeakMap再次完成依赖收集（相关逻辑参考Vue3硬核源码解析系列（3） reactive + effect源码解析）。 ​ 我们会发现，在该阶段，我们内部实际上触发了2次依赖收集，effect fn被ref收集的同时，也被proxy收集了。 依赖触发因为ref内部是一个对象，所以赋值也存在多种方式，这依赖触发存在多种方式 对象属性触发依赖1obj.value.name = &#x27;狂飙强&#x27; 这种不会破坏RefImpl初始化阶段其内部构建的proxy，仅修改已有proxy内部变量的值。 首先触发的是obj.value的get行为（此时没有effet在执行，不会发生依赖收集）。然后ref的get函数返回proxy对象 &#123;name:&#39;卖鱼强&#39;&#125; ，紧接着触发proxy的set，并完成依赖触发（proxy的依赖触发请看这里Vue3硬核源码解析系列（3） reactive + effect源码解析）。 对象触发依赖123obj.value = &#123; name: &#x27;狂飙强&#x27;&#125; 第二种方式首先触发obj.value的set行为，同时替换掉ref的值，注意这会破坏RefImpl初始化构建的_value的proxy，进而导致WeakMap中已有的依赖关系断裂 然后执行triggerRefValue，触发，ref本身在get阶段收集了相关effect fn，。 effect fn被触发后，再次触发ref的get，proxy的get，并帮助proxy又重建了与effect fn之间的依赖关系。 这就是为什么存在依赖收集2次的原因。 到此为止，我们的ref核心源码分析就全部完毕了。 关于ref的一些问题Q：为啥一定要.value，不能干掉吗？ A：非常遗憾，value是去不掉的，因为ref依赖class get set 进行实现，在当前实现的场景下，可以简写为v，但是无法去除 Q：我是不是可以完全使用ref，不用reactive？ A：是的，可以完全使用ref，因为ref会根据你传入的类型，自动识别内部是否需要使用reactive，但是读过源码的同学知道ref在处理响应式系统中，存在重复收集依赖的场景，如果你有极致的性能要求，建议复杂类型依旧使用reactive完成，业务开发场景则无所谓。 如果还有其他问题，请评论区提问~ 总结​ 通过对ref源码的阅读，我们可以察觉到，如果仅仅聚焦基础类型的ref，其实底层实现还是比较简单的，所以建议有兴趣的同学渐进式的阅读源码，先完成基础类型场景的源码解读，再进行复杂类型的源码解读，这样事半功倍~ ​ 如果有任何问题，请评论区留言~ ​ 下一个阶段，我将手摸手带大家完成mini版本vue3 ref API，帮助大家深入理解ref~ ​","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"（5）vue3 reactivity-computed源码解析","slug":"关于vue3的研究/（6）vue3 computed源码解析","date":"2023-02-02T16:00:00.000Z","updated":"2023-03-20T07:10:46.381Z","comments":true,"path":"2023/02/03/关于vue3的研究/（6）vue3 computed源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/03/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/%EF%BC%886%EF%BC%89vue3%20computed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言熟悉computed的同学都知道，computed会在依赖属性发生变化的时候自动更新结果。 他有一个重要的特点：计算值是可缓存的，只有依赖项发生变化的时候，才会重新计算 ​ 通过之前的文章，我们已经了解了reactive，ref的实现原理，已经对vue响应式机制有所了解，今天我们就来了解一下computed是如何实现的。 正文测试代码123456789101112131415const obj = reactive(&#123; name: &#x27;张三&#x27;&#125;)const showName = computed(() =&gt; &#123; return &#x27;我叫&#x27; + obj.name&#125;)effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = showName.value&#125;)setTimeout(() =&gt; &#123; obj.name = &#x27;李四&#x27;&#125;, 2000) ​ 以上代码运行后，我们可以看到如下现象 页面显示：我叫张三 2s后，页面显示我叫李四 先让我们看看computed内部都做了些什么吧 computed初始化12345678910111213141516171819202122232425// 入口函数export function computed&lt;T&gt;( getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;) &#123; let getter: ComputedGetter&lt;T&gt; let setter: ComputedSetter&lt;T&gt; // 传入的是否是一个方法 const onlyGetter = isFunction(getterOrOptions) if (onlyGetter) &#123; // 如果是方法, 则直接赋值到getter // 同时屏蔽setter行为 getter = getterOrOptions // dev环境下 set函数给予提示 setter = __DEV__ ? () =&gt; &#123; console.warn(&#x27;Write operation failed: computed value is readonly&#x27;) &#125; : NOOP &#125; else &#123; // 如果不是方法,则认为是对象,将对象中的get set分别赋值到getter setter中 getter = getterOrOptions.get setter = getterOrOptions.set &#125; const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR) return cRef&#125; ​ 入口函数的逻辑还是非常简单的，如果传入的是一个匿名函数，这处理为getter，如果传入的是对象，这赋值getter setter，这部分逻辑符合Vue官方文档的描述。 ​ 抹平两种传参方式的差异后，new ComputedRefImpl，并返回，看来核心实现都在ComputedRefImpl中了，我们接下来就进入该类中看看吧。 12345678910111213141516171819202122232425262728293031// 计算属性的响应式也是通过class get set去实现的export class ComputedRefImpl&lt;T&gt; &#123; public dep?: Dep = undefined // 依赖收集处(effect) private _value!: T // 存储计算属性结果的值 public readonly effect: ReactiveEffect&lt;T&gt; // 存储依赖 public readonly __v_isRef = true // 所有的计算属性也会被识别为ref public _dirty = true // 判断是否需要重新计算 constructor( getter: ComputedGetter&lt;T&gt;, private readonly _setter: ComputedSetter&lt;T&gt;, isReadonly: boolean, // 是否只读,如果存在setter,则为false ) &#123; // 将计算属性的识别为effect，初始化一个ReactiveEffect // 初始化阶段仅仅声明 但是却没有触发 this.effect = new ReactiveEffect(getter, () =&gt; &#123; // 脏变量（_dirty）的本质就是判断什么时候去触发依赖 // 脏变量为false的时候才会触发 if (!this._dirty) &#123; this._dirty = true // 触发依赖 triggerRefValue(this) &#125; &#125;) this.effect.computed = this // 赋值ReactiveEffect中的computed为当前this &#125; get value() &#123;&#125; set value(newValue: T) &#123;&#125;&#125; ​ 在ComputedRefImpl初始化阶段，我们看到了非常熟悉的api，ReactiveEffect，在我们的effect源码分析中，我们使用这个api来完成关键步骤依赖收集，但是这里却又有点不同，完成声明却没有执行，并且还传入了第二个参数，一个匿名函数，现在还无法发挥它的作用，我们需要后面再说。 ​ 总的来说，初始化的时候，生成了一个ReactiveEffect并保存到当前类的effect变量中，忘记ReactiveEffect记得去reactive章节看看其作用哦。 computed的get行为当我们的实例中的api，effect初次执行的时候，我们会触发showName.value的get，也就是说，会触发ComputedRefImpl的get。 123456789101112131415161718192021222324// 被读取的时候触发get value() &#123; // 依赖收集 trackRefValue(this) // 判断是否需要更新，如果需要则进入函数 if (this._dirty) &#123; // 如果更新过，这下一次就不需要更新了， this._dirty = false // effect的run执行，也就是执行computed的fn，将会得到一次计算属性的结果 this._value = this.effect.run()! &#125; // 返回computed的结果 return this._value&#125;export function trackRefValue(ref: RefBase&lt;any&gt;) &#123; // 首次computed内部的dep是不存在的，会通过createDep生成一个Set trackEffects(ref.dep || (ref.dep = createDep()))&#125;export function trackEffects(dep: Dep) &#123; // 将activeEffect，此时是effect的fn，收集到computed的dep中 dep.add(activeEffect!)&#125; ​ 当我们触发computed的get的时候，首先会触发trackRefValue，将当前activeEffect收集到类中的dep中，这正是依赖收集，这里effect被收集到了computed的dep中，建立起了computed与其被依赖项的联系。 ​ 然后判断**_dirty是否为true，默认是true，所以进入判断中，首先将_dirty改为false，下一次则不会进入判断，直接返回computed**之前的结果，之后执行初始化阶段声明的ReactiveEffect，也就是我们computed本身。 ​ computed的effect.run一旦触发，activeEffect将会被替换当前api effect的fn ，并且触发computed依赖项obj.name的get，再次触发proxy的依赖收集，于是obj.name成功收集到了computed内部的effect，proxy与computed建立了联系；同时返回了最新的computed结果。 ​ computed的get行为触发的时候，我们发现computed收集了effect，reactive收集了computed，三者之间建立起了联系。 ​ 而且我们还发现了**_dirty变量的含义，第一次get后，赋值为false，下一次就不需要再计算computed**的结果，实现了数据缓存。 obj.name触发set，计算属性触发2s后，我们触发了obj.name的set，所以首先触发obj.name的依赖触发，此时我们将可以通过WeakMap会找到之前收集到computed，我们直接进入依赖触发的逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;) &#123; const depsMap = targetMap.get(target) if (!depsMap) &#123; return &#125; let deps: (Dep | undefined)[] = [] deps.push(depsMap.get(key)) triggerEffects(deps[0]) // 找到了之前收集到的computed中的effect&#125;// 按照常理来说，我们找到指定依赖之后，就是触发依赖，但是计算属性有所不同，因为计算属性存在“调度器”// 还记得computed初始化阶段，new ReactiveEffect传递的第二个参数吗?// 该参数将会被保存到ReactiveEffect的scheduler(调度器)中// 所以此时的ReactiveEffect中，fn是computed的匿名函数，scheduler是computed初始化阶段new ReactiveEffect的第二个参数export function triggerEffects(dep: Dep | ReactiveEffect[]) &#123; const effects = isArray(dep) ? dep : [...dep] for (const effect of effects) &#123; triggerEffect(effect, debuggerEventExtraInfo) &#125;&#125;function triggerEffect(effect: ReactiveEffect) &#123; // 调度器的优先级大于run，所以此时会执行调度器逻辑 if (effect.scheduler) &#123; effect.scheduler() &#125; else &#123; effect.run() &#125;&#125;// 调度器代码this.effect = new ReactiveEffect(getter, () =&gt; &#123; // 还记得我们get之后将dirty改为false吗？ // 此时computed的依赖发生变化，将_dirty改为true，表示下次重新计算 if (!this._dirty) &#123; this._dirty = true // 触发当前computed中收集了相关effect（依赖触发） triggerRefValue(this) &#125;&#125;)export function triggerRefValue(ref: RefBase&lt;any&gt;, newVal?: any) &#123; // 公共依赖触发逻辑 triggerEffects(ref.dep)&#125;// computed的dep中收集的effect触发，再次触发computed的getget value() &#123; // 依赖项发生变化的时候activeEffect不存在，所以此处收集不到任何依赖 trackRefValue(this) // 刚才依赖项发生了变化，所以dirty为true，表示本次需要更新计算属性的结果 if (this._dirty) &#123; // 计算后dirty改为false 除非依赖项发生变化，否则将不会再重新计算。 this._dirty = false // 重新计算 computed的结果 this._value = this.effect.run()! &#125; return this._value&#125; ​ 计算属性的触发逻辑还是非常复杂的，首先proxy的set，触发computed的scheduler（调度器），scheduler通过computed的dep找到相关effect，effect的fn执行又会触发computed的get，并与首次完成computed的计算，同时缓存最新的computed的结果，进而再完成effect的全部逻辑。 代码执行流程依赖收集阶段 computed初始化阶段，通过ReactiveEffect进行初始化，并且生成scheduler（调度器） effect初始化，触发computed的get，将当前activeEffect（effect）收集到computed的dep中（computed将effect收集） 执行computed自身逻辑，刷新全局activeEffect 进而触发proxy的get事件触发，将当前activeEffect（computed）收集到WeakMap中（proxy将computed收集） proxy的返回值返回computed，完成computed的计算逻辑 获取到computed结果，完成effect 依赖触发阶段 触发proxy的set，set行为中触发依赖，触发之前保存的computed的调度器scheduler（proxy找到computed） 调度器scheduler触发，dirty改为true，同时触发computed中保存的依赖，其中都是相关effec的fn。（computed找到effect） effect触发，fn执行，触发computed的get行为 dirty为true，首次进行计算属性的重新计算（除非依赖项改变，否则下次不会重新计算），返回最新的computed结果， effect执行完成 回答一些问题computed如何实现高性能缓存的？​ 通过调度器scheduler + 脏值检查_dirty，实现依赖项不变化，不进行重新计算，依赖项变化后仅执行一次的逻辑，进而实现高性能缓存。 为什么访问computed需要.value​ 因为我们访问computed实际上是访问ComputedRefImpl这个Class的实例，他的内部通过get value返回被访问值，所以我们必须通过**.value**来访问 简述computed的实现原理？ vue的响应式api都可以从依赖收集 依赖触发2个角度出发阐述其原理实现 依赖收集阶段：computed通过首次get的完成相关effect的依赖收集，首次计算的时候proxy完成computed的依赖收集。 依赖触发阶段：computed的依赖项发生变化后，会通过proxy找到computed的调度器 scheduler，触发所有effect，effct中再出发computed的get，首次get将进行一次结果运算（后续不在运算，除非computed依赖项发生变化），effect触发完成 总结​ 到此为止，我们computed的核心源码就解读完毕了，虽然总体依旧可以从依赖收集和依赖触发两个角度去理解实现原理，但是新增加的scheduler（调度器）与**_dirty（脏值检查）**机制，让逻辑复杂了很多。 ​ 大家在理解computed源码的时候，一定要多走几遍流程，多捋几遍逻辑。","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"（3）vue3 reactive源码解析","slug":"关于vue3的研究/Vue3硬核源码解析系列（3） reactive + effect源码解析","date":"2023-01-31T16:00:00.000Z","updated":"2023-02-20T08:19:15.541Z","comments":true,"path":"2023/02/01/关于vue3的研究/Vue3硬核源码解析系列（3） reactive + effect源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/01/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20reactive%20+%20effect%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"专栏前言​ 本文是vue3源码解析系列的第三篇文档，在前两篇文章中，我们了解了vue3源码的运行、调试，以及阅读前的一些前置知识点，从本节开始，我们就可以正式的开始vue3的源码阅读了。 ​ 我们首先阅读的模块是@vue&#x2F;reactivity 中的reactive以及相关api，effect的源代码。 在正文开始之前，我先将本节的简化版源码放出来，有兴趣的同学可以clone到本地，一边debug，一边阅读文章，这样效果更佳~ https://github.com/BlueDancers/vue3-mini/tree/reactive 前言reactive的含义如其名称，通过reactive创建的对象都是具备响应式的。即reactive对象的改变会造成副作用。 于是我们引出副作用API（effect），如果effect内部依赖了reactive，则reactive的改变会重新触发effect。 现在让我们走进案例与源码，看看究竟是如何实现响应式的。 案例123456789101112 let &#123; reactive, effect &#125; = Vue const obj = reactive(&#123; name: &#x27;卖鱼强&#x27;, &#125;) effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = obj.name &#125;)setTimeout(() =&gt; &#123; obj.name = &#x27;狂飙强&#x27;&#125;, 2000) 以上测试案例，我们涉及到了三个重要的阶段 reactive初始化 effect初始化 reactive发生修改 最后形成了effect的自动触发，我们就从以上三个角度去切入源码实现。 reactive初始化 为了方便阅读与理解，以下仅贴出核心源码 packages/reactivity/src/reactive.ts 1234567891011121314151617181920212223242526272829303132export function reactive(target) &#123; return createReactiveObject( target, // reactive里面的值 false, mutableHandlers, mutableCollectionHandlers, reactiveMap )&#125;function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) &#123; // 判断是否已经被代理过了，如果是，则获取缓存中的值，并直接返回 // 我们这里第一次指定，必然是不存在的，所以跳过这个 const existingProxy = proxyMap.get(target) if (existingProxy) &#123; return existingProxy &#125; // 对reactive中的变量进行代理，我们这里的target类型是obejct，targetType为common，所以接下来进入baseHandlers逻辑 // 而baseHandlers从reactive被当做参数传递过来的，实际执行的是mutableHandlers const proxy = new Proxy( target, baseHandlers ) proxyMap.set(target, proxy) return proxy&#125;// reactive中变量类型为object场景下，proxy的监听逻辑会走到这里export const mutableHandlers = &#123; get, set,&#125; ​ 通过源码 我们可以看得出来，使用reactive，内部实际执行的是createReactiveObject，函数就是新建了proxy，并最终返回。 ​ 不过要注意一点的是，经过reactive处理过的对象，都会以target为WeakMap键，proxy为值，进行一次缓存，这样同一个值再次进行reactive的时候就会读取缓存中的值。 ​ 接下来，让我们进入初始化阶段的mutableHandlers，也就是proxy中核心的get set函数，看看内部做了些什么。 初始化读取（get）当触发obj.name的读取行为的时候，就会触发代理对象的get函数 packages/reactivity/src/baseHandlers.ts 123456789101112131415const get = createGetter()function createGetter() &#123; return function get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver) // 读取被代理对象 // 核心逻辑(track)：依赖收集，后续单独看 // 如果当前值是reactive则递归proxy处理 if (isObject(res)) &#123; return reactive(res) &#125; return res &#125;&#125; get内部的逻辑很简单，通过Reflect完成被代理对象的读取操作。 如果被读取对象的属性是object则会再次进入reactive逻辑中进行proxy处理，确保嵌套对象的响应式。 也许有的人会说了proxy不是自身就实现了对象的拦截了吗？为什么我们还是要递归处理嵌套obj呢？ 这里我给大家解释一下，proxy确实会拦截到所有操作，但是他也只能拦截当前层级的。 如果没有递归处理， obj.name.abc &#x3D; 123的时候，只会触发obj.name的get事件，但是不会触发obj.name.abc的set事件。 初始化修改（set）当触发obj.name的修改行为，将会触发代理对象的set函数 packages/reactivity/src/baseHandlers.ts 123456789101112const set = createSetter()function createSetter(shallow = false) &#123; return function set(target, key, value, receiver) &#123; // 修改被代理数据，完成数据更新 const res = Reflect.set(target, key, value, receiver) // 核心逻辑(trigger)：依赖触发，后续单独看 return res // true &#125;&#125; 通过Reflect完成被代理对象值的更新，最后返回本次Reflect.set的结果，完成逻辑。 总体就是对proxy的简单利用，还是很简单的嘛 小结​ 以上代码是去除所有边界判断，以及响应式逻辑后，reactive的核心代码；我们可以发现，其实就是proxy + Reflect的基础使用。 ​ 目前数据已经具备响应式，但是数据变化后，引用数据的effect如何实现自动执行呢？接下来我们就去看看effect初始化的时候究竟做了什么。 effect初始化读取 - 依赖收集（track）​ 我们回到测试demo中，根据我们使用vue3的预期，在初始化完成后，effect会触发一次，若干时间后，setTimeout内set触发，依赖obj.name的 effect的函数还会被触发一次，这又是如何实现的呢？ ​ 这里我要提到Vue3中第一个非常非常非常重要的概念，依赖收集（track），整个reactivity都利用到了这个概念。 ​ 接下来，我们就要通过源码去了解，effect的初始化的时候，到底发生了什么，Vue3在此阶段是如何完成依赖收集的。 packages/reactivity/src/effect.ts 12345678910111213141516171819202122232425/** * 当前被执行的effect */export let activeEffect: ReactiveEffect | undefinedexport function effect(fn) &#123; const _effect = new ReactiveEffect(fn) // 首先执行new ReactiveEffect，所以我们跳转到ReactiveEffect中 _effect.run() // 并立刻执行了run方法，run方法内实际执行的就是effect内部函数&#125;export class ReactiveEffect &#123; parent: ReactiveEffect | undefined = undefined constructor( public fn: () =&gt; T, // 这里的fn就是effect内部的匿名函数 ) &#123;&#125; run() &#123; try &#123; activeEffect = this // 将effect对象，也就是new ReactiveEffect的结果，保存到activeEffect shouldTrack = true // 表示开始依赖收集 return this.fn() // 这里的fn，实际上就是effect内部的匿名函数 &#125; &#125;&#125; vue3的依赖收集几乎都是通过ReactiveEffect进行完成的，简单来说就是ReactiveEffect.run一旦运行后，就会将当前正在运行的匿名函数保存到内存中，以便于proxy get事件触发的时候，收集保存在内存中的匿名函数，进而完成依赖收集。 ​ effect方法内部，首先new ReactiveEffect 最终执行了一次fn，但是在执行之前，将activeEffect赋值为this，将自身保存到了公共变量activeEffect之中。 让我们来看看此时运行的fn是什么 123() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = obj.name&#125; ​ 匿名函数的内部读取了obj.name，触发了被代理对象obj的get方法. ​ 所以接下来我们回到get方法中，查看之前忽略的依赖收集逻辑。 packages/reactivity/src/baseHandlers.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function createGetter(isReadonly = false, shallow = false) &#123; return function get(target: Target, key: string | symbol, receiver: object) &#123; const res = Reflect.get(target, key, receiver) // 读取被代理对象 if (!isReadonly) &#123; // obj为可读代码 所以isReadony一定为false 进入if中 track(target, TrackOpTypes.GET, key) &#125; return res &#125;&#125;// 依赖收集function track(target, type, key) &#123; if (shouldTrack &amp;&amp; activeEffect) &#123; // 在effect中执行run方法的时候，我们确保了shouldTrack为true activeEffect 存在值，所以进入判断 let depsMap = targetMap.get(target) // targetMap是一个全局变量，实际上是一个new WeakMap 首次depsMap肯定是不存在的 if (!depsMap) &#123; // 这里的target为被代理对象，&#123;name: &#x27;张三&#x27;&#125;，该值做为key，Map作为value targetMap.set(target, (depsMap = new Map())) &#125; let dep = depsMap.get(key) // 当前key为name 首次也是不存在的 if (!dep) &#123; // depsMap是一个Map结构，key是name value是createDep()的返回值，我们进入createDep depsMap.set(key, (dep = createDep())) &#125; // 将dep作为参数传递到trackEffects中，此时的dep为Set trackEffects(dep, undefined) &#125;&#125;export const createDep = (effects?) =&gt; &#123; const dep = new Set(effects) // 实际上就是生成了Set结构（Set我们简单理解为元素不可重复的数组） dep.w = 0 dep.n = 0 return dep&#125;export function trackEffects( dep: Dep,) &#123; // 一系列边界判断，合法的情况下shouldTrack为true if (shouldTrack) &#123; dep.add(activeEffect!) // 将全局变量activeEffect（包含effect的匿名函数）加入到dep（Set）中 // 到这里 我们将响应式数据与effect函数建立起了联系 标志着我们完成了依赖收集 &#125;&#125; ​ effect内部的fn被触发，fn执行中触发了obj的get，get内部触发了依赖收集（track），track内部通过构建targetMap，来维护变量与effect之间的关系，进而实现所谓的依赖收集。 ​ 我们来梳理一下他的数据结构 WeakMap key：被代理对象（{name:’张三’}） value：Map对象 key：响应式对象的指定属性（name） value：指定对象的指定属性的使用函数（effect的匿名函数） 在WeakMap中，我们不仅仅收集了effect的匿名函数，还将effect与effect中具体读取的变量建立起了联系。 在未来的依赖触发逻辑中，weakMap将会发挥巨大作用。 到此为止，effect内的匿名函数执行完毕，同时我们也完成了重要的依赖收集。 修改 - 依赖触发（trigger）继续回到demo中，2s后，obj.name赋值为狂飙强，此时的现象是effect中的函数自动执行了，这又是如何实现的呢？ 此处首先一定是触发了代理对象obj.name的set，所以我们由此处开始分析。 packages/reactivity/src/baseHandlers.ts 123456789101112131415161718192021222324252627282930function createSetter(shallow = false) &#123; return function set(target, key, value, receiver): boolean &#123; const result = Reflect.set(target, key, value, receiver) // 完成被代理对象的赋值操作 trigger(target, TriggerOpTypes.SET, key, value, oldValue) return result &#125; export function trigger(target, type, key?, newValue?, oldValue?, oldTarget?) &#123; // 通过全局变量targetMap（weakMap）获取value // 在依赖收集阶段我们收集到了当前target，所以这时候 depsMap存在值 值为Map Map的key为name 值为Set Set内部是effect的fn const depsMap = targetMap.get(target) triggerEffects(depsMap.get(key))&#125; export function triggerEffects(dep, debuggerEventExtraInfo?) &#123; const effects = isArray(dep) ? dep : [...dep] // 将set处理为数组 for (const effect of effects) &#123; triggerEffect(effect, debuggerEventExtraInfo) &#125;&#125; function triggerEffect( effect: ReactiveEffect, // 每一个effect都是ReactiveEffect，内部的fn都是effect的fn) &#123; // 此时的activeEffect为undefined，一定进入if中 if (effect !== activeEffect || effect.allowRecurse) &#123; effect.run() // effect的run方法就是effect的fn，完成执行 &#125;&#125; 经过以上代码，我们可以了解到，obj.name的改变在触发了proxy的set方法的同时，也触发了依赖触发（trigger）。 trigger中，我们首先通过**{name: ‘狂飙强’}，找到了Map，再通过name找到Set，最终找到对应的effect的fn**，并进行匿名函数的执行，于是我们便看到了effect函数自动触发。 到此为止完成了整个响应式过程。 reactive源码总结我们简单总结一下，reactive中依赖收集与依赖触发的过程 通过proxy处理reactive包裹的对象，被返回proxy代理对象 effect初始化，生成了类ReactiveEffect，并执行了其run方法 run方法执行后，当前effect的fn函数本身被保存到了activeEffect(公共变量)，随后执行了effect的fn effect的fn触发，函数内使用到了obj.name，触发了代理对象的get get方法内部触发了依赖收集（track），配合保存到局部的activeEffect，最终通过WeakMap，建立了effect的fn与当前get的属性的联系，完成了依赖收集。 若干时间后，obj.name &#x3D; ‘狂飙强’，触发proxy的set，同时触发了依赖触发（trigger） trigger内部通过当前代理对象以及具体修改的属性，在依赖收集阶段保存的WeakMap中，找到所有需要触发的effect的fn。 触发effect的fn函数，完成响应式。 最后反映在我们眼前，就是obj.name改变的同时，所有使用到obj.name的effet都被自动触发其匿名函数，完成响应式。 关于vue3 reactive的面试题为什么Vue3的响应式使用WeakMap实现？​ 还记得我们前一篇文章谈到的WeakMap吗，一旦被代理对象被置为null，weakMap中该key将会被垃圾回收，达到性能最大化的目的 简述Vue3的响应式的核心实现逻辑？​ 通过proxy递归代理对象，然后在get中完成依赖收集，在set中完成依赖触发 Vue3的reactive为什么不能代理简单类型？​ reactive底层依赖proxy，但是proxy只能代理对象，无法代理基础类型。 为什么reactive解构会失去响应式？​ 这里要明确一点，只有解构出来的变量是基础类型的时候，才会失去响应式，失去响应式的主要原因是基础类型无法被proxy代理。 总结​ 到此为止，我们的vue3中的响应式模块的第一个API，reactive源码解读就完成了； ​ 总的来说逻辑还是比较复杂的，尽管我已经很努力的去反复修改与简化，但是还是能可以感觉到，有些东西很难用文字讲清楚。 ​ 也不知道是否可以帮助到正在阅读文章的你，如果你觉得还不错的话，还麻烦你动动小手点个赞，关注专栏，这是我输出优质文章最大的动力。 ​ 如果有小伙伴存在视频教程诉求的话，请评论区告诉我，我会评估出几期视频的必要性~ ​ 下一站，我们将前往ref。 ​","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"（2）Object.defineProperty vs proxy","slug":"关于vue3的研究/Vue3硬核源码解析系列（2）Object.defineProperty VS proxy","date":"2023-01-29T16:00:00.000Z","updated":"2023-02-18T07:25:03.843Z","comments":true,"path":"2023/01/30/关于vue3的研究/Vue3硬核源码解析系列（2）Object.defineProperty VS proxy/","link":"","permalink":"https://bluedancers.github.io/2023/01/30/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89Object.defineProperty%20VS%20proxy/","excerpt":"","text":"专栏前言本文是vue3源码解析系列的第二篇文章，这一章我们主要学习vue3源码中涉及到的一些核心api。 后续的源码解读是非常复杂的，所以相关基础知识一定要牢固哦~ 前言大部分使用过vue3的同学都知道，vue3的底层的响应式实现由Object.defineProperty更换成了Proxy。 为什么vue3要更换呢？proxy相对于前者又有何优势呢？ 接下来让我们通过案例去一探究竟吧！ ​ 当响应式不存在我们先看一个例子 12345678910let shoes = &#123; num: 3, price: 10,&#125;let total = shoes.num * shoes.priceconsole.log(total) // 30shoes.num = 5console.log(total) // 30 第二次打印依旧是30，虽然我们的num发生了变化，但是下一次获取total的值依旧是之前的值，因为total已经被运算过了。 那应该怎么做，才能实时的获取到当前最新的total呢？ 也很简单，我们每次获取之间，手动重新计算一次就好了。 1234567891011121314151617let shoes = &#123; num: 3, price: 10,&#125;let total = 0function effect() &#123; total = shoes.num * shoes.price&#125;effect() // 重新计算console.log(total) // 30shoes.num = 5effect() // 重新计算console.log(total) // 50 ​ 我们增加effect方法来手动触发依赖，这样我们实现了需求。 ​ 但是这样手动触发的方式，在真实业务中过于繁琐，难以维护，本质上依旧是命令式思维。 ​ 如何实现值的修改，后续逻辑的自动执行呢？ vue2的解决方案通过Object.defineProperty来对字段进行代理，通过set，get方法，完成逻辑的自动触发。 123456789101112131415161718192021let num = 3let shoes = &#123; num: num, price: 10,&#125;let total = 0function effect() &#123; console.log(&#x27;开始计算&#x27;, shoes) total = shoes.num * shoes.price&#125;// 被代理的值无法不可再get中使用了 因为会触发ett的死循环// 所以,必须增加一个变量来做被代理的值,所以我们监听shoes.num的get set内部实际修改和读取的都是numObject.defineProperty(shoes, &#x27;num&#x27;, &#123; set(newVal) &#123; num = newVal effect() &#125;, get() &#123; return num &#125;,&#125;) ​ 我们再以上代码，再次修改shoes.num，将触发代理中的set，进而触发effect，实现依赖的自动触发，vue2的底层也正是如此实现的，这样看起来我们的需求已经解决了，那为何vue3有放弃了Object.defineProperty呢？ ​ 接下来我们就要聊聊他的缺陷。 Object.defineProperty的缺陷该API确实满足了我们上面提到的案例，但是他在一些场景也存在很多问题。 比如大家一定都遇到过的问题 object中新增字段 没有响应性 array中指定下标的方式增加字段 没有响应性的 为什么会这样呢？vue的官方解释是 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。 尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。 那JavaScript到底限制了什么呢？ ​ object.defineProperty只能监听到指定对象的指定属性的get set，这些工作其实是vue初始化阶段完成，所以指定对象的指定元素发生变化的时候，我们可以监听到变化，vue中也确实是这么表现的； ​ 但是如果，我们在指定对象上面新增属性，object.defineProPerty是无法监听到的，无法监听则无法处理被新增的字段，自然字段就不具备响应式； ​ 在vue2中，如果想解决以上问题，需要使用Vue.$set进行手动增加响应式字段，解决无法监听到字段新增的问题。 vue3的解决方案vue3中改用了proxy，为什么响应式核心api做了修改，proxy是什么？我们先实现一个类似vue2的案例 123456789101112131415161718192021222324252627let shoes = &#123; num: 3, price: 10,&#125;let shoesProxy = new Proxy(shoes, &#123; // target 被代理对象 key 本次修改的对象中的键 newValue 修改后的值 receiver 代理对象 set(target, key, newValue, receiver) &#123; console.log(&#x27;触发了写入事件&#x27;) shoes[key] = newValue effect() return true &#125;, // target 被代理对象 key 本次读取的值 receiver 代理对象 get(tartget, key, receiver) &#123; console.log(&#x27;触发了获取事件&#x27;) return shoes[key] &#125;,&#125;)let total = 0function effect() &#123; console.log(&#x27;开始计算&#x27;, shoes) // 如果使用被代理对象本身shoes,这不会触发 // 如果使用代理对象shoesProxy,则这里会触发proxy的get事件 total = shoes.num * shoes.price&#125; 通过以上代码，我们可以看到一些差别 object.defineproperty 代理的并非对象本身，而是对象中的属性 只能监听到对象被代理的指定属性，无法监听到对象本身的修改 修改对象属性的时候，是对原对象进行修改的，原有属性，则需要第三方的值来充当代理对象 proxy proxy针对对象本身进行代理 代理对象属性的变化都可以被代理到 修改对象属性的时候，我们针对代理对象进行修改 无论是逻辑的可读性，还是API能力上，proxy都比object.defineProPerty要强很多，这也是vue3选择proxy的原因。 proxy的好兄弟Reflect​ 在vue3的源码中的**@vue&#x2F;reactivity中，我们会经常看到在proxy的set、get中存在Reflect的身影，但是从我们上面对proxy的使用来看，赋值 读取都实现了，为什么vue3中使用了Reflect**呢？ 首先我们了解一下Reflect是干嘛的 官方解释：Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。 似乎比较难理解，我们举个例子吧 123let obj = &#123; num:10 &#125;obj.num // 10Reflect.get(obj,&#x27;num&#x27;) // 10 这么来看，似乎这个api很普通啊，反而把简单的读取值写复杂了。 这时候我们就要提一下Reflect.get 的第三个参数了 1Reflect.get(target, propertyKey, receiver]) // receiver 如果target对象中指定了propertyKey，receiver则为getter调用时的this值。 这次我们知道了，第三个参数receiver具有强制修改this指向的能力，接下来我们来看一个场景 123456789101112131415let data = &#123; name: &#x27;张三&#x27;, age: &#x27;12岁&#x27;, get useinfo() &#123; return this.name + this.age &#125;,&#125;let dataProxy = new Proxy(data, &#123; get(target, key, receiver) &#123; console.log(&#x27;属性被读取&#x27;) return target[key] &#125;,&#125;)console.log(dataProxy.useinfo) 打印情况如下 12属性被读取张三12岁 ​ dataProxy.useinfo的get输出的值是正常的，但是get只被触发了一次，这是不正常的； ​ 因为useinfo里面还读取了被代理对象data的name、age，理想情况应当是get被触发三次。 ​ 为什么会出现这样的情况呢，这是因为调用userinfo的时候，this指向了data，实际执行的是data.userinfo，此时的this指向data，而不是dataProxy，此时get自然是监听不到name、age的get了。 ​ 这时候我们就用到了Reflect的第三个参数，来重置get set的this指向。 1234567let dataProxy = new Proxy(data, &#123; get(target, key, receiver) &#123; console.log(&#x27;属性被读取&#x27;) return Reflect.get(target, key, receiver) // this强制指向了receiver // return target[key] &#125;,&#125;) 打印情况如下 1234属性被读取属性被读取属性被读取张三12岁 现在打印就正常了，get被执行的3次，此时的this指向了dataProxy，Reflect很好的解决了以上的this指向问题。 ​ 通过以上案例，我们可以看到使用target[key]有些情况下是不符预期的，比如案例中的被代理对象this指向问题，而使用Reflect则可以更加稳定的解决这些问题，在vue3源码中也确实是这么用的。 补充章节（WeakMap）​ 通过以上文章，我们了解到了object.defineproperty相较于proxy的劣势，以及搭配proxy同时出现的Reflect的原因，这是vue3最核心的api。 ​ 但是仅仅知道理解proxy+reflect，还不太够，为了尽量轻松的阅读Vue3源码，我们还要学习一个原生API，那就是WeakMap。 WeakMap MDN中文文档地址 ​ weakMap和map一样都是key value格式，但是他们还是存在一些差别。 weakMap的key必须是对象，并且是弱引用关系 Map的key可以是任何值（基础类型+对象），但是key所引用的对象是强引用关系 ​ 通过查阅MDN我们可以发现，weakMap可以实现的功能，Map也是可以实现的，那为什么Vue3内部使用了WeakMap呢，问题就在引用关系上 强引用：不会因为引用被清除而失效 弱引用：会因为引用被清除而自动被垃圾回收 概念似乎还无法体现其实际作用，我们通过以下案例即可明白 12345678910111213// Maplet obj = &#123; name: &#x27;张三&#x27; &#125;let map = new Map()map.set(obj, &#x27;name&#x27;)obj = null // obj的引用类型被垃圾回收console.log(map) // map中key obj依旧存在// WeakMaplet obj = &#123; name: &#x27;张三&#x27; &#125;let map = new WeakMap()map.set(obj, &#x27;name&#x27;)obj = null // obj的引用类型被垃圾回收console.log(map) // weakMap中key为obj的键值对已经不存在 通过以上案例我们可以了解到 弱引用在对象与key共存场景存在优势，作为key的对象被销毁的同时，WeakMap中的key value也自动销毁了。 弱引用也解释了为什么weakMap的key不能是基础类型，因为基础类型存在栈内存中，不存在弱引用关系； 在vue3的依赖收集阶段，源码中用到了WeakMap，具体什么作用？我们下一节进行解答。 结语​ 通过本篇文章，我们认识到了object.defineproperty相较于proxy的劣势，以及搭配proxy同时出现的Reflect的原因，还有一个Map的原生的API，WeakMap的作用。 ​ 接下来我们就可以正式走进vue3源码的世界~","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"（1.1）搭建属于自己的vue3","slug":"关于vue3的研究/Vue3硬核源码解析系列（1）准备工作","date":"2023-01-28T16:00:00.000Z","updated":"2023-02-14T03:28:05.420Z","comments":true,"path":"2023/01/29/关于vue3的研究/Vue3硬核源码解析系列（1）准备工作/","link":"","permalink":"https://bluedancers.github.io/2023/01/29/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"前言​ 我们本次源码的目的是最终完成一个简化版的vue3，我们将他称为vue3-mini，本节我们就开始项目的搭建工作。 生成项目1npm init 引入ts1tsc -init tsconfig.json范本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; // 编辑器配置 &quot;compilerOptions&quot;: &#123; // 根目录 &quot;rootDir&quot;: &quot;.&quot;, // 严格模式标志 &quot;strict&quot;: true, // 指定类型脚本如何从给定的模块说明符查找文件。 &quot;moduleResolution&quot;: &quot;node&quot;, // https://www.typescriptlang.org/tsconfig#esModuleInterop &quot;esModuleInterop&quot;: true, // JS 语言版本 &quot;target&quot;: &quot;es5&quot;, // 允许未读取局部变量 &quot;noUnusedLocals&quot;: false, // 允许未读取的参数 &quot;noUnusedParameters&quot;: false, // 允许解析 json &quot;resolveJsonModule&quot;: true, // 支持语法迭代:https://www.typescriptlang.org/tsconfig#downlevelIteration &quot;downlevelIteration&quot;: true, // 允许使用隐式的 any 类型(这样有助于我们简化 ts 的复杂度，从而更加专注于逻辑本身 &quot;noImplicitAny&quot;: false, // 模块化 &quot;module&quot;: &quot;esnext&quot;, // 转换为 JavaScript 时从 TypeScript 文件中删除所有注释。 &quot;removeComments&quot;: false, // 禁用 sourceMap &quot;sourceMap&quot;: false, // https://www.typescriptlang.org/tsconfig#lib &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot; ], &quot;baseUrl&quot;: &quot;.&quot;, // 设置路径映射 // 设置后ts在打包过程中也会自动完成路径映射,需要其他地方再次设置 &quot;paths&quot;: &#123; &quot;@vue/*&quot;: [ &quot;packages/*/src&quot; ] &#125; &#125;, &quot;include&quot;: [ &quot;packages/*/src&quot; ],&#125; 引入代码格式化vscode下载插件prettier 创建文件.prettierrc.js 12345678910module.exports = &#123; singleQuote: true, // 单引号 trailingComma: &#x27;es5&#x27;, // 对象属性最后有 &quot;,&quot; semi: false, // 是否需要分号 printWidth: 110, // 一行最多120 jsxSingleQuote: true, // jsx使用单引号 tabWidth: 2, // 一个tab代表几个空格数，默认就是2 useTabs: false, // 不使用缩进符，而使用空格 jsxBracketSameLine: true,&#125; 创建文件.prettierignore 1234567# Ignore artifacts:distbuildcoveragecommontsconfig.jsonREADME.md 后续的代码格式化工具上选择prettier即可 我们这里不使用eslint，不做非常强制的代码校验 创建相关文件按照vue3源码中的结构进行创建，暂时只创建packages文件夹 引入打包工具全局安装rollup 1npm install --global rollup 项目创建rollup配置文件rollup.config.js output中的name暂时不生效 123456789101112131415161718192021222324252627282930313233import resolve from &#x27;@rollup/plugin-node-resolve&#x27;import commonjs from &#x27;@rollup/plugin-commonjs&#x27;import typescript from &#x27;@rollup/plugin-typescript&#x27;/** * 默认导出一个数组,数组中,每个对象都是独立导出项 */export default [ &#123; input: &#x27;packages/vue/src/index.ts&#x27;, output: [ // 导出iife的包(自动执行 适用于script标签) &#123; format: &#x27;iife&#x27;, sourcemap: true, file: &#x27;./packages/vue/dist/vue.js&#x27;, name: &#x27;Vue&#x27;, // 指定打包后的全局变量名（如果被打包代码，没有任何导出，将不存在导出名称） &#125;, ], // 插件 plugins: [ // 让rollup 支持打包ts代码,并可以指定ts代码打包过程中的相关配置 typescript(&#123; sourceMap: true, &#125;), // 与webpack不同的是,rollup并不知道如何寻找路径以外的依赖,比如node_module中的 // 帮助程序可以在项目依赖中找到对应文件 resolve(), // rollup默认仅支持es6的模块,但是还存在很多基于commonjs的npm模块,这就需要改插件来完成读取工作 commonjs(), ], &#125;,] package.json中增加打包命令 1&quot;build&quot;: &quot;rollup -c&quot; 执行打包命令 1npm run build 然后我们在packages/vue/src/index.ts编写测试代码 123import &#123; isArray &#125; from &#x27;@vue/shared&#x27; // ts部分我们配置了paths选项console.log(isArray([])) 不出意外的话，这里肯定是正常打包了，并且会生成sourceMap文件。 热更新package的script中增加一个命令 1&quot;dev&quot;: &quot;rollup -c -w&quot; 至此，基础的vue3框架环境我们就搭建完成了。","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"（1）vue3 源码解读前的准备工作","slug":"关于vue3的研究/（1）vue3 源码解读前的准备工作","date":"2023-01-27T16:00:00.000Z","updated":"2023-02-18T06:22:06.001Z","comments":true,"path":"2023/01/28/关于vue3的研究/（1）vue3 源码解读前的准备工作/","link":"","permalink":"https://bluedancers.github.io/2023/01/28/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/%EF%BC%881%EF%BC%89vue3%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"前言​ 在22年下半年就有想阅读vue3源码的想法了，但是因为很多不可抗力原因，一直在不断拖延。 ​ 23年年初下定决心，一定要在半年内完成vue3的核心源码的解读，所有源码的阅读记录我都讲输出到本专栏中，目测可能有10片以上的文章，在输出中，我会尽力保证文字的简单易懂； ​ 话不多说，我们直接开始吧！ 下载vue3源码仓库地址：https://github.com/vuejs/core 本专栏版本为3.2.37，地址：https://github.com/vuejs/core/releases/tag/v3.2.37 克隆仓库地址 1git clone https://github.com/vuejs/core 打包与运行vue3源码vue3采用monorepo进行包管理，而monorepo由pnpm提供，所以需要一定要预先安装pnpm 1npm install -g pnpm pnpm安装完成后，开始安装vue3的依赖 1pnpm install 依赖安装完成后，开始vue3源码的打包工作，该步骤可能花费较长时间 1npm run build ​ 打包完成后，将会在packages/vue/dist，路径下生成打包后的vue3的代码，接下来我们去packages/vue/examples官方提供的案例中运行打包后代码，在目标html文件通过vscode启动live server，即可完成vue3示例的运行。 打包vue3源码可能遇到的问题Error: Command failed with exit code 128: git rev-parse HEAD运行build之后，出现以上错误，原因是因为build的过程中，会读取了当前git的commit id，如果当前目录下没有**.git**文件，相关逻辑就会出错，所以需要注释掉scripts/build.js中以下代码 12line34 const commit = execa.sync(&#x27;git&#x27;, [&#x27;rev-parse&#x27;, &#x27;HEAD&#x27;]).stdout.slice(0, 7)line97 `COMMIT:$&#123;commit&#125;` 跳过获取commitID相关逻辑代码，即可正确打包。 vue3示例中源码未支持SourceMap当我们完成上文的打包后，我们运行一个example，运行后就会发现一个问题，我们使用Vue3源码是打包后的代码，没有sourceMap，这样是无法调试源码的。 vue3源码内提供了打开sourceMap的能力，修改打包命令package.json中的line7，即可 1node scripts/build.js -s 为什么这个改动呢？我们还要从rollup.config.js入手 在rollup.config.js的line94 我们可以看到 1output.sourcemap = !!process.env.SOURCE_MAP // 反向取反，获取其对应的boolean类型的值 要开启sourcemap首先需要修改process.env.SOURCE_MAP，而这个值来源于scripts/build scripts/build.js中的line103 1sourceMap ? `SOURCE_MAP:true` : `` 而这里的sourceMap来源于命令行后缀 12const args = require(&#x27;minimist&#x27;)(process.argv.slice(2))const sourceMap = args.sourcemap || args.s 所以我们只需要在脚本命令后增加-s即可开启sourcemap。 至此为止，我们便可以在vue源码环境中进行阅读与调试了","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"（0）vue3源码解读前的准备工作","slug":"关于vue3的研究/（0）vue3源码解读前的准备工作","date":"2023-01-25T16:00:00.000Z","updated":"2023-02-18T06:22:01.620Z","comments":true,"path":"2023/01/26/关于vue3的研究/（0）vue3源码解读前的准备工作/","link":"","permalink":"https://bluedancers.github.io/2023/01/26/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/%EF%BC%880%EF%BC%89vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"命令式VS声明式命令式​ 我们的前端代码中，大部分都是命令式思维，这种思维与我们现实是具备一定的一致性的，也就是说他不抽象，这也是为什么JavaScript是一门容易入门的语言。 ​ 比如我们想获取Dom1中的Dom2中的Dom3，并给其赋值“你好”，则我们的流程是 获取dom1 获取dom1中的dom2 获取dom2中的dom3 给dom3赋值你好 ​ 命令式编程相对于结果更加强调过程，非常好理解，但是命令式也有他的缺点，那就是一旦命令很长，代码也会非常难以维护。 ​ 声明式​ 而声明式则更多关注结果，究竟是什么样的过程，这并不是开发者需要关心。 ​ 我们依旧使用上面的例子，我们只需要在Dom3中进行&#123;&#123; msg &#125;&#125;声明，然后只关心何时更新其具体的值即可，msg是如何更新，这并不是开发者关心的问题，一般来说这些工作我们都是交给框架进行完成的。 如何评价？评价一个框架的好坏，我们一般从2个角度出发 性能 可维护性 命令式编程是JavaScript自带的编程方式，毫无疑问性能是最好多，声明式则需要我们内部进行一些运算，但是在可维护性的角度上来说，声明式的代码要更加简单、直观，项目越复杂，越能体现声明式的可维护性 总结一下 性能：命令式 &gt; 声明式（项目越大，差距越小） 可维护性：声明式 &gt; 命令式（项目越大，差距越大） 企业应用的开发与设计原则企业开发中，公司关注的无非就是以下2点 项目成本：就是开发周期的控制，如何更快更稳定的完成开发工作是首要目标 开发体验：开发体验式开发者的第一诉求（开发、维护难度），但是也符合公司诉求，因为好的开发体验可以加速开发进度 所以在企业纬度，可维护性是非常看重的一点，所以企业更加愿意使用声明式的开发方式 但是在性能的角度来说，命令式是一定高于声明式的，难道性能就不重要吗？ 框架的取舍 在可维护性的角度 声明式 &gt; 命令式 从性能的角度 命令式 &gt; 声明式 ​ 所以框架设计上就希望可以兼顾两者，既要声明式，又要尽可能的保持性能不会太差，在性能与可维护性的基础上寻找一个平衡点，这就是框架的核心目标。 声明式框架的实现要素​ 声明式框架需要提前在html中进行声明，这并不符合html的规范，所以我们的vue中的HTMl代码其实并非真实的代码，而是通过内部的编译后，形成一个真实运行的代码。 ​ 而这在内部实现上，存在2个步骤 1. 编译（compiler） 1. 运行（runtime） 编译时 将模板代码编译为一种浏览器可读格式 ​ 框架为了开发体验，经常会提供一些更加人性化的写法，这些人性化的写法便于人类阅读，但是不利于机器阅读，所以需要将我们编写的代码编译为机器便于阅读的代码，在vue中，compile函数用于编译template为render函数认识的代码。 ​ 运行时 将vnode转变为当前平台实际运行的代码 ​ 在运行时阶段有两个非常重要的函数h render，h函数用于生成虚拟dom，也就是vnode，render函数则负责解析与渲染vnode到特定的平台，如果是web平台，则渲染为dom。 vue为何采用编译时 + 运行时 编译时+运行时的代码实现中，我们规避了直接操作dom，而是引入了vnode的概念，让我们对html的逻辑变成了对js的逻辑，运行速度大大增加 使用编译时 + 运行时可以将每个流程更加彻底的解耦合，使更多语言可以被编译，可以被运行到更多平台。 为什么vue3对ts支持更加友好？首先vue3对ts支持友好并不是仅仅因为ts写的，这是一个片面的回答，vue3有用良好的类型校验与格式存在2种原因 大量编写type类型文件，让vue3+ts代码非常严谨 api设计的前期就考虑到了这一点，尽管DSL实现类型推到非常麻烦，但是vue团队还是实现了","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"vue3-配置环境","slug":"关于vue3的研究/vue3-配置环境","date":"2023-01-18T16:00:00.000Z","updated":"2023-01-20T08:54:02.258Z","comments":true,"path":"2023/01/19/关于vue3的研究/vue3-配置环境/","link":"","permalink":"https://bluedancers.github.io/2023/01/19/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/vue3-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言​ 使用vue3也有一年半的时间的，原本打算在22年的9月开始源码阅读的，一方面是作为一个前端人应当去了解技术原理，其二也是想通过源码解读来回答一些我心中对vue3的疑惑；但是后面因为公司业务相关事宜，实在是静不下心来完成源码学习的工作；转眼之间又来到了23年春节，赋闲在家，是一个难得的学习的机会，所以打算在2月中旬之前，完成vue3源码的学习与分析工作。那我们废话就不多说了，直接开始吧。 环境搭建vue2与vue3的对比 对Typescript支持不友好 大量的api都挂载在Vue的原型上，难以实现tree shaking 架构上对跨平台开发支持较差 composition-api 收到react hook的启发 对虚拟dom进行重写，对模板编译进行优化 monorepo介绍 一种将多个package包打包到一个仓库的技术 monorepo环境搭建","categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"一个5年前端er的“前世今生”（前传）","slug":"日常/一个5年前端er的“前世今生”（前传）","date":"2023-01-10T16:00:00.000Z","updated":"2023-01-13T11:42:06.665Z","comments":true,"path":"2023/01/11/日常/一个5年前端er的“前世今生”（前传）/","link":"","permalink":"https://bluedancers.github.io/2023/01/11/%E6%97%A5%E5%B8%B8/%E4%B8%80%E4%B8%AA5%E5%B9%B4%E5%89%8D%E7%AB%AFer%E7%9A%84%E2%80%9C%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E2%80%9D%EF%BC%88%E5%89%8D%E4%BC%A0%EF%BC%89/","excerpt":"","text":"前言​ 我是一名18年下半年工作的一名前端开发，现在是一家规模不大的公司的前端组长 + C端产品经理，今年是我进入前端岗位的第五个年头，做C端产品经理的第一年；22年外部环境较差，技术岗位似乎也不再狂热，也看到了很多同学面对技术岗位的疑问，前端是否还值得学？，我适不适合学编程？，23年初亦是一个改天换日的节骨眼，借此机会，我也重新审视一下自己。希望我的经历可以为大家答疑解惑，为大家的职业选择提供一些参考。 ​ 篇幅较长，打算分两篇文章，前传写我是如何一步一步走向前端，以及学习开发的过程给我带来了怎样的改变。 ​ 对应的是16年9月到18年6月，也就是我进入大学之后，进入工作岗位之前的时间。 ​ 2016年​ 我是一名没参加过高考的同学，因为高三期间已经我确定了本科无望，决定在16年春天专科的自主招生中提前走，当时对专业的选择很清晰，因为一直以来特喜欢研究电子产品，对计算机很有兴趣的，所以专业方向很明确。为了求稳，最后选择了相对冷门的“物联网技术与应用”专业，这个专业其实和计算机技术与应用差不多，2016年3月20号考试，300分卷子，考了280分。 ​ 考试完成后，在家休息了10天，耐不住寂寞，就想出去挣钱，没想到意外开始了长达5个月的打工时光，那时候尚且未成年，9月还要上学，能找到一份有薪水的工作，且一个月有1600（对于当时的我来说，已然是一笔巨款），实属老天保佑，虽然是厂里面。这也是我人生中第一次进厂打工，那段日子，对我后来在大学中坚定学习信念产生的很大的影响，如果读者们兴趣的话，到时候再更新吧，我们回到主线故事。 ​ 转眼就到了16年9月，大学生活正式开始了，大一上学期简直就是一塌糊涂，学校教的第一门编程语言是C，可能天赋不够，第二节课就听不懂了，那一年基本玩过来的，其实内心已经很焦虑，但是又找不到方向。 ​ 面对C语言课程，我的表情大概是这样的。 ​ 后来到了16年冬天，学长给我看了一个表白主题的H5，依稀记得是用canvas实现的，代码那时候肯定是看不懂的，但是还是无师自通的发现了可以用记事本全局替换文字，发现这个秘密后，我打算给刚谈恋爱不久的同学一个惊喜（直男行为，请勿模仿），把里面的名字，替换成我和她的名字，项目里面很多文件，我估摸着用记事本一个一个替换至少花了三小时，后来被人家踹了。大一上学期就这样在学生会、游戏、恋爱，网吧中荒废。。 ​ 转眼到了17年春节，走亲访友下午回来后，一般都很闲，可能真的是太无聊了，竟然想学习一下之前的表白H5，学长告诉我，先学HTML+CSS，于是我就去了慕课网（imooc），学习了HTML+CSS的初级课程。不得不说，慕课网的课程做的很好，简单的同时，又充满了成就感，大约花了7天的时间，认认真真的把课程学完了，那时候还用本子做笔记，可惜本子现在找不到，要不然一定拍出来给大家看看。学习半个月后，我根据当时的全部知识，在2小时内使用Hbuilder临摹了百度的搜索首页，真的是成就感满满啊。 2017年​ 后来就到了大一的下学期，开始讲Java了，说实话，我也不清楚是老师问题，还是我的问题，我依旧上课听不懂。那时候已经不想荒废时间了，于是我上课就自己临摹网页，比如淘宝PC站点、网易新闻首页，看到啥就临摹啥。也算是认真学习了。还瞎折腾在阿里云上买了轻量级服务器和域名，配合wordpress，搭建个人博客；因为第一次接触阿里云，很多地方都无从下手，全靠自己摸索，一弄就是几个小时，急的我满头大汗，当然最终我还是部署成功了，回头来看，【折腾的过程】又何尝不是一种财富呢。 ​ 随着临摹的网页越来越多，html+css也愈发熟练，我开始进入JavaScript的神奇世界，那大概是17年5月。看的是网易云课堂的李炎恢老师的JavaScript教程；虽然课程有年头了，但是老师教的很不错。JavaScript难度比html大多了，最终还是坚持下来了，完成了第一遍学习，到了这个阶段，真的已经学入迷了，每天晚上我都和狗皮膏药一样跟着准备竞赛的室友找一间没人的办公室学习。 ​ 17年6月下旬，暑假前夕，在室友的引荐下，终于被竞赛老师注意到了，竞赛老师姓蔡，我们私下都叫他老蔡。 ​ 我对竞赛是充满期待的，同时也意识到了这是一次非常难得的机会，可惜谈话并不顺利，我和老师非常充分了的说明了我想参加比赛的决心，老师也和我聊了老半天。但是对于比赛这件事，却让我再学习学习，扔了几本书给我打发走了。我记得其中有一本《JavaScript设计模式》，完全看不懂。最后在大学图书馆重新找了本JavaScript入门数据。而进入竞赛组的学生都去北京培训了，我不止一次的表示也想去培训，但是老师委婉的表示，没有前端培训，你暑假自己学学吧，说起来还挺失落的。 ​ 比赛结束了我才知道，老师当时认定我不是正经人，其一是当时染了黄毛，其二是参加了学生会，其三是没有参加高考。 ​ 17年的暑假，只能回家啦。在之前的工厂继续打工，还好工厂里面可以接触到电脑，一边打工一边继续学习css、临摹网页，暑假就这样过去了，这次的工资后来成了我校内生意的启动资金，帮我赚到了半年的生活费，这个也有空再聊吧。 ​ 17年9月大二开始了，长期的学习已经让我铁了心想走前端路线了。自然不想把时间浪费在课程上了。我和老师请求能不能不上课，去没有人的教室自己学习，我们安卓老师比较好说话，说明情况后，老师让我和安卓竞赛组的学生一起学习，时至今日，依旧想说一声，感谢你，赵老师； ​ 大概就这样保持高强度学习到了9月底，机会终于来了，蔡老师的云计算竞赛组中，web + docker位置一直存在空缺，本届没有合适的学生，上一届同学已经功成名不想继续参加了，蔡老师最终还是给了我试一试的机会，10月7号，正式进入云计算竞赛组。 ​ 17年的10月初，进入实验室前夕，还朋友去南京玩了一圈，逛逛夫子庙、南京博物馆，与自由做一个告别。回来当晚就进入实验室。云计算竞赛组的规矩非常严格，作息时间：8:30 - 11:00&#x2F;14:00 - 18:00&#x2F;19:00 - 22:30，周一到周日全年无休，堪比互联网行业9107，但是对我来说这是得之不易的机会，因为兴趣，所以快乐。 ​ 进来之后，蔡老师就给我定了目标，一个月之内搞定web项目，起初还是有信心的，但看到这个所谓的web项目实际上是java的SSH项目时，我懵了。 ​ 整个项目web占比并不多，反而java开发量占比巨大，那个阶段我只会HTML CSS JavaScript（ES5），并且仅限静态页面的水平，web前端，HTTP，前后端交互完全不了解，更别说java了，相当于10级萌新直接挑战60级boss。初期异常困难，把ajax都写到java里面去了，还不知道为什么编译器报错，急的我天天都睡不着，好在整个10月学长一直对我进行指导，帮助我消化java部分，加上之前前端基础比较扎实，将绝大部分处理逻辑移到了前端侧后，11月初终于把ssh项目全部搞明白了，在实验室留了下来。 ​ 后面11月、12月都是日复一日的不断的学习，也进入了高速学习阶段，linux、docker、mysql、git，都是竞赛的一部分，肯定需要学习的。于此同时，私下也在继续深入前端领域，开始进入前端工程化的世界，学习Vue，之前一直写的都是原生或者jquery，编码思维上是面向过程的，刚开始接触Vue，很蒙圈，也很新奇，此外也逐渐进入了大前端领域，包括webpack scss typescript nodejs，还有github npm，琳琅满目的框架与工具，进一步的让我感受到了技术的魅力。 ​ 当然JavaScript不能放弃，那段时间把冴羽老师的JavaScript深入系列，专题系列认真看了一遍，当时只能看懂40%，但是依旧给了我莫大的帮助，对JavaScript的理解提升了一个档次，还有其他很多老师们的博客以及教学视频，非常感谢前辈们无私的奉献，有你们，技术世界会变得更好。 ​ 一转眼就放寒假了，我们竞赛组留在在学校，17年冬天很冷，鹅毛大雪，宿舍门口杯口粗的树干都压断了，为了增加学习时间。我也搬到实验室住了； ​ 这里我重点说一下，我们云计算实验室，听起来很高大上，其实上环境非常差，没有空调，到处都是机房的线，墙壁发黄并且起壳；是我们睡觉 + 吃饭 + 学习的地方，同时还是我们老师的办公室，而且还是顶楼，窗户也关不严，冬天风嗖嗖的，夏天墙壁被晒得发烫又像烤箱。不过我不在乎，燕雀亦有鸿鹄之志。我们在过年的前三天回家了，学校还发了坚果之类的慰问品，咱们学校还是很不错的。我家距离学校并不远，都在一个城市，但是这却是我时隔半年，第一次回家；临走前，学长给我丢了一本书《深入理解ES6》，让我过年在家继续学习。 ​ 动荡的2017年就这么过去了，年初还键盘都敲不利索的学习html css，而年底已经可以做一些独立开发，这一年经历了太多，从对未来的焦虑到对未来的兴奋，从荒废到废寝忘食的学习，，得到了竞赛老师的认可，进入了学习氛围浓厚的实验室，这是独一无二的一年。 2018年​ 18年春节，农历初五返回学校继续学习，在家的一个星期中也没歇着，加紧时间将《深入理解ES6》的全部内容看完，知识点很多，let、箭头函数、解构赋值、模板字符串、等等，受益匪浅，ES6是革命性的武器，后面我又断断续续学习 ES6 2年，足可见ES6的重要性，对了，深入ES6主要学习了《你不知道的JavaScript》，我们继续回到主线故事吧。 ​ 18年上半年只有一个旋律，职业技能大赛，18年3月中旬进行安徽区的省赛，前三名可以参与5月下旬深圳举办的国赛，蔡老师慎重思考后，决定暂时不让我上，让上一届的学长参加省赛。我可以理解，竞赛老师要为比赛结果负责，而我资历最浅，自然风险最高。最终兄弟们在安徽芜湖的芜湖职业技术学院拿到了省赛第一名，顺利进入国赛。 ​ 在比赛练习的间隙，我依旧保持了不断学习前端技术的习惯，具体学习方法是不断的看技术教程文章与视频、不断的写代码加深理解，那段时间经常看慕课网的付费Vue课程，老师们精彩的课程，在我理解现代前端上起到了很大的作用，另外就是技术胖老师的一些免费大前端课程，非常感谢老师们。同时也开始尝试写博客，进行输出，希望可以像帮助过我的前辈们一样，用我的能力帮助到更多前端人。 ​ 省赛之后，老师找我聊天，和我说会尽力为我争取国赛上场的资格，对与这件事，我很感动，因为校领导是不希望我上场的，我的学长能力更强，并且已经有一年参赛经验，能抗大旗，最后是蔡老师和校领导拍桌子，将一起责任担在自己肩上，才争取到了我国赛上场的机会，这些事情都是比赛结束之后才知道的，因为老师怕我比赛心理压力太大。其实蔡老师没理由这样，他的立场和校领导一样，只是蔡老师想尽自己所能，尽力为每一个追梦赤子带来回报，哪怕承受巨大的外界压力，真乃恩师也。 ​ 18年5月下旬，我们踏着初夏的晴日，带着8个月日日夜夜的努力，踏上了前往深圳的路程。到深圳的时候，已经是半夜2点，第二天8点无论是老师还是学生，依旧准时起床，做比赛前的最后冲刺，艰苦环境打不到意志坚定的人。 ​ 我们在深圳的宾馆练习到最后一刻；5月26号，正式开始比赛，我们早早的进入了比赛场地，对机器进行最后的调试。 ​ 真的进场了，到了最后一刻，其实也不紧张了，比赛时间2小时，因为我准备充分，我的题目都非常快速的完成了，拿到了可以拿的所有分数，团队中后期出现一些问题，但是最终都妥善解决了，没记错的话，最后存在小部分题目没有完成，但是这已经非常非常好了。 ​ 响铃，比赛结束，键盘敲击声逐渐停歇，人们开始根据引导逐步走出赛场，我的眼眶已经湿润，这一路太辛苦；从小我就爱玩，小学去游戏厅，中学去黑网吧，从来不好好学习，最后上了专科，其实不是不想学，只是因为一直断档，导致无法跟上学习节奏，随着年纪的增加，内心也越来越焦虑与自责，对未来充满迷茫，也愧对父母这么多年的养育之恩，但那一刻，我成了自己的英雄。 ​ 我们小组另外2个人因为没有拿到满分，似乎心情不太好，情绪没有渲染到位，我又把眼泪憋回去了，冷静下来后，仔细分析了一下，因为有一些题目没完成，内心还是比较担忧的，怕辜负了老师和大家这么久的努力。当天晚上成绩出来了，我们在全国88支队伍里面，排名第3，前10名国赛一等奖，我们成功了！。 ​ 成绩出来当晚，原本打算去看看深圳世界之窗，但是因为和校领导喝酒应酬，没去成，至今也没去成，回去的路上蔡老师和我们说了很多，包括强行让我上场和校领导的翻脸，以及这么多年搞比赛，做竞赛指导老师的艰辛；恩师难求，我们亦没有辜负蔡老师的期望。 ​ 第二天领奖仪式后，我们下午便启程返回合肥，学校专车过来拉横幅、送鲜花给我们拍照纪念，那种感觉还挺奇妙的。后来回到学校实验室后，也许真的是太开心了，紧绷的神经突然松开，似乎陷入到了一段甜蜜梦境，所以啊，那一段记忆怎么也回想不起来了。 最后​ 我偶尔会想，如果在另一个宇宙，我与蔡老师擦肩而过，是否还能走到前端这条路，会不会毕业就去工厂，亦或者毕业后花费几万元去培训，这些都是更加难走的路线。不过现在我有了答案，无论是何路线，都将走向现在技术岗位。 ​ 因为决定性的钥匙已经被我捏在手中，那就是兴趣。 ​ 这也是我想送给大家的答案，技术岗位似乎已经不像几年前那样火热，内卷非常严重，大厂开始裁员，互联网这么多年的发展似乎已经走到了尽头，不是这样的，可以独挡一面的开发，始终是稀缺的；但如果是奔着待遇来的，那么大概率拿不到高工资，并且职业上限很有限。只有兴趣，只有发自性的去做自己认定的事情，无论什么样的风雪都吹不灭的意志，才能带你突破重围，一定要不断思考自己，去探究本我，寻找自己的闪光点，然后不问结果的去做，直到最后一刻。如果历尽千辛万苦依旧失败，不必气馁，因为这一路的历练与坚持，会帮助你下一个的选择，如果成功了，将是人生的转折，就像《肖申克的救赎》中，Andy凭借超凡的信念与毅力，爬过长达500米的下水道，重获自由。 ​ 前传大概就到这里，后面还有坎坷的求职、专升本，那是一段与大学完全不同的经历，篇幅有限，下一篇我们再见吧！👋🏻","categories":[{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"阅读、游历和爱情","slug":"阅读/阅读、游历和爱情","date":"2023-01-09T16:00:00.000Z","updated":"2023-01-24T09:54:08.409Z","comments":true,"path":"2023/01/10/阅读/阅读、游历和爱情/","link":"","permalink":"https://bluedancers.github.io/2023/01/10/%E9%98%85%E8%AF%BB/%E9%98%85%E8%AF%BB%E3%80%81%E6%B8%B8%E5%8E%86%E5%92%8C%E7%88%B1%E6%83%85/","excerpt":"","text":"​ 这是梁永安老师的22年的初版的一本书，也是我第一次了解到老师，读了一部分，说实话，我觉得这本书写的还不错，虽然有些人会说，梁老师对某件事物的评价，都是套公式一样的废话，听了就像没听一样，说实话，我不这么认为，《阅读、游戏和爱情》这本书，有些文字确实存在看似“废话”的句子，但是人间的道理，不就是这么一回事吗，人类不就是需要在外力的引导下与自己和解吗？ ​ 读了三章，挺不错的，能看得出来，梁老师是一个热爱生活同时存在沉淀的人，他的文字具有让年轻人坐下来看看仅仅阅读的力量。 好了，废话就说这么多了，下面我会针对每个小节，写一些自己的想法，做一些积累与分享吧！ 自我​ 我们这一代，很多人是没有自我的，因为我们是中国第一代多元社会的经历者，我们大多数人带着传统思维来都这个多元的社会，一下子就陷入了一种迷茫，传统的思想不断受到挑战，甚至开始否定自我；在认识自我之前，我首先想说的是，要认识本我，很多人因为收到了家庭、社会、朋友的影响，开始分不清自我与本我，这可能会让一个人定位迷失，活在自己想象的世界里面，在寻找本我的过程中其实就是寻找自己在这个社会中的定位与坐标。 ​ 而我们现代社会因为历史阶段的复杂性，一方面我们没能脱离小农经济的影响，一方面我们需要像游牧民族那样快速适应，而中国社会本身有啥一个层叠社会，导致我们国家的价值观不是一元的，是有多重标准的，这都导致年轻去认识自我存在难度。 ​ 在这样的纷杂的大环境中，年轻人应该如何真正的认识自我呢，梁老师的答案是经历与突破，我们原生家庭带来的准则未必是符合现代的，倒是那些符合，那些又不符合呢？这个就需要当下的年轻人自己去经历，去沉淀，最后形成完整自我，完成对自身的突破。 ​ 有一句话是，世界上只有一种英雄主义，那就是看清了生活的真相后依然选择热爱他，其实这就是经历并且形成完整自我的结果，这个过程是艰难、挣扎、困惑的。 ​ 最后，想谈论一点，那就是坚定自己，其实在我这几年的经历里面，我也与都了很多对人格的冲击，从几十年来的固有观念的冲击，甚至对自身的准则产生怀疑，其实这是对自己认识不充分的体现，而现代生活又是如此多元化，坚定自己就显得极其珍贵，这里的坚定自己并不是顽固的坚持自己，而是接受世界，思考，批判，最后形成更加立体的自我。 工作​ 现代社会中，我们大部分人拥有了选择生活的机会，却又没有选择自己想要生活的权利，这有两方面的原因，一是固有观念的影响，二是社会本身的影响，我们现代社会是一个高度分工的社会，并且大家自由寻找的社会，其实这也是残酷的，因为岗位有好有坏，并且每隔10年也许就会发生变化，这样的环境充分的激发的大家的积极性，但是也加深了整个社会的焦虑； ​ 有些朋友可能还没有找到让自己满意的工作，其实越是这样的情况下，越是需要大家先去做，去深刻的体验，只有这样才能找到希望，找到自己的目标，如果一份工作你用尽全力依旧无法感受到自己的价值，那时候再带着这份工作带来的宝贵经验，再次出发，未必不是一件好事。 ​ 关于“摸鱼文化”，梁老师提出了很多很有价值的想法，一方面我们认同这种“亚文化”的出现，年轻人并非不努力，而是无可奈何，并且我们也没有形成让年轻人发泄的文化，最后形成了“躺平文化”，而这主要是两个因素的影响，一是层叠社会，二是我国的发展阶段，我们的父辈在改革开放的大环境下，是激发潜能，能人辈出的年代，他们在这边土地通过自己的打拼获得了回报，大家都看到了努力的价值，另外我国国情目前达到了非常关键的中等收入进入高等收入阶段，整个国家都在奋起前进，但是这样的环境中，我们年轻人是后来者，我们实际上是被裹挟在大环境的，我们从小直接自由主义的熏陶，但是通过了，却发现工作没有自由，所以这一切都是很合理的，年轻人陷入了迷茫，他们嘲笑自己躺平，实际上都是对生活的一种思考，这是积极向上的体现，我相信很多年轻人在挣扎与思考后都会发现，我能发挥自己的能力去让这个世界变得更好，去解决问题、探索答案，却不是仅仅抱怨问题。 ​ 肯定工作的价值，哪怕是阶段性的重复并且无聊的工作也未必就毫无价值，梁老师给了我们两个建议，第一是保持好奇，现代社会，前路是不可预测的，保持好奇才能更上脚步；第二是走出舒适圈，在新的领域寻找可能性，我们要去感受这个世界，人类，自然，情感，了解的多了，内心才能开阔，见识才能增长。 ​ 关于最后的斜杠青年，梁老师的观点我非常认同感，可以斜杠，但是不能太斜杠，太斜杠就不算斜杠了，那又如何找到值得斜杠的技能呢，梁老师的答案百分百真诚，百分百坚持的做一件事，如果我们没有到深入的程度，我们就无法值得一件事是否适合我们，哪怕最后结果不好，过程的宝贵经验也是非常重要的财富，帮助我们再次上路。 人格​ 人心是复杂的，好人与坏人也是界定不清晰的，现代社会的起点是文艺复兴，而文艺复兴最大的要点，就是释放人的本性亦或者说是欲望，人心这个社会是如此的多元化，也是如此的复杂，在这样大环境如何评价一个人格好与坏？这并没有答案，对于新鲜事物的好与坏的评价社会是存在一个缓慢的接纳过程的，就像“涂鸦文化”，早些年是一种反抗运动是坏的，但是几十年后，这成为了一种个性的表达，成了一种象征，我们无法用传统的人本主义去判断在这个“多元”社会发生的事情。 ​ 而发生在我们身边，对好人的界定依旧是复杂，书中提到了一个例子，我觉得非常经典，《挪威的森林》中，男主是放荡并且热爱自由的人，而女主却将男主当做唯一，这给男主造成了巨大的压力，以至于男主一直做出在女主看来很坏的事情，这是男主对自己自由的捍卫，对男主而言，这是好的，你看不同视角来看，就是不一样的，很难有一个道德标准去评价人的好与坏。 ​ 那倒是什么是好人呢？书中给了一个我很赞同的答案，身处迷茫的人，因为迷茫意味着思考，意味着自己探测，只有不断思考，接纳这个队员的社会，并去理解他，王阳明曾说：”知行合一，致良知“，做一个不断思考与接纳的好人。 躺平与幸福​ 躺平是不是坏事？其实这几年，躺平文化，确实是越来越被大众所熟知，我们已经进入了现代社会，自然不可用农业社会的道德标准去看待，农业社会中，日出而作日落而息，生活是规律性的，这自然是不允许躺平，而现代社会是细化分工的，是无规律的，年轻人具备了去躺平的条件，而躺平不是对生活的放弃，而是对迷茫生活的一种思考，对压力的一种宣泄方式，但是因为我们独有的内卷教育体系，我们无法像欧美国家那样，发展出摇滚，朋克文化，形成了我们独有的文化，就是躺平。 ​ 所以躺平不仅不是年轻人对生活的放弃，而是对现阶段社会的反抗与反思，在躺平中，人们开始思考我追求的究竟是什么，我如何过好我的一生，这都是一个人极其重要的组成部分，去认识到这个世界的高度，与自己的无知，去了解过去发生在这片土地的故事，然后再站起来，追求自己的幸福。 ​ 以上很多只是我有感而发，并非文中的想法，梁老师想告诉我们，远比我上面描述的要多的多，也更加体系化，总而言之，躺平不是不可取的，不是不被允许的，但是躺平之后要想想，好好体会一下，深入的思考一下，然后继续出发。 女性文化​ 这是一个很新鲜的话题，因为历史原因，女性在历史上是被压迫的存在，结婚后，就要离开原生家庭成为漂泊的人，成为别人的拥有物，这就需要女性对自己进行封闭，封建社会对女性的异化是非常严重的，也不断的压迫女性追求自由的权利，直到工业革命的出现，劳动力开始稀缺，女性得到走向前台的机会，并且在某些领域做的比男性更加好，从此女性获得了劳动回报“工资”，则意味着女人不再必须依赖男人才能活下去，拥有资本则拥有权利，但是女性文化的进步亦是曲折的，因为早期资本的介入，女性被按照男人的想法塑造出来，最后变成了追逐金钱的游戏，比如经济泡沫之前的日本，年轻女性被资本教育成了“如果没有拥有一个名牌包包就白活”。 ​ 女性文化真正的追求的是突破对自由的束缚，不仅是行为，更加是观念上的自由，不被封建思想左右，不被小农思维左右，去深度的思考突破不应存在的限制，这一点与追求完善的人格具有一定的相似性。 谈女性写作​ 女性写作最早最早起源与工业革命，因为工厂进入城市，大量贵族进入乡下，将一些古典贵族特有的习惯带入到乡绅，其中便有读书，女性开始了更大范围的阅读，这位后面女性的创作提供了基础。 ​ 女性的小说，相对与男性的宏达诗篇，冒险游记，其内容侧重点要更加细腻，以微观与心理描写为主，这也和女性的性格与生产环境存在一定的关系，而这些又深受工业革命背景下女性的喜爱； ​ 科学研究表示，女性的表达欲望是男性的三倍，并且更加注重情绪交换，但是这并不代表女性可以更加轻松的成为一名作家，写作是需要天分的，属于艺术范畴，我们一般认为这是一种突破常理的，虽然写作似乎很难，但是我们希望大家去尝试，也许这是自己被埋没的天赋，也许在这个多元世界受到新的启发后，就会产生一些第一五二的想法，去探索、探寻内心世界与思想的解放，其实这不论男女，都应该这样。 我们为何相爱相杀​ 我倒是觉得，这并不是坏事，工业革命之后，女性开始拥有人权，打破了几千年来的男尊女卑，女性得到了快速的进步，也开始兴起女性权利斗争运行，这在几百年前都是无法想象的事情，正是女性地位的上升，男女的差异才得以释放。 ​ 那么在现代社会，男女又应该如何相处呢，其实这一点我也经验尚欠，但是我赞成梁永安老师的想法，两个人在一起的价值就是一起创造独一无二的生活，相爱是存量的，而相杀的感情的增量，正是因为勇敢的相杀，彼此才能成长，而不是功利的去看待男女关系。 ​ 另外还要再多说一点，两个人再一起，不仅要向内走，更加要向外看，寻求更大的精神空间，现代社会是复杂的，多元的，我们现在的生活也非常向美国20世纪20年代，大量的年轻人成了无根的人，人的思想在不同环境中被影响与塑造，产生了很多选择，正是这些选择让人们活的很纠结，很累，这样的环境下，大家都想找一个可以帮助自己减负的人，婚姻就变成了解决问题的方式，但是在剩下的人生中，我们还会遇到比物质匮乏更加难的问题，精神的匮乏，人的异化，这都不是功利可以解决的。 ​ 最后，我想写单身并没有罪，我们90后身处传统意识与现代社会的交融点，是复杂的一代，一方面我们追求精神自由，一方面却无法摆脱传统思维，我亦是如此，观念上跨不过去，虚妄的恐惧统治了自己，希望后来者积极探索不一样的可能性。 谈爱情​ 读到这里，我基本确定了，梁老师这本书的基调，是以中国社会、世界文明的研究作为一切观点的基础，然后再延伸到各个方面，爱情、工作、关系。 ​ 未来的世界一定是更加开源，更加自由的社会，我们身处的时代要比国外更加复杂，我们短短几十年完成了工业化，同时存在农耕时代、工业时代、网络时代，我们身处自由之中，却被旧时紧固，这样的环境下，爱情就变成了一个非常复杂的命题，应该遵循传统，还是跟随内心，究竟是主动出击，还是听从安排，其实问题答案大家心里大部分都有数，现代社会重人权的，自然一切从自身出发，但是历史快速转变的背景下，又有几个可以做到突破镣铐呢。 ​ 爱一个人，万不可停留在臆想中，然后自以为找到了理想，一旦臆想逐渐破裂，就会形成巨大的悲剧，所以我们已经要走追求美好的勇气，也许要真正的看清自己看清您一半与拒绝一段感情的勇气。 ​ 最后，跟随本我，用实践去理解爱情，勇敢的去学习与接受这个世界，去打破固有观念的限制，保持学习，培养自己抓住一瞬间的能力。 ​ 谈孤独​ 人类需要孤独，因为孤独，人们才有审视自己的机会，因为孤独人们才有体会到感情的可贵，如果人人都在漂流，又如何去了解自己呢。 ​ 现今时代确实是一个纠结的时代，一方面是我们受到传统观念中一切寻求安稳与规律的影响，一方面我们接触这几十年改革开放，多元文化的快速进入，很多年轻人在安稳与自由之间举棋不定，因为自由伴随着困难与孤独，而安稳则无趣且不自由，这是两个完全不同的思想。 ​ 从古至今，所有有思想的人都是孤独的，因为他们具有超乎时代的能力，这对社会其实是一种反叛，自然探索者都是孤独的，而对于现代的年轻人来说，其实孤独并不是坏事，我们身处历史的转折点，需要很多的时间，去看清我们与历史、未来的关系，没有孤独则没有思考，没有思考在无法了解自己，无法审视自己，何谓自己的追求，在这个自由社会，我是否真正的自由了，这都需要我们静下心来，跳出现有框架，去俯瞰自己，一直活着浮华之中，只会让内在空空如也。 ​ 梁永安老师说，如果一个人完全忍受不了孤独那就出现大问题了，其实我不是很同意这个观点，其实这与很多因素有关，有些人的生长环境已经达到了自己的想象，甚至超越了，这就成了孤独最大的障碍，因为她当下没有理由去抛弃这一切，放弃现有的优待，去从零开始另一种生活无疑是困难的，这是一种生活态度，长远来看，也许懂得越少，活的越快乐呢，人活的成功，深度并不是唯一标准， ​ 但是请不要抗拒孤独，不要荒废孤独，孤独其实是奢侈的，可以放心自己的机会不常有，去静静的思考，去阅读，去感受自身独一无二的特性，思想的深度将会帮助你活的更加精彩。 谈读书​ 书籍是人类智慧的结晶，是独特的人类立足世界的基础，通过书籍，我们得到了和世界、时空对话的机会，年轻人们需要去多读书，去链接自己与世界，梁永安老师对读书有一些更加深层次的理解，就是寻找自己的生命之书，以及书籍具有改变命运的能力，历史中有很多非常伟大的人物，都与书籍有密不可分的关系，例如历史上的拿破仑，他一路增长欧亚大陆都带着《少年维特的烦恼》，这本书给予了拿破仑很大的精神支持，让人们在纷乱的世界中保持清醒。 ​ 另外梁老师谈到了一点我非常赞同，并且我去做了的事情，就是细读，我读书的速度一直都是慢于平均速度的，因为当我看一本书的时候，我会从，历史背景、作者背景、描述方式，等等多个角度去分析与欣赏一个作品，这让我每看一本书都受益匪浅。 ​ 第二个要谈的话题是，读书可以激发一个人的灵性，回想儿时，其实我一直都爱读书，作为独生子女一代，我的童年的独孤，是童话故事、拓展阅读，然后是作文范文，在之后是意林，但是因为客观因素，我接触到的书其实并不多；让我第一次感受到“读书”的魅力的书，是一本家喻户晓的书《活着》，我第一次意识到我们的世界并不是一层不变的，这个世界既有广度也有深度，于是书籍成了我重要的信息窗口，读书的同时让我沉浸在自己的反思中，获得更加有价值的提升，这是一件极其美妙的事情。 ​ 关于如何验证读书的作用，梁老师的观点是“写作”，除了这个观点之外，我还想说另一点，“交谈”能力，我近五年是认知提升，几乎都是读书带给我的，读书，让我的思想有了深度，让我有看到一件事更加底层的能力，以及对同龄人的观点输出能力，所以想验证读书的左右，除了写作，不妨也可以多试试深度交流，可以是你的群友、你的上级，甚至老板，而观点的碰撞，又会产生新的价值，这是非常宝贵的。 ​ 我们的时代，是适合读书的一代，我们的父辈被工业时代和尚不丰富的物质生活裹挟，并且大多存在兄弟姐妹，他们大部分没有反思自己，没有去读书的几乎，但是我们95后，是非常不同的一代，独生子女+现代社会，让我们每个人都是成了个体，社会关系逐渐变淡，我们有更多时间，和反思自己的机会，如何去反思？我认为读书是最好的选择，书籍让我们有了一场精神交流，去探究生活更加深层次的意义，读书会让我们收获良多。 谈生活​ 我们这一代年轻人其实是充满疑问的，因为我们是第一届无法循规蹈矩的一代，父母也好，父母的父母也好，他们都是一代继承一代，但是现在这个方法行不通了，我们的生活失去了最基本的框架，在现代社会，原本的价值观已经被打破，我们的生活出现了多样性，失去的同时，我们也获得了我们往上任何一代都不具备的选择权利，所以首当其冲的就是，了解我们可以拥有怎样的生活。 ​ 上上一代在温饱线挣扎，上一代被住房压住，而我们这一代，已经没有了以上烦恼，我们这一代一定是在文化上有更多的需求，按照梁老师的说话，我们应当打开想象，不要局限在一种日出而作日落而息的生活中，去外面把好的感觉带回来，我们年轻人还有很大的成长空间，多样的生活已经在我们眼前，但是我们还没有积极的去获取，我们的电影，书籍还有很大的市场，自由的文明与中华文明的结合，需要我们去努力场次独一无二的种子，希望大家在生活上可以跳开父辈的惯性生活，走出去看看，也走进自己的类型看看，用好我们独一无二的财富“自由”，一个好的人生，一定是具备深度的，即在岸上，也在水里。 谈社交​ 我们这一代的人的社交，是不同前人的，我们创造了属于我们的独特文化，例如“宅文化”“躺平文化”，我们引导如何看待现代的社交方式，我们需要谈两个关键因素，家庭 社会，家庭是我们最初的社交场，也会对我们的人生产生非常深远的影响，而我们这一代，大部分都是独生子女，并且父母多半是工业阶段，在家庭感情上投入甚少，所以我们90后其实大部分是孤独的一代；这样环境进入社会，自然也很难形成大规模的社交群体，每个人更加停留在自己的舒适圈中。 ​ 而到了社会的第二阶段，我们逐渐融入社会，按理说应该会有所突破，但是实际上也没有，因为我们这一代是规模化教育，每个的人经历大致相同，人与人之间很难产生灿烂的火花，于此同时，互联网短视频，游戏的不断发展，助长了断社交是趋势，没有社交，大家依旧可以过得更好，最后再说一个梁老师的观点，就是传统文化对我们的隐形影响，中国自古以来强调自给自足，关起门来过自己的日子，久而久之便失去了社交性，自然我们骨子里蒙蔽了交流的价值，进而形成了我们现代的“宅文化”。 ​ 梁老师是阅历丰富的人，他凭借敏锐的情感与经历，感受到了社交的价值，并且对中国先进社会的社交气氛有所反思，意识到了人想在这个社会生存下去，就需要与他人交流，通过整个市场将自己和他人连接起来，自有这样多方面才能全面发展，进而构成脱离小家小户的社会心态，我觉得，我们已经快做到了，我们有部分年轻人是有这样的趋势。 ​ 另外还要说一点，就是无效社交，如果老朋友见面就是吃吃喝喝玩玩，这样是无法形成内心深处的情感交流，这样的社交无法让两个人形成更加深层次的链接，我们便永远无法拉进彼此的距离，需要大家尽可能的去输出与输出，寻找精神上的共鸣。 ​ 社交是为了生活，从社会发展层面分析，我们的父辈，更多的投入到国家，公共事业之中，每个人都是国家的螺丝钉，个人的精神追求与国家深度绑定，虽然生活很艰苦，但是大部分人是具有一个相对可预见的未来的，但是我们这一代经历了改革开放后，私营企业承担了大部分就业，以前遍地都是的价值感，便需要我们自己去获取，所以现代大部分都是”自私”的，为自己而奋斗，其实这是很合理的事情，现在我们为资本打工，生活确实越来越好了，但是我们的精神也越发贫瘠，这不是社会可以解决的，需要自己我们去探索了，其实有价值的社交，就是探索的一种方式，所以不然让我们离开舒适区，对于土地，与风土人情，与朋友们进行一次更加深层次的交流吧。 谈修养​ 我们这一代年轻人是很有修养的，我们接受了以往任何一代都没有的通识教育，接受到了来自全球的人文精神的影响，但是我们这一代是挑战巨大的，因为我们不断面临各种异化，资本主义，家庭，在现今社会，道德修养就显得尤为重要，因为你的行为取决于你的修养，这是我们每一个年轻人都需要去深入思考与提升到地方，梁老师给出了他的建议。 热爱自然 热爱人类 热爱生命这些修养然后我们形成自己的道德标准， 热爱自然比较好理解，就是认识到人类与自然的关系，然后从本初出发的道德准则 热爱人类是指我们不可丧失人性，回到人类本身，而不是功利的去看待这个世界。 热爱生命是人类是很多人难以做到的，包括我自己，我的理解就是对生命要充满敬畏，对自己的人生负责，去思考，去勇敢的做出自己的选择，不进行外界因素的拖鞋，不辜负生命，给自己的定制一个有点难度的目标，去充实自己，也去释放自己的，人就这样语法具有深度，语法理解休养的价值 除了以上三点，我再说一下我的关键，就是深度阅读能力，在深度阅读的过程中，会逐渐形成属于自己的更加深厚的修养，将会潜移默化的让个人具备超乎同龄人的思想高度。 ​ 最后是尊重，尊重从何而来，如何评判是否应该被尊重，这些其实是源于个人的修养，这都是相辅相成的关系，坚持自己的价值与原则，判断不应来源外界的肯定与否定，而是源自你的内心。 谈美​ 什么是美？这其实是一个主观的认识，传统社会的人们认为男人雄壮是美，女人好生育是美，现代自然是另一个看法，还有其他国家呢，我们的审美进入现代社会后从实用化趋向于个人化，只是没有问题的，因为90后一代是开创性的一代，自然社会面的审美发生变化也是很合理的，但是这些都是表面的， ​ 所以我们不能从表面去评价什么美，这是片面且经不起推敲的，那对于你我来说，如何去评判何谓真正的美呢，我仔细的思考了梁老师的话，实践就是美，美即使真知；在纷乱复杂的社会中，只有实践才能理解美的含义，充满困惑依旧一往无前难道不是一种美？坚守底线不畏舆论也是一种美，这些都需要在实践中去理解。 ​ 除了审美 作者也谈了审丑，我理解的审丑，其实即使审视自己，只有我们把那些荒诞的事情摆在我们眼前的时候，我们哈哈大笑的之后，才会发现其实我们是在笑自己，这又何尝不是发现美的途径呢。 谈艺术​ 何谓艺术？艺术就是打破有限，打破固有，正是如此，所以艺术可以带给人精神的宽度。 ​ 我一直对这些虚无缥缈的因素很有兴趣，他有什么直接价值吗，甚至于所谓艺术接触的当时，我都无法理解，为何这是艺术？更多成分可能是不明觉厉。 ​ 作为前端开发工程师，我可以通过编程创造性的解决问题，作为一名产品经理，我亦想创造性的满足用户需求，我们身处世界最前沿，虽然前路一片朦胧，但是却充满机遇，我们也获得了创造的权利，如果我们不把艺术局限于文学、绘画、舞蹈领域，你我未尝不是行动艺术家。 ​ 我们上一辈的人，其实不理解艺术的价值，中国是一个务实的国家，我们强调传统意义上的价值，强调国有意志。所以我们中国可以产出如此多优秀的管理者，但是且很少做出革命性的事情，而现如今，我们之间意识到了艺术的价值，艺术充满了未知性，并且艺术无法用现在的价值标准去评判，古代大哲学家苏格拉底经常与当代哲学家一起探讨生存的意义，这些事情如果从那时的框架去思考是毫无意义的，但是却给后人带来了深远的影响，启发了一代又一代人，所以无用还是有用，我们再现有价值框架很难平淡，但是我们从历史来看，艺术给人类的发展做出了巨大的贡献。 ​ 我认为的年轻人学习艺术，我所说的艺术，不仅是是传统艺术，自由、创造对我而言就是艺术，其实就是打破固有观念，关注自身正式的想法，人活着不仅仅只是肉体上的吃吃喝喝，精神也是需要喂养的，父母给了我们肉体活下去的机会，而我们自己则需要给自己活下去的机会。 最后​ 起初吸引我的是引言中对生活的描写，只言片语中，我真切感受到了梁老师对生活的热爱与时代的沉淀，这是我们当代年轻人最缺乏的2点，前者的匮乏来源与快速转折的社会，后者则来源与经历与反思。阅读的过程中，我仿佛看到了梁老师坐在我的面前，时而温声细语，时而语重心长，谈论了很多与每个人都息息相关的点，我们不必将梁老师的话作为绝对正确的答案，我们需要聆听与反思，找到自己的答案。 ​ 通读全文，我认为最底层最重要是以下几点，自由 热爱 求知，这三把钥匙，帮助我们打开答案之门，我对梁老师口中的层叠社会概念受益匪浅，我作为一名95后，几乎一直活在现代社会，我本能性的认为这个世界是平面的，并且惯性的只向前看，而没想到，不知古，怎知今。 ​ 通过层叠社会的发展规律，我们可以在宏观层面解释现如今社会层面的很多现象，再向前一点还是文艺复兴、工业革命，这都是人类历史重要的节点，真正理解了历史，看世界的角度就会高出了很多，也能够解释很多以前的疑虑，受益匪浅，谁说作为一个合订本，内容上存在一切重复，但是作为一名初读者，可以反复理解案例也未必不是一件好事，总体是非常推荐大家阅读的，走进梁老师的理想世界。 2023-01-24完 ​","categories":[{"name":"阅读-2023","slug":"阅读-2023","permalink":"https://bluedancers.github.io/categories/%E9%98%85%E8%AF%BB-2023/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://bluedancers.github.io/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"更加优雅的web端上传文件","slug":"解决方案/更加优雅的web端上传文件","date":"2023-01-02T16:00:00.000Z","updated":"2023-01-11T10:10:19.010Z","comments":true,"path":"2023/01/03/解决方案/更加优雅的web端上传文件/","link":"","permalink":"https://bluedancers.github.io/2023/01/03/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%9B%B4%E5%8A%A0%E4%BC%98%E9%9B%85%E7%9A%84web%E7%AB%AF%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","excerpt":"","text":"前言​ 大家一起回想一下，我们在使用Element、Antd的时候，是如何实现图片、文件上传功能。 ​ antd就不截图了，使用方法差不多，相信写过相关代码的同学，都会感觉比较繁琐。 既要改html，还需要写JavaScript，开发效率低。 组件API复杂，很多时候，并不需要那么多功能，心智负担重。 等等 ​ 这时候，写过微信小程序的同学，心里肯定会想，小程序的上传图片API开发体验还可以，逻辑上也很直观，通过事件触发函数，函数内实现上传图片的逻辑，我们web端能否也能拥有类似的开发体验呢？ npm地址以下内容为实现思路以及关键代码，如果您仅仅想使用的话，请直接到npmjs 文档地址：https://github.com/vkcyan/choose-to-file#readme 1npm i choose-to-file 需求分析首先，web端使用文件上传功能，一般使用input标签进行实现 1&lt;input type =&quot;file&quot; onchange/&gt; 最后在onchangecallback中，获取本次的结果。 我们会发现，上传文件必须通过特定的标签才能触发。这么来看似乎与函数式相违背。 但这并不是死路一条，我们可以通过input.click()，自动指定点击事件，核心逻辑就是这样。 实现思路 创建input标签 触发&lt;input /&gt;的click事件 监听上传结果，并作为结果返回，同时对临时数据进行销毁。 具体实现实现不与具体框架做绑定，我们基于原生逻辑进行开发，天然兼容web端框架。 理想使用方式 12345678async function uploadImg() &#123; try &#123; let res = await chooseToFile() console.log(&#x27;file&#x27;， res) &#125; catch (err) &#123; console.log(err) &#125;&#125; 接下来开始实现chooseToFile，首先我们创建input标签 12let input = document.createElement(&#x27;input&#x27;)input.type = &#x27;file&#x27; 创建完成后，立刻执行自动点击事件 1input.click() 然后监听input的onchange callback，并通过Promise resolve进行返回。 12345input.onchange = (evt) =&gt; &#123; removeInput(input) // 删除dom let &#123; files &#125; = evt.target as HTMLInputElement return resolve(files)&#125; 至此，我们的核心逻辑就完成了，还是很简单的~ 一些问题初始化阶段调用无效，并且会弹出警告。1File chooser dialog can only be shown with a user activation. ​ 这是因为浏览器的安全限制，不允许用户在没有任何”激活行为“的情况下，JavaScript调用窗口，针对此问题官网有详细的说明user-activation。 ​ 也就是说这是不允许的，大家开发中要规避这种行为。 无取消上传callback​ 当用户点击文件进行上传的时候，我们可以通过onchange组件进行获取，但是如果用户关闭了上传文件弹窗，或者点击”取消“按钮，input并未提供响应的回调函数。 ​ 如果无法监听取消上传，逻辑将不知道何时销毁临时标签input，查阅了一些资料后，找到了解决方案。 ​ 无论用户是否上传，只要当前用户有操作，上传行为结束，都会重新聚焦到body本身，也就会触发全局的focus方法，如果用户上传了文件则在onchange callback中将fileCancle赋值为false； ​ 之后focus事件触发的时候则不会进入if内逻辑。 123456789101112let fileCancle = true // 是否未上传文件window.addEventListener( &#x27;focus&#x27;, () =&gt; &#123; setTimeout(() =&gt; &#123; if (fileCancle) &#123; removeInput(input) reject(&#x27;upload canceled&#x27;) &#125; &#125;, 500) &#125;) 最终效果 调用函数，打开文件管理器 用户上传文件：.then触发，收到上传的文件信息 用户取消上传：.catch触发，收到无文件上传错误 最后​ 功能的实现并不复杂，因为作者工作上vue用的较多，所以可以保证Vue是没问题，理论上React也是没问题的，欢迎大家体验，在使用中有任何问题，请评论区留言。 ​ 祝你开发愉快。","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"羊了个羊，怎么突然爆火了？","slug":"NPDP产品经理/羊了个羊爆火，到底发生了什么？","date":"2022-09-18T16:00:00.000Z","updated":"2022-12-11T13:51:24.079Z","comments":true,"path":"2022/09/19/NPDP产品经理/羊了个羊爆火，到底发生了什么？/","link":"","permalink":"https://bluedancers.github.io/2022/09/19/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A%E7%88%86%E7%81%AB%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"中秋节后的几天内，每个互联网人都主动或被动地了解到了一个现象级小游戏羊了个羊 ，该小游戏在一个星期内火速出圈，高频制造热点话题，火速出现大量梗图，段子，可以说一举一动都引发巨大话题热点。 当我在各大平台看到这个关键字的时候，我的脑子里面只有一句话“发生了什么？”，直到9月15号铺天盖地的信息才让我意识到了他的火爆程度。 微信指数&#x2F;抖音指数 截止9月16号，其热度在微信与抖音都出现了指数级爆炸，同时在微博多次荣登热搜第一，以及多个热点话题，可能还有其他作者不知道的平台，微博 抖音 微信三个国民级app，已经包含了全国几乎所有的网民，这也为他后面的爆火埋下了伏笔，那他又是如何制造话题的呢？ 信息传播让我们坐上时间机器，回到中秋之前，羊了个羊刚刚上线的时间 9-9号 其官方账号在微博发布了一篇推文 在随后的时间里面，发布了老师vs学生 打击作弊 服务器崩掉 再次崩掉等等一连串的话题，而根据微博指数显示13号开始，热点趋势开始疯狂增加，这也就表明9号到13号是第一波启动用户。 除了微博外，也在抖音进行短视频宣传，可惜抖音趋势无法显示14号之前的数据，但是我们可以推测得出来，其热点也是爆炸增长的。 而这个过程中其宣传的切入点，过关率极低，不睡觉也要玩网友热评等等口碑宣传也起到了早期非常重要的推波助澜作用，让我们来深入分析一下吧。 价值冲突 在不知道游戏内容的情况下，如何吸引用户进入游戏？羊了个羊在做出符合Z时代用户游戏界面的同时，创造了额外的动机。狼人VS吸血鬼 五仁VS莲蓉 学生VS老师 省份VS省份，一旦出现了站队，游戏便不仅仅是游戏，还包含个人价值是否被认同，如果你喜欢吃五仁，看待五仁落于下风，便存在内在动机去参与游戏进行支持，如果你喜欢吃莲蓉，便会进入胜利者的自嗨状态参与游戏寻求碾压对手。 一只羊一旦进入羊群，他便不仅仅是一只羊，而是羊群的一份子，自然带上了集体荣誉的帽子，排名靠前，自豪 快乐，排名靠后 焦虑 失望 甚至自责，无论如何，这都增加了玩游戏的动机。 人类是天生的冒险家如果我告诉你，这一款消消乐游戏很好玩，音乐很魔性，你可能大概率会说我没兴趣，但是如果我告诉这个消消乐游戏，你第二关都过不去，是不是有试一试的冲动了？ 还记得羊了个羊的官方简介吗？ 小游戏以简单休闲出名，很多玩家被极低的通关率所刺激，好奇心促使起主动打开小程序本着试试看的心态进行游戏。教学关卡确实非常简单，甚至会给人一种，后面的关卡也会这么简单的错觉，同时经过教学关卡的无脑通关，玩家也更加确定自己可以成为那0.1%的人。 结果大家都知道了，第二关的难度极大，在将上层较多的消除后，便进入极难的阶段，而到达这一步玩家已经在不知不觉中付出的大量的时间成本 心智成本，便有了足够的动机去看广告，然后复活，再用完所有道具，然后再次失败。 而人类天生爱好挑战，也很难接受与心理预期的巨大差距，也梦想在圈子种脱颖而出，明明是很简单的三消游戏，我怎么就过不了？便产生了再试一局的心态，游戏结束会显示今日挑战了多少次，结果越玩越久，又投入了更大的时间成本 心智成本，便更加不愿意放弃，开始自己和自己较劲（是不是很像拼多多的邀请好友获得100元）。 情绪引导游戏会在很多关键的裂变阶段下足了心思。 羊了个羊的分享文案几乎都是激发玩家胜负欲的主题加上非常魔性的，符合Z时代风格的分享图，事实证明一种方案确实很管用，在不假思索的情况下，我会有很大的概率去点击，尤其是圈子内的分享，例如室友圈 班级圈 好友圈。 而游戏通过给予道具的形式引导玩家进行分享，大部分首次观看广告复活的玩家再次面对困难的时候，便有了足够的动机去分享给朋友，这样每个玩家便会产生三次分享。 在你道具用完，游戏失败的时候同样进行引导，可以说是精准了抓住了用户的心理 我们可以看到，除了外部话题营销的爆火之外，产品类的裂变也在玩家的私域圈子内形成最直接的近距离触达，进而引发了指数级别的爆炸。 小程序的“天然优势”小程序触达路径极短，app内打开，无需下载，即点即玩，登录流程短，借助平台能力即可实现一键登录，这些特性显著降低了使用门槛。 推广能力强，传播渠道多，抖音视频，公众号文章，微信视频，用户可能在多个场景下触发。 开发、上线成本低，没有类似版号的限制 也难怪国内各大app都做小程序生态，从商业的角度上，小程序的优点实在是太多。 一些tips登门槛效应也被称给得寸进尺效应，是指一个人一旦接受了他人一个微不足道的要求，为了避免认知上的不协调，或者想给对方前后一致的印象，就有可能接受更大的要求 回想羊了个羊的关卡设计中第一关极度简单，随便点点就过了，而来自固有观念的路径依赖，会让用户产生后面也会很简单的想法，结果第二关直接地狱难度，与用户的期望结果出现偏差，此时用户为了证明自己，便会走进死胡同。 还有用户首次获得道具需要进行分享，之后再想获取道具便需要看视频，相对于看视频必然分享更加低成本，当用户第二次在想获得道具需要他看广告的时候，因为玩家已经有了分享获取道具的动作，这时候再让用户看广告获取道具便不会让用户非常抗拒。 羊群效应经济学里面经常用“羊群”效应来描述经济个体从众跟风心理，同时从众心理也会也会导致盲从，进而陷入骗局或者遭受失败。 不可否认高难度折叠类三消游戏确实好玩，但是在我看到开发方是非常恶趣味的，完成第二关的就可以加入羊群，成为“领头羊”，如果某位幸运儿过了第二关，那一定会大肆宣传，满足自己的社交情绪，殊不知最大受益者正式游戏方本身，因为你的榜样，更多的人开始盲目跟风，攀比，争取加入盐羊群，于是便开始不断挑战高难度第二关。等到小羊们反应过来的时候，游戏方早已赚得盆满钵满，潇洒离去。 而游戏的爆火也顺带其“周边产业”的爆火， 上瘾模型分析我们使用经典的上瘾模型进行分析，看看羊了个羊是如何让用户成为”犟驴”的 触发 外部触发：微博 抖音多平台 微信分享文案 切入0.01%过关率 话题营销 好友分享 Z时代画风 内部触发：人类的好奇心 胜负欲 社交需要 行动 行动 &#x3D; 动机 + 行为 + 触发 动机：好奇心 胜负欲 社交需要 话题PK 三消游戏的趣味性 行动：年轻群体 + 三线用户具备时间充裕，追求快乐的属性 触发：小程序无需下载，打开即玩的特点极大地降低了触发难度 多变的酬赏 游戏内每次三消带来的正向反馈 游戏话题热度带来的大量奶头乐信息 投入 当前场次，今日已经挑战场次的时间、精力成本的投入 社交关系的投入 而投入最终也成为用户下一次触发的原因，亦或者不服输的驴脾气，亦或者身边的社交唤醒，形成了上瘾模型的闭环。 但是我们可以看到酬赏环节相对薄弱，如果用户一直无法过关，便最终失去兴趣，而话题营销保质期是有限的，并且其游戏内部实现已经被扒了个底朝天，负面消息充斥互联网平台，可以预见在15天内，其流量会跌回他原本的高度（猜测是最高点的10%-20%）。 目标人群作者是9月15号知晓的时候，已经是产品最火的时候了，我们可以发挥想象简单分析一下，作者经过反复的外部触发，才打开小程序，很明显高强度上班族不是他的目标客户，9号到13号的用户才算是他的第一批用户，而他的第一批用户是时间较多的大学生，工作强度不大的年轻人为主，这部分人时间多，并且喜爱追热点话题。 而开发商也精准了抓住了目标用户的特点，从传播切入点 分享切入点 游戏画风等多方面进行针对性开发与策划，保证准确挠到目标用户的痒点，从这个角度看，其实羊了个羊小游戏火起来是存在实力的，不是一个简单的demo产品，大家也不要把他的爆火完全归功于传播营销，产品能力也是其热度持续引爆的原因之一。 非常遗憾在巨量算数中都无法看到9-13号的用户数据，无法验证结论，只能看看14号之后的数据。 从巨量数据来看，越年轻的用户越频繁触发关键词，而31-40岁的用户虽然也非常多，但是TGI数值已经非常低，基本是符合我们推测的结论的。 潮起与潮落9月16号是热度的转折点，不夸张的说，三天内（14-16）号，全国几乎所有网民都听说了一个新名词“羊了个羊”，凭借魔性的画风以及超难的第二关而破圈，而热度也伴随争议随之而来，抄袭，游戏无解，骗人看广告还赚了几百万。 流量的双刃剑已经挥下，这些消息也火速在网上传播开来，也让很多人意识到，原来玩家自己才是“羊”，自然羊群效应带来的用户也火速消失，如果没有这些争议点，也许该游戏可以多保持几天热度，截至19号，微博数据已经下跌了80%-90%，抖音也出现了大幅度的下滑，微信因为社交关系的原因稍微平稳一点，但是可以预见，最多半个月，便会回归到正常的水平，而这几天开发商已经赚的盆满钵满，开始研究下一个热点小游戏。 而微信 抖音，也等到开发商们为其带来下一个热点。 最后我们大多数人从小大到接受的是非常正向的教育理念，相信正义一定打败邪恶，游戏一定是给人带来快乐，哪怕类似《茶杯头》《坐在罐子里面的男人》都仅仅是极大的游戏难度，很难，看似无解，但是本质上都是有解的，但是羊了个羊在实现上采用伪真随机的方式进行打乱，导致游戏无法保证一定有解，也就是说很多时候注定是玩不过去的，也就是说就算你是三消游戏的天才，你也要看广告，他这样的目的是利用玩家的不愿放弃沉没成本、渴望社交酬赏、赌徒心理诱导你看广告而已。 而这样畸形的游戏却能火起来值得我们深思。","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"产品分析","slug":"产品分析","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"}]},{"title":"vue3相对于vue2做了什么？","slug":"关于vue3的研究/vue3相对于vue2做了什么？","date":"2022-09-17T16:00:00.000Z","updated":"2023-01-19T03:01:31.318Z","comments":true,"path":"2022/09/18/关于vue3的研究/vue3相对于vue2做了什么？/","link":"","permalink":"https://bluedancers.github.io/2022/09/18/%E5%85%B3%E4%BA%8Evue3%E7%9A%84%E7%A0%94%E7%A9%B6/vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"vue3.0更加注重模块上的拆分，在2.0版本中所有vue相关的逻辑都相互耦合在一起，就算仅仅使用vue的一小部分，也需要引入完成的vue，造成了空间的浪费，而vue3则在模块层面上进行拆分，通过tree-shaking实现按需导入，减少用户打包体积，同时每个项目单独管理，单独发布，更加具备稳定性 ​ 模块拆分成npm包，独立使用，独立发布 虽然底层出现大量改动，但是顶层设计理念没有发生改变，依旧是声明式架构。 Monorepo： 一个仓库下可以维护多个模块 方便版本管理，依赖管理，模块间引用。 搭建vue3仓库通过pnpm初始化项目1pnpm init 创建Monorepo仓库环境新建文件夹packages 新建文件pnpm-workspace.yaml 12packages: - &#x27;packages/*&#x27; // 含义为怕package目录下的每个文件都是一个单独的仓库 安装公共依赖 项目根目录执行 1pnpm install vue -w // w 为workspace-root的缩写，代表该包为全局依赖 幽灵依赖 ​ vue依赖了abc包，我们下载vue的时候abc包就被下载到项目，我们可以直接使用abc，但是vue可能在某一个版本就不再使用abc，这就会造成依赖丢失，这些依赖就被成为幽灵依赖 生成相关配置信息创建packages内部的package环境 通过 1pnpm tsc --init 生成ts默认配置文件 并且增加配置 1234&quot;baseUrl&quot;: &quot;.&quot;,&quot;paths&quot;: &#123; &quot;@vue/*&quot;: [&quot;packages/*/src&quot;] // 引入库关系映射&#125; 实现构建流程 编写每个组件的package.json 编写公共打包文件，可以打包packages中的所有库 编写esbuild打包代码","categories":[{"name":"Javascript-2022","slug":"Javascript-2022","permalink":"https://bluedancers.github.io/categories/Javascript-2022/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"}]},{"title":"现代心理学七种观点","slug":"心理学与生活/现代心理学七种观点","date":"2022-08-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.085Z","comments":true,"path":"2022/08/15/心理学与生活/现代心理学七种观点/","link":"","permalink":"https://bluedancers.github.io/2022/08/15/%E5%BF%83%E7%90%86%E5%AD%A6%E4%B8%8E%E7%94%9F%E6%B4%BB/%E7%8E%B0%E4%BB%A3%E5%BF%83%E7%90%86%E5%AD%A6%E4%B8%83%E7%A7%8D%E8%A7%82%E7%82%B9/","excerpt":"","text":"心理动力学观点​ 行为是由强大的内部力量驱使或者激发，这种观点认为，人的行为是由先天的本本和生物驱力产生，而且试图解决个人需要和社会要求之间的冲突。剥夺状态，生理唤起以及冲突都为行动提供了力量，就像煤为蒸汽机供应燃料一样，在这个模型中，当机体的需要得到了满足而驱力降低时，机体就会停止反应。行为的主要目的是降低紧张度。 行为主义观点​ 寻求理解特定环境刺激如何控制特定类型的行为，首先行为主义者分析向前的环境条件，他们把反应行作为主要研究对象，是为想要理解，预测和控制的行为 人本主义观点​ 人们既不是如弗洛伊德主义者假设的由强大本能理想所驱使，也不是如行为主义提出的由环境因素所操纵，相反人是具有能动性的生物，本性善良而且具有选择能力。 认知观点​ 人的思维以及所有的认识过程，注意、思考、记忆和理解。从认识的观点看，人们行动是因为他们思考，而人们思考是因为他们是人类，处于大脑的精细构造 生物学观点​ 在基因、大脑、神经系统以及内分泌系统中寻找行为的原因，心理现象与社会现象能够最终依据生物化学过程加以理解：及时最复杂的现象，也能够通过被分析或简化为更小、更具体的单位来理解。 进化论观点​ 能更好的适应环境的有机体，倾向于比那些适应性较差的有机体更能成功的产生后代，经过很多时代，物种朝着更具适应性的方向发展 ​ 社会文化观点​ 研究行为的原因和结果中跨文化差异。","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"pinia源码分析【5】- 150行代码实现mini版pinia","slug":"pinia源码解读/pinia源码分析【5】- 150行代码实现mini版pinia","date":"2022-07-28T16:00:00.000Z","updated":"2022-12-11T13:51:24.081Z","comments":true,"path":"2022/07/29/pinia源码解读/pinia源码分析【5】- 150行代码实现mini版pinia/","link":"","permalink":"https://bluedancers.github.io/2022/07/29/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%905%E3%80%91-%20150%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0mini%E7%89%88pinia/","excerpt":"","text":"源码解析系列文章分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言 别人还在学习使用pinia，看过文章的你直接了解核心原理，无论是实际使用，还是面试都将更上一层楼~ ​ 前段时间完成了对pinia核心源码的解读，因为源码存在难度，也间接到了分析文章具有较高的阅读门槛，为了解决这一问题，可以让更多人参与到pinia的源码阅读中，所以今天给大家带来一个mini版pinia的核心实现，核心代码压缩到100行左右，极大了降低了源码阅读难度。 ​ mini版pinia实现了state，getters，action，$patch，$reset，$dispose；居家旅行面试常备~ ​ 同时为了降低阅读门槛，方便TypeScript不熟练的同学，本版本全部使用any，话不多说我们直接开始！ ​ mini版pinia开源地址：https://github.com/vkcyan/mini-pinia mini版逻辑流程图 简单版实现我们在代码结构上尽量与正式源码保持一致，仅仅做一些逻辑上的简化与压缩，保证核心实现的质量。 注册到vue 这里主要参照官方实现，如果不清楚effectScope，请看分析pinia源码之前必须知道的API，如果想深入了解createPinia，请看Pinia源码分析【2】- createPinia 1234567891011121314151617181920212223/** * 创建Pinia */export function createPinia() &#123; // 创建响应空间 const scope = effectScope(true); const state = scope.run&lt;Ref&lt;Record&lt;string, StateTree&gt;&gt;&gt;(() =&gt; ref&lt;Record&lt;string, StateTree&gt;&gt;(&#123;&#125;) )!; // markRaw使其不具备响应式 const pinia = markRaw(&#123; install(app: App) &#123; // 注入pinia app.provide(piniaSymbol, pinia); &#125;, use() &#123;&#125;, _s: new Map&lt;string, StoreGeneric&gt;(), // 保存处理后的store数据全部数据 state, // 保存可访问state _e: scope, // 相应空间 &#125;); return pinia;&#125; 实现defineStore实现一个基础功能的pinia，简单来说，我们只需要做最核心的两件事 将state转为ref，使其具有响应式 将getters处理为computed 如果需要实现$Action还需要对action中所有事件进行拦截处理（mini版不实现$Action） defineStore defineStore中的useStore主要做一些初始化判断，如果是store第一次被使用，则需要初始化，进入createOptionsStore，非第一次直接获取_s中已被处理好的缓存。 1234567891011121314151617181920212223242526272829303132/** * 创建store（仅支持单对象创建方式） * @param options * @returns */export function defineStore(options: &#123; id: string; state: any; getters: any; actions: any;&#125;) &#123; let &#123; id &#125; = options; // 实际运行函数 function useStore() &#123; const currentInstance = getCurrentInstance(); // 获取实例 let pinia: any; if (currentInstance) &#123; pinia = inject(piniaSymbol); // 获取install阶段的pinia &#125; if (!pinia) &#123; throw new Error(&quot;super-mini-pinia在mian中注册了吗?&quot;); &#125; if (!pinia._s.has(id)) &#123; // 第一次会不存在，单例模式 createOptionsStore(id, options, pinia); &#125; const store = pinia._s.get(id); // 获取当前store的全部数据 return store; &#125; useStore.$id = id; return useStore;&#125; createOptionsStore 使用ref处理state，使用computed处理getters，但是此处尚未运行，将setup函数作为参数传值到createSetupStore。 12345678910111213141516171819202122232425262728/** * 处理state getters * @param id * @param options * @param pinia */function createOptionsStore(id: string, options: any, pinia: any) &#123; const &#123; state, actions, getters &#125; = options; function setup() &#123; pinia.state.value[id] = state ? state() : &#123;&#125;; // pinia.state是Ref const localState = toRefs(pinia.state.value[id]); return Object.assign( localState, // 被ref处理后的state actions, // store的action Object.keys(getters || &#123;&#125;).reduce((computedGetters, name) =&gt; &#123; computedGetters[name] = markRaw( computed(() =&gt; &#123; const store = pinia._s.get(id)!; return getters![name].call(store, store); &#125;) ); return computedGetters; &#125;, &#123;&#125; as Record&lt;string, ComputedRef&gt;) // 将getters处理为computed ); &#125; let store = createSetupStore(id, setup, pinia); return store;&#125; createSetupStore ​ 声明当前store的方法，并且运行上一个函数组建的setup函数，其中包含state，getters，我们将其响应式存储到pinia._e中，便于后面对数据变化进行监听，以及统一管理。 ​ 最后将setup返回的对象与存放方法的partialStore对象进行assign，完成store的全部初始化逻辑，并将其加入_s，下次使用该store则直接取值，最后返回当前store。全部逻辑结束。 12345678910111213141516171819202122232425262728293031323334/** * 处理action以及配套API将其加入store * @param $id * @param setup * @param pinia */function createSetupStore($id: string, setup: any, pinia: any) &#123; // 所有pinia的methods let partialStore = &#123; _p: pinia, $id, $reset: () =&gt; console.log(&quot;reset&quot;), // 该版本不实现 $patch: () =&gt; console.log(&quot;patch&quot;), // 该版本不实现 $onAction: () =&gt; console.log(&quot;onAction&quot;), // 该版本不实现 $subscribe: () =&gt; console.log(&quot;subscribe&quot;), // 该版本不实现 $dispose: () =&gt; console.log(&quot;dispose&quot;), // 该版本不实现 &#125;; // 将effect数据存放如pinia._e、setupStore let scope!: EffectScope; const setupStore = pinia._e.run(() =&gt; &#123; scope = effectScope(); return scope.run(() =&gt; setup()); &#125;); // 合并methods与store const store: any = reactive( Object.assign(toRaw(&#123;&#125;), partialStore, setupStore) ); // 将其加入pinia pinia._s.set($id, store); return store;&#125; ​ 我们nimi版pinia的核心实现便完成了，真实的pinia源码中存在许多边际判断，为了方便阅读作者仅仅保留核心逻辑，剔除ts，简化分叉流程，极大的降低了了解pinia核心实现的门槛。 增加一些方法 $Action $subscribe因为涉及到订阅发布模块，所以代码量比较大，mini版就忽略了，对其原理有兴趣的请看pinia源码分析【4】- Pinia Methods $patch 将状态补丁应用于当前状态 123456function $patch(partialStateOrMutator: any) &#123; // mini版实现仅支持传入function if (typeof partialStateOrMutator === &quot;function&quot;) &#123; partialStateOrMutator(pinia.state.value[$id]); &#125;&#125; $reset 初始化state 123456store.$reset = function $reset() &#123; const newState = state ? state() : &#123;&#125;; // 通过闭包获取最初定义的state this.$patch(($state: any) =&gt; &#123; // 借用$patch完成state数据的替换 Object.assign($state, newState); &#125;);&#125;; $dispose 停止store的所有effect，并且删除其注册信息 1234function $dispose() &#123; scope.stop(); // effect作用于停止 pinia._s.delete($id); // 删除effectMap结构&#125; 测试使用我们首先将实现的函数导出出去 src\\super-mini-pinia\\index.ts 1234import &#123; createPinia &#125; from &quot;./createPinia&quot;;import &#123; defineStore &#125; from &quot;./store&quot;;export &#123; createPinia as myCreatePinia, defineStore &#125;; 在项目中的main.ts进行注册 123456import &#123; createApp &#125; from &quot;vue&quot;;import &#123; myCreatePinia &#125; from &quot;./super-mini-pinia/index&quot;;import App from &quot;./App-super-mini.vue&quot;;const app = createApp(App);app.use(myCreatePinia());app.mount(&quot;#app&quot;); 在页面增加一些测试代码 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;div&gt;state.num:&#123;&#123; useStore.num &#125;&#125;&lt;/div&gt; &lt;div&gt;getters.dnum:&#123;&#123; useStore.dnum &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;addNum&quot;&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; watchEffect &#125; from &quot;vue&quot;;import &#123; useCounterStore &#125; from &quot;./super-mini-store/counter&quot;;const useStore = useCounterStore();watchEffect(() =&gt; &#123; console.log(useStore.num);&#125;);function addNum() &#123; useStore.addNum();&#125;&lt;/script&gt; 预期效果 action正常触发 num与dnum随着action的触发更新UI mini版pinia测试 ​ 到此为止，我们便完成了mini版pinia的开发，代码虽少，但是核心逻辑五脏俱全，看懂了mini版pinia便是了解了pinia最核心的实现逻辑。 ​ 我已将mini版pinia的开源到github，如果你对pinia核心实现有兴趣，欢迎fock、clone，有任何问题请评论区留言。 结语​ 到此为止pinia源码解读系列便全部结束了，总体来说难度不算太大，作者前前后后花费了半个月时间，从零开始搭建环境，逐步深入阅读，读懂pinia源码的也让作者vue3 reactivity核心响应机制，闭包，订阅发布有了更深入的理解，值得阅读；也欢迎大家一起阅读源码，交流讨论~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"pinia源码分析【3】- defineStore","slug":"pinia源码解读/pinia源码分析【3】- defineStore","date":"2022-07-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.080Z","comments":true,"path":"2022/07/18/pinia源码解读/pinia源码分析【3】- defineStore/","link":"","permalink":"https://bluedancers.github.io/2022/07/18/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%903%E3%80%91-%20defineStore/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言本系列文章参考源码pinia V2.0.14 源码分析记录：https://github.com/vkcyan/goto-pinia 在上一节，我们完成了createPinia相关逻辑的源码解读，了解了pinia注册到vue的阶段具体做了哪些工作，以及pinia核心对象的生成逻辑，本文我们就要一起解读pinia中最重要的方法defineStore的实现原理 关于store的初始化三种创建方法 源码中对defineStore的三种类型描述便解释了为何我们可以用以上三种方式创建。 在defineStore声明中，我们需要传入三种的参数。 id：定义store的唯一id，单独传参或者通过options.id进行传参 options：具体配置信息包含如果传参是对象，则可以传，state，getters，action，id，例如上图1 2 种声明方式；如果传参是Function，则自主声明变量方法，例如上图第三种声明方式 storeSetup：仅限第三种store的声明方式，传入函数 defineStore执行逻辑1234567891011121314151617181920212223242526export function defineStore( // TODO: add proper types from above idOrOptions: any, setup?: any, setupOptions?: any): StoreDefinition &#123; let id: string; let options: // .... // 对三种store创建形式进行兼容。 const isSetupStore = typeof setup === &quot;function&quot;; if (typeof idOrOptions === &quot;string&quot;) &#123; id = idOrOptions; options = isSetupStore ? setupOptions : setup; &#125; else &#123; options = idOrOptions; id = idOrOptions.id; &#125; function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric &#123; //.....下面单独分析 &#125; useStore.$id = id; // 将useStore执行结果返回，在该store在使用之前被返回函数不会执行。 // 所以defineStore早于在Vue种注册pinia也不会出现错误。 return useStore;&#125; ​ 通过对defineStore的源码大致分析可以得知，只有在store被执行的时候才会运行被返回的函数useStore，useStore才是核心store的创建逻辑，我们接下便要重点分析其实现原理。 useStore逻辑分析useStore之前的逻辑执行顺序我们在App.vue中使用我们创建的store 123&lt;script setup lang=&quot;ts&quot;&gt; const useCounter1 = useCounterStore1();&lt;/script&gt; 在main createPinia defineStore useStore初始化处增加日志 defineStore初始化 main.ts -&gt; createPinia -&gt; vue.use -&gt; install（注册逻辑） 执行useStore（页面逻辑） 代码执行与我们想象的一致，defineStore是一个函数，会在引用阶段执行，并返回未执行函数useStore，之后便是一连串的初始化，最后是页面中使用pinia而运行的useStore。 useStore准备工作 12345678910111213141516171819202122// useStore接受两个参数，一个是pinia的实例，另一个与热更新相关。function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric &#123; // 首先会通过getCurrentInstance获取当前组件实例，并处理参数pinia，组件实例可以被正常获取，接下来通过inject(piniaSymbol)获取pinia实例（在install阶段保存）。 const currentInstance = getCurrentInstance(); pinia = (__TEST__ &amp;&amp; activePinia &amp;&amp; activePinia._testing ? null : pinia) || (currentInstance &amp;&amp; inject(piniaSymbol)); // 设置当前活跃的pinia，如果存在多个pinia实例，方便后续逻辑获取当前pinia实例 if (pinia) setActivePinia(pinia); // 在dev环境并且全局变量activePinia获取不到当前pinia实例，则说明未全局注册，抛出错误 if (__DEV__ &amp;&amp; !activePinia) &#123; throw new Error( `[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\\n` + `\\tconst pinia = createPinia()\\n` + `\\tapp.use(pinia)\\n` + `This will fail in production.` ); &#125; // 获取最新pinia，并断言pinia一定存在（猜测这里主要为了断言，此时两个变量就是一个值） pinia = activePinia!; // ....&#125; 核心store创建 ​ 当我们第一次运行store的时候，才会进行相关逻辑的执行，通过单例模式创建，未来再次使用该store将会直接从pinia._s中获取已经被处理过的store并返回。 12345678910111213141516function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric &#123; // ..... // 如果是第一次使用创建store逻辑，后面则跳过 if (!pinia._s.has(id)) &#123; // 如果defineStore的时候第二个参数是函数则为true，否则为false if (isSetupStore) &#123; createSetupStore(id, setup, options, pinia); &#125; else &#123; createOptionsStore(id, options as any, pinia); &#125; &#125; // 从_s中获取当前id对应的store信息 const store: StoreGeneric = pinia._s.get(id)!; // 这里返回的值实际上就是我们实际获取到值 return store as any;&#125; useStore的大致逻辑比较简单，我们假设第一次使用，并且通过非Function进行传参，进入createOptionsStore函数。 createOptionsStoredefineStore的第二个参数使用非Function进行声明将会走入该逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function createOptionsStore&lt; Id extends string, S extends StateTree, G extends _GettersTree&lt;S&gt;, A extends _ActionsTree&gt;( id: Id, // storeid options: DefineStoreOptions&lt;Id, S, G, A&gt;, // state action getters pinia: Pinia, // 当前store实例 hot?: boolean): Store&lt;Id, S, G, A&gt; &#123; const &#123; state, actions, getters &#125; = options; // 获取state中是否已经存在该store实例 const initialState: StateTree | undefined = pinia.state.value[id]; console.log(&quot;initialState&quot;, initialState); let store: Store&lt;Id, S, G, A&gt;; function setup() &#123; if (!initialState &amp;&amp; (!__DEV__ || !hot)) &#123; if (isVue2) &#123; set(pinia.state.value, id, state ? state() : &#123;&#125;); &#125; else &#123; // 将数据存储到state中，因为state时通过ref进行创建 pinia.state.value[id] = state ? state() : &#123;&#125;; &#125; &#125; // 避免在 pinia.state.value 中创建状态 console.log(11, pinia.state.value[id]); console.log(22, toRefs(pinia.state.value[id])); const localState = __DEV__ &amp;&amp; hot ? // 使用 ref() 来解开状态 TODO 中的 refs：检查这是否仍然是必要的 toRefs(ref(state ? state() : &#123;&#125;).value) : toRefs(pinia.state.value[id]); // 经过toRefs的处理后，localState.xx.value 就等同于给state中的xx赋值 let aa = assign( localState, // state =&gt; Refs(state) actions, // Object.keys(getters || &#123;&#125;).reduce((computedGetters, name) =&gt; &#123; if (__DEV__ &amp;&amp; name in localState) &#123; // 如果getters名称与state中的名称相同，则抛出错误 console.warn( `[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with &quot;$&#123;name&#125;&quot; in store &quot;$&#123;id&#125;&quot;.` ); &#125; // markRow 防止对象被重复代理 computedGetters[name] = markRaw( // 使用计算属性处理getters的距离逻辑，并且通过call处理this指向问题 computed(() =&gt; &#123; setActivePinia(pinia); // 它是在之前创建的 const store = pinia._s.get(id)!; // allow cross using stores /* istanbul ignore next */ if (isVue2 &amp;&amp; !store._r) return; // @ts-expect-error // return getters![name].call(context, context) // TODO: avoid reading the getter while assigning with a global variable // 将store的this指向getters中实现getters中this的正常使用 return getters![name].call(store, store); &#125;) ); return computedGetters; &#125;, &#123;&#125; as Record&lt;string, ComputedRef&gt;) ); console.log(&quot;aa&quot;, aa); return aa; &#125; // 使用createSetupStore创建store store = createSetupStore(id, setup, options, pinia, hot, true); // 重写$store方法 store.$reset = function $reset() &#123; const newState = state ? state() : &#123;&#125;; // 我们使用补丁将所有更改分组到一个订阅中 this.$patch(($state) =&gt; &#123; assign($state, newState); &#125;); &#125;; return store as any;&#125; ​ createOptionsStore函数在获取defineStore声明的数据后，在其内部构建了setup函数，该函数将option形式的state与getters分别转化为ref与computed，这样就与setup形式声明的store保持一致。 ​ 这一块代码非常核心，初步解释了为何state具备响应式，为何getters具备computed的效果 ​ 最后不论是option方式创建还是setup的形式创建，最后都统一通过createSetupStore完成对store最后的处理 createSetupStore 无论是何种defineStore创建方式，最终都会走向createSetupStore，在这里进行最终store的生成以及相关methods的实现。 注：这一块代码实在是复杂，关于$reset $patch等API，我们放下一个系列文章 ​ 经过createOptionsStore的处理，已经将option形式的字段全部转化为setup形式进行返回，现在无论何种创建方式，执行此处的setup函数，都会得到同一个结果。 以上三种创建方式，内部运行setup函数都会得到如下结果 接下来，我们就需要对其数据进行处理，获取到所有变量与方法，并对action通过wrapAction进行处理，便于实现后续的订阅发布模式 methods$Action 12345678910111213141516171819202122232425262728293031const setupStore = pinia._e.run(() =&gt; &#123; scope = effectScope(); return scope.run(() =&gt; setup());&#125;)!;for (const key in setupStore) &#123; const prop = setupStore[key]; if ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123; // 如果当前props是ref并且不是计算属性与reative if (!isOptionsStore) &#123; // option结构已经在createOptionsStore将其加入pinia if (isVue2) &#123; set(pinia.state.value[$id], key, prop); &#125; else &#123; pinia.state.value[$id][key] = prop; &#125; &#125; &#125; else if (typeof prop === &quot;function&quot;) &#123; // 如果当前函数是fun // wrapAction 会将当前prop也就是函数增加调用错误与正常的回调函数 const actionValue = __DEV__ &amp;&amp; hot ? prop : wrapAction(key, prop); if (isVue2) &#123; set(setupStore, key, actionValue); &#125; else &#123; setupStore[key] = actionValue; &#125; // 将其函数同步到optionsForPlugin中 optionsForPlugin.actions[key] = prop; &#125;&#125; ​ 经过以上逻辑处理后，setupStore方式进行创建的store也会被添加到pinia.state中，而所有的function都会被wrapAction进行包装处理。 ​ 对state，action进行处理的同时，还需要对当前store可调用API进行处理，例如$reset，$patch 1234567891011121314151617181920212223242526const partialStore = &#123; _p:pinia, $id, $Action, $patch, $reset, $subscribe, $dispose&#125;const store: Store&lt;Id, S, G, A&gt; = reactive( assign( __DEV__ &amp;&amp; IS_CLIENT ? // devtools custom properties &#123; _customProperties: markRaw(new Set&lt;string&gt;()), _hmrPayload, &#125; : &#123;&#125;, partialStore // must be added later // setupStore )) as unknown as Store&lt;Id, S, G, A&gt;;// ...将变量 方法合并到store中assign(toRaw(store), setupStore); ​ 最终将相关methods与store内的数据进行合并，存储以当前store的id为key的Map中，createSetupStore的核心逻辑便全部结束了。 useStore后续逻辑我们再回到defineStore的逻辑中，获取到createSetupStore最后放入pinia._s中的当前store被处理后的对象。 12345// ....// 从_s中获取当前store的effect数据const store: StoreGeneric = pinia._s.get(id)!;// StoreGeneric cannot be casted towards Storereturn store as any; ​ 最后将通过createSetupStore处理后的数据进行返回，我们便得到了使用当前store中变量与方法以及各种方法的能力。 拓展：为什么访问defineStore创建的state不需要.value​ 通过以上源码分析可以得知，state的数据都会被处理为ref，那访问ref自然是需要.value，但是我们日常使用pinia似乎从来没有.value。 我们先看一个小例子 1234567let name = ref(&quot;张三&quot;);let age = ref(&quot;24&quot;);const info = reactive(&#123; name, age &#125;);console.log(info.name); // 张三console.log(info.age); // 24 ​ 简单来说就是reactive中嵌套ref的时候，修改reactive内的值不需要.value ​ 在官方文档（https://vuejs.org/api/reactivity-core.html#reactive）中，我们也能找到相关说明 注意：reactive嵌套ref的场景下，对象与数组格式存在差异，有兴趣可以了解一下 根据文档我们简单的翻阅了一下vuejs&#x2F;core&#x2F;…&#x2F;baseHandlers.ts的源码 源码地址：https://github.com/vuejs/core/blob/main/packages/reactivity/src/baseHandlers.ts line 131 - 134 createGetter() line 131 - 134 createSetter() 可以发现，逻辑实现与文档描述相符。 最后再看一下我们的pinia源码中createSetupStore函数中store声明的那一段函数，这便解释了为什么在使用pinia修改值、读取值的时候都不需要进行.value了。 12345678910111213const store: Store&lt;Id, S, G, A&gt; = reactive( assign( // ... partialStore ) ) as unknown as Store&lt;Id, S, G, A&gt;;// .....if (isVue2) &#123; // ...&#125; else &#123; assign(toRaw(store), setupStore); // 将defineStore的数据合并到reactive声明的store中&#125; 结语​ 虽然代码量比较大，但是核心逻辑就是将state处理为ref，将getters处理为computed，将action进行二次封装，提供若干方法，最后组合对象存储到Pinia中。 ​ 在这一章我们完成了最核心store创建流程的源码分析，但是通过partialStore增加的方法我们还没有一一了解。下一篇我们将会重点介绍store相关Methods的具体实现。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"pinia源码分析【4】- Pinia Methods","slug":"pinia源码解读/pinia源码分析【4】- Pinia Methods","date":"2022-07-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.081Z","comments":true,"path":"2022/07/18/pinia源码解读/pinia源码分析【4】- Pinia Methods/","link":"","permalink":"https://bluedancers.github.io/2022/07/18/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%904%E3%80%91-%20Pinia%20Methods/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言本系列文章参考源码pinia V2.0.14 源码分析仓库：https://github.com/vkcyan/goto-pinia ​ 上一章我们对store的核心流程完成了分析，从而了解了一个store从定义到被使用的实现逻辑，但是store相关的方法，我们还未进行分析，本章我们就重点分析分析store自带的Methods $onAction使用示例订阅当前store所有action操作，每当action被执行的时候，便会触发该方法 12345678910onMounted(() =&gt; &#123; useCounter1.$onAction((option) =&gt; &#123; let &#123; after, onError, args, name, store &#125; = option; &#125;); setInterval(() =&gt; &#123; useCounter1.counter++; // useCounter1.increment(); &#125;, 1000);&#125;); 源码分析订阅在$Action声明的地方，我们可以看到一段这样的函数 第一个参数传null，则不改变this指向，并且在后续的调用依旧是该this。 123const partialStore = &#123; $onAction: addSubscription.bind(null, actionSubscriptions), // action事件注册函数&#125; ​ 也就是说，当我们使用store.$Action的时候实际上触发的是addSubscription函数，并将我们$Action中的回调函数传入createSetupStore中的actionSubscriptions中，也就是订阅了我们的callback ​ 运行store.$Action后得到了addSubscription方法的返回值removeSubscription方法，让我们可以执行其返回值，达到取消订阅的目的。 1234567891011121314151617181920212223export function addSubscription&lt;T extends _Method&gt;( subscriptions: T[], // createSetupStore中的actionSubscriptions callback: T, // 我们传入的callback detached?: boolean, // 如果为true，则该$Action在页面销毁之后依旧有效 onCleanup: () =&gt; void = noop) &#123; // 使用$Action的时候就会触发本函数 subscriptions.push(callback) const removeSubscription = () =&gt; &#123; const idx = subscriptions.indexOf(callback) if (idx &gt; -1) &#123; subscriptions.splice(idx, 1) onCleanup() &#125; &#125; if (!detached &amp;&amp; getCurrentInstance()) &#123; // 如果detached参数不存在，则在当前页面卸载的时候，去除该订阅事件 onUnmounted(removeSubscription) &#125; return removeSubscription&#125; 触发订阅​ 在useStore中对action进行处理的逻辑中，存在这样的一段代码，这段代码中的hot在正常使用的业务场景下都是undefined，所以会走后面的逻辑。 1const actionValue = wrapAction(key, prop) // hot为undefined的情况下 ​ 所有的action在初始化阶段都会被wrapAction方法拦截，也就代表我们执行action的时候，实际上执行的是wrapAction函数，那就让我们就看看，在wrapAction中究竟发生了什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*** 包装一个action来处理订阅** @param name - store的名称* @param action - 需要被包装的action* @returns a wrapped action to handle subscriptions*/function wrapAction(name: string, action: _Method) &#123; return function (this: any) &#123; setActivePinia(pinia); // 获取当前action的参数 const args = Array.from(arguments); const afterCallbackList: Array&lt;(resolvedReturn: any) =&gt; any&gt; = []; const onErrorCallbackList: Array&lt;(error: unknown) =&gt; unknown&gt; = []; // 声明after方法 function after(callback: _ArrayType&lt;typeof afterCallbackList&gt;) &#123; // 将after的call放入list中 afterCallbackList.push(callback); &#125; // 声明error方法 function onError(callback: _ArrayType&lt;typeof onErrorCallbackList&gt;) &#123; onErrorCallbackList.push(callback); &#125; // @ts-expect-error // 触发actionSubscriptions中订阅的store.$Action的全部回调函数,并将参数传入 // 此时store.$Action的callback已经执行,但是after onError的回调函数尚未执行 triggerSubscriptions(actionSubscriptions, &#123; args, name, store, after, onError, &#125;); let ret: any; // ret为action的返回值 try &#123; ret = action.apply(this &amp;&amp; this.$id === $id ? this : store, args); // handle sync errors &#125; catch (error) &#123; // 如果action执行出错,则直接执行错误回调,终止函数 triggerSubscriptions(onErrorCallbackList, error); throw error; &#125; // 如果ret是promise,则当前结果未知，会通过上方的try catch，但是会在action结尾增加then catch进行结果捕捉 if (ret instanceof Promise) &#123; return ret .then((value) =&gt; &#123; triggerSubscriptions(afterCallbackList, value); return value; &#125;) .catch((error) =&gt; &#123; triggerSubscriptions(onErrorCallbackList, error); return Promise.reject(error); &#125;); &#125; // allow the afterCallback to override the return value // 如果try catch 通过，并且当前action不是Promise，则逻辑进行到此处，触发所有 触发真正的after函数，并将当前action的返回值传入其中，至此完成对action触发的监听。 triggerSubscriptions(afterCallbackList, ret); return ret; &#125;;&#125; ​ 之前在$Action中的回调函数在此处发挥了作用，每当一个action触发的都会遍历之前订阅的所有$Action的回调函数，其内部执行action方法，action执行正常在触发after的callback，执行异常则触发onError的callback。 小结 本质上来说$Action就是一个订阅发布模式。 $Action 订阅者 store.action 发布者 actionSubscriptions - 事件注册中心 triggerSubscriptions - 调度中心 ​ 通过订阅者（$Action）把对发布者（action）的订阅注册到事件注册中心（actionSubscriptions）中，当发布者（action）触发时，通知调度中心（triggerSubscriptions），调度中心（triggerSubscriptions）触发事件注册中心中的所有订阅。 $subscribe使用示例​ 订阅当前store中的state的变化，state发生任意更改都会触发其回调函数，他还会返回一个用来删除的回调函数 12345678910111213let abc = useCounter1.$subscribe( (option, state) =&gt; &#123; // 通过store.num = xxxx修改，type为direct // 通过store.$patch(&#123; num: &#x27;xxx&#x27; &#125;)修改，type为directpatchObject // 通过store.$patch((state) =&gt; num.name=&#x27;xxx&#x27;)修改，type为patchFunction // storeId为当前store的id // events 当前改动说明 let &#123; events, storeId, type &#125; = option; console.log(events, storeId, type, state); &#125;, &#123; detached: false &#125;); 源码分析当我们使用$subscribe并传入callback的时候，首先会将当前的callback加入注册中心中 123456const removeSubscription = addSubscription( subscriptions, // 事件注册中心 callback, // $subscribe传入的callback options.detached, // 页面卸载的时候是否取消监听 () =&gt; stopWatcher() // 执行stopWatcher实际上执行的是scope.run返回的watch，而执行watch的返回函数，也就是停止当前watch); ​ 前三个参数经过对$Action的分析后已经比较熟悉，这里我们重点说明一下第四个参数 ​ stopWatcher是当前store中的effectScope，我们将对当前state的watch放入scope中，以便于销毁store的时候统一处理。 12345678910111213141516171819const stopWatcher = scope.run(() =&gt; watch( () =&gt; pinia.state.value[$id] as UnwrapRef&lt;S&gt;, // 监听state的变化 (state) =&gt; &#123; // 在不使用$patch的情况下，则两个参数都为true，callback一定会执行 if (options.flush === &quot;sync&quot; ? isSyncListening : isListening) &#123; callback( &#123; storeId: $id, // type: MutationType.direct, events: debuggerEvents as DebuggerEvent, &#125;, state ); &#125; &#125;, assign(&#123;&#125;, $subscribeOptions, options) ) ) 小结 ​ $subscribe主要依赖vue3的watch进行实现，在subscriptions中注册callback，但是注册的callback不通过triggerSubscriptions进行触发，仅仅作为保存，watch的触发函数中通过闭包触发$subscribe中的callback，达到store中任意值发生变化的时候都执行callback的目的 ​ 在addSubscription的返回值removeSubscription中，不仅会在subscriptions(注册中心)删除订阅，同时也会执行() =&gt; stopWatcher()，停止watch监听。达到完全停止监听的目的。 $patch使用示例直接更新当前state，可以通过传入对象与callback两种方式进行state更新，允许传递嵌套值 123456// 对象useCounter1.$patch(&#123; counter: 2 &#125;);// functionuseCounter1.$patch((state) =&gt; &#123; state.counter = 2;&#125;); 源码分析​ $patch的主体逻辑不算很复杂，针对不同的参数类型进行分别处理，其中partialStateOrMutator是传入的方法，我们将当前store传入其中，通过其callback直接完成state的修改，而传入类型为object的时候，则通过mergeReactiveObjects进行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function $patch(stateMutation: (state: UnwrapRef&lt;S&gt;) =&gt; void): void; // Fun传参function $patch(partialState: _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt;): void; // 对象传参function $patch(partialStateOrMutator: | _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt; | ((state: UnwrapRef&lt;S&gt;) =&gt; void)): void &#123; let subscriptionMutation: SubscriptionCallbackMutation&lt;S&gt;; isListening = isSyncListening = false; // reset the debugger events since patches are sync /* istanbul ignore else */ if (__DEV__) &#123; debuggerEvents = []; &#125; // 如果参数是方法，走以下处理逻辑 if (typeof partialStateOrMutator === &quot;function&quot;) &#123; partialStateOrMutator(pinia.state.value[$id] as UnwrapRef&lt;S&gt;); subscriptionMutation = &#123; type: MutationType.patchFunction, storeId: $id, events: debuggerEvents as DebuggerEvent[], &#125;; &#125; else &#123; // 如果参数是对象，走以下处理逻辑 mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator); subscriptionMutation = &#123; type: MutationType.patchObject, payload: partialStateOrMutator, storeId: $id, events: debuggerEvents as DebuggerEvent[], &#125;; &#125; const myListenerId = (activeListener = Symbol()); nextTick().then(() =&gt; &#123; if (activeListener === myListenerId) &#123; isListening = true; &#125; &#125;); isSyncListening = true; // 在上方逻辑中，我们将isListening isSyncListening 重置为false，不会触发$subscribe中的callback，所以需要手动进行订阅发布 triggerSubscriptions( subscriptions, subscriptionMutation, pinia.state.value[$id] as UnwrapRef&lt;S&gt; );&#125; 12345678910111213141516171819202122232425262728// $patch传入参数为Object的处理逻辑function mergeReactiveObjects&lt;T extends StateTree&gt;( target: T, patchToApply: _DeepPartial&lt;T&gt;): T &#123; // no need to go through symbols because they cannot be serialized anyway for (const key in patchToApply) &#123; if (!patchToApply.hasOwnProperty(key)) continue; const subPatch = patchToApply[key]; const targetValue = target[key]; if ( isPlainObject(targetValue) &amp;&amp; isPlainObject(subPatch) &amp;&amp; target.hasOwnProperty(key) &amp;&amp; !isRef(subPatch) &amp;&amp; !isReactive(subPatch) ) &#123; // 如果被修改的值 修改前修改后都是object类型并且不是Function类型、并且不是ref 不是isReactive，则递归mergeReactiveObjects达到修改嵌套object的目的 target[key] = mergeReactiveObjects(targetValue, subPatch); &#125; else &#123; // @ts-expect-error: subPatch is a valid value // 如果是简单类型 则直接进行state的修改，这里的target为pinia.state.value[$id] // 按我们的示例来实际分析：pinia.state.value[$id].counter = 2 target[key] = subPatch; &#125; &#125; return target;&#125; ​ 完成对mergeReactiveObjects的分析后，$patch的核心逻辑就全部结束了，但是还有一点我们没完成，就是通过$patch修改的state，$subscribe是否可以监听到。 $patch触发$subscribe​ 在$patch执行的中，我们会修改当前store中的state，$subscribe中的watch在flush=&#39;sync&#39;的情况下可以立刻监听到，但是也无法执行callback，因为$patch函数最开始的地方将isListening，isSyncListening置为false ​ 在对值完成修改后，我们将isSyncListening置为true，并且手动订阅$subscribe的callback，达到通过$patch修改state也能被$subscribe监听到的目的。 小结​ $patch的源码相对来说比较简单，但是关于触发$subscribe的部分代码逻辑比较复杂，尤其是当$subscribe option设置中的flush为sync的时候，修改state立刻就会触发$subscribe的watch，虽然最终呈现出来的结果是一致的，但是内部对不同情况的兼容没有看起来那么简单。 $dispose调用该方法后将会注销当前store scope中存储当前store中的相关反应，当前state的watch，ref，等等effect都通过scope.run创建，就是为了方便统一处理，这里调用scope.stop()所有的effect便被全部注销了。 123456function $dispose() &#123; scope.stop(); subscriptions = []; // $subscribe注册中心 actionSubscriptions = []; // $Action的注册中心 pinia._s.delete($id); // 删除effectMap结构&#125; $reset调用该方法可以将当前state重置为初始化的状态 但是有点需要注意，如果defineStore通过setup类型声明，则无法调用该函数 1234567const $reset = __DEV__ ? () =&gt; &#123; throw new Error( `🍍: Store &quot;$&#123;$id&#125;&quot; is built using the setup syntax and does not implement $reset().` ); &#125; : noop; // noop为空函数 如果通过option类型进行声明，则会重写$reset方法 12345678store.$reset = function $reset() &#123; // state通过闭包机制获得最初state定义的状态 const newState = state ? state() : &#123;&#125;; // 通过$patch完成对state中数据的更新 this.$patch(($state) =&gt; &#123; assign($state, newState); &#125;);&#125;; 总结​ 至此，我们就完成了对pinia所有方法的源码解读，而pinia源码解读系列文章也将告一段落，我们从pinia的初始化到了解如何实现state，getters的响应式，最后完成对pinia metnods的全部解读，也算是完全了解了其核心实现，最后我们将会实现一个mini版的pinia，仅仅保留核心实现，降低阅读门槛，让大多数人可以轻松了解pinia的核心实现原理~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"Pinia源码分析【2】- createPinia","slug":"pinia源码解读/pinia源码分析【2】- createPinia","date":"2022-07-06T16:00:00.000Z","updated":"2022-12-11T13:51:24.080Z","comments":true,"path":"2022/07/07/pinia源码解读/pinia源码分析【2】- createPinia/","link":"","permalink":"https://bluedancers.github.io/2022/07/07/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%902%E3%80%91-%20createPinia/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言参考源码pinia V2.0.14 源码分析仓库：https://github.com/vkcyan/goto-pinia 上一篇文章我们主要介绍了如何搭建一个pinia源码阅读环境；本文主要介绍pinia在vue3初始化阶段相关逻辑，以及如何构建pinia对象。 正文根据官方文档，我们使用pinia首先需要是将它注册到vue中 12const pinia = createPinia();app.use(pinia); createPinia阶段究竟做了什么，他又是如何被注册到vue中呢？我们要从createPinia中寻找答案。 源码地址我们通过pinia\\src\\index.ts找到 1export &#123; createPinia &#125; from &#x27;./createPinia&#x27; // `pinia\\src\\createPinia.ts为源码文件` createPinia函数​ 在函数的最开头，我们就可以看到通过effectScope声明了一个ref，并赋值给了state，这里的effectScope是高级API，未来会单独介绍，有兴趣的同学可以看一下官方文档，我们将其简单理解为声明了一个ref并赋值给state。 1234567891011export function createPinia(): Pinia &#123; const scope = effectScope(true); const state = scope.run&lt;Ref&lt;Record&lt;string, StateTree&gt;&gt;&gt;(() =&gt; ref&lt;Record&lt;string, StateTree&gt;&gt;(&#123;&#125;) )!; // 简化理解 // const state = ref(&#123;&#125;) // ...&#125; ​ pinia通过markRaw进行包装，将其标记为不会转化为响应式，最终pinia对象被createPinia函数返回，执行vue.use(pinia)的时候便会执行pinia对象中的install函数。 12345678910111213141516171819202122232425262728293031323334export function createPinia(): Pinia &#123; // ... let _p: Pinia[&quot;_p&quot;] = []; // 所有需要安装的插件 let toBeInstalled: PiniaPlugin[] = []; // install之前保存的待安装插件 // 使用markRaw标记pinia使其不会被响应式 const pinia: Pinia = markRaw(&#123; // vue.use实际执行逻辑 install(app: App) &#123; setActivePinia(pinia); // 设置当前使用的 pinia if (!isVue2) &#123; // 如果是vue2，全局注册已经在PiniaVuePlugin完成，所以这段逻辑将跳过 pinia._a = app; // 保存app实例 app.provide(piniaSymbol, pinia); // 通过provide传递pinia实例，提供给后续使用 app.config.globalProperties.$pinia = pinia; // 设置全局属性 $pinia toBeInstalled.forEach((plugin) =&gt; _p.push(plugin)); // 处理未执行插件 toBeInstalled = []; &#125; &#125;, use(plugin) &#123; if (!this._a &amp;&amp; !isVue2) &#123; // 如果use阶段为初始化完成则暂存toBeInstalled中 toBeInstalled.push(plugin); &#125; else &#123; _p.push(plugin); &#125; return this; &#125;, _p, // 所有pinia的插件 _a: null, // app实例，在install的时候会被设置 _e: scope, // pinia的作用域对象，每个store都是单独的scope _s: new Map&lt;string, StoreGeneric&gt;(), // store缓存 key为pinia的id value为pinia的对外暴露数据 state, // pinia所有state的合集 key为pinia的id value为store下的所有state（所有可访问变量） &#125;); return pinia;&#125; 返回值的含义以及作用 ​ 初始化的逻辑相对比较简单，只需要了解effectScope markRaw便能完全读懂，install阶段组成的pinia对象被setActivePinia保存了下来，而这个对象贯穿pinia整个生命周期，每个字段的作用在后面的源码解读中都会有所体现。 关于Vue2​ 通过pinia官网，我们可以了解到pinia支持vue2，不过vue2环境需要在使用createPinia之前，预先安装插件PiniaVuePlugin，通过pinia的入口文件了解到PiniaVuePlugin的源码入口为pinia\\src\\vue2-plugin.ts ​ PiniaVuePlugin是vue2插件比较主流的实现方式，获取Vue实例，通过mixin实现数据共享。如果了解过vuex的源码，相信对以下代码会十分熟悉。 1234567891011121314151617181920212223242526272829303132333435363738394041export const PiniaVuePlugin: Plugin = function (_Vue) &#123; // Equivalent of // app.config.globalProperties.$pinia = pinia // pinia在vue2中的注册逻辑与vuex核心逻辑几乎一致， // 注入全局mixin的beforeCreate _Vue.mixin(&#123; beforeCreate() &#123; const options = this.$options; // 在根节点通过vue.use中注册了pinia if (options.pinia) &#123; const pinia = options.pinia as Pinia; // defineProperty版provided实现 if (!(this as any)._provided实现) &#123; const provideCache = &#123;&#125;; Object.defineProperty(this, &quot;_provided&quot;, &#123; get: () =&gt; provideCache, set: (v) =&gt; Object.assign(provideCache, v), &#125;); &#125; (this as any)._provided[piniaSymbol as any] = pinia; // 首次注册变量不存在，进行存储 if (!this.$pinia) &#123; this.$pinia = pinia; &#125; // 保存Vue实例 pinia._a = this as any; if (IS_CLIENT) &#123; setActivePinia(pinia); &#125; &#125; else if (!this.$pinia &amp;&amp; options.parent &amp;&amp; options.parent.$pinia) &#123; // 所有子组件/页面都继承上一层的pinia this.$pinia = options.parent.$pinia; &#125; &#125;, destroyed() &#123; delete this._pStores; &#125;, &#125;);&#125;; 关于devTool在createPinia中存在这样一段代码 123if (__DEV__ &amp;&amp; IS_CLIENT &amp;&amp; !__TEST__) &#123; pinia.use(devtoolsPlugin);&#125; 如果是开发环境，并且是浏览器环境，并且不是测试环境，就会向pinia注册devtoolsPlugin，也就是将pinia注册到浏览器插件Vue.js devtools中。 结语​ createPinia的源码解读就全部结束了，现在我们已经了解初始化的具体流程，以及生成的pinia对象中存在什么参数，这些参数在运行阶段都会发挥它应用的价值。 ​ 下一章我们将要解析创建以及使用pinia的相关源码，defindStore函数实现逻辑，在defindStore中我们将会了解到install阶段每个字段的实际用途，以及pinia的核心响应原理。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"Pinia源码分析【1】- 源码分析环境搭建","slug":"pinia源码解读/pinia源码分析【1】- 源码分析环境搭建","date":"2022-07-05T16:00:00.000Z","updated":"2022-12-11T13:51:24.079Z","comments":true,"path":"2022/07/06/pinia源码解读/pinia源码分析【1】- 源码分析环境搭建/","link":"","permalink":"https://bluedancers.github.io/2022/07/06/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%901%E3%80%91-%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言​ 经过vue3从beta版本走向默认版本，vue2.x更新最后一个版本Naruto，全局状态管理也从vuex慢慢走向更加易用更加契合vue3的pinia。 本系列文章将会带领大家从源码角度去理解下一代vue全局状态管理库 pinia 的实现原理。 参考源码pinia V2.0.14 源码分析仓库：https://github.com/vkcyan/goto-pinia 工欲善其事，必先利其器，我们应该如何去阅读pinia的源码呢？ 本文将手摸手教大家如何在vue3环境搭建pinia的源码阅读环境。 创建源码分析环境我们使用vue3开箱即用的CLI初始化一个项目，创建项目非常简单，不做过多赘述。 https://vuejs.org/guide/quick-start.html 1npm init vue@latest pinia源码入口分析先去pinia的官方仓库下载源码 源码地址：https://github.com/vuejs/pinia，我们将其clone到本地 1git clone https://github.com/vuejs/pinia.git 首先分析pinia仓库的打包文件，寻找源代码位置 源码地址​ 在pinia/packages/package.json中，我们找到了打包命令，打包命令中可以得知，打包文件为../../rollup.config.js ​ 在打包文件中，我们找到了被打包源码的入口文件，即为pinia/packages/pinia/src/index.ts 仓库依赖​ 在打包文件rollup.config.js中line121标注了依赖文件，不过我们通过CLI生成的项目中已经包含了以下依赖文件，所以这一步我们不需要额外操作。 环境变量​ 源码中存在大量环境变量注入代码，具体配置在rollup.config.js中line121；如果缺失环境变量声明，会导致源码无法正常运行。 ​ 所以在源码阅读环境，我们需要添加合适的环境变量，让源码正常运行起来。 环境适配将pinia/packages/pinia目录下的所有文件复制到我们之前通过CLI生成项目的/src中。 并根据我们通过源码入口分析获取的信息进行环境变量补全。 在vite.config.ts增加环境变量1234define: &#123; __DEV__: &quot;true&quot;, // 是否开发环境 __TEST__: &quot;false&quot;, // 是否测试环境&#125;, 全局环境变量报错​ 我们在vite的配置文件中向运行环境注入了pinia必要的环境变量，但是TypeScript并不认识相关全局变量，便会发出警告。 ​ 我们需要将源码中的pinia/packages/pinia/src/global.d.ts文件内的声明复制到项目中的env.d.ts即可。 123456789101112/// &lt;reference types=&quot;vite/client&quot; /&gt;// Global compile-time constantsdeclare var __DEV__: boolean;declare var __TEST__: boolean;declare var __FEATURE_PROD_DEVTOOLS__: boolean;declare var __BROWSER__: boolean;declare var __CI__: boolean;declare var __VUE_DEVTOOLS_TOAST__: ( message: string, type?: &quot;normal&quot; | &quot;error&quot; | &quot;warn&quot;) =&gt; void; 至此，我们解决了项目静态检查阶段中所有报错信息，接下来我们启动项目。 浏览器控制台报错’…ComputedRef’​ 启动项目后，在浏览器控制台收获了一个报错信息 我们找到报错代码type.ts进行分析 ​ 错误提示已经非常贴心，可以得知是tsconfig.json配置问题，我们根据报错信息修改配置 出现报错的原因是因为这里vue CLI生成的代码自带一份配置文件，此文件与pinia源码的tsconfig部分配置发生了冲突。 123456789101112131415161718&#123; &quot;extends&quot;: &quot;@vue/tsconfig/tsconfig.web.json&quot;, &quot;include&quot;: [&quot;env.d.ts&quot;, &quot;src/**/*&quot;, &quot;src/**/*.vue&quot;], &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;./src/*&quot;] &#125;, &quot;importsNotUsedAsValues&quot;: &quot;remove&quot;, // 默认被设置为error error情况下类型导入必须增加前缀type 以区分类型 改成remove即可 &quot;preserveValueImports&quot;: false // 对于类型，在同时启用了 &quot;preserveValueImports&quot; 和 &quot;isolatedModules&quot; 时，必须使用仅类型导入进行导入；改成false即可 &#125;, &quot;references&quot;: [ &#123; &quot;path&quot;: &quot;./tsconfig.config.json&quot; &#125; ]&#125; 源码分析环境测试在源码处增加打印，测试pinia源码是否正常运行。 log被正常打印，说明pinia源码已经被正常运行。 ​ 如果感觉搭建环境过于繁琐，又想阅读pinia源码，可以直接clone项目，https://github.com/vkcyan/goto-pinia，开箱即用~ 结语​ 至此，我们便完成了万里长征第一步；植入的源码文件被正常运行，我们便可以通过log debug的方式来进行逻辑观测，接下来我们将正式开始pinia核心实现的探索之旅~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"分析pinia源码之前必须知道的API","slug":"pinia源码解读/分析pinia源码之前必须知道的API","date":"2022-07-04T16:00:00.000Z","updated":"2022-12-11T13:51:24.082Z","comments":true,"path":"2022/07/05/pinia源码解读/分析pinia源码之前必须知道的API/","link":"","permalink":"https://bluedancers.github.io/2022/07/05/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%88%86%E6%9E%90pinia%E6%BA%90%E7%A0%81%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84API/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言​ 在pinia源码中有一些业务场景下不常用的vue3 api，如果没有预先了解将会给源码解读带来较大困难，建议先搞清楚相关API，阅读代码将会事半功倍~ effectScope​ 在createPinia中的遇到的第一行就是不认识的vue3 API，打开官网看了一下，最上方info中写道 effect作用域是一个高阶API，专为库作者服务。 ​ 他的作用是创建一片单独的effect空间，该空间内的effect将可以一起被处理，有点类似docker与k8s的关系，例如ref computed watchEffect 都是docker中的容器，而effectScope就是k8s，它可以统一管理effect集群。 类型： 123456function effectScope(detached?: boolean): EffectScopeinterface EffectScope &#123; run&lt;T&gt;(fn: () =&gt; T): T | undefined // 如果这个域不活跃则为 undefined stop(): void&#125; ​ 通过官网的类型可以看到，effectScope存在一个boolean类型的参数，但是在vue3文档中并未找到参数说明，而在RFC中找到了更加详细的文档。接下来为effectScope的相关API说明。 run 接受一个函数并返回该函数的返回值 1234567891011121314const scope = effectScope();const counter = ref(1);const setupStore = scope.run(() =&gt; &#123; const doubled = computed(() =&gt; counter.value * 2); watch(doubled, () =&gt; console.log(&#x27;doubled&#x27;,doubled.value)); watchEffect(() =&gt; console.log(&quot;count:&quot;, doubled.value)); return &#123; doubled, &#125;;&#125;);// 打印 &#x27;count 2&#x27; watchEffect触发console.log(setupStore!.counter.value); // 打印&#x27;1&#x27;,可以正常访问返回值setupStore!.counter.value = 2; // 打印 &#x27;doubled 4&#x27; &#x27;count: 4&#x27; counter修改触发watch与watchEffect stop 递归结束所有effect，包括后代effectScope 12345678910111213141516171819const setupStore = scope.run(() =&gt; &#123; const counter = ref(1); const doubled = computed(() =&gt; counter.value * 2); nestedScope = effectScope(true /* detached */); nestedScope.run(() =&gt; &#123; watch(counter, () =&gt; console.log(&quot;doubled&quot;, counter.value * 2)); watchEffect(() =&gt; console.log(&quot;count:&quot;, counter.value*2)); &#125;); return &#123; counter, doubled, &#125;;&#125;);scope.stop();setupStore!.counter.value = 2;// 打印 doubled 4 count: 4 // 因为nestedScope被指定为true，所以就算父级被销毁，nestedScope依旧存在反应。// 如果想结束nestedScope，需要手动进行销毁nestedScope.stop() detached表示是否在分离模式下创建，该参数默认为false；当为true的时候，父级被停止，子集也不会受影响。 12345678910111213141516171819202122232425const scope = effectScope();let nestedScope: any;const setupStore = scope.run(() =&gt; &#123; const counter = ref(1); const doubled = computed(() =&gt; counter.value * 2); nestedScope = effectScope(true /* detached */); nestedScope.run(() =&gt; &#123; watch(counter, () =&gt; console.log(&quot;doubled&quot;, counter.value * 2)); watchEffect(() =&gt; console.log(&quot;count:&quot;, counter.value * 2)); &#125;); return &#123; counter, doubled, &#125;;&#125;);scope.stop();setupStore!.counter.value = 2;// 打印 doubled 4 count: 4// 因为nestedScope被指定为true，所以就算父级被销毁，nestedScope依旧存在反应。// 如果想结束nestedScope，需要手动进行销毁nestedScope.stop()nestedScope.stop();setupStore!.counter.value = 3;// 不会出现任何打印 markRaw标记一个对象，使其永远不会转换为 proxy。返回对象本身。 123456const foo = markRaw(&#123;&#125;)console.log(isReactive(reactive(foo))) // false// 嵌套在其他响应式对象中时也可以使用const bar = reactive(&#123; foo &#125;)console.log(isReactive(bar.foo)) // false markRaw在pinia源码中非常常见，主要用于优化pinia的自身性能。 toRaw toRaw可以获取一个响应式对象的原始属性 1234567const foo = &#123;&#125;;const reactiveFoo = reactive(foo);console.log(&quot;toRaw&quot;, toRaw(reactiveFoo) === foo); // trueconst foo1 = &#123;&#125;;const refFoo1 = ref(foo1);console.log(&quot;toRaw&quot;, toRaw(refFoo1.value) === foo1); // true 在pinia源码中用于获取reactive的原始数据，并添加字段到其中 toRefs​ toRefs比较常见，简单来说：结果中的每个对象都指向原始属性；在实际开发中常用于reactive的解构。 ​ 在pinia的源码中，针对store中的state的处理用到了toRefs，不过它解构的是state（ref类型）对象，如果解构的是普通对象将不具备响应式。 结语​ 以上就是pinia源码中使用较多的vue3 api，还有些非常基础的例如ref reactive，就不做过多赘述了。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"关于我使用Hexo搭建个人博客这档子事","slug":"关于开源/关于我使用Hexo搭建个人博客这档子事","date":"2022-06-29T16:00:00.000Z","updated":"2022-12-11T13:51:24.085Z","comments":true,"path":"2022/06/30/关于开源/关于我使用Hexo搭建个人博客这档子事/","link":"","permalink":"https://bluedancers.github.io/2022/06/30/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%BA%90/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/","excerpt":"","text":"前言​ 在我刚工作的那年，便搭建过一次Hexo静态站点到github Pages，那时候输出不多，几乎全都是技术类文章，于是我便把学习记录、文章都放在github仓库中，也会把精品文章发布到掘金；这样的情况下，自建博客没有被维护下去。 ​ 时间来到2022年，随着输出类型越来越多，自然便需要一个空间来存储所有的输出，调研了很多在线文档工具，比如语雀，飞书，Notion，都是非常不错的，不过我个人非常喜欢用Typora，也不太习惯其他文档工具，同时作者也是比较喜欢自由的人，思来想去还是自建博客吧，这便是再次搭建github Pages的原因。 ​ 博客搭建过程也花费了一些时间，遇到了若干小问题，希望后来人不要踩前人已经踩过的坑，这也是这篇文章的由来，希望借此可以帮到大家。 ​ 接下来就让我们正式开始吧。 适合人群 爱折腾、爱自由的开发者 需要一个美观的空间来存储各类文章的开发者 通过个人博客让面试加分的开发者 Hexo介绍​ Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的markdown文件，按照指定的主题解析成静态网页。 githubPages介绍​ GitHub Pages 是一种静态站点托管服务，它直接从 GitHub 上的存储库获取 HTML、CSS 和 JavaScript 文件，可选择通过构建过程运行文件，然后发布网站。您可以在GitHub Pages 示例集合中查看 GitHub Pages 站点示例。 ​ 通过上面的介绍我们便可以得到一个结论：githubPages + Hexo &#x3D; 个人博客，下面让我们正式开始搭建个人博客吧！ 环境要求 nodejs环境 安装git并 注册github账号，并已经将当前电脑的ssh秘钥添加到了Github（相当于告诉github，这台电脑有权操作你的github数据） 创建github Pages仓库 最后点击下方的 Create repository ，完成创建即可。 配置hexo搭建环境首先全局安装hexo 1npm install -g hexo-cli 然后创建存放站点资源的文件夹，在你认为合适的目录下执行 123hexo init 文件夹名称 // 建议username.github.iocd username.github.io // 刚才创建的文件夹npm install install完成后，在该文件夹下执行 1hexo s // hexo server的缩写 正常情况下会看到以下信息 然后我们访问http://localhost:4000/,便可以看到hexo生成的站点 能到这一步就算搭建成功了，接下来我们需要认识hexo生成文件中的配置，来个性化定制我们的个人站点 hexo文件说明_config.yml 一定要仔细看每一项配置哦，比如语言，博客简介，等等 非常重要的文件，配置网站的基本信息信息，比如名称 描述 分页 主题等信息。具体含义看这里 配置参数 themes​ 第三方网站主题存放目录，后面我们会用到 source​ 该文件夹是存放站点文章的地方，_post目录为文章存放处，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。 public​ 所有打包生产的文件都会被输出到public中，其中MD html文件将会被解析再存放在其中，其他文件会被拷贝进去。 将文章发布到Hexo中 可以将搬运到hexo，但是需要修改&#x2F;增加文章头部的配置信息，让hexo得以自动化归类 我们在_post中增加一个md文件，然后文章开头处写入以下信息，使用过wordPress的同学应该很熟悉，这是对当前文章的属性描述，具体配置可以看官方配置，之后便是填入文章内容，还记得我们通过hexo s启动的本地服务器吗，文章编写完成后，让我们去看看是是否存在变化。 不出意外的话应该可以看到我们刚才写的文章出现在网页中了,如果这里未显示可以尝试重启服务 在文章头部编写的categories，tags字段，hexo会按照关键字自动生成索引。 下一步我们便要将其发布到github Pages中，让所有人都可以访问到。 将hexo发布到githubPages​ 我们之前已经处理过了git本地环境与仓库，hexo的部署十分简单 安装快速部署脚本 该脚本会在你的目录下生成.deploy_git/执行更新命令的时候就会将该文件夹下的所有文件上传到指定的仓库中。 1npm install hexo-deployer-git --save 填写相关配置 12345deploy: type: git repo: https://github.com/username/username.github.io // 替换这里的username branch: master // 填写部署的GitHub分支，默认为gh-pages message: &#x27;&#x27; // 提交信息，存在默认值，可以不填写 部署到仓库 12hexo clean // 清除缓存文件 db.json与public/ (建议每次部署之前清除缓存)hexo d // deploy的缩写，读取yml中deploy的配置并部署 看到以上日志则说明部署成功 接下来我们前往仓库，就会发现仓库master分支中已经存在代码，再设置一下github Pages的分支，让博客资源文件可以被正常读取。 最后点击Action查看部署任务是否正常完成，正常情况下Action会在60s左右完成，部署完成后我们便可以访问线上站点了，https://username.github.io/ 只要可以看到我们的文章，便是部署成功了~（可能访问速度还有些慢，我们后面再优化） 这里肯定有好奇的小伙伴要问了，为什么你的样子和我部署的不一样？ 这就是下面要说的，自定义主题。 自定义主题​ 一个风格优美的博客可以为读者带来更好的体验，也是作者个性的一种表达，这也是自建博客的优势所在， hexo中存在大量官方提供 + 个人维护的Themes ​ 如果出现Hexo官网的Themes无法正常访问，可以在github中搜索hexo-theme，同样可以看到受欢迎的hexo主题，每个主题都会有使用文档，只需要仔细阅读文档并进行配置即可使用主题，感谢开源大佬们，别忘记给他们一个Star。 ​ 主题文件都存在在项目的themes文件夹中，并且需要将根目录的_config.yml的themes字段改为主题名称。 插件功能​ 自建博客的虽然不存在后端服务，但是借助第三方服务依旧可以实现交互能力，例如评论系统，统计系统，等等非常有趣的插件，常见的插件第三方主题的README中都会有相关介绍，本文就不做过多赘述了，建议大家看专门介绍相关内容的文章。 常见问题站点很慢​ github Pages访问很慢，绝大部分原因都是因为JS脚本加载阻塞问题，在不加任何异步属性的情况下，script的下载和执行都会阻塞dom的渲染。 ​ 例如项目依赖了jQuery，但是其CDN因为某些原因加载缓慢甚至超时失败，都会导致页面的长时间白屏，这会非常影响访问者的用户体验，以及作者的创作热情。 ​ 如果出现此类情况，我们就打开Chrome devTool查看NetWork中加载缓慢的脚本文件，然后复制其名称，在hexo源码中找到，再百度搜索国内的高速CDN替换掉即可。（注意不要修改打包后代码） 点击菜单404​ 有些第三方主题自带的一些菜单点击可能会出现白屏的情况，这是因为没有建立标签页 执行以下命令建立不存在的页面即可，新建的md具体内容还是需要参考使用的主题文档 1hexo new page books // 缓存问题​ 修改了一篇文章，但是打包到github Pages依旧没有被删除，类似这样的缓存问题怎么办？ ​ 我们只需要在每次push到github之前清除hexo生成的缓存文件即可 1hexo clean 部署报错执行hexo d，得到错误： 12345678910fatal: unable to access &#x27;https://github.com/username/username.github.io/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054FATAL &#123; err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (xxx\\username.github.io\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:390:28) at ChildProcess.cp.emit (xxx\\username.github.io\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123; code: 128 &#125;&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html ​ 网络问题，重试即可。 其他静态构建工具Vuepress​ Vue出品的静态站点生成工具，用来写文档非常不错，但是如果你对个性化要求较高，可能他不是很适合你。 jekyll​ 非常老牌的静态网站生成工具，使用Ruby语言进行开发，这就意味着使用jekyll需要安装Ruby环境，据说构建速度相对较慢，相对于Hexo未发现明显优势，喜欢的小伙伴可以试用一下。 Hugo​ 基于Go语言开发的静态网站构建工具，不过它并不需要Go环境，对于非前端开发者还是不错的选择，他号称是最快的构建框架；在搭建完hexo后才看到hugo，感觉有点意思，喜欢折腾的朋友可以试用一下，目前拥有59.8k的Star，是静态构建工具中最受欢迎的项目。 结语​ 搭建好github Pages并不是一件很困难的事情，但是保持输出习惯却是一件有难度的事情，通过这篇文章成功搭建起了个人博客，非常恭喜，你完成了万里长征非常重要的第一步，希望你可以坚持输出，从小的知识点开始做起，保持对可输出点的敏感嗅觉，并将其输出，逐渐搭建起自己的知识库，这对知识积累，将来跳槽也有很大的帮助。 ​ 如果一个正在被使用的技术方案当事人却无法教会别人，这便不算完全掌握，浅尝辄止是技术岗位的大忌。在输出的过程中，也是重新梳理的过程，在过程中会发现一些开发中未注意到潜在问题，逻辑漏洞，而为了完成输出，便会自我驱动解决遇到的问题； ​ 用输入驱动输出，用输出倒逼输入，将复杂的知识通过简单平实的话说出来，并教会别人，才是完全掌握，这也是输出的意义，这也是个人博客的意义。 ​","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://bluedancers.github.io/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://bluedancers.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"关于消费降级","slug":"随想/关于消费降级","date":"2022-06-27T16:00:00.000Z","updated":"2022-12-11T13:51:24.096Z","comments":true,"path":"2022/06/28/随想/关于消费降级/","link":"","permalink":"https://bluedancers.github.io/2022/06/28/%E9%9A%8F%E6%83%B3/%E5%85%B3%E4%BA%8E%E6%B6%88%E8%B4%B9%E9%99%8D%E7%BA%A7/","excerpt":"","text":"当我们买东西的时候，我们支付的不是钱。 我们支付的是我们生命中，去挣这笔钱所花掉的时间。 在我们创造的消费性社会，它还会持续不断的增长。 每当无法增长的时候，变成了悲剧。 我们为自己造了一座名叫【需求过剩】的大山。 你得不停的购买然后抛弃，在这个过程中，你却买不来生命，生命只会逝去。 浪费生命，失去自由是非常糟糕的 要懂得知足，不要给自己过重的负担，保持内心的幸福，否则你将一事无成。 出自《人类Human》（2015）","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://bluedancers.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"价值观","slug":"价值观","permalink":"https://bluedancers.github.io/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"}]},{"title":"移动端兼容性那些事儿","slug":"技术文章/移动端兼容性那些事儿","date":"2022-06-23T16:00:00.000Z","updated":"2022-12-11T13:51:24.089Z","comments":true,"path":"2022/06/24/技术文章/移动端兼容性那些事儿/","link":"","permalink":"https://bluedancers.github.io/2022/06/24/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/","excerpt":"","text":"低版本IOS系统Promise不存在finally事件​ 这是几年前生产环境发生的问题，通过错误监控看到了该错误，并且集中出现在ios10.0.x版本中，出现了，网上也有开发者遇到了IOS 10 Promise不存在问题，我们没遇到该情况，如果Promise对象不存在，则引入Promise的polyfill，如果仅仅是finally函数不存在则只需要手动补充即可 12345678910Promise.prototype.finally = function (callback: any) &#123; let P = this.constructor return this.then( (value) =&gt; P.resolve(callback()).then(() =&gt; value), (reason) =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) ) &#125; IOS时间戳兼容性问题​ 在ios无法解析使用-分割的时间字符串 123new Date(&#x27;2022-6-27 12:00:00&#x27;).getTime() // Android 正常获取 IOS NaNnew Date(&#x27;2022/6/27 12:00:00&#x27;).getTime() // 均正常new Date(1656302400000) // 均正常 ​ 在移动端开发中建议统一采用时间戳记录时间，具体格式交给时间处理函数即可。 移动端1px问题点击事件300ms延时问题​ 因为历史原因，移动浏览器会在touch和click事件之间增加300ms等待时间，来判断用户是否会进行双击手势来缩放页面，自然该特性也会影响到单击事件，后来在Chrome团队的推动下，该问题逐渐有了清晰的解决方案 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; // 窗口自动调整到设备宽度，并禁止用户缩放页面 ​ 随着响应式设计的逐步推进，开发者们已经根据设备本身的尺寸对站点进行了优化，也就逐渐淘汰了诸如双击缩放的约定。 移动端长按识别二维码无效​ 有些移动端开发者在使用类似uniapp这样的框架在开发H5应用中的，长按识别二维码的时候会出现不触发识别的情况，这是因为，长按识别图片信息仅仅在img标签生效，所以只需要使用原生img标签即可。 微信小程序按钮边框无法覆盖问题​ 非常常见的问题，button的边框无法被css中的border正常覆盖掉，那是因为自带的边框是通过伪类实现的 123button::after&#123; border: none;&#125; IOS input标签type为search时候右边有放大镜​ 在ios中input的type值为search的时候，会自带一个搜索icon，而安卓则没有此icon，为了保证一致性，我们需要删除ios自带的搜索icon 12input[type=&quot;search&quot;]&#123;-webkit-appearance:none;&#125; input::-webkit-search-cancel-button &#123;display: none;&#125; 公众号登录路由栈无法去除问题IOS系统微信公众号location跳转后，回退页面不刷新Vue2.x 报错Cannot read property ‘_wrapper’ of undefined​ 这个错误原则上也不算移动端错误了，但是这个报错信息确实会让人摸不着头脑，堆栈信息也无法明确看到具体报错位置，但是出现这个错误八成是因为@click事件在methods中未定义 vue2.x 排序key值问题如果JSON.stringify进行深拷贝时，一些引用类型的异常情况。replaceAll兼容问题uniappv3版本开发小程序 textarea事件绑定错乱","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"兼容性","slug":"兼容性","permalink":"https://bluedancers.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"JavaScript设计模式","slug":"设计模式/JavaScript设计模式","date":"2022-06-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.096Z","comments":true,"path":"2022/06/18/设计模式/JavaScript设计模式/","link":"","permalink":"https://bluedancers.github.io/2022/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JavaScript设计模式基础JavaScript是一门经典动态类型语言，对变量类型的宽容给实际编码带来了很大灵活性。由于无需进行类型检测，我们可能尝试调用对象的任何方法，而无需去考虑它原本是否被设计拥有该方法。 ​ 这一切都建立在鸭子类型的概念上，鸭子类型：如果它走起路来像鸭子，叫起来像鸭子，那他就是鸭子 ​ 利用鸭子类型，我们就不必借助类型的帮助，实现一个动态语言专有原则：面向接口编程，而不是面向实现变成，例如一个对象，具备length属性，那我们就可以将其视为数组，而不需要关心它的实际类型。 多态​ 同一个操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果 ​ 例如：小狗汪汪叫 小猫喵喵叫 他们都是动物，都会发生，但是各自发出的声音并不一样 ​ 其背后的思想是将“做什么”于“谁去做以及怎么样”分离开来，也就是将“不变的事物”于“变化的事物”分离开来。这给予了我们拓展程序的能力，程序看起来是可生长的，也是符合开放封闭原则的，相对于修改代码，增加代码显然优雅安全的多。 12345678910111213141516function sound(animal) &#123; animal.sound();&#125;var Dog = function () &#123;&#125;;Dog.prototype.sound = () =&gt; &#123; console.log(&quot;汪汪汪&quot;);&#125;;var Cat = function () &#123;&#125;;Cat.prototype.sound = () =&gt; &#123; console.log(&quot;喵喵喵&quot;);&#125;;new Dog().sound()new Cat().sound() 如果是强类型语言就需要借助继承来实现向上转型，从狗可以发出叫声转变为动物可以发出叫声，从而避免我们指定了发出声音对象是某一个类型，他就不可能被替换成为另一个类型。 ​ 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 封装封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节，设计细节以及隐藏对象的类型。 原型编程JavaScript本身就是基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型业务更加合适。 ​ 在JavaScript中不存在类的概念，对象也并非从类中创建出来，所有的JavaScript对象都是从某个对象上复制出来的。 ​ 原型编程存在一个重要特性，即当对象无法响应某个请求的时候，就会把该请求委托给自己的原型；这里更好的说法是把请求委托给它的构造器的原型 ​ 在JavaScript中，一个function并不一定仅仅是一个普通函数，也可以是一个函数构造器，当使用new运算符来调用函数的时候，此时函数就是一个构造器。使用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype，再进行一些其他额外操作的过程。 原型链查找对象的过程12345678var A = function () &#123;&#125;;A.prototype = &#123; name: &quot;sven&quot; &#125;;var B = function () &#123;&#125;;B.prototype = new A();var b = new B();console.log(b.name); 首先尝试遍历对象b中的所有属性，但是没有找到name这个属性 查找name属性的请求被委托到对象b的构造器原型，它被b._proto_记录并指向B.prototype，而B.prototype又直线new A()创建的对象 再该对象中依旧没有找到name属性，于是请求又被委托到这个对象的构造器的原型A.prototype 在A.prototype中找到了name属性，返回值 闭包闭包案例123456789101112var func = function () &#123; var a = 1; return function () &#123; a++; alert(a); &#125;;&#125;;var ff = func();ff();ff();ff(); ​ 局部变量在函数执行结束后将会被销毁，但是以上的例子中，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行func的时候，func返回了一个匿名函数的引用，它可以访问到func被调用时产生的环境，而局部变量所在的环境一直处于这个环境中。既然局部变量所处的环境还能被外界访问，这个局部变量就有了不被销毁的理由；在这样的闭包结构中，局部变量实现了生命的延续。 闭包与面向对象过程与数据的结合是形容面向对象中的对象时常用的表达 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据 通常用面向对象实现的功能，用闭包也能实现，反之亦然。 闭包版本 1234567891011121314var app = function () &#123; var value = 0; return &#123; call: function () &#123; value++; console.log(value); &#125;, &#125;;&#125;;var App = app();App.call(); // 1App.call(); // 2App.call(); // 3 对象版本1234567891011var app = &#123; value: 0, call: function () &#123; this.value++; console.log(this.value); &#125;,&#125;;app.call(); // 1app.call(); // 2app.call(); // 3 类版本12345678910111213var App = function () &#123; this.value = 0;&#125;;App.prototype.call = function () &#123; this.value++; console.log(this.value);&#125;;var app = new App();app.call(); // 1app.call(); // 2app.call(); // 3 高阶函数高阶函数是指最少满足下列条件之一的函数 函数可以作为参数被传递 函数可以作为返回值输出 ​ JavaScript语言的函数显然满足高阶函数，在实际开发中将函数作为参数进行传递，让函数的执行结果返回一个另一个函数都是非常普遍的情况，例如函数执行的callback函数。 ​ 通过高阶特性，我们可以实现AOP，也就是面向切面编程 1234567891011121314151617181920212223242526272829303132// 面向切面编程Function.prototype.before = function (beforeFn) &#123; console.log(&quot;before&quot;); var _self = this; return function () &#123; beforeFn.apply(this, arguments); // 执行before本身 return _self.apply(this, arguments); // 返回函数本身 &#125;;&#125;;Function.prototype.after = function (afterFn) &#123; console.log(&quot;after&quot;); var _self = this; return function () &#123; var ret = _self.apply(this, arguments); // 先执行before afterFn.apply(this, arguments); // 最后执行after return ret; &#125;;&#125;;var func = function () &#123; console.log(2);&#125;;func = func .before(function () &#123; console.log(1);&#125;) .after(function () &#123; console.log(3);&#125;);func(); 首先执行before，打印‘before’，然后执行after，打印‘after’ 执行func()，开始执行after，进入after闭包中，然后执行ret，进入before before中首先执行了自己beforeFn，打印‘1’，然后执行func本身，打印‘2’，并返回本身 ret执行结束，开始执行afterFn，打印‘3’，返回func本身 高阶应用 - 函数柯里化​ 柯里化又被称为部分求值，一个柯里化函数首先会接受一些参数，接收参数后不会立刻求职而是继续返回当前函数，之前传入的值在函数形成的闭包种被保存了起来。待函数真正需要求值的时候，之前传入的所有参数都会被一次性求值。 ​ 例如实现一个计算每个月花费多少钱的函数，但是在实现中，我们并不关心吗，每天花费了多少，只想知道月底花掉了多少，实际上只需要计算一次 12345678910111213141516171819202122232425262728function currying(fn) &#123; var args = []; return function () &#123; if (arguments.length == 0) &#123; var res = fn.apply(this, args); args = []; return res; &#125; else &#123; [].push.apply(args, arguments); return arguments.callee; // 当前正在执行的函数 &#125; &#125;;&#125;var cost = (function () &#123; var money = 0; return function () &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; money += arguments[i]; &#125; return money; &#125;;&#125;)();var cost = currying(cost);cost(100)(100)(100)(100);cost(100);console.log(cost()); 500cost(100);console.log(cost()); 600 单例模式​ 要实现一个单例模式并不复杂，无非是用一个变量来标志是否已经为某个类创建过对象，如果是，则下一次获取该类的实例，直接返回之前创建的对象。 vue2.x 中的vuex在页面与组件中进行挂载使用的就是单例模式 使用代理实现单例模式12345678910111213141516171819202122var createDiv = function (html) &#123; this.html = html; this.init();&#125;;createDiv.prototype.init = function () &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = this.html; document.body.appendChild(div);&#125;;var proxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new createDiv(html); &#125; return instance; &#125;;&#125;)();var a = new proxySingletonCreateDiv(&quot;one&quot;);var b = new proxySingletonCreateDiv(&quot;two&quot;);console.log(a === b); // true JavaScript的单例模式​ 单例模式的核心是确保只有一个实例，比提供全局访问。在JavaScript中很多都会通过全局变量进行实现，但是JavaScript的全局变量并不是非常好的特性，在中大型项目中会存在命名冲突问题，所以应当尽量使用命名空间。 惰性单例​ 在未使用之前，相关逻辑不会被创建，并且只有第一次使用的时候才会创建，同时我们别忘记了单一职责原则 ​ 在下面的代码中，我们将创建单例与具体单例逻辑进行分离，这两个方法独立变化而且互不影响，这样避免了下次出现其他元素，我们需要将整个单例函数都复制一遍的情况，而是只需要创建对应的创建函数即可。 123456789101112131415161718192021function getSingle(fn) &#123; let result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;;&#125;function createLoginLayer() &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是登录弹窗&quot;; div.style.display = &quot;none&quot;; document.body.appendChild(div); return div;&#125;var createSingLoginLayer = getSingle(createLoginLayer);document.getElementById(&quot;loginBtn&quot;).onclick = function () &#123; var loginLayer = createSingLoginLayer(); loginLayer.style.display = &quot;block&quot;;&#125;; 小结​ 单例模式是一种简单，但是非常实用的模式，特别是惰性单例技术，在合适的时候再去创建对象，并且只创建唯一一个，同时我们将创建对象与管理单例的职责分开到不同方法中，这样的模式更加体验单例模式的优势。 策略模式​ 策略模式：定义一系列的算法，把它们一个个的封装起来，并且使它们可以相互替换。 ​ 案例：某个公司年终奖方式为基础工资乘以效绩等级，S为基础工资的4倍，A为基础工资的3倍，我们实用策略模式进行实现 1234567891011121314151617181920212223242526272829303132var performatceS = function () &#123;&#125;; // 效绩为S 工资算法performatceS.prototype.calculate = function (salary) &#123; return salary * 4;&#125;;var performatceA = function () &#123;&#125;; // 效绩为A 工资算法performatceA.prototype.calculate = function (salary) &#123; return salary * 3;&#125;;var Bonus = function () &#123; this.salary = null; // 基础工资 this.strategy = null; // 具体算法&#125;;Bonus.prototype.setSalary = function (salary) &#123; this.salary = salary;&#125;;Bonus.prototype.setStrategy = function (strategy) &#123; this.strategy = strategy;&#125;;Bonus.prototype.getBonus = function () &#123; return this.strategy.calculate(this.salary);&#125;;var bonus1 = new Bonus();bonus1.setSalary(10000);bonus1.setStrategy(new performatceS());console.log(&quot;效绩为A&quot;, bonus1.getBonus()); // 40000bonus1.setStrategy(new performatceA());console.log(&quot;效绩为A&quot;, bonus1.getBonus()); // 30000 JavaScript中策略模式的体现以上是类的实现方法，在JavaScript中我们可以通过函数进行实现，代码将会简洁很多 123456789101112var srtategies = &#123;&#125;;srtategies.S = function (salary) &#123; return salary * 4;&#125;;srtategies.A = function (salary) &#123; return salary * 3;&#125;;var calclateBonus = function (level, salary) &#123; return srtategies[level](salary);&#125;;console.log(&quot;效绩为S&quot;, calclateBonus(&quot;S&quot;, 10000));console.log(&quot;效绩为A&quot;, calclateBonus(&quot;A&quot;, 10000)); 多态在策略模式中的体现​ 通过使用策略模式，我们可以消除程序中大量的ifelse语句，并将我们将具体逻辑与实际执行函数进行分离，执行函数没有计算能力，而是委托某个策略对象来完成奖金计算，这正是多态性的体现。 策略模式在表单校验的应用​ 在通过JavaScript表单校验的场景中,我们可以通过ifelse进行校验判断，但是这种方式不符合单一职责，开放封闭原则，我们可以通过策略模式来优化他，将通用的校验逻辑与具体校验条件进行解耦合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 校验逻辑/** * 如果同时设置了required与verify，将会忽略required * verify为自定义校验函数 可以理解为一旦写了verify,其他参数都不需要写了 * @param data 被校验对象 * @param validate 校验规则 * @param isOne 是否校验到错误就立刻返回 * @returns */function starValidate(data, validate, isOne) &#123; let errBack: any[] = [] for (const key in data) &#123; if (validate[key]) &#123; if (validate[key].verify) &#123; validate[key].verify(&#123; data: data[key], allData: data &#125;, (errMsg) =&gt; &#123; if (errMsg) &#123; errBack.push(errMsg) &#125; else &#123; errBack.push(validate[key].callback(data)) &#125; &#125;) &#125; else &#123; // 开启校验 if (validate[key].required) &#123; // 数据不存在 if (!data[key]) &#123; errBack.push(validate[key].callback(data)) &#125; &#125; &#125; &#125; if (isOne &amp;&amp; errBack.length != 0) &#123; break &#125; &#125; console.log(&#x27;处理结果&#x27;, errBack) if (errBack.length == 0) &#123; return Promise.resolve() &#125; else &#123; if (isOne) &#123; return Promise.reject(errBack[0]) &#125; else &#123; return Promise.reject(errBack) &#125; &#125;&#125;// 校验条件const validateRules = &#123; cashingInstructions: &#123; required: true, callback: () =&gt; (&#123; selector: &#x27;.open_prize&#x27;, message: &#x27;请输入字段cashingInstructions&#x27; &#125;), &#125;, lotteryDescription: &#123; verify: (&#123; data &#125;, err) =&gt; &#123; if (data == &#x27;[]&#x27;) &#123; err(&#123; selector: &#x27;.launch_total&#x27;, message: &#x27;请输入字段lotteryDescription&#x27;, &#125;) &#125; &#125;, &#125;,&#125;let data = &#123; cashingInstructions:&#x27;&#x27;, lotteryDescription:&#x27;[]&#x27;&#125;// 实现表单校验 starValidate(data, validateRules, true) 策略模式的优缺点优点 策略模式利用组合，委托和多态等技术与思想，可以有效避免多重条件选择语句 策略模式符合开放封闭原则，将具体逻辑单独封装，使其易于理解易于拓展 策略模式的策略函数可以再多项目之间复用，避免复制粘贴工作 缺点 相对于ifelse，策略模式的整体代码量会有所增加 调用者需要对策略细节可能了解，才能很好的使用该策略，这违反了最少知识原则，增加了使用成本 一等公民函数与策略模式​ 在函数作为一等公民的语言中，策略模式是隐形的具体策略的值就是函数变量。 ​ 在JavaScript这种将函数作为一等对象的语言中，策略模式已经融入到语言中，例如我们经常使用高阶函数来封装不同行为，并且将它传递到另一个函数中，当我们对这些函数发出“调用”的消息，不同的函数会返回不同的结果，函数对象的多态性来到更加简单。 代理模式​ 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个提升对象来控制对这个对象的访问，客户实际上访问的是替身对象。 小红想找心仪的对象让小明作为自己的媒人(代理人) 保护代理：张三找过来了，但是张三没车没房，小红便直接帮他拒绝 虚拟代理：介绍给小明是非常重要的事情，李四对小红有兴趣，给小明好处费，小明便在小红心情好的时候给其介绍（延迟到正常需要的时候再创建） 单一职责原则​ 对一个类&#x2F;函数&#x2F;对象而言，应该仅有一个引起它变化的原因，如果一个对象承担了多种职责，就意味着这个对象将变得巨大，引起它变化的原因将会有多种。面向对象估计设计将行为分布到细颗粒度的对象中，如果一个对象承担的职责过多，等于把这些职责耦合在一起，这种耦合会导致脆弱和低内聚的设计，当变化发生时，设计会遭到意外的破坏。 开放封闭原则​ 例如我们为了更好的性能将一些数据处理成为另外的数据格式，但是2年后上游帮助我们处理过了，我们不再需要额外处理，就不得不在改动原本函数中的代码 ​ 我们可以使用代理模式 达到不改动原对象的情况下，为其提供新的行为，他们各自变化，也不影响对象。 代理与本体接口的一致性​ 通常来说，代理对象对外提供的方法名称会与本体名称保持一致，这样可以在任何使用本体的地方替换成使用代理 代理模式-合并http请求​ 这是一个应用案例，文中的例子我在日常生活中也经历过，将每次点击都请求转变为收集2s类所有请求，并统一发送出去，发送请求时一个函数，何时发送，发送什么，时另一个函数，其中用到了节流函数来控制请求频率 代理模式 - 空间复杂度换取时间复杂度面对非常复杂的计算逻辑，我们可以保存每一次的计算结果，下一个再来同样的参数可以直接走缓存，不再需要计算，这样增加空间，但是缩小了时间。 代理模式示例12345678910111213141516171819202122232425262728293031323334353637var muit = function () &#123; var a = 1; for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i]; &#125; return a;&#125;;var plus = function () &#123; var a = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; a = a + arguments[i]; &#125; return a;&#125;;// 代理模式函数var ceateProxyFactory = function (fn) &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, &quot;,&quot;); if (args in cache) &#123; console.log(&quot;存在缓存&quot;, args,cache); return cache[args]; &#125; cache[args] = fn.apply(this, arguments); return cache[args]; &#125;;&#125;;var muitFun = ceateProxyFactory(muit);var plusFun = ceateProxyFactory(plus);console.log(muitFun(1, 2, 3, 4, 5)); // 120console.log(muitFun(1, 2, 3, 4, 5)); // 走缓存 120console.log(plusFun(1, 2, 3, 4, 5)); // 15console.log(plusFun(1, 2, 3, 4, 5)); // 走缓存 15 总结​ 总体来说代理模式相对简单并且常用，就算一名开发人员没听过这个名词也会写出比较优秀的代理模式代码，并且代理模式不需要预先考虑，需要用到的时候再编写代理函数也不迟。 迭代器模式内部迭代器​ 完全接手整个迭代过程，外部只需要初始调用即可，外界不需要关心迭代器的内部实现，但是这也是内部迭代器的缺点 ​ 例如JavaScript的map forEach 外部迭代器​ 外部迭代器必须显式的请求迭代下一个元素，外部迭代器增加了程序的复杂度，但是也增强了迭代器的灵活性。 12345678910111213var current = 0;var aa = function (obj) &#123; var next = function () &#123; current += 1; &#125;; var getItem = function () &#123; return obj[current]; &#125;; return &#123; next, getItem, &#125;;&#125;; ​ 再具体业务中，使用何种迭代器并无优劣，根据实际场景而定。 总结​ 大部分语言已经内置了迭代器，并且使用频率高、门槛低；迭代器是一种非常简单设计模式，简单到大部分人不认为他是一种迭代器。 发布-订阅模式​ 发布-订阅模式它订阅了一种一对多的依赖关系,当一个对象的状态发生改变的时，所有依赖于它的对象都将得到通知 案例​ 小明看重了某一个小区的热门户型，并且得到消息，后期还会开放一批，但是时间未知，于是小明找到售楼处，预留了自己的电话号码，让售楼处在开发房源的时候通知他，同理，小张、小王都预留了手机号码，于是售楼处就会在房源发布的时候通知预留电话的客户。 ​ 客户想知道房源开售消息，于是他订阅了售楼处，售楼处得到消息后，第一时间将消息发布给订阅者，这样具备显而易见的优点。 小明不需要天天给售楼处打电话，在合适的时间售楼处会通知购房者 购房者于售楼处不再有强耦合关系 发布-订阅模式的作用​ 以上场景于程序中的异步场景是非常相似的，例如我们订阅ajax的error事件，我们无需关心异步运行期间的内部状态，只需要订阅需要的事件发生点即可。 ​ 另外发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式的调用另一个对象的某个接口。 dom事件​ 我们使用dom绑定事件函数就是发布-订阅模式的实际应用，我们不知道用户会在什么时候点击点击，所以我们订阅了dom本身的click事件。 自定义发布-订阅事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546var salesOffices = &#123;&#125;;salesOffices.clientList = [];salesOffices.listen = function (key, fn) &#123; // 创建订阅关联关系 if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn);&#125;;salesOffices.trigger = function () &#123; // 获取订阅数组 var key = Array.prototype.shift.call(arguments); var fns = this.clientList[key]; // 不存在订阅数组则直接返回 if (!fns || fns.length === 0) &#123; return false; &#125; // 执行订阅数组 for (let i = 0; i &lt; fns.length; i++) &#123; let fn = fns[i]; fn.apply(this, arguments); &#125;&#125;;// 小明订阅salesOffices.listen(&quot;sq88&quot;, function (price) &#123; console.log(&quot;我是小明，88平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);salesOffices.listen(&quot;sq88&quot;, function (price) &#123; console.log(&quot;我是小强，88平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);// 小红订阅salesOffices.listen(&#x27;sq110&#x27;, function (price) &#123; console.log(&quot;我是小红，110平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);salesOffices.trigger(&quot;sq88&quot;, 20000000);salesOffices.trigger(&quot;sq110&quot;, 30000000);// 我是小明，88平方// 价格=20000000// 我是小强，88平方// 价格=20000000// 我是小红，110平方// 价格=30000000 取消订阅​ 取消订阅只需要将订阅数组中的指定订阅函数删除即可 123456789101112131415161718192021222324/** * key 订阅类型 * fn 订阅函数 */salesOffices.remove = function (key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; // 没有传入具体的回调地址，则取消所有订阅函数 if (fns) &#123; fns.length = 0; &#125; &#125; else &#123; for (let i = 0; i &lt; fns.length; i++) &#123; const fnItem = fns[i]; if (fnItem === fn) &#123; fns.splice(i, 1); // 删除订阅函数回调 break; &#125; &#125; &#125;&#125;; 关于网站登录的实际应用场景：用户登录完成后，我们需要刷新不相邻模块的数据，这种异步问题，我们一般通过回调函数的方式解决 123456login.succ(() =&gt; &#123; header.setAvatar(data.avatar) nav.setAvatar(data.avatar) message.refresh() // ....&#125;) ​ 这种编写方式将组件数据于信息产生了强耦合关系，如果在未来，我们又增加了一个模块，则需要再次修改改回调函数 ​ 而通过发布-订阅模式，我们就可以在不同模块中订阅用户信息状态的变化，当登录成功的时候，登录模块发布消息到订阅他的模块中，至于各个模块做了什么，登录模块并不关心。 123login.listen(&#x27;loginSucc&#x27;,() =&gt; &#123; // 登录成功，用户数据获取完毕&#125;) 全局模式下的发布-订阅模式​ 全局状态下的发布-订阅可以在两个毫不相关的模块之间进行使用，这样就能保持模块的封装性 ​ 但是这里也需要留意一个问题，如果模块之间又太多的全局发布-订阅模式，就会造成消息流向混乱问题，这会导致维护上出现一些问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var Event = (function () &#123; var clientList = &#123;&#125;; var listen; var trigger; var remove; listen = function (key, fn) &#123; // 创建订阅关联关系 if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function () &#123; // 获取订阅数组 var key = Array.prototype.shift.call(arguments); var fns = clientList[key]; // 不存在订阅数组则直接返回 if (!fns || fns.length === 0) &#123; return false; &#125; // 执行订阅数组 for (let i = 0; i &lt; fns.length; i++) &#123; let fn = fns[i]; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; // 没有传入具体的回调地址，则取消所有订阅函数 if (fns) &#123; fns.length = 0; &#125; &#125; else &#123; for (let i = 0; i &lt; fns.length; i++) &#123; const fnItem = fns[i]; if (fnItem === fn) &#123; fns.splice(i, 1); // 删除订阅函数回调 break; &#125; &#125; &#125; &#125;; return &#123; listen, trigger, remove, &#125;;&#125;)();var xm = function (price) &#123; console.log(&quot;小明价格&quot;, price);&#125;;Event.listen(&quot;sq88&quot;, xm); // 订阅Event.listen(&quot;sq110&quot;, xm); // 订阅Event.remove(&quot;sq88&quot;, xm); // 取消订阅Event.trigger(&quot;sq88&quot;, 220000); // 发布Event.trigger(&quot;sq110&quot;, 2020000); // 发布 JavaScript实现发布-订阅模式的便利性推模型​ 事情发生的时候，发布者会一次性将所有改变的状态与数据都推送给订阅者 拉模型​ 事情发生的时候，发布者只会告诉所有订阅者，需要订阅者手动去拉去 ​ 而在JavaScript中，因为语言特性的存在，是我们可以非常方便的将所有参数通过arguments传入订阅者，所以我们使用推模型来完成消息的订阅与发布。 总结优点 对象之间的解耦合，可以帮助我们写出更好的应对异步编程的场景。 通过订阅-发布模式可以实现以此为特性的解决方案，例如MVVM。 缺点 创建订阅-发布模式需要消耗一定的时间与内存。 订阅的消息会一直留存在内存中，产生了无意义的消耗。 过度使用订阅-发布会导致程序难以追踪与维护。 ​ 命令模式​ 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者与请求接收者能够消除彼此之间的耦合关系 ​ 命令模式还需要支持撤销、排队等等操作 命令模式的例子-菜单程序（面向对象）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var btn1 = document.getElementById(&quot;btn1&quot;);var btn2 = document.getElementById(&quot;btn2&quot;);var btn3 = document.getElementById(&quot;btn3&quot;);var setCommand = function (btn, commm) &#123; btn.onclick = function () &#123; commm.execute(); &#125;;&#125;;var MenuBar = &#123; refresh: function () &#123; console.log(&quot;刷新菜单目录&quot;); &#125;,&#125;;var SubMenu = &#123; add: function () &#123; console.log(&quot;增加子菜单&quot;); &#125;, del: function () &#123; console.log(&quot;删除子菜单&quot;); &#125;,&#125;;var RefreshMenuBarCommand = function (receiver) &#123; this.receiver = receiver;&#125;;RefreshMenuBarCommand.prototype.execute = function () &#123; this.receiver.refresh();&#125;;var AddSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;AddSubMenuCommand.prototype.execute = function () &#123; this.receiver.add();&#125;;var DelSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;DelSubMenuCommand.prototype.execute = function () &#123; this.receiver.del();&#125;;var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);var addSubMenuCommand = new AddSubMenuCommand(SubMenu);var delSubMenuCommand = new DelSubMenuCommand(SubMenu);setCommand(btn1, refreshMenuBarCommand); // 将div与方法做好绑定关系,同时约定一个触发指令点击btn1触发refresh内部预留的execute方法setCommand(btn2, addSubMenuCommand);setCommand(btn3, delSubMenuCommand); 命令模式的例子-菜单程序（面向函数）123456var bindClick = function (btn, func) &#123; btn.onclick = func;&#125;;bindClick(btn1, MenuBar.refresh);bindClick(btn2, SubMenu.add);bindClick(btn3, SubMenu.del); 命令模式的由来，其实就是回调（callback）函数的一个面向对象的替代品 而再JavaScript这样函数作为一等公平的语言中，命令模式早已经融入到语言之中，函数本身就可以被四处传递，即时我们依旧需要请求“接收者”，那也未必使用面向对象的方式，闭包同样可以完成同样的功能。 命令模式的例子-菜单程序（闭包）1234567891011121314var setCommand = function (btn, func) &#123; btn.onclick = function () &#123; func(); &#125;;&#125;;var RefreshMenuBarCommand = function (receiver) &#123; return function () &#123; receiver.refresh(); &#125;;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(btn1, refreshMenuBarCommand); 命令模式 - 回放123456789101112131415161718192021222324252627282930313233343536373839var Ryu = &#123; attack: function () &#123; console.log(&quot;攻击&quot;); &#125;, defense: function () &#123; console.log(&quot;防御&quot;); &#125;, jump: function () &#123; console.log(&quot;跳跃&quot;); &#125;, crouch: function () &#123; console.log(&quot;蹲下&quot;); &#125;,&#125;;var makeCommand = function (receiver, state) &#123; return function () &#123; receiver[state](); &#125;;&#125;;var commandStack = []; // 保存命令堆栈document.onkeypress = function (ev) &#123; var commands = &#123; 119: &quot;jump&quot;, // w 115: &quot;crouch&quot;, // s 97: &quot;defense&quot;, // a 100: &quot;attack&quot;, // d &#125;; if (commands[ev.keyCode]) &#123; var command = makeCommand(Ryu, commands[ev.keyCode]); command(); // 执行命令 commandStack.push(command); // 保存到堆栈 &#125;&#125;;document.getElementById(&quot;replay&quot;).onclick = function () &#123; var command; while ((command = commandStack.shift())) &#123; command(); &#125;&#125;; 宏命令​ 宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。 ​ 在创建命令模式的时候，增加一个add方法来增加命令，并保存到任务对略，最后调用execute方法依次执行即可 总结​ 命令模式在JavaScript中因为高阶函数的存在，让其不太显眼，本质上他是将具体调用与调用的具体逻辑进行分离，具体逻辑就是命令的体现。 组合模式​ 组合模式需要通过对象的多态性进行体现，是的用户对单个对象和组合对象的使用具有一致性 示例​ 这里定义了一个通用函数execute来作为组合模式的桥梁，完成对象树的构建。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;button id=&quot;button&quot;&gt;按我&lt;/button&gt;&lt;script&gt; var MacroCommand = function () &#123; return &#123; commandsList: [], add: function (command) &#123; this.commandsList.push(command); &#125;, execute: function () &#123; for (let i = 0; i &lt; this.commandsList.length; i++) &#123; this.commandsList[i].execute(); &#125; &#125;, &#125;; &#125;;var openAcCommand = &#123; execute: function () &#123; console.log(&quot;打开空调&quot;); &#125;,&#125;;var openTvCommand = &#123; execute: function () &#123; console.log(&quot;打开电视&quot;); &#125;,&#125;;var openSoundCommand = &#123; execute: function () &#123; console.log(&quot;打开音响&quot;); &#125;,&#125;;var macroCommand1 = MacroCommand();macroCommand1.add(openTvCommand);macroCommand1.add(openSoundCommand);var closeDoorCommand = &#123; execute: function () &#123; console.log(&quot;关门&quot;); &#125;,&#125;;var openPcCommand = &#123; execute: function () &#123; console.log(&quot;打开电脑&quot;); &#125;,&#125;;var openQQCommand = &#123; execute: function () &#123; console.log(&quot;登录QQ&quot;); &#125;,&#125;;var macroCommand2 = MacroCommand();macroCommand2.add(closeDoorCommand);macroCommand2.add(openPcCommand);macroCommand2.add(openQQCommand);var macroCommand = MacroCommand();macroCommand.add(openAcCommand); // 如果是基本对象,就是直接触发到其本身的execute方法macroCommand.add(macroCommand1); // 如果是复杂对象,则触发到下一级的execute,然后以深度优点遍历直到最底部的基本对象macroCommand.add(macroCommand2);var setCommand = (function (command) &#123; document.getElementById(&quot;button&quot;).onclick = function () &#123; command.execute(); &#125;;&#125;)(macroCommand);&lt;/script&gt; ​ 组合模式最大的优点在于可以一致地对待组合对象与基本对象。客户不需要关心当前处理的是谁，只要它是一个命令，并且有execute方法，这个命令就可以被执行。 ​ 得益于JavaScript是动态类型语言，对象的多态性与生俱来，不会存在编辑器检查，所以我们实现组合模式并不需要编写抽象类，只需要保证组合对象与叶对象拥有相同的方法即可，并且用鸭子类型的思想进行接口检查 组合模式-扫描文件夹​ 我们通过组合模式，可以做到更新树的结构，但是却不需要改变原有代码，这符合开放封闭原则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Folder = function (nameParams) &#123; let name = nameParams; let files = []; function add(file) &#123; files.push(file); &#125; function scan() &#123; console.log(&quot;开始扫描文件夹&quot;, name); for (let i = 0; i &lt; files.length; i++) &#123; files[i].scan(); &#125; &#125; return &#123; add, scan, &#125;;&#125;;var File = function (nameParams) &#123; let name = nameParams; function add() &#123; throw new Error(&quot;文件中不能增加文件夹&quot;); &#125; function scan() &#123; console.log(&quot;开始扫描文件&quot;, name); &#125; return &#123; add, scan, &#125;;&#125;;var folder = new Folder(&quot;学习资料&quot;);var folder1 = new Folder(&quot;JavaScript&quot;);var folder2 = new Folder(&quot;jQuery&quot;);var file1 = new File(&quot;JavaScript设计模式与开发实践&quot;);var file2 = new File(&quot;精通jQuery&quot;);var file3 = new File(&quot;重构与模式&quot;);folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3);var folder3 = new Folder(&quot;Nodejs&quot;);var file4 = new File(&quot;深入浅出Node.js&quot;);folder3.add(file4);var file5 = new File(&quot;JavaScript语言精髓与编程实战&quot;);folder.add(folder3);folder.add(file5);folder.scan(); 一些需要注意的地方 组合模式不是父子关系 对一组叶对象的操作必须具有一致性，只有用一致的方式对待列表中的每一个叶对象，才适合使用组合模式 如果存在一个叶子元素存在多个父级，可能就需要管理映射关系，避免子元素多次被执行 总结​ 组合模式可以让我们把相同的操作应用在组合对象和单个对象上。 组合模式的美国和对象看起来都和其他对象差不多，他们的区别只能在运行中才能显现出来，这会使代码难以理解 组合模式会大量创建变量，会让系统负担不起 模板方法模式​ 模板方法是一种只需要继承就可以实现的非常简单的模式（多态性） 模板方法由2部分组成，第一部分是抽象父类，第二部分是具体的实现子类 在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留到子类中进行实现，这很好的体现了泛化的思想。 ​ 在模板方法中，子类实现中的相同部分被上移到父类中，而将不同的部分留给子类实现，子类可以复写其具体实现。 咖啡与茶1234567891011121314151617181920212223242526272829303132333435363738394041var Beverage = function () &#123;&#125;;Beverage.prototype.boilWater = function () &#123; console.log(&quot;把水煮沸&quot;);&#125;;Beverage.prototype.brew = function () &#123;&#125;;Beverage.prototype.pourInCup = function () &#123;&#125;;Beverage.prototype.addCondiments = function () &#123;&#125;;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;;var Coffee = function () &#123;&#125;;Coffee.prototype = new Beverage();Coffee.prototype.brew = function () &#123; console.log(&quot;沸水冲泡咖啡&quot;);&#125;;Coffee.prototype.pourInCup = function () &#123; console.log(&quot;把咖啡倒进杯子&quot;);&#125;;Coffee.prototype.addCondiments = function () &#123; console.log(&quot;加糖和牛奶&quot;);&#125;;var Coffee = new Coffee();Coffee.init();var Tea = function () &#123;&#125;;Tea.prototype = new Beverage();Tea.prototype.brew = function () &#123; console.log(&quot;沸水冲泡咖啡&quot;);&#125;;Tea.prototype.pourInCup = function () &#123; console.log(&quot;把咖啡倒进杯子&quot;);&#125;;Tea.prototype.addCondiments = function () &#123; console.log(&quot;加糖和牛奶&quot;);&#125;;var Tea = new Tea();Tea.init(); ​ 在以上例子中Beverage.prototype.init就是所谓的模板方法，因为该帆帆中封装了子类的算法框架。 抽象类模板方法模式是一种严格依赖抽象类的设计模式。 抽象帆帆被声明在抽象类中，抽象方法并没有具体的实现过程，是一些哑巴方法 如果每个子类中都有一些同样的具体实现方法，那么这些方法也可以选择放在抽象类中，这样可以节省代码以达到复用的效果，这些方法被叫做具体方法。 钩子方法​ 模板方法是固定不变的，但是在某些场景下却又要求他变化，有什么办法可以让子类不受这个约束呢？ ​ 我们可以使用钩子方法来实现，放置一个钩子在特定的逻辑。例如以上的例子中咖啡有些人不希望加调料 12345678910111213141516171819// ...Beverage.prototype.custonmerWantsCondiments = function () &#123; return true; // 默认需要调料&#125;;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); if (this.custonmerWantsCondiments()) &#123; this.addCondiments(); &#125;&#125;;// ...Coffee.prototype.custonmerWantsCondiments = function()&#123; return window.confirm(&#x27;请问需要调料吗？&#x27;)&#125;var Coffee = new Coffee();Coffee.init(); 好莱坞原则​ 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历投递过去之后，只能回家等电话，有些等不及的就会打电话过去问，而好莱坞每次都会回答：“不太来找我，有消息我会通知你” ​ 在设计中，这种模式被称为好莱坞原则，在程序中，高层组件决定什么时候以何种方式使用这些底层组件 ​ 这种模式在模板方法模式中很常见，在发布订阅模式，回调函数都非常适用，就像出租车司机告诉你别问我还有多远到，到了我会告诉你。 小结​ 模板方法是一种典型的通过封装变化提高系统拓展性的设计模式。我们把部分抽象逻辑抽象到父类的模板方法，而子类的方法具体怎么实现是可变的，于是我们把这部分变化的逻辑封装到子类中。 享元模式案例​ 假设有一个服装工厂，目前里面50个男士样式，50个女士样式，他们都需要模特穿上拍宣传片，正常情况下就需要分别50个模特来拍照，程序实现逻辑为 123456789101112131415var Model = function (sex, underwear) &#123; this.sex = sex; this.underwear = underwear;&#125;;Model.prototype.takePhoto = function () &#123; console.log(`$&#123;this.sex&#125;:$&#123;this.underwear&#125;`);&#125;;for (let i = 0; i &lt; 50; i++) &#123; var maleModel = new Model(&quot;male&quot;, `underwear$&#123;i&#125;`); maleModel.takePhoto();&#125;for (let i = 0; i &lt; 50; i++) &#123; var femaleModel = new Model(&quot;female&quot;, `underwear$&#123;i&#125;`); femaleModel.takePhoto();&#125; ​ 现在分别50种内衣，一共有100个对象，后面如果越来越多，10000个，可能就会导致程序崩溃。其实我们仔细想想就会发现，我们不需要一套内衣都搭一个模特，只需要一个男模特，一个女模特就够了，我们根据这样的思路再次改写代码 123456789101112131415var Model = function (sex) &#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function (underwear) &#123; console.log(`$&#123;this.sex&#125;:$&#123;underwear&#125;`);&#125;;var maleModel = new Model(&quot;male&quot;);var femaleModel = new Model(&quot;female&quot;);for (let i = 0; i &lt; 50; i++) &#123; maleModel.takePhoto(`underwear$&#123;i&#125;`);&#125;for (let i = 0; i &lt; 50; i++) &#123; femaleModel.takePhoto(`underwear$&#123;i&#125;`);&#125; ​ 改造之后，我们只需要两个对象就实现了相同的功能，并且开销是固定的2个，就算10000间衣服也不会出现问题 外部状态与内部状态 享元模式的目标是尽量减少共享对象的数量，是优先使用时间换取空间的优化模式 上传文件的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var id = 0;window.startUpload = function (uploadType, files) &#123; for (let i = 0; i &lt; files.length; i++) &#123; let file = files[i]; var uploadObj = new Upload(uploadType, file.fileName, file.fileSize); // 实例化传入变量 uploadObj.init(id++); // init中创建dom &#125;&#125;;var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null;&#125;;Upload.prototype.init = function (id) &#123; var that = this; this.id = id; this.dom = document.createElement(&quot;div&quot;); this.dom.id = id; this.dom.innerHTML = `&lt;span&gt;文件名称：$&#123;this.fileName&#125; 文件大小：$&#123;this.fileSize&#125; 上传方式:$&#123;this.uploadType&#125;&lt;/span&gt;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;`; this.dom.querySelector(&quot;.delFile&quot;).onclick = function () &#123; that.delFile(); &#125;; document.body.appendChild(this.dom);&#125;;Upload.prototype.delFile = function () &#123; if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm(&quot;确定删除文件吗？&quot; + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;;startUpload(&quot;plugin&quot;, [ &#123; fileName: &quot;1.txt&quot;, fileSize: 1000, &#125;, &#123; fileName: &quot;2.txt&quot;, fileSize: 2000, &#125;,]);startUpload(&quot;flash&quot;, [ &#123; fileName: &quot;5.txt&quot;, fileSize: 6000, &#125;, &#123; fileName: &quot;6.txt&quot;, fileSize: 7000, &#125;,]); ​ 在以上例子中，我们上传多少文件就需要创建多少个对象，接下来我们用享元模式重构以上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; &#125;; Upload.prototype.delFile = function (id) &#123; let carry = uploadManager.setExternalState(id); return carry.dom.parentNode.removeChild(carry.dom); &#125;; var UploadFactoy = (function () &#123; var createFlyWeghtObjs = &#123;&#125;; return &#123; create: function (uploadType) &#123; if (createFlyWeghtObjs[uploadType]) &#123; return createFlyWeghtObjs[uploadType]; &#125; createFlyWeghtObjs[uploadType] = new Upload(uploadType); return createFlyWeghtObjs[uploadType]; &#125;, &#125;; &#125;)(); var uploadManager = (function () &#123; var uploadDataBase = &#123;&#125;; return &#123; add: function (id, uploadType, fileName, fileSize) &#123; var flyWeight = UploadFactoy.create(uploadType); var dom = document.createElement(&quot;div&quot;); dom.innerHTML = `&lt;span&gt;文件名称：$&#123;fileName&#125; 文件大小：$&#123;fileSize&#125; 上传方式:$&#123;uploadType&#125;&lt;/span&gt;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;`; dom.querySelector(&quot;.delFile&quot;).onclick = function () &#123; flyWeight.delFile(id); &#125;; document.body.appendChild(dom); uploadDataBase[id] = &#123; fileName, fileSize, dom, &#125;; console.log(uploadDataBase); return flyWeight; &#125;, setExternalState: function (id) &#123; return uploadDataBase[id]; &#125;, &#125;; &#125;)(); var id = 0; window.startUpload = function (uploadType, files) &#123; for (let i = 0; i &lt; files.length; i++) &#123; let file = files[i]; uploadManager.add(++id, uploadType, file.fileName, file.fileSize); &#125; &#125;; startUpload(&quot;plugin&quot;, [ &#123; fileName: &quot;1.txt&quot;, fileSize: 1000, &#125;, &#123; fileName: &quot;2.txt&quot;, fileSize: 2000, &#125;, ]); startUpload(&quot;flash&quot;, [ &#123; fileName: &quot;5.txt&quot;, fileSize: 6000, &#125;, &#123; fileName: &quot;6.txt&quot;, fileSize: 7000, &#125;, ]); ​ 通过享元模式创建后，实例化的对象因为工厂模式的存在只创建了2个。 享元模式的适用性 一个程序中使用了大量相似的对象，并且这些对象大多数状态是可以成为外部状态的 可以使用共享对象取代大量对象，将外部状态剥离出去 对象池​ 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不会再去new，还是从对象池中进行获取，如果对象池不存在可用对象，则创建一个新对象，当获取处的对象完成了他的职责之后，再次进入池子等待下次获取 地图标点demo​ 进入地图软件后，首先搜索A地点，存在2个坐标点，通过工厂函数便创建了2个，而后搜索了B地点，存在6个坐标，便会利用之前空闲的2个，再新增加4个坐标点 ​ 对象池的模式与享元模式类，知识没有状态分离的过程。 12345678910111213141516171819var objectPoolFactory = function (createObjFun) &#123; var objectPool = []; return &#123; create: function () &#123; // 创建对象 if (objectPool.length === 0) &#123; // 如果对象池中没有对象，就创建一个新的对象 return createObjFun.apply(this, arguments); &#125; else &#123; // 如果对象池中有对象，就从对象池中取出一个对象 return objectPool.shift(); &#125; &#125;, recover: function (obj) &#123; // 回收对象 objectPool.push(obj); &#125;, &#125;;&#125;; 总结​ 享元模式主要为解决性能问题，在一个存在大量相似对象的系统中，享元模式可以很好的解决大量对象带来的性能问题。 职责链模式​ 使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 ​ 职责链优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系 使用指责链完成订单生成demo 支付过定金的不受库存限制，直接可下单 下了定金的订单但是却没有支付的正常购买 未支付定金的正常购买 12345678910111213141516171819202122var order500 = function (orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log(&quot;500定金预付，得到100元优惠券&quot;); &#125; else &#123; order200(orderType, pay, stock); &#125;&#125;;var order200 = function (orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log(&quot;200定金预付，得到50元优惠券&quot;); &#125; else &#123; order(orderType, pay, stock); &#125;&#125;;var orderNormal = function (orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log(&quot;普通购买，无优惠券&quot;); &#125; else &#123; console.log(&quot;手机库存不足&quot;); &#125;&#125;;order500(1, true, 10); ​ 我们按照职责链进行实现，但是链条的耦合问题非常严重，加入后面出现其他折扣，便需要改写原本已经写好的代码，这违反看开放封闭原则。我们继续优化 123456789101112131415161718192021222324252627282930313233343536373839404142var order500 = function (orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log(&quot;500定金预付，得到100元优惠券&quot;); &#125; else &#123; return &quot;nextSuccessor&quot;; &#125;&#125;;var order200 = function (orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log(&quot;200定金预付，得到50元优惠券&quot;); &#125; else &#123; return &quot;nextSuccessor&quot;; &#125;&#125;;var orderNormal = function (orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log(&quot;普通购买，无优惠券&quot;); &#125; else &#123; console.log(&quot;手机库存不足&quot;); &#125;&#125;;var Chain = function (fn) &#123; this.fn = fn; this.successor = null;&#125;;Chain.prototype.setNextSuccessor = function (successor) &#123; this.successor = successor;&#125;;Chain.prototype.passRequest = function (orderType, pay, stock) &#123; var ret = this.fn(orderType, pay, stock); if (ret === &quot;nextSuccessor&quot;) &#123; this.successor.passRequest(orderType, pay, stock); &#125; return ret;&#125;;var chianOrder500 = new Chain(order500);var chianOrder200 = new Chain(order200);var chianOrderNormal = new Chain(orderNormal);chianOrder500.setNextSuccessor(chianOrder200);chianOrder200.setNextSuccessor(chianOrderNormal);chianOrder500.passRequest(1, true, 10); ​ 现在我们将职责链的耦合关系维护交给Chain进行维护如果后期还会增加其他预约类型，只需要编写相关逻辑代码与部分职责链代码即可 异步职责链1234567891011121314151617181920Chain.prototype.next = function () &#123; return this.successor.passRequest(arguments);&#125;;var fn1 = new Chain(function () &#123; console.log(1); return &quot;nextSuccessor&quot;;&#125;);var fn2 = new Chain(function () &#123; console.log(2); var self = this; setTimeout(() =&gt; &#123; self.next(); &#125;, 1000);&#125;);var fn3 = new Chain(function () &#123; console.log(3);&#125;);fn1.setNextSuccessor(fn2);fn2.setNextSuccessor(fn3);fn1.passRequest(); ​ 我们增加一个next方法来执行下一个职责链的回调函数，进而实现异步效果 职责链模式的优点 解耦了请求发送者与若干接收者之间的复杂关系，并不需要链中谁可以处理，只需要传递给第一个人即可 职责链上的各个节点互不影响 职责链可以灵活拆分重组 职责链可以手动指定起点，而不是必须从第一个开始传递 职责链模式的缺点 不能保证请求一定会被职责链处理到，可能不存在任何结果，需要额外加一个保底判断。 职责链模式会让程序多很多对象，并且可能大部分阶段不会起到作用，它的作用仅仅是让请求传递下去，过长的职责链会造成了一部分的性能损耗，但是这个问题ifelse也存在。 使用AOP思路实现职责链 AOP为面向切面编程，例如装饰器，可以做到在代码执行的前后插入代码切片，并且并修改源代码 123456789101112131415161718192021222324252627282930Function.prototype.after = function (fn) &#123; var self = this; return function () &#123; var ret = self.apply(this, arguments); // 调用者结果 if (ret === &quot;nextSuccessor&quot;) &#123; let res = fn.apply(this, arguments); // 执行下一个函数 console.log(&quot;函数结果&quot;, res); if (res != &quot;nextSuccessor&quot;) &#123; return res; &#125; &#125; return ret; &#125;;&#125;;var getActiveUploadObj = function () &#123; return &quot;nextSuccessor&quot;; // 创建Ie上传组件(假设一定失败)&#125;;var getFlashObj = function () &#123; return &quot;nextSuccessor&quot;; // 创建flash对象(假设一定失败)&#125;;var getFormObj = function () &#123; return &quot;hahahah&quot;; // 创建表单对象(假设一定成功)&#125;;var getUploadObj = getActiveUploadObj.after(getFlashObj).after(getFormObj);console.log(&quot;getUploadObj&quot;, getUploadObj()); 小结个人感觉指责链有链表的感觉，在原型链，事件冒泡上都有所体现，在日常开发中倒不算很常见，类似订单demo可能更加偏向于使用ifelse + 封装来组织代码，同样可以实现职责链的效果。 中介者模式中介者模式的作用就是接触对象与对象之间的紧耦合关系。增加一个中介者后，所有的相关对象都通过中介者对象进行通信；而不是相互引用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/categories/JavaScript/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://bluedancers.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"随选朗读 - 给长辈更好的手机使用体验","slug":"随想/随选朗读 - 赋予长辈手机使用能力","date":"2022-06-11T16:00:00.000Z","updated":"2022-12-11T13:51:24.097Z","comments":true,"path":"2022/06/12/随想/随选朗读 - 赋予长辈手机使用能力/","link":"","permalink":"https://bluedancers.github.io/2022/06/12/%E9%9A%8F%E6%83%B3/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB%20-%20%E8%B5%8B%E4%BA%88%E9%95%BF%E8%BE%88%E6%89%8B%E6%9C%BA%E4%BD%BF%E7%94%A8%E8%83%BD%E5%8A%9B/","excerpt":"","text":"时代背景​ 在历史上的1952年5月24日是一个特殊的日子，在那一天正式开始大规模扫盲运动。新中国成立之初，全国5.5亿人口，80%都是文盲，农村的文盲率达到了95%以上，让我们把时间拉回2022年的今天，今天我想描述的是90后的父母一代，大约是1960-1975诞生于华夏文明的人，根据官方调查90后父母一代的文盲率大约为40%。 ​ 90后父母一代是疲惫的，他们大多从农村出来，为城市建设添砖加瓦，拿着微薄的薪水，做着繁重的工作，赶上了房价翻了一番又一番，他们的压力从来不会出现在主流媒体中，他们也大多数已经年过半百，身体机能开始衰退，视力开始下降，在互联网时代与90、00后赚个满怀的时候，他们只能踉踉跄跄的跟紧时代的步伐，他们是社会上看不见的大多数。而随着岁月的流失，亦或者时代的影响，存在很大一部分人因为视力问题，或者文盲，失去了使用手机的能力。 随选朗读 ​ 大部分年轻人可能并不知道这个名词，因为我们正值身体的最佳状态，本身便不存在工具来创造无障碍的场景，我们来了解一下“随选难度”的官方定义吧。 ​ “随选难度”可帮助障碍用户在无法使用视觉获取信息、阅读困难等情况下通过读取屏幕的无障碍接口来获取用户想要阅读的界面的文本信息，然后再调用语音库将之朗读出来。简而言之，用户在开启该功能后，可将他想获取的文本信息转化为音频被接收。 目标人群 低视力、老花眼人群 低文化水平、文盲人群 场景性障碍人群 ​ 随着岁数的增加，亦或者长期疲劳用眼，老花眼必然会出现在人类的生命轨迹之中，面对这样的情况，一般需要配一个老花镜，在阅读较小较密集文字的时候带上眼镜才能看清文字，正常生活并不需要长时间戴眼镜，而有了随选朗读功能后，查看手机咨询只需要滑动文字区域，即可让手机完成其识别与阅读，规避用眼场景，这将大幅度改善中老年人的手机使用体验。 ​ 90后的父母一代，文盲比例已经相对较少，但是在华夏大地庞大的人口基数下，也算是5%也是非常大的人口体量，因为不认识字，他们使用手机困难重重，但是又不得不使用智能手机，例如在进出都需要扫码的疫情时代，遍地移动支付的互联网时代，如果没有家人或者朋友的反复教学，他们可能永远都无法正常使用智能手机，甚至家人微信聊天都只能发送语音，而随选朗读则给予了文盲人群识别文字的能力，遇到不认识的字，滑动一下就会读出来，这给予了文盲用户独立使用智能手机的能力，作为晚辈也减小了压力。 ​ 最后是场景性障碍人群，例如开车中，做饭中暂时无法看长时间看屏幕的场景，不过从现实来看此类场景需求不大，因为长文可以等会看，一小段文本则很快就看完了，此处便不再赘述。 如何使用小米手机设置 - 更多设置 - 无障碍 - 视觉 - 随选朗读 开启后点击小喇叭就会出现一个红色按钮，即可选中你想被阅读的区域，松手即可开始朗读，朗读完毕后自动关闭，如果想下次使用，可以再次点击小喇叭，不同手机入口显示方式不同，有些是显示小人形状。 华为手机设置 - 辅助功能 - 无障碍 - 随选朗读 - 开启 iphone设置 - 辅助功能 - 朗读内容 - 朗读屏幕 - 语音控制器 - 打开显示控制器 其他手机​ 身边手机有限，就算一个品牌的手机不同版本设置路径也存在一定区别，不过可以放心无障碍功能所有手机都有，因为这是android，ios系统原生功能，一般都在其他设置&#x2F;无障碍菜单中。 没有随选朗读​ 我把周围同事的手机大致都研究了一遍，发现如果是20年之前的手机，大部分是没有“随选朗读”功能的，无障碍套件由安卓系统提供，低版本系统存在没有随选朗读的现象，手机没有自带没有关系，可以第三方下载，我在百度网盘放了一个，android无障碍套件v12.1，有需要的朋友请自取。 结语​ 看到这里，不知道你是否想到了长辈们，为了看手机上的微信消息而着急寻找眼镜的匆忙场景，是否想到了长辈们因为看不懂文字而无法正常使用手机的窘境，而通过简单设置，就可以赋予有困难的长辈们更好使用智能手机的能力，机器无情，人间有情，沉舟侧畔千帆过，病树前头万木春，记得多回头看看驻留在原地的那群可爱的人。","categories":[{"name":"玩机技巧","slug":"玩机技巧","permalink":"https://bluedancers.github.io/categories/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"无障碍","slug":"无障碍","permalink":"https://bluedancers.github.io/tags/%E6%97%A0%E9%9A%9C%E7%A2%8D/"},{"name":"随选朗读","slug":"随选朗读","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB/"}]},{"title":"三辆自行车","slug":"随想/三辆自行车","date":"2022-06-09T16:00:00.000Z","updated":"2022-12-12T07:34:54.509Z","comments":true,"path":"2022/06/10/随想/三辆自行车/","link":"","permalink":"https://bluedancers.github.io/2022/06/10/%E9%9A%8F%E6%83%B3/%E4%B8%89%E8%BE%86%E8%87%AA%E8%A1%8C%E8%BD%A6/","excerpt":"","text":"​ 初中的时候，我特别想要一个自行车，大概觉得骑车很酷吧，或者是幼年的虚荣心作祟，那时候家里条件还很差，三口之家租住在一个没有空调的老旧矮楼的二楼第一间，大约12平方的四方四正的小屋，大家可以想象一下电视剧蜗居的样子吧，父母自然不同意卖一辆自行车，上学的路程只有2公里，这点距离还要骑自行车，在爸妈眼里是不可理喻的，可终究是拗不过我，在那个夏天的夜晚，爸带我到一个破破烂烂的修车铺，那是一辆蓝色有点破旧的小轮自行车，依稀记得车头是一个T形的，黑漆上零星的白点，刹车线已经泛黄仿佛蒙上了茶油的滤镜，这似乎在告诉我它的年纪，我爸对此很满意，大约150吧，带着我带着它一起回家了，我相信爸妈是开心的，因为终于不用听这小子天天嚷嚷了，我也就是这么迷迷糊糊的有了一台自行车。 ​ 好景不长，这辆蓝色小轮车骑起来轴承里面会发出宛如鞭炮一样哒哒哒的，这让一个刚刚满12岁的小孩内心倍感自卑，因为我害怕因为这个声音招来马路上嘲笑的目光，以至于放学路上同学都骑走了，我才会开始骑车，我又开始不断嚷嚷自行车的问题，我妈耳根子软，心里虽然气愤儿子不懂事，但是依旧妥协了，没多久换了一辆新的凤凰牌自行车，蓝色小车被我爸骑电瓶车带回了老家，给了在村里的表姐，因为离镇上很远，她非常需要一辆车，而我终于如愿以偿的得到了一辆崭新的真正的自行车，那是一辆的银灰色自行车，车架在阳光下发射着宛如银河的色彩，黑色的车头一尘不染的深邃，仿佛在告诉全世界，他的诞生，也终于没有了哒哒哒的骑行背景音乐；而这属于我的第一辆新自行车的命运却是如此的凄惨，在我还没来得及和他好好人认识的时候，便戛然而止，是的，没多久他就被偷了；记得那天早上我骑着它到补习班，补习班对面是人流量很大的商业街，我用买车赠送的那把蓝色细锁火速锁好车便跑进补习班，等到中午补习结束回到停车点的时候，我傻眼了，同学一个个离开，而我在那片不大的地方反复寻找，恨不得把地下的砖都扒开，我可能找了半小时，最后我浑浑噩噩的走回家，那段路挺远，大概4个路口，回到家已经12点多了，我妈没有打我，但是我害怕极了，后续发生了什么也记不清了，也许是因为选择性忘记，最后，补习班和老师还赔了200块。 ​ 车丢了，但是习惯已经养成了，自然还是要买自行车，人总是贪婪的，得到了谷子就想得到糖，得到了糖就想得到肉，十三岁的我自然也不例外，这次我斗胆提议要一辆变速山地自行车，每次放学我都会偷偷观察同桌的捷安特，那卡卡的变速声音不断挠动我心中的痒，夜里做梦都想拥有一辆这样的自行车，去享受大家羡慕的目光；变速自行车比较贵，是普通自行车的2-3倍，爸妈自然非常不愿意，毕竟赚钱真的很不容易，那时候依旧在12平小屋中，夏天的下午会被太阳从侧面暴晒，晚上睡觉都能感受到从墙体深处散发的热浪，实在无法忍受，才加装了空调；耐不住我的软磨硬泡，耐不住这是他的儿子，最后还是给我买了，就在我丢掉凤凰牌自行车的商业街对面，我获得了我人生中第三辆自行车 ​ 那是一辆黑红相见的变速山地自行车，品牌名为“巨凤”，不是名牌所以也比较便宜，不过我依旧很喜欢，他看起来是那么具有运动感，如此的个性鲜明，花费了500多，这对我们家庭来说已经是一笔巨款，我带着它回家了，我至今都记得，在回家的路上有一段上坡，我将变速调节到比较省力的轮档，我向往常一样踩着踏板，但是这却是一种未曾有过的体验，如此的轻巧，如此安稳，第二天早上5点多我便醒来，迫不及待的我想骑上的我新车去学校，那时已经是晚秋，我踏着淡淡曙光，仿佛骑行在云端之上，到学校的时候，天都未亮，对于那一刻的我来说，我的虚荣心大概已经得到了满足。在后来的日子里，我经常骑着它去偏远的谭冲湖，去几公里外的古梗公园，去杂草丛生的老肥西火车站，没有理由，随便定一个目标的骑行，在我那平淡如水的初中时光，我和“巨凤”游览了肥西大大小小很多角落。在天气还不算燥热的初夏，在平坦又人际罕见的单排公路，路旁的山丘跑向我的身后，柏油路前方看不见尽头，河水流淌声不断微弱，我不断加速，尽情的享受与风的交流。 ​ 在我初中阶段中，我对自行车是如此的执着，我认为我热爱自行车，但是我错了；在买“巨凤”的第二年，我初三了，中考勉勉强强的考上了高中，但是分数线只够去比较远的地方，我与我的“巨凤”便失联了，我再次见到的他的时候，它已经落满了灰尘，斜靠在墙角，嶙峋的轮胎上满是龟裂，前轮已经完全漏气，夕阳下，他就像一匹消瘦的老马，我路过很多次都没注意到他，直到在大学入学前夕，我对家恋恋不舍的时候，我终于注意到了它，我已经不记得当时面对它的表情，是我抛弃了它，就像随着岁月不断被丢弃的东西们一样。 ​ 前往古梗公园的路依旧平整，谭冲湖的河水依旧川流不息，到现在也依旧会时常回想起与它们们在路上的时光，只是再也找不回记忆中的微风拂面的感觉。 ​ ​","categories":[{"name":"随想集","slug":"随想集","permalink":"https://bluedancers.github.io/categories/%E9%9A%8F%E6%83%B3%E9%9B%86/"}],"tags":[{"name":"童年","slug":"童年","permalink":"https://bluedancers.github.io/tags/%E7%AB%A5%E5%B9%B4/"},{"name":"随想","slug":"随想","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0","slug":"关于开源/【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0","date":"2022-05-24T16:00:00.000Z","updated":"2022-12-11T13:51:24.084Z","comments":true,"path":"2022/05/25/关于开源/【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0/","link":"","permalink":"https://bluedancers.github.io/2022/05/25/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%BA%90/%E3%80%905000%E5%AD%97%E9%95%BF%E6%96%87%E3%80%91%EF%BC%88%E5%BC%80%E6%BA%90%EF%BC%89%20%E4%BD%8E%E4%BB%A3%E7%A0%81H5%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%20-%20%E6%98%93%E5%8A%A8v3.0/","excerpt":"","text":"前言​ 作者在2020年的时候开源了易动第一个版本（开源）从0打造H5可视化搭建系统 - 易动（vue+ts+egg），这两年在公司针对装修技术方案做了大量的实践，使用过draggable方案 iframe装修方案 绝对定位方案，对其在技术，产品层面都存在更深入的理解，今天给大家带来新一代企业级H5装修方案易动v3.0 开源地址 拖拽生成h5页面，支持页面全局设置，组件，自定义URL，插件市场，公共npm组件库 基于最新vue技术栈， 易动v3.0 已上线，欢迎体验~~ YD 管理端 YD_Client 客户端 开源不易，给个Star吧~ 技术栈管理端：vue3 + vite + pinia + vueuse + TypeScript 客户端：vue3 + vite + TypeScript 集成组件库（ydh5-ui）：基于Vue3 + TypeScript进行开发 服务端：serverLess 项目架构​ 在正文开始之前先为大家介绍一下项目架构，我们从底层到上层依次介绍 ​ 易动3使用腾讯云serverless作为后端服务，serverless在易动系统中提供组件schema的数据存储服务，为什么使用serverless下文在说明。 ​ 易动3将客户端、管理端的公共装修组件进行了统一封装发布成为npm包，解决了以往存在的一个组件需要写、改两遍代码的核心问题。 ​ 易动管理端是项目的最核心系统，除了核心的保存，修改之外，以及一系列提供装修效率的功能，例如组件市场、辅助线、复制、粘贴、撤销、放撤销，这个低代码装修系统的上限于下限皆由此项目决定。 ​ 易动客户端功能比较单纯，主要是根据约定好的js Schema结合集成组件库进行数据渲染于逻辑触发。 使用方向​ 这几年关于低代码领域开始不断有大厂入场，这也变相的说明了该领域巨大的提效需求，愿望是美好的，但是现实是骨感的，低代码无法做到全盘通吃，只能聚焦某个领域，易动v3.0也是这样的，他无法处理存在大量逻辑的页面，所以易动v3.0选择专注于营销单页，在营销单页领域他可以发挥自己的优势。 ​ 除了基础的按钮、图片组件外，业务组件可以做很多场景化组件，例如banner，商品专区，甚至从接口获取数据的组件都可以通过js Schema的约定进行实现 ​ 而营销单页的需求络绎不绝，这样的工作就像在工厂“打螺丝”，大部分前端开发者并不愿意做这件事情，并且工作流程比较繁琐，可能因为业务原因频繁改动，大致工作流程如下 ​ ​ 一个再简单的单页都需要走一样的固定流程，并且一旦某个环节出现了问题就需要回滚好几步，在这儿个过程中开发者也需要跟着回滚，遍出现了频繁改样式，重复机械行为。 ​ 如果有了低代码平台 流程可以变成这样 ​ 这样的架构中权责变的更加清晰，开发者从“螺丝钉”变成了技术解决方案开发者 ​ 而业务的决定权也掌握在专人手中；大家各司其职，技术根据实际需求不断优化技术解决方案，运营使用低代码平台的搭建能力 物料能力也能提高运营的效率。 H5装修常见方案​ 据作者了解，目前市面上所有的低代码平台几乎都是基于Schema进行实现的，这种方案的核心原理比较简单 ​ 基于这样的Schema结构，便衍生出来了多种实现方案，在这里简单描述一下我在实际工作中都使用过方案以及他们的优缺点； 绝对定位方案​ 简介：所有的装修组件都是再后台直接拖拽放置，没有组件群组的概念，可以任意放置你的组件到任何地方。 ​ 优点：灵活 ​ 缺点：无法流式布局，需要维护公共组件库，操作门槛较高，需要通过技术能力填补，例如吸附辅助线。 流式布局方案​ 简介：装修组件遵循流式布局，从上到下从左到右进行排序，就像搭积木一件，这种方案仅限移动端 ​ 优点：操作简单 ​ 缺点：组件不够灵活，因为只能上下移动，想做到非常规布局比较麻烦，需要维护公共组件库 iframe方案​ 简介：将客户端通过iframe内嵌到装修管理端中，再通过postMessage进行项目间通信，客户端识别环境开启装修模式与后台进行实时通信 ​ 优点：不需要维护公共组件库 ，只需要维护客户端代码 ​ 缺点：客户端与管理端代码耦合严重 装修操作部分代码需要写在客户端中 流式布局 + 绝对定位方案​ 简介：为绝对定位组件增加一个流式布局的父级容器，让装修数据具备二级结构， ​ 优点：灵活 具备可生成代码的规范结构 ​ 缺点：操作麻烦，存在一定学习成本 ，需要维护公共组件库，相对其他方案多了一层结构，难度相对更加大 易动3选择的方案​ 在公司生产环境项目中，凭借易动v1.0的经验，我使用了流式布局方案，最初效果还是非常不错的，那时候没想到将公共组件发布到npm，两端项目公用组件的方案，后期组件改动频繁，出现了极大的维护问题，这迫使我寻找其他出路。 ​ 为了解决流式布局中一套组件，两套代码问题，在生产环境项目中实验性的使用管理端 + 客户端耦合的iframe方案，满足了公司的需求只需要维护一套代码，并且可以将Schema抽象出来应用到单页中，实现活动页装修，iframe装修方案在公司也是沿用至今，帮助公司搭建了200+的页面。 ​ 再后来，我准备重启易动项目，开发易动v2.0，我们在易动v2.0中实验性的尝试了流式布局 + 绝对定位方案，在开发之前普遍觉得这是一个天才的主意，同时具备流式布局与绝对定位方案的优点，而且易动v2.0开发技术中还存在类似易企秀的多页的需求，大概经过2个月的代码编写，最终发现还是我们的想法过于理想化，首先操作上就存在比较高的门槛，技术难度也很大，而且因为Schema结构复杂，后期代码难度也是几何级别的提升，最终我们PASS了这个方案。 ​ 在后面一段时间我一直在思考一个问题，也就是低代码的边界性，他应该做什么，他可以做什么，我们如何通过低代码来创造产品价值，在不断的思考中我也逐渐明确了开发方向，不再去想他还能做什么，而是在开发之前就确定一个目标，易动3.0将会在营销领域发挥它的作用，所有的功能都围绕这个核心目标 ​ 基于这样的目标，易动v3.0再出发，依旧采用绝对定位方案，因为绝对定位方案符合需求，难度最小，具备拓展性，后期维护性更强。 ​ 方案确定好了，接下来将会介绍一些核心的实现思路。 核心实现思路Schema的编写​ schema的结构将会决定你的装修系统的上限，一个良好的设计结构将会为后面的开发降低很大的难度，我们需要定义好页面的结构与组件的结构。 ​ 而在代码中增加组件，或者增加组件类的数据，例如在轮播图组件中增加一项轮播图，都需要通过函数return的方式进行对象创建，以免出现多个组件使用的数据为一个数据源。 在项目中增加一个组件，只需要将组件Schema push到模板变量中即可 代码位置：https://github.com/vkcyan/YD/blob/main/src/modules/component/index.ts 123456789101112131415161718192021222324252627282930/** * 组件信息列表 * @param name 组件名称 * @param tempLen 本次层级 * @returns */function baseComList(name: string, tempLen) &#123; const list: baseComponent[] = [ &#123; id: guid(), name: &#x27;y-img&#x27;, showTitle: `图片$&#123;tempLen&#125;`, // 显示组件名称 show: true, cssModule: &#123; ...absolute(tempLen), ...borderData(), ...compSize(100, 60), &#x27;background-color&#x27;: &#x27;#ffffff00&#x27;, &#125;, // 样式 staticData: &#123; imglUrl:&#x27;xxxx.png&#x27;, ...linkData(), &#125;, // 行为 function: &#123;&#125;, // 方法 animation: [], // 动画 &#125;, // ..... ] return list.find((e) =&gt; e.name == name)&#125; ​ 例如增加一个图片组件，我们只需要将参数’y-img’，传入函数，即可得到一个图片组件的Schema，这样我们便具备搭建页面Schema树的能力。 实现拖拽 实现良好的拖拽是一件非常有难度的事情，它不仅仅是简单元素的移动，而是通过技术的手段降低装修的操作门槛。 元素位移​ 在易动v3.0中，弃用了以往采用的监听鼠标单次移动距离实现方案，因为这会导致快速移动后出现坐标不准确的情况，改成获取相对父级绝对坐标。 ​ 全局鼠标监听使用vueuse的useMouseInElementAPI，帮助我们获取每次的相对位置，鼠标按下同时保存元素下标，再通过watchEffect全局监听useMouseInElement的变化，拿着鼠标按下阶段保存的下标去寻找需要位移的元素，不断更新其Schema中的cssModule字段中的top与left值，进而实现元素移动。 元素缩放 ​ 我们为元素增加 上 下 左 右 左上 左下 右上 右下，八个操作点，是元素支持任意缩放功能，再点击任意缩放点的时候，我们都会保存一个标识，来确定当前点击的点是什么，然后在 全局监听鼠标移动的watchEffect中执行对应缩放逻辑，来不断更新选中的元素的 top left width height的组合值，进而实现元素缩放功能。 元素多选 ​ 支持元素位移与缩放其实已经完成了装修的最核心功能，已经可以完成简单的页面搭建了，但是仅凭位移与缩放操作起来不方便，这时候就需要开发多选功能，我们把之前保存的单个选中下标改成一个选中数组。 ​ 这里说明一下为什么保存数组下标，而不是组件的唯一id，这是一个时间复杂度的问题，如果保存组件唯一id，更新组件数据就需要通过循环再找到下标，进而通过下标更新数据，这时候时间复杂度为On，而直接保存数组下标，在通过下标直接更新数据，时间复杂度为O1。 ​ 回到正题，我们开发一个选中框组件，在拖动选中框的时候判断是否包含了组件，不断更新当前选中框多选的元素，进而实现多选删除，多选拖动，等等多选功能。 ​ 目前多选框计算逻辑还比较单一，仅支持从左上向右下拖动，后续有时间会继续完善。 辅助线 ​ 辅助线是低代码系统必备功能，这将会极大的降低使用门槛，实现辅助线相对来说也是非常复杂的，假如页面有4个组件，我们点击了任意一个的时候，就需要去保存其他3个组件的 top top + height/2 top + height left left + width/2 left+width，并且将其数组保存成为字典结构，也就是ES6的Set，相对数组实现可以将时间复杂度从On2降低到On，有效避免了卡顿的情况，在被选中元素不断拖动的时候，我们会不断对比当前变化坐标与之前保存的3个组件的坐标，一旦对比到了一致，就会将其值push到存储变量，并在页面上显示，表明已经对齐。 辅助线吸附​ 先声明一下，辅助线吸附作者的实现还存在瑕疵，目前还在寻找更好的方案，也希望有大佬可以指点一二，目前吸附还存在一点操作上的不流畅情况，所以这部分我便不多赘述。找到最佳解决方案再更新。 时间旅行 pinia的subscribes存在差异，并且events在生产环境无法获取，导致现在线上无法相关使用 ​ 所谓时间旅行就是可以进行撤销 反撤销操作操作，，具体原理感兴趣可以看看vuex版本的实现，本质原理都是一样的，基于vuex实现 撤销 与 反撤销 的plugins，采用数组 + 单指针进行实现。 more​ 移动端如何读取schema，使其还原装修效果；如何实现二次编辑组件的保存到创建市场；还有很多拖拽细节的实现；章节有限，这里不再一一赘述，有兴趣可以加入微信群在一起聊聊。 基础组件or业务组件 基础组件：按钮 图片 输入框 文字 模块（html自带的标签元素） 业务组件：富文本 轮播图 若干营销组件（由开发人员定制化产出的标签元素） ​ 在早期开发低代码，无代码产品的时候，我将绝对定位方案与基础组件绑定，业务组件与流式布局绑定，随着对低代码的深入理解，我在这里必须纠正之前的偏见，正确的观点应该是：基础组件 + 绝对定位方案更加和谐、业务组件 + 流式布局方案更加和谐。 ​ 随着将装修组件发布成为npm包，他们的隔阂已经几乎不存在，全部视为公共组件，公共npm组件包中将会抹平平台差异，任何可以描绘的组件可以看作为静态结构组件都可以被低&#x2F;无代码平台使用。 关于低代码​ 这几年关于低代码讨论也非常多，最近一直看到大厂开源的低代码工具，例如腾讯的tmagic-editor，阿里的LowCodeEngine，还有5月28号掘金直播低代码的探索与实践，其背后是前沿开发者们对效率的思考，是从局部效率转变到全局效率思想的转变。 ​ 在技术条件有限的情况下，低代码产品的广度与深度只能选择其一，我们自然希望低代码可以做的事情越多越好，生成页面，生成代码，直接编写事件，支持单页，支持多页，支持无限嵌套dom，达到降低门槛，提效降成本的作用，甚至解放劳动力，创造更大的社会价值，但是如果没有足够的技术基础，做的功能越多，就死的越惨。所以如果你也发现存在类似需求，切勿在产品设计期间不断加功能，要专注细分领域，只有这样，低代码项目才有发光发热的机会，有了经验之后再决定做什么也不迟。 ​ 从发现需求到明确定位有很长的路要走，低代码产品从可用到好用还有很长的路要走。 其他问题为什么易动v3.0选择绝对定位方案​ 易动v3.0考虑到营销页面的多样化，他并不是理想化的流式布局，而是多样化的，甚至你意想不到的UI实现方式，这也是易动v3.0使用绝对定位方案实现的一个重要原因，后续作者也会不断加强可用性，进一步降低搭建门槛。贯彻技术为业务服务，而不是业务为技术服务的理念。 为什么使用serverless​ 做出这个决定处于两点考虑 大部分公司不会使用node作为服务端框架，接入会重写服务端。 本人是前端工程师，node 以及服务端周边服务不算精通，低代码的项目核心也不在服务端，serverless满足了作者的需求，后续我会提供表结构，以及关联关系。 因为腾讯云serverless已经开始收费了，后续可能会换成fastify进行服务端编写，主要看作者是否有时间，也非常欢迎有志之士为开源做出贡献。 关于PC端​ 易动3的实现方案是绝对定位方案，这让实现pc端装修的可能性，但是个人感觉这部分需求比较小，B端的客户都是ToC，所以并没有做相关功能开发，但是理论上可以实现的。 后续还会做什么 目前易动v3.0 并不是完整状态，因为作者比较忙碌，很多功能依旧在开发中，大家也可以提出需求，如果存在价值，作者会加入后面的工作计划。 数据分析能力：页面的曝光情况是客户非常关心的指标，这也是易动v3.0非常关注的功能 模板市场功能：物料市场也是低代码平台非常重要的功能，配合组件市场，实现团队资源最大化利用，降低搭建门槛 丰富业务组件：根据客户需求开发其满足业务场景的组件，达到一次开发，多次使用的效果 增强装修能力：组件旋转，多选组件辅助对齐，搭建页面快捷操作，进一步降低大家门槛 最后​ 这个开源项目将会一直做下去，未来可能也会尝试做收费版本，毕竟为爱发电还是过于理想化了，如果你也是同道中人或者有这样的潜在需求，可以加入微信群，一起交流学习，共同进步~ 讨论群","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"},{"name":"低代码","slug":"低代码","permalink":"https://bluedancers.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"h5装修","slug":"h5装修","permalink":"https://bluedancers.github.io/tags/h5%E8%A3%85%E4%BF%AE/"},{"name":"Vue3","slug":"Vue3","permalink":"https://bluedancers.github.io/tags/Vue3/"}]},{"title":"关于免登录的一些实践与思考","slug":"解决方案/针对免登录的一些实践与思考","date":"2022-05-23T16:00:00.000Z","updated":"2022-12-11T13:51:24.095Z","comments":true,"path":"2022/05/24/解决方案/针对免登录的一些实践与思考/","link":"","permalink":"https://bluedancers.github.io/2022/05/24/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E9%92%88%E5%AF%B9%E5%85%8D%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"前言​ 听用户说，但是不要照着做。 ​ 这句话来自苏杰的《人人都是经理》这本书；在产品维度我们遵循这样的原则，其实在程序维度，也需要遵循这样的原则，如果没有意识到这一点我们也许会深陷泥潭。 案例：免登录到商品详情页面聊一个我们之前遇到的问题，场景是这样的 用户在第三方平台登录，用户登录后点击商品会免登录到我们商城 跳转过来后，我们商城需要完成免登录操作，服务端同时给用户发放优惠券，在这个过程中必须保证通过免登录进入后同步调用登录 发券 获取商品详情接口顺序。 ​ 场景就是这么简单，似乎并不是太难的问题，于是我们将我方的商品详情URL给对方，对方在URL后面拼接token，web端拿到token之后将token给后台，完成登录 发券 获取详情逻辑，流程图如下 ​ 按照我们上面的思路似乎没啥问题，无非就是用Promise控制代码顺序，但是在逻辑达到一定复杂程度后，这个问题就会变的非常棘手。 问题：非业务逻辑与业务逻辑的耦合​ 本质上来说，从第三方平台免登陆到我们商城中，并不属于购买商品逻辑，那就不应该将其逻辑写在商品详情页中 ​ 况且这必须同步，用户没有完成我们这边的登录逻辑之前，我们不能发起商品详情接口，因为我们的商品详情数据包括用户最新的优惠券信息，如果异步，就会出现用户第一次进入是没有券的情况；这样的规则就导致我们需要对商品详情页面的业务逻辑进行改动。 ​ 在这样的不安中，我们修改了商品详情页面的生命周期逻辑，一旦检测到需要免登录就会先执行登录再执行商品详情的获取。 ​ 后续又多次出现了其他平台免登录到商品详情页面，并且流程都不太一样，最终导致了我们的商品详情页生命周期代码凌乱不堪，异步流程难以维护，甚至会出现逻辑相互冲突的情况。 问题2：封装问题​ 最后我们商城对接的免登录越来越多，慢慢的我们便在逻辑层面进行了封装，但是依旧还是要动具体页面生命周期代码，而有些页面比如首页就存在很多第三方平台登录进来的，在生命周期代码中就出现大量的来源判断用来调用我们封装好的免登录逻辑，并且有些第三方还是具备时效性的，虽然我们在技术层面已经尽力，但是开发起来依旧很别扭，尤其是对于频繁需要维护的模块。 解决方案​ 再后面遇到这样一件事情，存在一个第三方商城免登录到我们的任意页面，听到需求的时候，我内心有点凌乱，因为我们目前免登录逻辑都是一对一的针对单个页面 ​ 最开始我们聊了能否在nginx中进行统一拦截，后面觉得性能很差，也有种走进死胡同的感觉，后台后端同事提出一个方案，这是一个技术上微不足道，但是却非常好的解决这个问题的方案。 ​ 我们将免登录的封装维度从单个逻辑的角度，提升为在对方跳转到我们目标页面中间的一层拦截 举个例子 ​ 原本 www.abc.com/goods/index?token=xxxxx，我们在具体页面中处理 ​ 最新 www.abc.com/autoLogin?sc=xxx&amp;redirectUrl=www.abc.com/goods/index&amp;token=xxxxx 如果redirectUrl存在参数一定要将该参数encodeURIComponent处理以下，以免参数解析异常 这样做有三个优点也有一个缺点 优点一：非业务逻辑与业务逻辑的耦合的问题，将免登录代码与业务代码完美的隔离开了，不论有多少，多个性化的免登录场景，都不会影响被跳转页面的逻辑 优点二：不再需要逻辑封装，直接将与服务端交互的代码写在该页面即可，因为他已经与业务逻辑解耦合了 优点三：可以形成对接规范，降低开发对接门槛，以及出现问题的可能性。 缺点一：对于用户来说需要多跳转一层页面，有可能需要多等待20-100ms。这一点就要看取舍了，我们是单页应用，站内跳转很快，从线上效果来看对用户影响很小，几乎忽略不计。 总结​ 回头看优化后的实现方案，其实技术难度非小，如果把需求说明白了，这是一个大学生都能写好的需求，这样一个毫无技术难度的方案，在项目中却完成让人非常头疼的部分非业务逻辑与业务逻辑的解耦合。 ​ 虽然作为一名开发人员，我们的本质工作就是实现需求，但是实现需求并不代表别人怎么说你就怎么做，而是根据需求加以自己的思考，在非开发角度提供自己宝贵的建议，也许，换一种思路，一个非常复杂的需求就会变得如此简单。 ​ 现在让我们回到文章开头的那句话，听用户说，但是不要照着做，是不是有点感悟了。","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"关于C端","slug":"关于C端","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8EC%E7%AB%AF/"}]},{"title":"上瘾模型如何应用到产品","slug":"NPDP产品经理/上瘾模型如何应用到产品","date":"2022-05-22T16:00:00.000Z","updated":"2022-12-11T13:51:24.077Z","comments":true,"path":"2022/05/23/NPDP产品经理/上瘾模型如何应用到产品/","link":"","permalink":"https://bluedancers.github.io/2022/05/23/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E4%B8%8A%E7%98%BE%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E5%88%B0%E4%BA%A7%E5%93%81/","excerpt":"","text":"前言​ 为什么有些产品有抓住我们的注意力，而其他产品却不能？是什么让我们出于习惯而建立与产品的联系？是否有一种潜在模式能够通过技术将用户紧紧吸引，欲罢不能。 ​ 这是《上瘾》的引言，我相信看到上面这些话的时候，你的脑海中一定出现了让你上瘾的产品，比如抖音，这样现象级的产品是如何被设计出来的呢？《上瘾》通过大量实验案例，社会调研，总结并抽象了用户上瘾的产品设计原则。最后提炼出一个通用模型，掌握这样的通用模型，你就会得到一个产品设计框架。 当你从0到1设计产品的时候，或者分析市面上的产品，你就可以将上瘾模型应用到你的产品。 上瘾模型是什么触发 行动 多变的奖励 投入 触发 内部触发​ 内部触发是用户与产品建立的感情链接，不需要被打广告，不需要被通知，我主动去使用，就好像短视频APP，没有给我钱，也没有被推广，但是我们每天都高频使用，内部触发是给予用户情感的满足，让产品融入到了生活，是用户内心真实情感的触发，获得快乐、认同与安慰，具体类型会在行动中说明 下班后无聊，打开短视频APP 自拍几张照片，发布到社交平台 ​ 这就是发生在我们身边的日常，我们选择某个产品是因为它能够为我们带来快乐或者解决烦恼，这就是为什么说要洞察用户的用户需求，而内部触发就是研究用户需求，而且是最深处的情感需求 ​ 所以常说做产品是发现用户需求，要去思考，我们的产品能够为用户解决什么问题，这自然是需要深入了解用户的痛苦与挣扎，然后设计出给予用户安慰的产品。 外部触发指用户在非主动情况下接收的信息，有清晰的动作指令进行行动召唤 付费型触发：电梯广告 APP中推广 回馈型触发：某某软件因为做的好，被APP Store上了推荐位 人际型触发：小明觉得某个软件特别有意思，推荐给小红 自主型触发：小明毕业了需要找工作，下载了一个BOOS直聘 ​ 一般会采用简单重复或者“经典+创新”的方式来完成外部触发，效果更加好，例如蜜雪冰城 还有很多老歌+新词的电梯广告 行动 ​ 用户完成触发后，就会来到产品中，让用户开始使用产品就是行动，而长时间高频率的行动才能养成用户习惯 用户行为模型公式：行动 &#x3D; 动机 * 能力 *触发 ​ 如果一个用户想完成一个行动，这三者是缺一不可的。例如，周末你打算找你朋友开黑王者荣耀，但是朋友突然有事，你放弃了周末打王者 动机：渴望快乐 能力：有手机 有网络 有时间 触发：和朋友一起玩做王者荣耀 然后因为朋友突然放弃了，缺少触发条件，放弃 亦或者网络太差，缺少能力，放弃 亦或者由于某种突发紧急事件，没心情去体会游戏里面的快乐，缺少动机，放弃 动机能够驱使用户采取行动的核心动机无非就是以下三种 - 追求快乐，逃避痛苦 - 追求希望，逃避恐惧 - 追求认同，逃避排斥 ​ 补充：相对与失去快乐，人们更加害怕痛苦，就像捡到100块钱，你会很快乐，但是你丢失一百块钱，你会非常痛苦，这远比捡到100块情绪更加激烈，这在产品中常常表现为厌恶损失心理 能力能力是行动的门槛，福格教授提出六要素 - 时间：完成这件事情需要的时间 - 金钱：从事这件事情需要的经济投入 - 体力：完成这件事所消耗的体力 - 脑力：完成这件事所消耗的脑力 - 社会偏差：他人对这项活动的接受度 - 非常规性：该活动与常规活动的匹配程度或矛盾程度 ​ 一个行动需要的能力越少，用户就越轻松使用你的产品，所以我们反复强调降低用户使用门槛，从而减少因为能力问题而造成的流失 多变的奖励 ​ 用户通过触发进入产品，并做出了行动，但是如果用户在你的产品中没有得到物质或者精神的奖励，用户自然会离你而去 猎物奖励​ 猎物奖励就是获取自己想要的资源，刷抖音，寻找带来满足的视频，刷知乎，发现自己感兴趣的问题与回答，这就像原始人类追逐猎物一样，抓住他会充满获得感的 社交奖励​ 社交奖励即为被认同，被赞美，被尊重，人类是情感动物，对社交奖励非常上瘾，会陶醉到社交带来的快乐中，这是及其有效的奖励方式，所以社交类产品经久不衰的原因，他的本质是获得一种社会认同 自我奖励​ 自我奖励主要为使用产品时候的成就感，满足感，控制感。比如你喜欢收集手办，没人让你收集，收集了也没钱，但是让自己快乐了，同时找到了志同道合的朋友，我把我的手办发布到社区，被点赞，被评论这就很快乐，还有例如蚂蚁森林浇水，这都会带来内心的满足，从而实现自我价值 多变性​ 灵长动物大都喜欢新奇的东西，一件事情，如果已经经历过很多次，再次经历将会失去兴趣，你的大脑不会获取快乐，因为你已经可以预感到下一步的行动，预感到你将会得到什么，大数据精准推荐、千人千面都是为了满足用户喜欢新奇的心理 ​ 如果某一次刷新知乎，推荐的都是你看过的或者不感兴趣的问答，那你自然不会上瘾，反之，如果你总是给用户带来新奇感，用户必定会进行更多的行动，来获取更多奖励，所以多变性是奖励的核心概念 ​ 最后补充一点，除了让用户经常获得奖励之外，让用户在第一次接触你的东西就有一个好印象也是关键点，例如首次打开小红书，QQ，他的登录背景视频是美好切令人向往的，让你感受到产品倡导的价值，如果恰好这也是你向往的，这个产品毫无疑问会吸引了你的注意力，你将会继续使用他 投入 ​ 想象一个简单的场景，小明经过朋友推荐下载了王者荣耀，玩了1年时间，在游戏中达到了王者段位，期间在王者荣耀中购买了大量付费皮肤，同时认识了游戏好友；这时候出来了另一个竞品，不比王者荣耀逊色 ​ 但是该竞品想吸引小明，难度是极大的，因为小明已经在王者荣耀中投入太多，时间，皮肤，游戏好友，对局资料，绝活英雄，这都会让小明无法脱离。 ​ 投入是上瘾模型闭环的最后一步，当用户通过触发，采取了行动，并获得了奖励，这时候如果能让用户进一步进行投入，那么这个产品在用户心中的地址将会达到顶峰 内容​ 在微信上添加好友，添加群，这都是内容，随着使用的时间越长，你就会越离不开微信，让你换掉微信，那真的比登天还难 数据资料​ 以作者为例子，作为一名前端开发者，我的开源代码都存放在GitHub，随着我工作年限越长，我越舍不得离开GitHub，我的大量资料都在github中，对我而言，他有很高的价值 关注者​ 小红是一位大厂产品经理，通过长期在知乎发表高质量文章获得了20w关注，随着人数的变多，小红将会越来越离不开知乎，微博，小红书 B站社区都是这样，关注者对于当事人来说是不可忽视的隐形价值 信誉​ 小明觉得咸鱼不错，经常在咸鱼上售卖一些东西，你已经售卖一些东西，在未来会越来越关注你的信用情况，你就会花更多的经历去经营他 技能​ 以我自己举例子，学习编程的时候，使用的是vscode（编程开发软件），至今我已经使用了5年，已经对他产生了依赖，通过他学会了编辑技能，投入了很大的时间成本，学习成本，尽管竞品某些细节更好，但者依旧很难让我行动起来去换掉vscode 总结​ 至此我们走完了上瘾模型，我们回顾一下，首先通过外部或者内部触发来让用户进入行动阶段，在行动中给予用户多变的奖励，最后让用户不断投入，时间，金钱，内容，或者资料，也可以为用户到来价值 信誉 关注这，经过这样的闭环后，用户将会越来越依赖你的产品 ​ 似乎这个模型很棒，是一个值得思考的方法论，但是一个有价值的产品是一切的前提，如果产品没有挠到用户痒点，或者本身就是伪需求，那上瘾模型也无济于事，他不是救命稻草，而是锦上添花，让你的产品变的更加好。 ​ 屏幕前的你此时此刻是否脑海中已经想到了很多，或者是对产品的理解，或者是对你正在进行中的项目产生了新的想法；后续内容提供了基于上瘾模型的产品设计模板，通过这样的模板可以分析别人的项目，也可以构建你准备开发或者正在进行中的项目 将上瘾模型应用到产品中以内部触发为起点​ 如果一款产品无法让用户内部触发，这就意味着用户感知不到其价值，产品的本质是满足客户需求，帮助用户解决问题；在这阶段我们需要研究、定位我们的客户群体，提炼特性，描述用户画像，通过丰田5Why法，深入了解用户的核心诉求，保证内部触发的合理性 设计多变的奖励​ 一款产品可以为用户带来什么？这是极其重要的问题，我们通过内部触发确定我们的用户群体，下一步就需要思考给予用户什么奖励，猎物奖励更好，还是社交奖励更好，同时要在奖励环节中贯彻多变性原则，这里再次强调：多变性是奖励的关键 注：如何给用户第一次良好的体验，让用户感知到价值，引导其内部触发，这也是关键的一环，其中越是生命周期短的产品，首次的啊哈时刻（一个用户对产品感知最强的点）必须要越早出现 用户可以投入什么​ 用户可以在你的产品中生产什么样的内容，数据资料，还是关注者，找准类型，同时要研究用户心理，找到用户可能想投入的实际，再引导用户去完成 利用外部触发推广​ 上瘾模型一旦形成，便需要源源不断的用户进入其中，这里可以根据自身的产品类型来选择外部触发方式，例如自身有钱，可以付费完成触发，或者通过社群进行人际型触发，具体触发方式需要根据产品特性来决定 重复测试迭代优化​ 当用户进行上瘾模型，并产生依赖之后，我们就需要不断检查每个环节是否符合预期，是否存在短板，根据实际数据进行测试，并进行优化迭代，不断完善上瘾模型 对抽奖助手小程序的上瘾模型分析 参考资料参考文章：http://www.woshipm.com/pd/5386132.html 参考书籍：上瘾：让用户养成使用习惯的四大产品逻辑 尼尔·埃亚尔 瑞安·胡佛","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"产品日常","slug":"产品日常","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E6%97%A5%E5%B8%B8/"}]},{"title":"Vue + webpack项目的移动端适配","slug":"技术文章/vue项目使用vw进行移动端适配","date":"2022-05-19T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2022/05/20/技术文章/vue项目使用vw进行移动端适配/","link":"","permalink":"https://bluedancers.github.io/2022/05/20/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8vw%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","excerpt":"","text":"2022-5-20更新技术栈：vue3 + webpack5 安装插件1npm i postcss-px-to-viewport -D 增加配置新建配置文件postcss.config.js 1234567891011121314151617181920212223module.exports = () =&gt; &#123; return &#123; plugins: &#123; autoprefixer: &#123;&#125;, &quot;postcss-px-to-viewport&quot;: &#123; unitToConvert: &quot;px&quot;, // 需要转换的单位，默认为&quot;px&quot; viewportWidth: 750, // 设计稿的视口宽度 unitPrecision: 5, // 单位转换后保留的精度 propList: [&quot;*&quot;], // 能转化为vw的属性列表 viewportUnit: &quot;vw&quot;, // 希望使用的视口单位 fontViewportUnit: &quot;vw&quot;, // 字体使用的视口单位 selectorBlackList: [&quot;.ignore&quot;, &quot;.hairlines&quot;, &quot;.ig-&quot;], // 需要忽略的CSS选择器 minPixelValue: 1, // 最小的转换数值，如果为1的话，只有大于1的值会被转换 mediaQuery: false, // 媒体查询里的单位是否需要转换单位 replace: true, // 是否直接更换属性值，而不添加备用属性 include: undefined, // 如果设置了include，那将只有匹配到的文件才会被转换，例如只转换 &#x27;src/mobile&#x27; 下的文件 (include: /\\/src\\/mobile\\//) landscape: false, // 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape) landscapeUnit: &quot;vw&quot;, // 横屏时使用的单位 landscapeWidth: 568, // 横屏时使用的视口宽度 &#125;, &#125;, &#125;;&#125;; end以下配置已经过时，请看最新内容 需要安装一下的插件 1npm install postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano cssnano-preset-advanced postcss-import postcss-url --S postcss.config.js配置 123456789101112131415161718192021222324252627module.exports = &#123; plugins: &#123; &#x27;postcss-import&#x27;: &#123;&#125;, &#x27;postcss-url&#x27;: &#123;&#125;, &#x27;postcss-aspect-ratio-mini&#x27;: &#123;&#125;, &#x27;postcss-write-svg&#x27;: &#123; utf8: false &#125;, &#x27;postcss-cssnext&#x27;: &#123;&#125;, &#x27;postcss-px-to-viewport&#x27;: &#123; viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: &#x27;vw&#x27;, // 指定需要转换成的视窗单位，建议使用vw selectorBlackList: [&#x27;.ignore&#x27;, &#x27;.hairlines&#x27;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 0, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换`px` &#125;, &#x27;postcss-viewport-units&#x27;: &#123; filterRule: rule =&gt; rule.nodes.findIndex(i =&gt; i.prop === &#x27;content&#x27;) === -1 &#125;, cssnano: &#123; preset: &#x27;advanced&#x27;, autoprefixer: false, &#x27;postcss-zindex&#x27;: false &#125; &#125;&#125;; 这里注意假如生成的项目里面没有.postcssrc.js 说明写在package.json里面,记得把package里面的部分配置删除 12345&quot;postcss&quot;: &#123; &quot;plugins&quot;: &#123; &quot;autoprefixer&quot;: &#123;&#125; &#125; &#125;, 最后在index.html里面进行引入viewport-units-buggyfill解决兼容问题 123456&lt;script src=&quot;//g.alicdn.com/fdilab/lib3rd/viewport-units-buggyfill/0.6.2/??viewport-units-buggyfill.hacks.min.js,viewport-units-buggyfill.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; window.viewportUnitsBuggyfill.init(&#123; hacks: window.viewportUnitsBuggyfillHacks &#125;); &#125; &lt;/script&gt; 注意如果遇到图片无法正常显示 1.img图片不显示： 全局引入 123img &#123; content: normal !important;&#125; 2.与第三方UI库兼容问题： 使用postcss-px-to-viewport-opt，然后使用exclude配置项，具体参考 Vue+ts下的移动端vw适配（第三方库css问题）","categories":[{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://bluedancers.github.io/tags/vue3/"},{"name":"webpack5","slug":"webpack5","permalink":"https://bluedancers.github.io/tags/webpack5/"},{"name":"响应式","slug":"响应式","permalink":"https://bluedancers.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"vw","slug":"vw","permalink":"https://bluedancers.github.io/tags/vw/"}]},{"title":"工具与绩效度量","slug":"NPDP产品经理/工具与绩效度量","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.077Z","comments":true,"path":"2022/03/18/NPDP产品经理/工具与绩效度量/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%BB%A9%E6%95%88%E5%BA%A6%E9%87%8F/","excerpt":"","text":"9种创意工具 名称 内容 SCAMPER 特别是在生产改进现有产品，产生新的产品的想法上很有帮助，SCAMPER是一些行为东西的首字母缩略词。又叫奔驰法 奔奔法S：替代 C： 合并 A：改造 M：调整 P：改变用途 E：去除 R：逆向操作 头脑风暴 在群体决策中，由于群体成员心理相互作用影响，易屈于权威或大多数人意见，形成“群体思维”。群体思维削弱了 思维导图 在各种信息或创意之间建立思维链接的图形化技术。首先，讲一个关键字或者短语写在一页纸的中间，然后，从这一中心点触发，将其与不同方向的新创意连接，从而建立起网络式思维关系","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"文化、组织与团队","slug":"NPDP产品经理/文化、组织与团队","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.077Z","comments":true,"path":"2022/03/18/NPDP产品经理/文化、组织与团队/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E6%96%87%E5%8C%96%E3%80%81%E7%BB%84%E7%BB%87%E4%B8%8E%E5%9B%A2%E9%98%9F/","excerpt":"","text":"文化定义​ 组织中人们共同拥有接受的信念、核心价值观、行为准则、思维方式、假设与期望 示例 反应组织的价值观，彰显与习惯、仪式、典礼、故事、英雄榜样 指出如何完成工作 表达生存力，即为了活下去我们应当做些什么 文化是否正确取决于组织本身​ 一个组织中运作良好的文化可能对于另一个组织是完全错误的 成功的创新文化具备的共同特点 清晰的方向和目标 鼓励尝试 个人绩效与组织绩效密切相关 契合创新文化是招聘标准之一 鼓励内部和外部的有效沟通 鼓励建设性冲突 让工作尽可能愉悦有回报 氛围定义​ 是员工可直接或者间接感知到的工作环境特点的集合，对员工的行为有重大的影响 示例 领导人水平、沟通、责任、信任、公平的认可与回报、机会，员工参与 新产品开发中的管理者角色战略纬度 管理内容 角色与职责分配 使命愿景、价值观 整体的企业愿景、使命价值观是由公司高管以及关键职能部门的负责人一起指定，在董事会层面通过 业务战略 通常由某个特定的业务单元的执行团队指定（有歧义） 职能战略 职能部门负责人以及高管团队定制 产品战略 高级产品经理（高级产品副总裁，首席产品官等）指定 创新战略 跨职能团队的高级经理定制，由一位董事会成员领导 流程纬度 角色 管理内容 流程拥护人process champion 负责推动组织内正式商业流程的日常工作，对流程进行调整、创新和持续改进 类似考委会，负责定制和改进考试规则 流程主管process owner 对新产品开发流程的战略性结果，包括生产能力、输出质量和组织类的参与度负责的执行经理，敏捷中由PO和敏捷教练来负责 类似巡场老师，负责监督规则的执行效果 流程经理process manager 确保流程中的创意和项目按时有序进行的运营经理。有时被成为业务流程经理或者工艺经理 类似监考老师，负责规则的按时有序执行 项目经理project manager 采用组织认可的流程，负责管理特定的产品开发项目 类似班主任，组织学生按规则试试考试项目 组织与团队 职责 说明 建立文化氛围 组织的文化和氛围由最高层管理者领导，并受其影响 推动积极氛围 是职能经理和各个团队或项目经理的职责 团队开发 整体团队开发的责任由高级产品开发经理承担，包括：团队成员的选拔，高绩效团队的建立，气氛的保持 产品管理者的关键职责落实产品开发战略，跨职能合作。 职位 职责 首席产品官 先CEO回报，定制整体的产品战略，监控、管理好产品的营销与开发 高级副总裁 领导大型产品经理团队，与工程、销售、制造、营销职能的主要领导紧密配合工作，确保开发中的产品是正确的，且有助于实现公司目标 产品群经理 为负责某个产品群的产品团队提供指导，负责执行高级管理者指定的战略，领导跨职能团队 产品经理 对具体的产品和产品类别负责 产品经理 VS 项目经理 产品经理 项目经理 发现与定义范围（要做什么，做成什么样） 范围的执行与交付（执行并交付产品） 对产品整个生命周期负责 阶段性的对项目负责 团队领导者的角色和职责-高级管理者新产品开发中高级管理者角色为战略负责 定制企业级和事业群级战略的终极责任在于高级管理者 而包括产品研发战略在内的职能型战略定制的责任人在于职能部门负责人 高级管理者角色倡导者：项目倡导者并非团队的一员，可能是市场部或者是研发部的总经理，他们对项目充满了热情，有感染力，并且愿意为推进项目承担风险，能够帮助团队获得资源，帮助团队承担风险 发起者：提供项目所需的资源，总资源需求承诺以及优化配置，评估绩效，提供激励奖励，关口评审，运营规划等 引导者：帮助团队尽量减少官僚主义，突破繁文缛节的限制和其他组织壁垒，从而提高生产力 高级管理者任务方向引领者： 奖励公司战略 确保为新产品所做的一切努力是一致的 产品线缔造者 为理解目前及未来的产品线确立框架 定义产品类型 组合管理 确定项目设置 匹配项目容量、生产力 高级管理者总结 跨职能团队和矩阵结构组织结构类型​ 矩阵结构式一种组织结构，其中的汇报关系按网格或者矩阵奖励，而不按照传统的层级结构，换言之，一个员工具有双重的回报关系，通常是指职能经理和产品经理（项目经理）汇报 矩阵结构 团队类型 项目经理 上下级 团队成员 团队能力 适合的产品任务类型 职能型团队 无 有 分散 最弱 改进的，轻微的（支持型项目） 轻量级团队 有无实权 无 兼职 弱 派生的扩张产品线（衍生型项目） 重量型团队 有有实权 无（交叉） 临时专职 强 新领域，不确定，复杂的（平台型项目） 自主型团队 创业团队领导 有 专职 最强 全新的，长周期，高风险（突破性项目）","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"新产品开发战略","slug":"NPDP产品经理/新产品开发战略","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.078Z","comments":true,"path":"2022/03/18/NPDP产品经理/新产品开发战略/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E6%96%B0%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E6%88%98%E7%95%A5/","excerpt":"","text":"战略定义：能够引向未来的一种方法与战略，例如，某个目标的实现路径或某个问题的解决方法 商业环境下的战略定义： 战略能够定义与传播一个组织的独特定位，说明应当如何调整组织的资源、技能与能力以获取竞争优势（波特，2008） 给予行业定位、机遇和资源，企业为实现长远目标而定制的计划（科特勒 2012） 经营战略的设计步骤 战略制定与执行责任人​ 整体的企业愿景和使命通常由公司高管团队以及关键职能部门（财务、营销、制造等）的负责人一起正式制定，这些内容在董事会层面得到了正式通过 业务战略：通常由某个特定的业务单元的执行团队进行制定 职能战略：通常由职能部门负责人及高管管理团队（财务，营销）进行制定 产品战略：通常由高级产品经理（如高级产品管理副总裁）进行制定 创新战略：同工厂由跨职能部门的高级经理制定，由一位董事会成员领导，他可能是创新副总裁，首席技术官或首席执行官 使命 愿景 价值观使命定义： 公司信念、哲学、目的、经营原则或者企业信仰的声明 目的：阐述企业为什么存在(Why)。为了凝聚公司能量与资源 案例： 发布创意 克服困难(3M公司使命) 愿景定义： 透过预见与洞察的现象，透过实际上的限制，借此想象出企业对于未来发展的可能性 目的：阐述企业要往哪里(Where) 案例： 设计各式精良，优异的家居用品，并且价格低到让许多人都买得起(IKEA宜家家居愿景) 价值观 参与的成员为了完成任务需要遵守的行为准则 一个人或者公司带来某种程度的情感来遵守一个原则 目的： 阐述企业的行为准则与价值观(How) 案例： 诚信正直 承诺 创新 客户伙伴关系(TSMC公司价值观) 四种创新战略框架波特战略框架波特将公司优势最终划分成为2个部分：成本优势与差异化 通过运营这些优势或宽或窄的范围，定义了三种通用战略 成本领先战略 差异化战略 细分市场战略 战略名称 特点 优势 劣势 例子 成本领先战略 吸引价格敏感性客户提升市场份额规模生产降低成本优化供应链 在价格竞争激烈市场中有保持竞争的方法 利润低降低成本影响质量导致客户流失 世界工厂，中国制造 差异化战略 聚焦较宽产品基础交付优质产品建立忠诚客户关系获取市场份额更关注产品品质和性能 利于建立客户忠诚度可以获得更高的利润率 必须持续创新，开发新产品吸引客户性能不好可能导致市场份额的大幅度下滑 星巴克苹果 细分市场战略 也称”聚焦战略”适用于狭小市场对市场有深入认识与独特见解 聚焦营销和新产品开发工作具备很高的竞争壁垒增加产品开发投入提高利润率 依赖单一狭小市场风险大新技术冲击 医美行业月子中心 迈尔斯.斯诺战略框架基于企业对于变更响应的研究，提供有用框架去描述产品开发战略方法 类型 动作 方式 探索者Prospector 首先上市寻求增长敢于冒险 开发和应用新技术借助快速上市，占领市场份额 分析者Analyzer 快速跟随产品通常更好 经常跟随探索型公司，开发模仿产品被称为”快速跟随者”新产品开发成本低 防御者Defender 在稳定市场中维护其市场份额 风险厌恶型，聚焦于狭窄的，稳定的市场与产品类别通常不具备技术进攻能力 反应者Eeactor 只有在遭遇威胁时才会有所反应 没有清晰的战略目标没有明确的技术开发计划和市场进入计划 持续式创新 VS 颠覆式创新持续式创新 不创造新的市场与新价值主张，致力于把现有产品做的更加好 从审美，功能，特性或成本角度关注产品变更和改进的渐进过程 颠覆式创新 克莱顿.克里斯坦森首次提出颠覆式创新的概念(1997) 有助于创建新市场与新的价值网络(价值主张) 初期关注小众有影响力的目标市场，该市场产品具有重要的新特性或功能，但是因为开发成熟度不够充分，还无法与现在已被广泛接受的产品竞争 初期在目标市场的影响力加上产品改进将会扩大市场，导致现有产品最终退出市场 促成和创造颠覆式影响的通常是一个商业模式，而非是一项技术 颠覆式创新不会一夜之间实现，而是逐渐发生的 皮萨诺战略框架 - 创新画布在技术与商业模式创新的两个方面有效分配精力和资源 其他战略库珀的战略 库珀是门径管理流程的奠基人，库珀的战略从技术和市场的角度来讨论 差异化战略： 与波特的差异化战略类似，提供高价格，高质量的产品，满足客户需求 高成本战略： 研发成本高，较少关注市场和客户需求 技术推动战略： 最新技术，高度创新想法，较少关注用户需求 保守战略： 低风险，有限研发投入，非差异化产品 非博弈战略： 与迈尔斯.斯诺的反应者战略类似 平台战略平台战略被定为为一系列子系统及其接口，由此可以建一个通用架构，继而高效的开发，制造出其延伸产品 优势： 快速，连续的推出一系列产品 鼓励从长期视角定制产品战略 能大幅度提升运营效率 公司与市场能清晰理解产品平台的底层要素 能带来巨大的差异化，使自身产品与竞争产品得以区分开来 技术战略技术战略是一份有关技术维护和技术发展的计划，这些技术能够支持组织的未来发展，有助于组织战略目标的实现 技术战略与经营战略和创新战略相连 技术预测方法 头脑风暴法 专家小组法 德尔菲法 (专家 匿名 多轮 趋向一致) SWOT法 专利分析法 趋势分析法 技术S曲线基本上显示了大多数技术的生命周期阶段 引入期 成长期 成熟期 知识产权战略知识产权： 智力制造出来东西，比如发明、文学、艺术、设计、符号、名称、商业用户图像的所有权；同其他产权一样可以出售，授权，交换或者被拥有者放弃；知识产权被法律保护，例如专利、版权和商标可以让所有人从他们的创造中获取荣誉和金钱回报。 知识产权的类型专利：在一定时间阶段生效的，由政府授权或许可的权利，特别指禁止他人制造，使用或者销售一个发明的所有权力 版权：一定年限内，给予原创者独家的，指定的法律权利，可以印刷，发行，制作 商标：代表公司、产品的经由法定注册或许可的符号，单词或者词组 植物品种权： 给予独家权力生产和销售某种可繁殖的植物 商业机密：和企业相关的保密信息 营销战略从业务目标到营销计划，其中包含业务目标、营销战略、公司组合、营销计划 市场营销组合4P产品Product：外观 功能 特色 质量 包装 支持 质保 品牌 促销Promotion：主题&#x2F;信息 社交媒体 公关 销售团体 商品展会 纸质媒体 定价Price：目录价格 折扣 捆绑销售 信用条款 渗透定价（低价占领市场） 撇脂定价（高价回收成本） 地点Place：渠道 库存 物流 实体分销 如何定价 无论何时何地，对产品经理而言必须明确点：总利润比市场份额、效率更加重要 维持低成本是产品的事情，维持高售价是运营的事情 降价是最昂贵的运营策略，而提价的效果未必会有想象中的糟糕 如何应对竞争对手的价格变化​ 某一家酒企的一款酒经过多年经营，在市场上占有率一度达到20%，后来竞争对手也出了类似的产品，比他要低1美元，这时候酒企应该进行价格竞争吗？显然这会导致自己总利润降低，这时候决策者决定，将这款酒提价1美元，同时出这款酒的不同包装的产品，可以理解为青春版，其价格更加低廉，以此与对手竞争，一方面提高了前者酒的地位，一方面拉低了对手的品牌力，使销售量增加，利润量增加 如何“忽悠”用户付费在一定得到3w 80%的几率得到4w，20%的概念得到0元面前，大部分用户会选择前者 在一定失去3w 80%的几率失去4w，20%的概念失去0元面前，大部分用户会选择后者 结论：人性在面对失去与风险的时候更加害怕失去 策略：不要告诉用户买了产品会得到什么，而是告诉用户不购买会失去什么 场景：儿童兴趣班 阅读到一半的付费阅读 营销理念的历史演变 4P - 4C - 4R 4P 产品导向 4C 顾客导向 4R 顾客忠诚度导向 产品（product） 顾客需求（Consumer） 关系（Relation） 促销（promotion） 便利性（Convenience） 反应（Respond） 价格（price） 沟通（Communication） 回报（Return） 分销（place） 成本（Cost） 关联（Relevancy） 产品三环靶核心利益：产品核心价值（不是有形物理属性） 有形性能：赋予产品外观和功能的物理和美学设计特征 附加性能： 产品提供的额外性能可以是免费的 产品描述FAB每个产品或者品牌都具备的三个要素 产品的F-A-B结构（总结每个产品的卖点，特点，优势和利益） 特点（Feature）：对产品本身的技术性解释，通常包含产品专业化词语 优势（Advantage）：由于产品本身的特性所导致的产品表现 利益（benefit）：与消费者的感受密切相关，由产品带给消费者的价值 基于感觉上的体验，往往是针对个人而言，相对的，类比的，定性的 采用FAB表述产品卖点示例 名称 特点（F） 优势（A） 利益（B） 海飞丝 富含最新丝源蛋白 头屑去无踪 秀发更出众 潘婷 含丰富的维他命原B5 能由发根渗透到发烧，补充养分 使他浦发健康，亮泽 飘柔 含丝质润发素 洗发洗护一次完成 令头发柔顺飘逸 为产品卖点塑造画面感（场景） 产品卖点 普通文案 有画面感的文案 耳机音质好 声声震撼，激发梦想 犹如置身音乐会现场 笔记本噪音低 创想极致，精心由我 闭上眼睛，感受不到电脑开机 工资辛苦，不如旅行 乐享生活，畅意人生 你写PPT时，阿拉斯加的鳕鱼正跃出水面 波士顿矩阵分析 商业画布主要内容与要点 亚马逊商业画布 能力战略能力来源能力要求 技术 营销 研发 内部来源 保持现有能力 获取新能力 重新培训，重新开发现有能力 外部来源 兼并或收购 合资企业 开放式创新 咨询 封闭式创新 VS 开放式创新 封闭式创新的基本原则 开放式创新的基本原则 本行业里最聪明的员工为我们工作 并非所有的聪明人都给我们工作，我们需要和企业内外部的聪明人合作 为了从研发中会哦你，我们必须自己进行发明创造，开发产品并推向市场 外部研发工作可以穿在巨大价值，而要分享其中的一部分，则必须进行内部研发 如果我们自己进行研究，就能最先把产品推向市场 我们不是非要自己进行研究才能从中受益 最先将创新商业化的企业将成为赢家 建立一个更好的商业模式要比贸然冲进市场好很多 如果我们创造出商业中最多最好的创意，我们必将胜利 如果我们能充分利用企业内外部的创意，我们必将胜利 我们必须控制知识产权，这样竞争对手就无从我们的创意中获利 我们应当通过让他人使用我们的知识产权而从中获利，同时应当购买他人的知识产权只要它能提升我们的商业模式 保持市场竞争优势的办法 如果在一个相对封闭的行业，应当着重发展内生优势，提升自身能力但产业融合与跨界合作兴起时，生态优势的重要性会特别明显 定位观​ 认为决定竞争优势的因素有两个，一是行业盈利能力，二是企业在行业中的地位。因此企业的盈利能力取决于其竞争战略选择，而竞争战略的选择则是：选择有吸引力、高潜在利润的行业并建立自己的优势竞争地位 资源能力观​ 认为企业在竞争优势产生与企业内部运作（组织过程，包括协调&#x2F;整合、学习&#x2F;重构与转变）、流程和当前所处位置，具有路径依赖性 生态优势观​ 认为在新技术应用层出不穷、产业环境日趋动荡、消费者对一体化解决方案的期望越来越高的背景下，产业边界逐渐模糊，跨界合作与价值共创成为潮流，他不仅仅关注自身的价值链还要重新定义和优化价值网上面的活动，管理好未拥有的资源 互联网思维“孤独九剑”剑谱 互联网+​ “互联网+”就是“互联网+各个传统行业”，但这并不是简单的两者相加，而是利用信息通信技术以及互联网平台，让互联网与传统行业进行深度融合，创造新的发证生态 ​ “互联网+”行动加护将重点促进云计算、物联网、大数据为代表的新一代信息技术与现代制造业、生产性服务业等的融合创新，发展壮大新兴业态，打造新的产品增长点，为大众创业、万众创新提供环境，为企业智能化提供支撑，增强新的经济发展动力，促进国民经济提质增效升级 互联网+ 开展的前提用户中心不充分 行业通点多，低效环节多，用户体验不好的行业 充分竞争市场，行政垄断少，市场化长度比较高的地方 数据驱动不充分 产品或者服务可虚拟化、数据化的行业 价值环节可数据化的地方，将面临数据化改造 生态协作不充分 利用信息不对称，靠中介型的商业模式盈利的地方，会被改变","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"新产品流程","slug":"NPDP产品经理/新产品流程","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.078Z","comments":true,"path":"2022/03/18/NPDP产品经理/新产品流程/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E6%96%B0%E4%BA%A7%E5%93%81%E6%B5%81%E7%A8%8B/","excerpt":"","text":"思维导图管控产品失败（降低不确定性）的方法不确定性、累计成本与开发阶段的关系 标准的决策框架 产品开发流程基本阶段 探索（Exploration） 筛选（Screening） 商业评估（Business Evaluation） 开发（Development） 测试（Testing） 商业化（Commercialization） 常见产品开发流程 门径管理流程（Stage - Gate@） 集成产品开发（IPD） 精益开发（Lean） 敏捷开发（Agil） 设计思维（Design Thinking） 模糊前端FFE​ 模糊前段（Fuzzy front end，FFE）：产品开发项目的前端是一个早期极端的起点，在进入正式的产品开发流程前，组织在该阶段识别机会，形成概念。 ​ 该阶段包括创意生成阶段，初始概念发展阶段和高级业务阶段。 ​ 是项目中定义最不确定的一个阶段 ​ 注：创意阶段可能有5个，概念开发阶段经过淘汰与融合变成了2个，最后立项分析，确定要做的项目 门径管理流程 阶段-关口概念什么是阶段产品开发流程中的一个确认区域，包括： 活动：项目负责人及团队成员依照项目计划必须完成的工作 综合分析：通过跨职能部门及团队成员依照项目计划必须完成的工作 可交付成果：是综合分析结果的呈现，这是团队必须完成的并在关口时所以提交的内容 什么是关卡基本上，他是产品开发流程中的一个确认节点，在该阶段时需要做出有关项目未来的关键决策。包括 可交付成果：关口评审点的输入内容（阶段中的可交付成果）。它是前阶段行为的结果，是实现确定的，在每个关口都有一个可交付成功的标准清单 标准：判断项目是继续还是停止以及优先级决策的标准，这些标准通过以分数呈现，包括财务和定向标准 输出：关口评审结果。关口必须有明确的输出包括一个决策（继续或者停止）以及下一个阶段的路径 阶段 - 关口（Stage - Gate）新产品开发过程 根据需要，可灵活裁剪与添加 分为六个阶段，由来自公司内部不同职能领域的人员一起完成： 发现（Discovery）：寻找新机会和新产品创意 筛选（Scoping）：也叫观察，初步评选市场机会、技术需求以及能力的可获得性 立项分析（Business Case）：也叫构建产品框架，建立在筛选阶段之上的一个关键阶段，包括更为深入的技术，市场和商业可行性分析 开发（Development）：产品设计，原生制造，生产设计，制造准备和上市规划 测试与修正（Testing and Validation）：也翻译成测试与确认，测试产品以及商业化计划的所有方面，以修正所有假设和结论，和证实对产品的预期和总结 上市（Launch）：也翻译为投放市场，产品的完整商业化，包括规模制造以及商业化上市 阶段：一个确定区域，包括 活动，综合分析，可交付成果 关卡：一个确定阶段，必须又明确的输出包括一个决策（继续或者停止等）以及下一阶段的路径。包括：可交付成果，标准，输出 瀑布模型 要求：了解要设计产品需要什么功能、目的、用户需求 设计：确定完成项目所需的软件与硬件，之后被转化为物理设计 实施：根据项目要求和设计规范编写实际代码 验证：确保产品符合顾客的期望 维护：通过客户确定产品设计中的不足或错误，进行修正 集成产品开发IPD integrated Product Development，PID 前身 - 并行工程含义​ 在产品的设计与制造流程中，跨职能团队采用并行模式进行工作，而不是各个功能的顺序依次开发，从而促使团队全面考虑产品生命周期中从概念到实施的全部元素，包括质量、成本、维护等方面 主要特征 并行交叉：并行工程强调产品设计与工艺过程设计、生产准备、采购等活动交叉进行 按部件并行交叉，将一个产品分成若干部分，使其各部件能并行进行交叉开发 各个组件的设计、采购、生产等各种互动尽可能的交叉并行 尽早开始工作，目的就是争取时间 具体做法​ 在产品开发的初期，组织多种可协同工作的项目组，使得有关人员从一开始就获得有关项目的最新消息，积极研究涉及本部门的工作任务，并将需求提供给设计人员，使得许多问题在开发早期就得到了解决从而保证设计质量，减少返工与浪费 发展 - 集成产品开发IPD含义​ 系统综合地应用不同职能体系的成果和理念，有效、高效的开发新产品，满足客户需求的方式 IPD管理的精髓 IPD基于并行工程发展而来 IPD首先是一个商业流程，关注商业结果，将产品开发作为一项投资进行审慎管理 IPD采用跨职能团队，加强部门合作，形成合力，共同承担 IPD流程分为不同的阶段，通过在决策评审点的决策实现集成组合管理团队（IPMT）和产品开发团队（PDT）互动，资源受控分配与投入，既满足项目进展的需求，又避免了投资失控的风险 IPD是灵活的，发展的，持续改进设计的，在不断吸纳业界实践和解决业务问题的过程与时俱进 IPD流程是基于市场的开发，关注市场需求和竞争分析，鼓励创新基于着二者之上 集成产品开发系统分级 精益产品开发定义（Lean Product Development）：创建在丰田首创的精益方法（TPS）的基础之上。目的是：从流程中去掉浪费 精益开发的原则（提升生产效率） 确定客户定义的价值 尽最大努力探索不同的解决方案 创造顺畅的产品开发流程 尊重颜色的标准，以减少变异 首席工程师全程参与 跨职能整合 学习不断改进 准求卓越与不断学习的文化 团队整个组织 消除浪费 + 强化学习 + 慎重政策 + 尽快交付 + 授权团队 + 品质为先 + 全局优化 + 消除浪费 &#x3D; 精益产品 潜在的浪费来源包括 混乱的工作环境 缺乏可用的资源 缺乏明确的优先级顺序 不同职能之间的沟通存在障碍 糟糕的产品需求定义 缺乏对可制造性的早期考虑 过度设计 太多无效会议 太多的电子邮件 直接效益 显著提升生产效能 准时制准时制生产方式（Just In Time简称JIT），又称作无库存生产方式（stockless production），零库存（zero inventories），单件流（one - piece flow）或者超市市场生产方式（supermarket production） JIT的基本理念：只在需要的时候、按需要的量，生产所需的产品，故又被称为准时生产、适时生产方式。 JIT的目标：彻底消除无效劳动和浪费。具体要达到以下目标 废品量最低 2. 库存量最低 3. 准备时间最短 4. 生产提前期最短 5. 减少零件搬运，搬运量低 6. 机器损坏低 7. 事故降低 单件流批量生产虽然是降低成本的生产方法，但是容易出现堆积浪费，周转麻烦，容错率低的问题 单件流则有目的的降低周转问题，并且减少堆积浪费，同时增加容错率 5WHY法（刨根问底法） 安灯法操作：产线异常，按下按钮 - 产线报警 - 领班支持 收益： 一线员工既要动手，也要动脑 鼓励员工持续成长，获得成就感 公司流程优化，持续改善 现场现物亲临现场 - 细致观察，分析&#x2F;评估 - 找出原因 构建学习型组织 超越短期利益，着眼长期利益 致力提升员工，合作伙伴能力 继任领导延续公司文化基因 丰田模式的核心精神是通过支持和鼓励员工持续改善工作流程 让他们不断成长与进步，进而获得工作成就感和主人翁意识 精益产品开发过程的核心概念 精益产品开发的优劣势优势 流程的聚焦点在于信息的顺畅流动,而非严厉管控 通过事件驱动方法简化合作，优化设计 重视对进度、成本、消极和质量方面的风险的积极管控 适用于各种规模的项目 用于记录学习和进展、判定优先级和解决问题的工具是简单的，可视化的 劣势 参与人员必须是相当敬业并且经验丰富的 需要改变组织的结构和文化 需要强有力的供应商管理 组织有意愿且有能力接受项目目标的和方向上的变化 敏捷开发传统方法VS敏捷方法 传统的写作方式 敏捷的写作方式 确定主题 与读者互动 整理大纲、搭建框架 确定主题 书写内容 与读者互动。收集反馈 设计、排版、校对 试写第一张 出版 与读者互动，收集反馈 与读者见面 试写第二章 筹集反馈 … 设计、排班、校对 出版 传统VS敏捷之客户互动对比 确定性项目VS不确定性项目 生命周期类型 增量型：楼盘 定下来不会变 但是要不断交付 敏捷性：互联网项目 不断在变化 预测型：铁路建造 变化极小，有规律的项目 迭代型：研发疫苗 不断变化，但是只需要交付一次 Stacy斯泰西图 敏捷宣言 敏捷宣言 价值观 个体以及互动 胜于 流程和工具 以人为本 可工作的软件 胜过 完整的文档 以价值为导向 客户合作 胜过 合同谈判 合作共赢 响应变化 胜过 遵循原则 拥抱变化 敏捷开发十二大原则 通过尽早和持续地交付有价值的软件来满足客户 欢迎对需求提出变更，敏捷过程要善于利用需求变更，帮助客户获得竞争优势 经常交付可用软件，并周期越短越好 业务人员与开发人员必须通力合作 要善于激励项目人员，基于他们所需的环境和支持，并相信他们能完成任务 团队内部和各个团队之间，最有效的沟通方式是面对面沟通 可工作的软件是衡量进度的首要指标 敏捷过程体长可持续的开发。项目方、开发人员和用户应该能够保持稳定恒久的进展速度 对技术的精益求精以及对设计的不断完善将提高敏捷性 尽量做到简洁，尽最大可能减少不必要工作，这是一门艺术 最佳的架构、需求和设计出自于自组织团队 团队要定期回顾和反思如何能够做到更有效，并相应地调整团队的行为 敏捷Scrum框架 敏捷实践SCRUM的333555 三个支柱 三个角色 三个工件 透明性（Transparency） 产品负责人（Product Owner） 产品待办事项列表（Product Backlog） 检查（Inspection） 敏捷教练（Scrum Master） 冲刺待办事项列表（Sprint Backlog） 适应（Adaptation） 项目团队（Scrum Team） 可交付产品增量（Increment） 五个事件 五大价值观 冲刺 承诺（Commitment） - 愿意对目标做出承诺 冲刺规划会议 专注（Focus） - 全身心都用到你承诺的工作上去 每日站会 开放（Openness） - 团队内所有信息对所有人开发 迭代评审会议 尊重（Respect） - 每个人都有他独特的价值与经验 迭代回顾会议 勇气（Courage） - 勇于承诺，履行承诺，敢于说不 敏捷实践 - 3个角色 产品负责人 敏捷教练 敏捷团队 确定产品的功能和标准维护产品待办事项列表指定软件的交付内容代表客户利益拥有最终解释权平衡有竞争关系的利益相关者 团队和产品主管之间的协调者，消除他们之间的障碍工作职责不是管理团队激发团队的创造力，给团队授权提升团队生产率改进工程工具的实践确保团队取得进展的信息实时更新与同步服务团队、教导团队、保护团队 5到9个人多职能部门人员组成冲刺阶段，团队通过自组织的方式实现冲刺目标实现目标的帆帆上有选择自主权责任属于整个开发团队一起成功，一起失败一起调整，一起改进 敏捷实践 - 用户故事作为 学员 我想 看直播课 以便于 和老师互动 作为老师 我想 提前排课表 以便于 合理安排事件 作为xx 我想 xx 以便于xxxxx 用户说出自己的问题而不是给出具体解决方案 敏捷实践 - 产品代办列表​ 待办事项是所有工作的有序列表，他以故事形式呈现给团队。价值大的排在上面。他是产品需求变更的唯一来源 ​ 他是一个持续完善的清单，根据产品和开发环境的变化而演进。 ​ 产品负责人Product Owner负责待办事项列表的内容，可用性和优先级 几种开发流程的对比瀑布模型 VS 敏捷流程 瀑布模型 敏捷流程 瀑布使用阶段 敏捷使用迭代 瀑布使用不提供高低频率的互动（开发阶段低频率，业务测试阶段高频率） 有频繁的业务互动 瀑布模式一个项目经理 敏捷流程是scrum master 瀑布不能迭代 敏捷能迭代 敏捷与精益敏捷开发：敏捷设计的初衷是再短时间内执行任务，与客户进行频繁互动，并能够对变化做出迅速相应，比较常用于软件开发 精益开发：精益旨在减少浪费，提高运营效率，特别适用于制造过程中常见的重复性任务 门径管理 VS 敏捷 特征 门径管理 敏捷 模型类型 宏观技术 微观计划，项目管理 范围 创意到结束，端点到端点 只有开发与测试阶段 组织广度 跨职能 - 技术、市场、生产 技术 结束点 上市成为新产品 已开发或测试的软件 决策模型 投资模型：设计高级管理层治理的继续或停止模型 主要是战术性的：下一个冲刺需要的动作 集成产品开发与其他流程对比 集成产品开发提供一种将产品开发中的功能，角色和行为集成起来的框架。 定义为系统地、综合的应用不同职能体系的成功和理念，有效、高效地开发新产品，满足客户需求的方式 集成产品开发模型的一个重要功能是“学习与持续改进”，模型表明专注于产品开发过程和技术的组织如何发展以知识为基础的学习型组织 各流程模型是潜在互补的，而不是相互排斥的，应以持续学习和改进为重点，将每个模型中的元素融合为一个真正适合于产品开发的模型 特点 门径管理模型 宏观规划、决策基础 敏捷模型 微观技术和灵活性 精益生产 减少浪费 集成产品开发 学习型组织，对新产品开发的综合集成 开发流程的治理治理：用于指导项目、程序和项目组合管理中的活动框架、功能和流程。治理是采取高层级和战略性的视角，而不是陷入过程和项目细节 治理 管理 职能 监督、控制、整合和决策 技术、组织、领导和控制 关注点 结果和目标 方法和技术 层面 宏观（战略、决策角度） 中观和微观（战术、执行角度） 负责人 董事会 管理层 作用 为管理提供框架、功能和过程授予管理者经营权并加以监督 再治理提供的框架和监督中形式经营权，实现经营目标 总结所有流程模型均遵从一下共同原则 关注战略一致性 基于知识进行决策 降低产品失败的风险 剪掉将利益相关者的输入信息融入设计决策 应用跨职能团队 是一个结构化框架，要被整个项目所理解和应用 门径管理流程 集成产品开发 精益开发 敏捷开发 是否对整个新产品开发流程进行管理 是 是 是 否 是否专注于跨职能团队的使用 是 是 是 是 能加快上市速度吗 是 是 是 是 最适用什么类型的产品行业 硬件、实物 多产品 制造 软件 软件类 如何降低产品失败的风险 关口 决策点 消除浪费 快速迭代 是线性还是迭代 线性 线性 线性+迭代 迭代+线性","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"组合管理","slug":"NPDP产品经理/组合管理","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.079Z","comments":true,"path":"2022/03/18/NPDP产品经理/组合管理/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E7%BB%84%E5%90%88%E7%AE%A1%E7%90%86/","excerpt":"","text":"组合管理大纲 产品组合产品组织：一个组织正在投资的并将其做出战略性权衡取舍的一系列项目或产品 产品组合管理：以组合形式被管理的一系列程序、项目和&#x2F;或操作的集合。一个组合的构成元素未必是相互依赖的，甚至未必是相关的，但他们被集合成一个组合，以此为单位接受管理，以实现战略目标。 在产品开发和产品管理中，企业可以通过两种途径实现新产品成功 正确的完成项目（项目管理） 完成正确的项目（组合管理） 管理组合的五大高层次目标价值最大化​ 进行资源配置将组合价值最大化（独立项目商业价值的综合）（非财务评估与财务评估） 战略协同​ 确保整体组合战略与经营战略及创新战略始终保持一致（自下而上，自下而上，结合法） 项目平衡​ 根据预定设定的标准如长期或短期、高风险或低风险、特定产品或市场分类等，保持正确的项目之间的平衡 管道平衡​ 确保资源及焦点不会过度分散，避免组合囊括的项目过多，导致被过度分流（资源配置） 财务稳健​ 确保产品组合所选项目能够实现新产品创新战略中所设定的财务目标（财务可行性） 产品规划定义​ 运营严格、规范的方法对市场走势及客户的要求及需求进行分析，创建合理的市场细分规则，对要投资和取得领先地位的细分市场进行选择和优先级排序，从而设计确保市场营销取得成功需要执行的活动，定制可盈利，可执行的业务计划和驱动产品平台、新产品包的开发 老板决定 集体决定 成立规划部门 跨部门团队运行 优点 决策迅速 体现集体意志，形成共识 保证资源，提升专业能力 提升规划质量 缺点 随意、混乱 方法不严谨，责任容易分散 存在局限性，影响规划执行 对管理要求高，决策可能较慢 适用情况 公司创业阶段 公司规模不大，产品较少 公司规模较大，产品较多 公司多产品线，众多产品 组合管理流程 组合中的项目类型 类型 特点 团队（一般而言） 突破型项目Breakthrouth 有时被称为激进的或颠覆式的努力通过技术将新产品带进市场与公司现行的项目大不相同，有高风险 自主团队 平台型项目LpatForm 开发出一系列子系统及其接口，由此创建一个通用架构，继而高效的卡覅和生产一系列衍生产品为发现衍生产品、项目提供平台风险比产品改进或增量提升要高，但比开发突破性产品低 重量级团队 衍生项目Derivative 从其他现有产品或平台中衍生出来可以填补有产品线的空白，提供更具有成本竞争力的制造能力基于组织的核心技术提升性能和引入新特效风险较低 轻量级团队 支持项目Support 对现有产品渐进式改革提高现有产品的制造效率低风险 职能团队 产品组合与战略的关系自上而下法 开发过程中首先考虑愿景与战略 确定整个项目组合中可获得的资源平衡，根据重要战略可能对新产品的贡献，确定业务单元和产品种类的顺序 “战略水桶方法”规定了不同业务单元或产生种类理想的投入比例 在路径上，项目按优先级排序 自下而上法 始于单个项目，经评估筛选，形成项目组合 战略标准依据评估每个项目的选择标准而定 不同与自上而下法，单个的产品组合即是结果不对业务部门和产品类型进行特别考虑（不是很懂） 该法保证项目与战略是保持一致的，但可能无法对特定的项目类型头图理想比例的成本 自上而下和自下而上的结合法 具备两种方法的优点 确定能根据业务部门或产品类型的投入，进行战略优先级的排序 所有潜在的项目都要根据战略标准和每个项目的预估投入进行排序 通过战略预算分配项目时，要综合考虑独立的目标优先顺序和预算投入，并与业务部门或产品类型优先顺序保持一致 从上而下的确定计划，从下而上确定执行 产品机会评估新产品技术评估常用方法气泡图、选项标价、评分方法、项目排序、战略水桶、折现现金单、检查清单、投资回收期 一般分为财务方法与非财务方法 非财务性评估非财务评估方法或评分依据是主观判断。确定要采用的标准包括： 战略一致 产品优势 风险高低程度 法律法规影响 上市时间 市场吸引 利用核心竞争力的能力 技术可行性 通过&#x2F;失败评估示例 财务性评估建立对每个产品机会进行潜在财务评估的基础上 决定新产品在财务上是否可行 决定项目的优先级 具体可用的财务评估方法有： 净现值（Net Persent Value，NPV） 投资回收期（Payback Period） 内部回报率（Internal Rate of Return，IRR） 投入产出比、投资回报率（Return on Invesment， Rol） 以上每种方法都需要 销售潜力及回报的相对值 制造和营销成本的相对值 资金投入预估（对新厂房、设备等进行的投资） 财务可行性研究 - 净现值分析净现值NPV，表示期望项目未来收益折算到此刻的值的总和 财务可行性研究 - 投资回报期投资回报率（Payback period）：指多长时间能够收回在产品上的自由投入 静态投资回收期：不考虑资金的时间成本计算投资回收期 动态投资回收期：考虑资金的时间成本计算投资回收期 投资回收率 &#x3D; 1&#x2F;投资回收期 * 100%（假设3.2年成本收回，则投资回收率为30%左右） 投资回报率（ROI） &#x3D; 运营期年均收益&#x2F;投资总额 * 100%（投资收益率）（假设运营了5年，平均每年收益100，投资总额500，则投资回报率为20%） 内部收益率 &#x3D; 净现值等于0的折现率 什么是平衡组合目的：达到良好的风险与回报平衡，加入一些新产品机会 新产品机会所属的业务单元、产品类别、目标市场，或者产品特征，都可以作为新产品机会的分类标准。 例如： 突破性项目、衍生项目、平台型项目、支持性项目 研发成本、商业化成本 潜在的回报和利益 风险水平 - 开发阶段或商业化阶段 技术难度 - 开发或维护 上市时间 - 从决定开发到获得商业汇报时间 设施设备上的资金投入 知识产权的价值创造潜力 气泡图组合分析用气泡图（Bubble Diagram）来展示产品组合是否有效 通常，用气泡图来表示处于二维坐标图中的项目 X轴和Y轴表示具体的利益标准，如风险和回报 气泡表示单个项目，是根据项目在X轴和Y轴的排序所绘 气泡的大小表示第三个标准，如所需投入资金数额或资源份额 资源配置新产品开发成功率受限因素 同时项目太多 项目计划糟糕，执行任务能力差 产品开发项目与其他业务有优先级之争 上市延期，按照完成难度极大 产品资源竞争，流程不合理，缺乏辅助支持 任务优先级不断变化，资源配置随之改变 管理者陷入困境，无法施救项目 资源配置方法 基于项目资源的需求 基于新业务的目标 将资源配置作为一个业务流程","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"NPDP产品经理国际资格认证","slug":"NPDP产品经理/NPDP产品经理介绍","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.076Z","comments":true,"path":"2022/03/18/NPDP产品经理/NPDP产品经理介绍/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"产品经理与项目经理对比 内容 产品经理 项目经理 职责 发现并定义范围 执行并交付范围 范围 对产品整个生命周期负责 阶段性对项目负责 角色 母亲，定义目标，发布计划，然后在生命周期的各个阶段继续培育产品 像家庭教师，一直待在产品旁边，帮助产品成长，让他最后成为产品满意的样子 主题知识组合管理 新产品开发战略 新产品流程 产品生命周期管理 文化，组织与团队 工具与效绩度量 市场研究 知识点分布新产品流程 20% 新产品开发 20% 组合管理 10% 产品生命周期管理 10% 市场研究 10% 工具与绩效度量 20%","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"Vue3 + jsx开发指南","slug":"技术文章/Vue3 使用jsx开发指南","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.086Z","comments":true,"path":"2022/03/15/技术文章/Vue3 使用jsx开发指南/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Vue3%20%E4%BD%BF%E7%94%A8jsx%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"","text":"​ 在2021年，vue3发布了正式版本，并且经过一年的维护已经越来越稳定，我们在公司项目中也小范围的上线了vue3的项目，总体还是很不错的 ​ 但是setup语法需要return比较麻烦，还有.value问题，尝试过setup语法糖，依旧觉得setup语法的api记忆负担比较重 ​ 所以下半年逐渐拾起了jsx的语法，并在开源项目中使用，总体感觉还是相当不错的，前人栽树后人乘凉，本文对jsx for vue的常见问题进行说明 jsx学习成本更低，这么多年jsx没有大改动； 无记忆负担，同时足够灵活，如果你是vue开发者，同时对setup语法并不是太合得来， vue3 + jsx也是非常不错的选择~ 前置知识​ 在vue3中使用jsx需要安装@vitejs&#x2F;plugin-vue-jsx（webpack版本的不了解，有需要者执行搜索），根据文档配置一下就行了，官方提供了文档供参考，提供了相关示例jsx-next,有react基础的同学可以先看官方文档，在开发过程中出现问题再看本文 指令v-modelJSX for vue是支持v-model语法的，这一点比react的setState,体验感确实要好 1234567891011// 正常写法&lt;input v-model=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;value&#125; /&gt; // jsx// 指定值写法&lt;input v-model:modelValue=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;]&#125; /&gt; // jsx // 修饰符写法&lt;input v-model:modelValue.trim=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;,[&#x27;trim&#x27;]]&#125; /&gt; // jsx v-show这个api与在vue中的表现形式一致 12&lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt; // vue&lt;div v-show=&#123;isShow&#125;&gt;&lt;/div&gt; // jsx v-bind1234567891011121314// vue&lt;a-modal :width=&quot;&#x27;400px&#x27;&quot; :title=&quot;&#x27;设置组件名称&#x27;&quot; &gt; // ....&lt;/a-modal&gt;// jsx&lt;a-modal width=&#123;&quot;400px&quot;&#125; title=&#123;&quot;设置组件名称&quot;&#125; &gt; // ....&lt;/a-modal&gt; v-if在jsx for vue中没有这个api，我们需要用jsx风格来实现v-if的效果 可以简单理解为jsx直接将if搬到html中 12&lt;div v-if=&quot;isShow&quot;&gt; ... &lt;/div&gt; // vue&#123;isShow &amp;&amp; &lt;div&gt; ... &lt;/div&gt;&#125; // jsx 事件事件语法jsx for vue，所有的事件都按照react风格来 所有事件有on开头 所有事件名称首字母大写 例如：@click &#x3D;&gt; onClick @change &#x3D;&gt; onChange @drop &#x3D;&gt; onDrop 事件修饰符这里没有找到权威的资料，有小伙伴知道也请告知一下，目前建议大家通过原生JavaScript来实现vue事件修饰符的效果 .stop ： 阻止事件冒泡，在JSX中使用event.stopPropagation()来代替 .prevent：阻止默认行为，在JSX中使用event.preventDefault() 来代替 APIref与reactivevue3的template会自动解析ref的.value,在jsx中ref的.value是不会被自动解析的 1234//声明变量 let type = ref(1)&lt;p&gt;&#123;&#123; type &#125;&#125;&lt;/p&gt; // vue&lt;p&gt;&#123;type.value&#125;&lt;/p&gt; // jsx props在jsx for vue中，props的语法使用的就是setup的语法，实际表现形式完全一致 1234567891011export default defineComponent(&#123; props: [&#x27;title&#x27;], setup(props) &#123; onMounted(() =&gt; &#123; console.log(props.title); &#125;) return () =&gt; ( &lt;div&gt;&#123;props.title&#125;&lt;/div&gt; ) &#125;&#125;) emit同样与vue3的setup语法保持一致，注意子父方法需要符合react规范 123emit(&#x27;changeVisible&#x27;, false) // 子组件 &lt;xxx onChangeVisible=&#123;(params) =&gt; xxxFun(params)&#125;&gt;&lt;/xxx&gt; // 父组件 solt如何写插槽这里以antd for vue的Popover 气泡卡片，为例子 Vue3语法123456&lt;a-popover title=&quot;Title&quot;&gt; &lt;template #content&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/template&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; jsx for vue语法123456789&lt;a-popover title=&quot;Title&quot; content=&#123; &lt;&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/&gt; &#125;&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; 基础模板12345678910111213import &#123; defineComponent, onMounted, ref &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; // props: [&#x27;xx&#x27;], setup(props,&#123; emit &#125;) &#123; onMounted(() =&gt; &#123; // ... &#125;) return () =&gt; ( &lt;div&gt;&lt;/div&gt; ) &#125;&#125;) 结语 国内这方面资料比较少，查问题的时候注意vue版本，以及jsx的使用（render方式本文不适用） 如果代码里面存在问题，如果是ui框架，建议直接看react版本的代码，例如antdv的jsx版本直接看antd的实例代码 直接看jsx语法的项目代码，H5-YD.v2 不接受杠精，例如写jsx为啥不去用使用react 如果在学习过程中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"Vite配置alias（设置别名）","slug":"技术文章/vite配置alias","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2022/03/15/技术文章/vite配置alias/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/vite%E9%85%8D%E7%BD%AEalias/","excerpt":"","text":"Vite配置alias需要两步进行（TS项目） 1、修改vite.config.ts（让程序支持） 2、修改tsconfig.json（让编辑器支持） 修改vite配置12345678910111213141516171819import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;function _resolve(dir: string) &#123; return path.resolve(__dirname, dir)&#125;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], // 配置项目别名 resolve: &#123; alias: &#123; &#x27;@&#x27;: _resolve(&#x27;src&#x27;), &#125;, &#125;,&#125;) 修改tsconfig.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;noImplicitAny&quot;: false, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true, &quot;importHelpers&quot;: true, // 不让同样的辅助函数重复的出现在多个文件中 &quot;allowSyntheticDefaultImports&quot;: true, // 允许对不包含默认导出的模块使用默认导入。 &quot;baseUrl&quot;: &quot;.&quot;, // 非相对模块的导入可以相对于baseUrl或通过下文会讲到的路径映射来进行解析 &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot; ], &quot;paths&quot;: &#123; // 配置导出路径（这里根据自己项目执行修改） &quot;@/stores*&quot;: [ &quot;./src/stores*&quot; ], &quot;@/components*&quot;: [ &quot;./src/components*&quot; ], &quot;@/modules*&quot;: [ &quot;./src/modules*&quot; ], &quot;@/utils*&quot;: [ &quot;./src/utils*&quot; ], &#125;, &quot;types&quot;: [ &quot;element-plus/global&quot; ] &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot;, ], &quot;include&quot;: [ &quot;src/*&quot;, &quot;src/**/*.vue&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.jsx&quot;, &quot;src/**/*.ts&quot;, &quot;src/**/*.js&quot; ]&#125; 结语 修改后请重启编辑器 本文验证与2022年1月10号，mac，win双平台均有效，如果以上配置无效了，请查看相关api的改动 如果帮助你解决了问题，动动小手点个赞吧！:)","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"Vue3.x 预渲染 Unable to prerender all routes错误排查","slug":"技术文章/vue3.x 预渲染 Unable to prerender all routes错误排查","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2022/03/15/技术文章/vue3.x 预渲染 Unable to prerender all routes错误排查/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/vue3.x%20%E9%A2%84%E6%B8%B2%E6%9F%93%20Unable%20to%20prerender%20all%20routes%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/","excerpt":"","text":"前言​ BOOS最近对前几年做的公司官网不太满意，觉得没有有效体现公司的优势，表明随着公司这几年的努力发展，我们将会接触到更大规模的合作伙伴，自然要展示更好的企业形象，所以官网重做。 需求分析 没有交互的静态页面，但是存在大量动画 需要支持良好的SEO ​ 最早期的官网是vue2.x + webpack3.x + vue-cli-plugin-prerender-spa进行实现的，效果挺不错，很快各大搜索引擎就收录了我们的网站，所以这次我们打算沿用此方案，不过使用最新技术栈； 为什么不用vite​ 查阅vite的生态后，未找到类似prerender-spa的plugin，没办法支持预渲染，所以vite就被淘汰了。 为什么不用unxtjs​ 我们的官网不具备大量的接口交互，用Nnxtjs多少有点杀鸡用牛刀了，并且还需要使用pm2部署代码，付出于收获不成正比，被淘汰。 最终方案​ 我们部门是vue技术栈，团队不考虑react，通过以上排除法，只能使用vue3.x + webpack5.x + prerender-spa进行业务实现了。 技术实现基础模板我们使用最新的vue-cli进行项目搭建，选择vue3版本，最近的cli默认就是webpack5 安装预渲染插件1npm i prerender-spa-plugin -D 增加配置123456789101112131415161718const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)const path = require(&#x27;path&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, &#x27;dist&#x27;), routes: [&#x27;/xxx&#x27;], &#125;) ) &#125; &#125;,&#125;) 打包测试1npm run build 然后就出现一个错误 1[prerender-spa-plugin] Unable to prerender all routes! 让我们一起抽丝剥茧，看看报错的具体原因。 错误排查因为报错提示很模糊，我们打开他的源码，在源码line144发生错误的地方增加log，了解具体报错。 再次执行npm run build，得到真正的错误。 1Building for production...error TypeError: compilerFS.mkdirp is not a function ​ 我们继续最终源码发现 compilerFS 由webpack进行提供，我们带着错误前往webpack官网查询错误，于是就找到了Filesystems，因为这个插件已经好几年没有更新，而我们当前使用的是webpack5，出现了API变更的情况。 ​ 于此同时，根据错误提示，我们也在该库的issues中找到了历史讨论。 在讨论中，找到了两种解决方案 修改node_modules源码，使其兼容webpack5 1234567891011// From https://github.com/ahmadnassri/mkdirp-promise/blob/master/lib/index.js const mkdirp = function (dir, opts) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;\\ndir&#x27;, dir, opts, &#x27;\\n&#x27;); try &#123; compilerFS.mkdirp(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; catch(e) &#123; compilerFS.mkdir(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; &#125;) &#125; 使用已经被修改的库，感谢这位大哥 1npm i @dreysolano/prerender-spa-plugin 我们使用第二种方案，重新修改vue.config.js 12- const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)+ const PrerenderSPAPlugin = require(&#x27;@dreysolano/prerender-spa-plugin&#x27;) 然后再次打包测试 打包成功，通过启动本地服务器curl命令测试得知，SEO功能正常，未发现问题。 总结​ 使用prerender-spa-plugin打包出现报错[prerender-spa-plugin] Unable to prerender all routes!，更换库为**@dreysolano&#x2F;prerender-spa-plugin**，即可解决问题。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"写给前端新人的nginx教程","slug":"技术文章/前端工程师的nginx教程","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.088Z","comments":true,"path":"2022/03/15/技术文章/前端工程师的nginx教程/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84nginx%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言​ 我相信大部分前端新手是接触不到部署相关的工作的，一般都是将代码包交给后端，或者通过CI，FTP完成代码的更新，至于代码如何部署，如何从域名到前端代码包，很多前端仔没有实际操作过，自然是不知道的，这篇文章就是要帮助未接触过部署的人学会在服务器上线部署一个前端项目，在这个主线中带大家慢慢的熟悉nginx ​ 记得在2017年暑假，那时候大二还没开学，当时我只会写一点简单代码，linux和运维完全没接触过，一冲动在阿里云购买了一个服务器，外加一个域名，好像还是xiaowuasy.top,现在已经不能访问了；那时候单纯的兴趣使然，想搭建一个网站，因为实力不足，也不知道求助别人，前前后后折腾了一个月，最终竟然成功在服务器上面部署了wordpress服务，后面域名备案也成功了； ​ 这段经历是曲折的，依稀记得在盛夏的傍晚，我坐在慢慢暗下来的客厅，头上还残留着因为紧张流下的细汗，眼睛因为专注而干涩，面对不太看得懂的文档，一遍一遍尝试；我自然不希望大家在这上面浪费时间，这也是写这篇文章的初衷 前置知识 一个云服务器，阿里云，腾讯云，xx云都行，首次购买或者学生认证都是有很大的优惠（本文以阿里云为例子） 了解linux基础命令，也就是对各种文件的增删改查 本教程基于CentOS 7.5系统，如果是图形化界面，或者其他系统，命令可能不完全一致，但是流程都是一致的，建议看对应教程 如果linux基础命令不会。下面的也不用看了，立刻去学 搭建环境连接服务器通过远程工具（CRT，Xshell）或者自带的远程连接进入自己的服务器，连接方式选择公网ip 安装nginx CentOS自带yum命令，这个命令很关键，自行了解 执行命令 1yum install nginx // 终于遇到需要确认的，直接确认即可 安装完成后,主机中便有了nginx服务，相关命令如下，启动完成后 1nginx 启动完成后，浏览器访问公网IP,就可以访问到nginx的默认主页 到这一步就算是nginx部署成功了 nginx相关文件路径12/etc/nginx/ // 配置文件/usr/share/nginx/ // 默认前端代码存放处 ​ 默认配置在/etc/nginx/nginx.conf,nginx根据默认配置，监听80端口，80端口指定了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html这个文件夹，于是你访问公网ip -&gt; 公网ip:80 -&gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html,于是”Welcome to CentOS“便呈现在你的面前 ​ 如果你希望不显示默认的页面，而是显示你自己写的项目，直接替换/etc/nginx/nginx.conf中的root,字段为自己程序包的路径 在6666端口上搭建一个站点​ 我们的代码除了部署在默认80端口上面，还可以其他端口上，例如8888，7777，等等 ​ 接下来我们就在一个自定义的端口上面部署一个站点 ​ 这里我们需要注意nginx.conf中的一行配置 含义：在&#x2F;etc&#x2F;nginx&#x2F;conf.d下面所有nginx的配置文件都会自动生效 根据配置文件的提示我们到目标文件夹下面，建立test.conf，名字无所谓，配置文件里面是通配符匹配的 并通过vi 写入内容 123456server &#123; listen 7777; server_name _; root /usr/share/nginx/test;&#125; 再去文件夹/usr/share/nginx/test下建立一个index.html 123mkdir test cd testvi index.html 将一下内容放入index.html种 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是7777端口&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后重启nginx 1nginx -s reload 访问我们部署的项目ip:7777 然后你会发现访问不了，最终访问超时(&#x3D;&#x3D;)，这是因为服务器限制了可访问端口，此时需要到云管理后台设置安全组 在阿里云后台增加安全组规则 之后就可以正常访问了！ 至此，便完成了第一个nginx项目的部署 部署一个vue项目​ 通过上面的例子，我们已经可以完成一个自定义站点的部署了，那么真实项目呢，例如将一个vue项目部署到3006端口 首先编写xxx.conf 1234567891011121314151617181920server &#123; listen 3006; server_name _; # 开启gzip相关配置 gzip on; gzip_static on; gzip_min_length 2k; gzip_buffers 4 8k; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/x-icon application/javascript; gzip_comp_level 9; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 站点代码路径 root /usr/share/nginx/client; # 单页应用必须设置（刷新404问题） location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 将打包之后的代码，通过FTP上传代码到目标文件夹/usr/share/nginx/client（注意文件夹名称） ftp 重启nginx nginx -s reload 这边完成了一个站点的部署！是不是很简单 绑定域名​ 直接拿ip+端口给别人访问是不太好的，大家都给自己站点绑定上一个好记忆的域名，那么nginx如何绑定域名呢？ 购买一个域名https://wanwang.aliyun.com/domain/，备案域名，这个流程很麻烦，需要10-30天 备案完成后，域名就可以使用了 我们需要去修改我们的nginx配置，将server_name的值修改为需要绑定的域名即可； 1234server &#123; listen 3006; server_name xxx.com;// .... 增加https支持 申请一个https证书，数字证书管理，以阿里云为例子，国内云厂商都有 将证书放在服务器中你可以记得住的文件夹里面 修改nginx配置 12345678910111213141516171819202122232425server &#123; // # 将当前域名的http自动打到https listen 80; server_name xxx.com; rewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123; listen 443 ssl http2; server_name xxx.com; ssl_certificate xxxx/yy.pem; # 证书 ssl_certificate_key xxxx/yy.key; # 证书秘钥 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; root /usr/share/nginx/client; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 结语​ 虽然部署一个站点，仅仅是用到nginx，但是涉及到的知识点还是很多的 ​ 如果遇到了错误，一定要仔细检查报错信息，问题百度百度基本都能得到答案，如果实在搞不定，直接重做云服务器系统，重头再来；遇到问题并把它解决了，便成了你的技能 ​ 一个有经验的开发人员部署一个站点，可能半小时就弄完了，想要熟练的话，一定要多练习多实践，从0到1部署一个项目还是一件很酷的事情！ 如果搭建中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"浏览器读取xls并生成二维码下载到本地","slug":"技术文章/浏览器读取xls生成二维码并下载","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.088Z","comments":true,"path":"2022/03/15/技术文章/浏览器读取xls生成二维码并下载/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96xls%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"需求一次普通的技术需求会议 ​ 项目经理首先发言 我们技术这边需要将xls表格中的几千条数据变成二维码，并且中间镶嵌logo，图片底部放置编号，由于xls表格数据私密，不能通过第三方完成 ​ 平常这个事情都是后端处理的，前端就是来摸鱼的，但是这次一反常态，后端脸黑了，带样式搞不来，脚一蹬，直接装死 ​ 项目经理用期盼的眼神看着我，顿时我紧张了起来，眼神飘忽，我已经好多年没搞过node了啊！！会议室都沉默了，在项目经理不断精神攻击下，后端装死的情况下，看来注定要大前端来拯救世界了，毕竟JavaScript万能语言，俺来试试吧！ 实现方案​ 以上情节纯属虚构，但是需求确实是这样的，虽然好几年没碰过node，好歹年轻记性好，用过的基本都还记得，调研实现方案上没出现太多问题，有如下方案 puppeteer地址：https://github.com/puppeteer/puppeteer ​ 使用基于node环境的puppeteer，进行二维码绘制，图片绘制，是JavaScript开发者面对此类需求的主流选择 node-canvas地址：https://github.com/Automattic/node-canvas ​ 同样是在服务端完成渲染，但是这个库依赖node-gyp，如果不安装python2，那安装过程懂得都懂，不过这也是很不错的方案 浏览器​ 通过浏览器canvas绘制，然后下载下来，会有刷刷刷下载图片的炫酷效果 很明显有刷刷刷下载图片炫酷效果的方案更好，所以就选择你了 浏览器方案！ 问题分解确定了技术方案，就要考虑具体实现了 JavaScript读取execl文件，并处理成理想格式 将读取到的execl中的网址字段生成一张二维码 将二维码写入canvas，在其中间加上logo，并在底部加一行文字 将canva转化为DataURL，下载它 不断递归生成，直到xls数据全部处理完毕 理论存在，实践开始！ 具体实现启动一个本地服务器首先我们通过VScode Live Server 启动一个本地服务器 这里有好奇宝宝要问了，为啥第一步是这？ 答：因为浏览器是访问不了电脑的文件系统的，所以只能通过启动一个本地服务器的方案，来读取我们的资源文件 创建html，引入资源库分析需要用到的第三方开源库 解析xls https://github.com/sheetjs/sheetjs 生成QRcode https://github.com/soldair/node-qrcode 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生成二维码&lt;/title&gt; &lt;script src=&quot;./qrcode.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./xlsx.full.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 用于生成载体 最终生成的图片大小，按自己的需求来 --&gt; &lt;canvas width=&quot;260&quot; height=&quot;310&quot; id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; const ctx = initCanvas(); // 获取ctx实例 // 初始化画布 function initCanvas() &#123; const canvas = document.getElementById(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); return ctx; &#125; &lt;/script&gt;&lt;/html&gt; 解析xls文件1234567891011121314151617181920212223242526272829303132333435363738readWorkbookFromRemoteFile().then((res) =&gt; &#123; // res 为实际解析代码 [&#123;key:&#x27;xxxx&#x27;,value:&#x27;xxxx&#x27;&#125;,....]&#125;);// 读取xls信息，并处理function readWorkbookFromRemoteFile() &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;http://127.0.0.1:5500/xls.xls&quot;, true); xhr.responseType = &quot;arraybuffer&quot;; xhr.onload = (e) =&gt; &#123; if (xhr.status == 200) &#123; var data = new Uint8Array(xhr.response); var workbook = XLSX.read(data, &#123; type: &quot;array&quot; &#125;); // 获取实际表格长度（去除表头） let carryLen = 0; for (const key in workbook.Sheets[&quot;Sheet&quot;]) &#123; const ele = workbook.Sheets[&quot;Sheet&quot;][key]; if (key.includes(&quot;A&quot;)) &#123; carryLen++; &#125; &#125; // 解析数据 let xls = []; for (let i = 2; i &lt;= carryLen; i++) &#123; let data = workbook.Sheets[&quot;Sheet&quot;]; xls.push(&#123; key: data[&quot;A&quot; + i].w, value: data[&quot;B&quot; + i].w, &#125;); &#125; resolve(xls); &#125; &#125;; xhr.send(); &#125;);&#125; 看到这里肯定也有细心的好奇宝宝问，为啥循环体中的i为2呢? 答案：因为表格中的A1，B1为表格的第一行，而第一行是表头，要去除 将链接生成为二维码12345678910111213141516171819new Promise((resolve, reject) =&gt; &#123; // 生成二维码 QRCode.toDataURL( &#x27;xxxxxxx&#x27;, &#123; width: 260, height: 260, margin: 3, &#125;, (error, url) =&gt; &#123; if (error) console.error(error); const code = new Image(); code.src = url; code.onload = () =&gt; &#123; ctx.drawImage(code, 0, 0); resolve(code); &#125;; &#125; ); 写入中间logo12345678return new Promise((resolve, reject) =&gt; &#123; const code = new Image(); code.src = &quot;http://127.0.0.1:5500/logo.jpeg&quot;; code.onload = () =&gt; &#123; ctx.drawImage(code, 260 / 2 - 20, 260 / 2 - 20, 40, 40); resolve(); &#125;;&#125;); 写入底部文字123456// 写入编号ctx.font = &quot;24px Arial&quot;;ctx.fillStyle = &quot;#000&quot;;ctx.textAlign = &quot;center&quot;;ctx.textBaseline = &quot;middle&quot;;ctx.fillText(xls[index].value, 130, 270); canvas转化为图片，并下载到本地1234567// 用于预览let url = document.getElementById(&quot;canvas&quot;).toDataURL(&quot;image/png&quot;);var a = document.createElement(&quot;a&quot;); // 生成一个a元素var event = new MouseEvent(&quot;click&quot;); // 创建一个单击事件a.download = xls[index].value; // 将a的download属性设置为我们想要下载的图片名称，若name不存在则使用‘下载图片名称’作为默认名称a.href = url; // 将生成的URL设置为a.href属性a.dispatchEvent(event); // 触发a的单击事件 第一张图片，完成生成 递归调用我们修改发起逻辑代码，逻辑尾部增加递归调用就好啦 12345678910111213141516171819202122232425262728readWorkbookFromRemoteFile().then((res) =&gt; &#123; createImg(res, 0); // 递归生成&#125;);// ......// 实际生成逻辑function createImg(xls, index) &#123; new Promise((resolve, reject) =&gt; &#123; // 生成二维码 &#125;) .then((res) =&gt; &#123; // 生成中间logo &#125;) .then(() =&gt; &#123; // 写入编号 &#125;) .then(() =&gt; &#123; // 下载图片 &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; if (xls.length &gt; index + 1) &#123; ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); // 初始化画布 createImg(xls, index + 1); &#125; &#125;, 20); // 爱惜机器，加个延时，也可以去掉延时，体会机器的极致速度 &#125;);&#125; 最终效果 至此，终于实现了刷刷刷下载图片炫酷效果，此时可以脑部一段很快的rap，如果华佗再世，崇洋可以医治，外邦来学汉字…………… 最终生成的文件 最终代码地址 一定要针对该项目启动一个本地服务器，否则资源无法访问 web-Output-QRcode 结语​ 首先纠正一点，JavaScript开发者针对生成二维码类似的任务，首选肯定是puppeteer，使用浏览器绕个弯这种实现方案，多少带点科研味道，长期项目自然是不推荐的 ​ 带着学习的态度去完成需求，并且不断优化代码、总结问题，将遇到的未知知识点学会，（比如创建a链接，自动触发点击事件），这才是本文的目的。 ​ 感谢阅读，觉得还不错就点个赞吧~ ​ QQ交流群：530496237 大佬解答疑惑~（内有微信群二维码） ​","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"三个案例带你理解Event Loop流程","slug":"技术文章/聊一聊宏任务与微任务以及EventLoop","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.089Z","comments":true,"path":"2022/03/15/技术文章/聊一聊宏任务与微任务以及EventLoop/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E8%81%8A%E4%B8%80%E8%81%8A%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEventLoop/","excerpt":"","text":"为什么 JavaScript 需要 Event Loop JavaScript 在创建之初就确认了一点，JavaScript 是一门单线程语言，因为 JavaScript 主要提供用户互动以及操作 DOM，假定存在两个线程，同时对一个 Dom 进行操作，那究竟以谁为准呢，为了避免这种复杂性，JavaScript 确认了单线程这个核心概念 在单线程中，除了 JavaScript 本身的逻辑之外，还存在一些 IO 操作，例如从服务端获取数据，在单线程中就需要等待结果的返回才能继续下面的逻辑，这时候机器是挂起状态，为了避免这个低效问题，这里就引入了同步任务与异步任务的概念，依旧是是单线程，但是有些任务不等待其运行结果 于是同步任务都在函数执行栈（Stack）上执行，所有的异步任务，在有了运行结果之后，就会将其放入任务队列（callback queue），如果 Stack 中任务执行完毕，就会再去检查任务队列是否存在待执行的回调任务，将其任务放入 Stack，再执行，这里就会不断循环此操作 Stack 执行 - Stack 执行完毕 - 检查任务队列 - 将任务加入 Stack - Stack 执行，这样重复的过程就需要 Event Loop 来持续不断的循环检查任务队列，确保异步任务被准时加入到 Stack 相关名词介绍函数执行栈（Stask）：遵循后进先出原则，同步函数执行栈 webAPIs：异步任务的发起者，事件是首先进入 stack，例如 click，change，再将 callback 加入任务队列 回调队列（callback queue）：也可以被称为任务队列，回调函数到达了执行时机就会进入任务队列，他们将会被 Event Loop 持续打入函数执行栈 事件循环解析我们用 Event Loop 来解释一个简单的 demo 1234567consoleo.log(&quot;1&quot;);setTimeout(() =&gt; &#123; console.log(&quot;2&quot;);&#125;, 5000);console.log(&quot;3&quot;); 我相信大部分人都知道，这里打印的顺序为 1 3 2，下面我们用事件循环的流程来说明为什么是这个结果 注： cb 为 callback console.log(&#39;hi&#39;)，进栈 执行 出栈，打印 1 setTimeout进栈 执行 cb 加入异步队列 自身出栈 console.log(&#39;end&#39;)，进栈 执行 出栈 打印 3 5s 后，cb 加入任务队列，event Loop 检查当前执行栈是否存在函数，检查发现不存在，将 cb 加入函数执行栈 cb进栈 执行 出栈 打印 2 我们通过 event Loop 的角度进行解析，就能很轻易的解释为什么代码执行顺序是 1 3 2，这是非常简单的场景，接下来我们会分析一些更加有难度的代码 关于宏任务与微任务 通过上面的介绍，我相信大部分人都事件循环有一个基础的认知的，但是与以上我们通过简单的示例，演示了异步代码在事件循环中的运行流程，并没有涉及宏任务与微任务，这两货是什么呢，为什么要在这里出现？ 首先，宏任务（macrotask），微任务（microtask）都是异步任务 宏任务：setTimeout setInterval setImmediate I/O 键盘事件 网络事件 UI rendering 微任务：pormise MutationObserver process.nextTick 他们在执行层面上存在一定差异 例子 1123456789101112131415console.log(&quot;script start&quot;);setTimeout(function () &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);Promise.resolve() .then(function () &#123; console.log(&quot;promise1&quot;); &#125;) .then(function () &#123; console.log(&quot;promise2&quot;); &#125;);console.log(&quot;script end&quot;); 结果为 script start script end promise1 promise2 setTimeout pormise 与 setTimeout 虽然都是异步任务，但是上图的代码你会发现，promise 仿佛插队了，这便是宏任务与微任务在任务队列最大的不同之处 event Loop 在事件循环中,首先解析 script，将宏任务加入宏任务队列，将微任务加入微任务队列，栈空了之后，执行当前微任务，第一轮事件循环结束 在第二轮事件循环中，首先执行宏任务 callback 中的第一个，执行完毕，栈空了之后，再执行当前微任务，后面同理 例子 212345678910111213141516171819202122232425console.log(&quot;a&quot;);setTimeout(() =&gt; &#123; console.log(&quot;b&quot;); setTimeout(() =&gt; &#123; console.log(&quot;g&quot;); &#125;, 0); new Promise((resolve) =&gt; &#123; resolve(); &#125;).then(() =&gt; &#123; console.log(&quot;h&quot;); &#125;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&quot;c&quot;); resolve();&#125;) .then(function () &#123; console.log(&quot;d&quot;); &#125;) .then(function () &#123; console.log(&quot;e&quot;); &#125;);console.log(&quot;f&quot;); 大家可以先别看答案，自己先尝试将答案推算出来 第一轮事件循环console.log(&quot;a&quot;);进入栈 执行 出栈 打印 a setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 console.log(&quot;c&quot;);进入栈 执行 出栈 打印 c new Promise.then 进入微任务队列 console.log(&quot;f&quot;);进入栈 执行 出栈 打印 f new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;d&quot;)进入栈 执行 出栈 打印 d console.log(&quot;e&quot;)进入栈 执行 出栈 打印 e –微任务执行完毕 第一轮事件循环完毕– 结果为 a c f d e 第二轮事件循环第一轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;b&quot;) 进入栈 执行 出栈 打印 b setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 new Promise.then 进入微任务队列 new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;h&quot;)进入栈 执行 出栈 打印 h –微任务执行完毕 第二轮事件循环完毕– 结果为 b h 第三轮事件循环第二轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;g&quot;);进入栈 执行 出栈 打印 g —宏任务完毕，开始执行微任务— –微任务队列为空 第三轮事件循环完毕– 结果为 g 结果a c f d e b h g 宏&#x2F;微任务的结论通过上面三个例子，我们可以得出以下结论 函数执行栈中如果还存在函数，则等待其结束，才会继续事件循环 Event Loop 先执行同步任务，再微任务，下一轮循环，宏任务加入队列，执行，所以说先微任务，再宏任务是合理的 单次 Event Loop 中，只会执行一次宏任务，但是微任务可以一次执行多个 推荐文章做一些动图，学习一下 EventLoop 通过动图看 Event Loop 更加便于理解 总结 JavaScript 单线程语言的特性注定其需要异步队列，让网页交互体验上更加友好，对于开发来说，需要尽量了解其特性 首先我们需要了解事件循环机制，搞懂代码执行栈 异步队列的概念，再后面搞懂宏任务与微任务，读懂异步队列的运行机制，这样基本上就可以解决大部分 Event Loop 问题，了解宏任务 微任务 将会对代码执行顺序有更加底层的理解，这样就可以解决","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"JS数据结构与算法","slug":"算法与数据结构/JS数据结构与算法","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.091Z","comments":true,"path":"2022/03/15/算法与数据结构/JS数据结构与算法/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"数据结构为算法提供服务，算法围绕数据结构操作 时间复杂度 一个函数用大O表示，比如O(1)，O(n)，O(logN)… 定性描述该算法的运行时间 O(1)12let a = 1a += 1 每次执行改逻辑的时候，之后执行一次，复杂度不会随着时间的变化而变化 O(n)123for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; for循环里面的代码执行n次 O(1) + O(n) &#x3D; O(n)123456let a = 1a += 1for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; 两个时间复杂度先后排列就需要相加，相加的情况下低的的忽略不计，取更高的时间复杂度 O(n) * O(n) &#x3D; O(n ^ 2)12345for (let i = 0; i &lt; n; i += 1) &#123; for (let j = 0; j &lt; n; j += 1) &#123; console.log(i, j) &#125;&#125; 两个时间复杂度嵌套排列，时间复杂度就需要相乘 O(logN)$$对数函数：如果ax&#x3D;N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x&#x3D;loga$$ 12345let i = 1while(i &lt; n) &#123; console.log(i) i *= 2&#125; 这里的logN以2为底数，目的是就是求2的多少次方为N， 上面的代码while循环每次*2，实际上就是求2的多少次方为N，所以时间复杂度就是O(logN) 空间复杂度 一个函数用O表示，比如O(1)，O(n)，O(n^2) 算法在运行过程中临时占用存储空间的大小的量度 O(1)12let i = 0i += 1 声明了变量i，单个变量所占用的内存为1，所以空间复杂度为O(1) O(n)1234let list = []for (let i = 0; i &lt; n; i += 1) &#123; list.push(i)&#125; 声明了变量list，通过循环我们增加了n个值，相当于占用了n个内存单元，所以这段代码的空间复杂度为O(n) O(n^2)1234567const matrix = []for (let i = 0; i &lt; n; i += 1) &#123; matrix.push([]) for (let j = 0; j &lt; n; j += 1) &#123; matrix[i].push(j) &#125;&#125; O(n^2)实际上就是一个矩阵，矩阵的本质就是一个二维数据，存储了n的二次方的变量 小知识调试工具栏每个图标的作用 第一个箭头：程序运行到下一个断点，没有断点，程序执行完毕 第二个图标：一行一行执行代码 第三个图标：当前处如果调用了fun，点击此图标就会进入函数里面 第四个图标：点击跳出当前函数 第五个图标：重启调试 第六个图标：停止调试","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"基于PromiseA+，从零实现Promise","slug":"源码解读/promise的源码解读","date":"2021-12-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.090Z","comments":true,"path":"2021/12/15/源码解读/promise的源码解读/","link":"","permalink":"https://bluedancers.github.io/2021/12/15/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/promise%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"ECMAScript6中promise是划时代的API，他的出现解决了一直困扰前端开发者的异步问题，从此面对异步回调，我们有了更好的武器 前言​ 面对天天都能见面的promise，不知道你是否有以下的一些问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 为什么resolve之后才会执行then或者catch？ 为什么可以链式.then，并且还都会按同步进行？ 为什么执行promise.resolve()，后面的函数就支持promise了？ promise.all是如何实现的？ 是否被面试题中的promise题目迷惑的头晕目眩？ 让我们了解Promise的实现原理，所有问题答案自然浮出水面~ ​ promise在潜移默化之间帮助我们简化了复杂的异步代码，降低逻辑难度，说promise是划时代的异步解决方案也不为过，他很好的提现了开放封闭原则，解决耦合性过高的问题 ​ 说一个小知识，es6发布之前类似prmise的异步方案已经存在，在jquery的ajax中已经应用了类似的技术方案的jQuery.deferred()，感兴趣的同学可以去了解一下 123$.ajax(&quot;test.html&quot;).done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;).fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 简化版Primise 基础版本的实现虽然简单，但是解释了很多问题 建议将代码复制到本地，通过断点的方式查看代码的执行流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const PEDDING = &#x27;pending&#x27; // 等待状态const FULFILLED = &#x27;fulfilled&#x27; // 成功状态const REJECTED = &#x27;rejected&#x27; // 失败状态class APromise &#123; constructor(executor) &#123; this.status = PEDDING // 初始化状态 this.value = undefined // 成功的数据 this.reason = undefined // 失败的原因 this.onFulfilledCallbacks = [] // 保存成功状态的回调队列 this.onRejectCallbacks = [] // 保存失败状态的回调队列 const resolve = (data) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = FULFILLED this.value = data &#125; this.onFulfilledCallbacks.map((e) =&gt; e()) &#125; const reject = (err) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = REJECTED this.reason = err &#125; this.onRejectCallbacks.map((e) =&gt; e()) &#125; try &#123; executor(resolve, reject) &#125; catch (error) &#123; rejected(error) &#125; &#125; then(onFulfilled, onRejected) &#123; if (this.status == FULFILLED) &#123; onFulfilled(this.value) &#125; if (this.status == REJECTED) &#123; onRejected(this.reason) &#125; if (this.status == PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(this.value) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; &#125;&#125;new APromise((resolve, reject) =&gt; &#123; console.log(&#x27;开始回调&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;执行回调&#x27;) resolve(11111) &#125;, 1000)&#125;).then( (value) =&gt; &#123; console.log(&#x27;成功回调&#x27;, value) &#125;, (err) =&gt; &#123; console.log(&#x27;失败回调&#x27;, err) &#125;) 代码运行流程 初始化APromise，开始执行class中的constructor 在constructor中初始化当前promise的一些状态值以及resolve，reject函数 最后将resolve函数与reject函数以参数的形式给promise的回调函数，同时执行函数，打印开始回调 运行setTimeout，并且开始解析then函数 如果是成功，或者失败状态，直接执行回调，如果是pedding状态，则存储成功与失败回调函数 1s之后，setTimeout执行完毕，resolve执行触发constructor中的resolve resolve函数中执行之前初始化.then时候存储的回调函数，打印 成功回调，11111或者失败回调 逻辑流程图 基础版本的实现，不支持链式调用，不支持then穿透，不支持catch，只实现了最基础的逻辑 我们在这里解答一下前言中提出的问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 答：new的时候执行Promise中的constructor，声明了resolve与reject，并且在执行Promise回调函数的时候将参数传入到函数中 为什么resolve之后才会执行then或者catch？ 答：因为在初始化阶段，pedding状态下，我们存储了当前Promise的成功与失败回调，当执行resolve的时候，当前Promise的状态发生变化，开始执行之前存储的回调函数，如果不是padding，则立即执行回调函数 后面的问题我们暂时还无法解释，但是随着我们进一步的实现，答案都会浮出水面 正式版（链式回调，then值穿透，.catch 等）链式回调​ 我们一般写promise都会写多个.then，在多个.then中我们将异步代码变成同步代码块，但是我们基础版本的promise中无法显示链式调用，因为执行.then之后函数没有任何返回值，自然不会存在.then方法，在这个思路上，我们对promise的.then解析过程进行改写,尝试让其支持链式调用 每次.then中都需要返回一个promise来触发下一个.then 对then回调函数的各种情况需要进行判断，例如。then中返回的是一个string还是返回了一个promise，如果是则需要增加链式回调触发父级的resolve then函数执行需要通过settimeout进行包裹，让其加入宏任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * then可能返回的是普通值,也可能返回一个promise，这里的写法参照PromiseA+标准进行完成 * 逻辑较为复杂，可以先看静态变量代码逻辑，再看针对promise的处理逻辑 * @param &#123;*&#125; promise 当前promise * @param &#123;*&#125; x 当前返回值 * @param &#123;*&#125; resolve 成功回调 * @param &#123;*&#125; reject 失败回调 */const resolvePromise = (promise, x, resolve, reject) =&gt; &#123; if (promise === x) &#123; return reject(new TypeError(&#x27;检测到promise的循环调用&#x27;)) // &#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27; &#125; let called = false if ((typeof x === &#x27;object&#x27; &amp;&amp; x !== null) || typeof x === &#x27;function&#x27;) &#123; try &#123; const then = x.then if (typeof then === &#x27;function&#x27;) &#123; then.call( x, (y) =&gt; &#123; if (called) return called = true resolvePromise(promise, y, resolve, reject) &#125;, (r) =&gt; &#123; if (called) return called = true reject(r) &#125; ) &#125; else &#123; resolve(x) &#125; &#125; catch (err) &#123; if (called) return called = true reject(err) &#125; &#125; else &#123; resolve(x) &#125;&#125;then(onFulfilled, onRejected) &#123; let apromise = new APromise((resolve, reject) =&gt; &#123; if (this.status === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) &#125; &#125;) return apromise&#125; 经过上面的内部promise处理，函数的运行逻辑发生了很大的变化 我们直观看到的逻辑是 ​ 实际的运行逻辑是每次.then中都会再次创建一个Promise，以便于下次进行调用，并且对.then的回调函数进行处理，区分.then中返回了Promise对象还是普通对象，这样的思路实现了.then链式调用 当then中存在return promise的情况，逻辑会发生一些变化，这些主要体现在resolvePromise函数中 then值穿透首先查看一种场景 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then() .then() .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) ​ 这里我们就会发现，then的回调函数都不存在，自然无法将resolve的值传递到最下面的.then中，所以这里我们需要对这种情况做一些处理 123456789then(onFulfilled, onRejected) &#123; // 值穿透问题 如果then是空的话,就手动的将上一个resolve的值带入到下一个then中 onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : (data) =&gt; data onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err &#125; let apromise = new APromise((resolve, reject) =&gt; &#123; // .... &#125;) return apromise&#125; 当我们对then值中的回调函数进行处理后，实际运行的函数变成 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then((data) =&gt; data) .then((data) =&gt; data) .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) 这样便实现了then穿透问题 .catch目前我们错误回调在.then的第二个参数中，并不支持.catch的写法，我们可以在原型链上面增加catch方法 catch其实也是对.then方法的封装，只不过不存在成功回调，只有失败回调 123APromise.prototype.catch = function (errCallback) &#123; return this.then(null, errCallback)&#125; .finally 由于finally无法预知promise的最终状态，所以finally的回调函数中不接受任何参数，他仅用于无论最终结果都要执行的情况 需要注意的一点是如果finally中存在Promise，这需要等待promise执行完毕 123456789101112APromise.prototype.finally = function (callBack) &#123; return this.then( (data) =&gt; &#123; return APromise.resolve(callBack()).then(() =&gt; data) &#125;, (err) =&gt; &#123; return APromise.reject(callBack()).then(() =&gt; &#123; throw err &#125;) &#125; )&#125; 关于finally的小知识123Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 此时传递下去的是undefinedPromise.resolve(2).finally(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 传递下去的是 2，finally本身未接收参数，但是将上次的回调数据放入到了下次的回调 Promise.resolve() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回成功回调 12345APromise.resolve = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; resolve(data) &#125;)&#125; Promise.reject() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回失败回调 12345APromise.reject = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; reject(data) &#125;)&#125; Promise.race() 当调用race方法的时候，必须传入一个数组，数组中可以存在不同类型以及函数类型，在初始化过程中会再次创建一个promise，当数组中的某个promise对象最先执行的时候，触发自身的.then在回调函数中触发了race本身的resolve，后面执行完毕之后，因为race的状态已经发生了变化，自然无法再执行 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 同时执行多个promise,但是最返回最先返回的结果 * @param &#123;*&#125; promiseList * @returns */APromise.race = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须传递数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; promiseList.forEach((item) =&gt; &#123; if (item &amp;&amp; typeof item.then == &#x27;function&#x27;) &#123; item.then(resolve, reject) &#125; else &#123; resolve(item) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;ok2&#x27;) &#125;, 2000)&#125;)APromise.race([1, p1, p2]).then( (data) =&gt; &#123; console.log(&#x27;success1&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error1&#x27;, err) &#125;) Promise.all() all的实现逻辑非常简单，all的时候创建一个promise，内部记录当前传入的列表状态成功的单个数据，当所有的then数据都成功，调用自己的resolve，当有一个失败的时候，调用自己的reject 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 同时执行多个promise,会等待每次promise的结果,最后一起返回,有一个失败,这都不会返回 * @param &#123;&#125; promiseList * @returns */APromise.all = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resulteArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (key, val) =&gt; &#123; resulteArr[key] = val if (++currentIndex == len) &#123; resolve(resulteArr) &#125; &#125; for (let i = 0; i &lt; len; i++) &#123; const val = promiseList[i] if (val &amp;&amp; typeof val.then === &#x27;function&#x27;) &#123; val.then((data) =&gt; &#123; getResult(i, data) &#125;, reject) &#125; else &#123; getResult(i, val) &#125; &#125; &#125;)&#125;let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;); &#125;, 1000);&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;); &#125;, 2000);&#125;)Promise.all([1,2,3,p1,p2]).then(data =&gt; &#123; console.log(&#x27;success&#x27;, data);&#125;, err =&gt; &#123; console.log(&#x27;error&#x27;, err);&#125;) Promise.any() 实现方法与all非常相似，是all完全相反的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * any与all完全相反,只要有个一个成功就会返回成功,全部失败才会返回失败 * @param &#123;*&#125; promiseList * @returns */APromise.any = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, err) =&gt; &#123; resultArr[index] = err if (++currentIndex == len) &#123; reject(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then(resolve, (err) =&gt; &#123; getResult(index, err) &#125;) &#125; else &#123; resolve(res) &#125; &#125;) &#125;)&#125;let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.any([p3, p4]).then( (data) =&gt; &#123; console.log(&#x27;success&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error&#x27;, err) &#125;) Promise.allSettled() allSettled是ES2020加入的工具方法，一句话总结：他是永远都不会失败处理的promise.all 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 保存所有的成功与失败 * @param &#123;*&#125; promiseList * @returns */APromise.allSettled = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, data, status) =&gt; &#123; if (status == FULFILLED) &#123; resultArr.push(&#123; status: status, value: data, &#125;) &#125; if (status == REJECTED) &#123; resultArr.push(&#123; status: status, reason: data, &#125;) &#125; if (++currentIndex == len) &#123; resolve(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then( (data) =&gt; &#123; getResult(index, data, FULFILLED) &#125;, (err) =&gt; &#123; getResult(index, err, REJECTED) &#125; ) &#125; else &#123; getResult(index, res, FULFILLED) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;) &#125;, 2000)&#125;)let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.allSettled([1, 2, 3, p1, p2, p3, p4]).then((res) =&gt; &#123; console.log(&#x27;success&#x27;, res)&#125;) 测试函数首先需要安装测试脚本 npm install -g promises-aplus-tests 测试命令 promises-aplus-tests xxxx.js 测试文件末尾需要加入如下代码 不存在错误则为符合promiseA+标准 12345678910APromise.defer = APromise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new APromise((resolve, reject) =&gt; &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd&#125;module.exports = APromise 源码地址github-promise 可以通过chrome DevTool或者Vscode Debug的方式，加上断点，查看代码运行流程，便于理解promise运行逻辑 参考链接重学Promise，基于A+规范实现它，感谢掘金@关er的promise解读文章，大大降低了深入promise的门槛 PromiseA+规范 MDN-Promise 45道Promise面试题","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"简易版Reactivity源码解析","slug":"源码解读/简易版Reactivity源码解析","date":"2021-11-30T16:00:00.000Z","updated":"2022-12-11T13:51:24.090Z","comments":true,"path":"2021/12/01/源码解读/简易版Reactivity源码解析/","link":"","permalink":"https://bluedancers.github.io/2021/12/01/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AE%80%E6%98%93%E7%89%88Reactivity%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 首先感谢__mxin同学的简易版本，没有这个简化版本，我大概率也没办法沉下心来将代码读下去，再次表示感谢，通读下来简化之后的逻辑清晰，只需要对几个JavaScript原生API进行了解，走完代码流程，便了解了核心流程 代码地址：传送门 前置知识Proxy Reflect WeakMap 核心流程图​ 尝试绘制了一遍代码流程图，主要流程就是初始化时候对reactive，computed，effect的依赖收集，以及在触发set事件的时候，对收集到的依赖的触发 reactive123456789const object = &#123; r: 0, g: 0, b: 0, o: &#123; a: 1, &#125;, &#125; const proxy = reactive(object) ​ reactive是一个赋予对象响应式特征的方法，传入的数据会被proxy代理，变量一旦被代理，就将会被加入reactiveMap，以后都会触发reactiveMap内的proxy 12345678910111213141516171819202122232425262728/** * 定义响应式对象，返回proxy代理对象 * @param &#123;*&#125; object */function reactive(object) &#123;// 判断是否已经代理，已经存在直接取自 if (reactiveMap.has(object)) return reactiveMap.get(object) // 第一次进行处理，进行proxy代理 const proxy = new Proxy(object, &#123; // 处理器对象，定义捕获器 get(target, key) &#123; console.log(&#x27;get方法&#x27;, target, key) // 针对effect，computed依赖进行处理 track(target, key) // 如果当前代理的值为object类型，将会对当前的值再次进行proxy,否则直接获取数据 return typeof target[key] === &#x27;object&#x27; ? reactive(target[key]) : Reflect.get(...arguments) &#125;, set(target, key) &#123; console.log(&#x27;设置的值&#x27;, ...arguments) // 在set事件中对原本的数据进行修改 Reflect.set(...arguments) // trigger(target, key) &#125;, &#125;) reactiveMap.set(object, proxy) return proxy&#125; 完成代理的数据 effect effect会在依赖的经过reactive处理后的对象发生变化的时候，自动执行一次回调函数，通常称它为副作用函数 effect的实现是Reactivity最核心的部分，也是比较难理解的部分，依赖WeakMap进行实现，如果不了解WeakMap，务必先去看一下文档 1234567const computedObj = computed(() =&gt; &#123; return proxy.r * 2&#125;)effect(() =&gt; &#123; console.log(`proxy.o.a: $&#123;proxy.o.a&#125;`)&#125;) 初始化的过程中触发effect，将函数fn放入effectStack，同时执行effect中的函数，一旦执行，必定会触发经过reactive代理的get函数，进行数据获取 123456789101112131415161718192021222324252627282930313233343536373839404142const effectStack = [] // 收集副作用函数/** * 副作用函数 */function effect(fn) &#123; try &#123; // 将需要执行的effect入栈 effectStack.push(fn) // **** 执行该effect，进入proxy的get拦截 **** return fn() &#125; finally &#123; // 依赖收集完毕及所有get流程走完，当前effect出栈 effectStack.pop() &#125;&#125;// ......// get方法触发了track方法get(target, key) &#123; // .... track(target, key) // ....&#125;/** * 依赖收集 */function track(target, key) &#123; // 初始化依赖Map let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; // 第二层依赖使用Set存放key对应的effect let dep = depsMap.get(key) if (!dep) &#123; targetMap.get(target).set(key, (dep = new Set())) &#125; // 取当前栈中的effect存入第二层依赖中 const activeEffect = effectStack[effectStack.length - 1] activeEffect &amp;&amp; dep.add(activeEffect) // 最后触发effect函数的finally，将处理完毕的effect进行弹出，完成依赖收集&#125; 初始化完成后，effect全部完成处理，我们可以看一下targetMap的数据 我们可以看到，变量a与effect中的函数关联在了一起，经过track处理后，effect内部用到的变量都与effect建立了某种关联，至此我们就完成了依赖收集 computedReactivity计算属性的实现是依赖effect进行实现，仅仅是增加了一个value函数进行包裹 12345678910/** * 计算属性 */function computed(fn) &#123; return &#123; get value() &#123; return effect(fn) &#125;, &#125;&#125; 变量发生变化数据发生变化的时候，例如我们将proxy.o.a&#x3D;1,他是如何完成响应式，以及effect的触发的呢？ 首先一定是触发proxy的set函数 123456789101112131415161718192021222324set(target, key) // 修改代理的值 Reflect.set(...arguments) // 等同于arguments[0][arguments[1]] = arguments[2] // 触发依赖收集器 trigger(target, key)&#125;, /** * 依赖收集触发器 */function trigger(target, key) &#123; // target: &#123;a:1&#125; key: a // 获取当前修改的值 const depMap = targetMap.get(target) // 开始执行effect方法 if (depMap) &#123; // 如果存在，开始寻找Map的value，在通过key找到对应的回调函数 const effects = depMap.get(key) effects &amp;&amp; effects.forEach((run) =&gt; &#123; // 执行收集的effect函数 run() &#125;) &#125;&#125; 至此完成数据的响应式，effect的函数触发完成 关键概念reactive 创建响应式对象 effect 副作用函数，存储匿名函数，同时调用自身收集依赖，最后弹出匿名函数 computed 计算属性，其原理是对effect的包装 track 收集依赖，绑定变量与使用该变量的effect trigger 触发依赖，根据变量触发对应的effect 总结​ 这个文章是一个代码记录贴，希望大家看到可以静下心来看看__mxin同学的文章，或者传送门代码，了解了基础的原理后再去看@vue&#x2F;Reactivity的代码，将会事半功倍； ​ 日积月累，将知识变成你的财富吧","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"React17学习记录","slug":"技术文章/react17学习","date":"2021-10-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2021/10/15/技术文章/react17学习/","link":"","permalink":"https://bluedancers.github.io/2021/10/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/react17%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"为什么学习React17​ 公司使用的是vue技术栈，并且因为历史原因，以及外部因素，可能不会使用react来做生产环境的项目，最近vue3走上正轨，大家都需要抛弃vue2.x的编码思想，在vue3中，hook思想开始越发明显，所以学习react17也是想借此加深对hook的理解，同时取长补短，综合vue与react的优点，在实际的开发中更好的完成开发任务 useState的疑问​ 关于react的useState有一个疑问，useState里面是一个对象，我想要修改对象里面的某一个字段，每次都需要...state,把之前的数据预先填入，这做法感觉有点傻 自定义hookhook是在特定换下调用自己的代码 实现自定义hook必须使用关键字use开头，这是ESLint的规则 自定义hook一般用于需要持续监听的值，而针对纯工具函数则不需要进行处理 实现一个hook风格的防抖函数1234567891011121314151617181920212223242526const [param, setParam] = useState(&#x27;ha ha&#x27;);const debounceParam = useDebounce(param, 2000);useEffect(() =&gt; &#123; console.log(&#x27;log log&#x27;)&#125;, [debounceParam]);/** * 去抖函数 * @param value 监听的值 * @param delay 防抖时间 * @returns 变化后变量 */export function useDebounce(value, delay) &#123; // 声明一个保存防抖结果的字段 const [debounceValue, setDebounceValue] = useState(value); useEffect(() =&gt; &#123; // 每次value,delay发生变化的时候生成一个定时器 const timeout = setTimeout(() =&gt; &#123; setDebounceValue(value); &#125;, delay); // 在执行下一个useEffect之前,会执行上一个useEffect的返回函数 return () =&gt; clearTimeout(timeout); &#125;, [value, delay]); return debounceValue;&#125; useDebounce是一个hook风格的函数 每次param发生变化都会触发useDebounce中的useEffect 而在2000ms时间内如果重复触发就会执行上一个effect return的函数 进而不修改debounceValue，直到2000ms内无任何操作，触发setDebounceValue修改属性，改变了debounceParam 第一个useEffect触发，触发打印log log react中使用TS做代码静态检查 函数类型 fn: () =&gt; void any类型是危险的，应当尽量不用，但是对于模糊的类型，我们可以在标注类型为unknown，这样就不会对赋值做任何校验，但是ts不允许我们对unknown类型做出任何处理，所以可以吧unknown理解成为加强版any 针对参数不固定，返回值不确定的场景，应当使用泛型，在方法名称后面加,然后在参数上指定某一个为T，则T跟这参数的类型而变化 自定义hook useArray 传入一个hook，我们返回针对这个hook的可使用的对应方法，总体来说实现一个hook还是一个比较简单 1234567891011121314151617181920212223242526/** * hook处理的Array * @param value * @returns */export function useArray&lt;V&gt;(value: V[]) &#123; const [arrayValue, setArrayValue] = useState(value); const clear = () =&gt; &#123; setArrayValue([]); &#125;; const add = (value: V) =&gt; &#123; setArrayValue([...arrayValue, value]); &#125;; const removeIndex = (index: number) =&gt; &#123; let value = [...arrayValue]; value.splice(index, 1); setArrayValue(value); &#125;; return &#123; value: arrayValue, add, clear, removeIndex, &#125;;&#125; 关于TS中interface的属性继承123456789101112131415161718interface a &#123; a: number;&#125;interface b extends a &#123; b: number;&#125;let c: b = &#123; a: 1, b: 2,&#125;;function test(p: a) &#123; console.log(p);&#125;test(c); // 不会报错，因为b包含了a，所以这个传入b也不会出现错误 useContext useContext主要用于多个组件之间共享状态 在parent组件中存在child1.child2，child3组件，我们希望这些组件之前都共享一个状态1 生成createContext 1const TestContext = React.createContext(&#123;&#125;); 使用createContext.Provider包裹parent组件 1234567891011&lt;TestContext.Provider value=&#123;&#123; username: &#x27;我是变量&#x27;, &#125;&#125;&gt; &lt;div className=&quot;parent&quot;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;Child3 /&gt; &lt;/div&gt;&lt;TestContext.Provider/&gt; 在子组件中就可以使用useContext来获取父级创建的TestContext 12345678const Child1 = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext); return ( &lt;div className=&quot;child1&quot;&gt; &lt;p&gt;1 message for &#123;username&#125;&lt;/p&gt; &lt;/div&gt; )&#125; 通过useContext就可以做到子组件共享一个状态，如果状态被改变，所有使用变量的都放都会发生变化 TS类型的一些知识Parameters 获取函数的全部参数，并且以元祖类型进行返回,Utiltity Types 123456function test(a: string, b: number, c: number[], d: any) &#123;&#125;// 直接继承test函数的全部参数类型function testPlus(...[a, b, c, d]: Parameters&lt;typeof test&gt;) &#123; console.log(a, b, c, d);&#125; 联合类型12345678910111213141516let a:string | number; // 可以是多种类型// 抽象联合类型type aType:string | number;let a:aType// 也可以通过interface可以实现类型功能，但是指定单个类型是无法实现的，但是interface的全部功能type都可以实现// 例如：interface aaa &#123; a:string&#125;type aaa = &#123; a:string&#125;// 以上2种效果都是一致的 js的typeof与ts的typeof123// js: typeof runtime阶段运行 检查参数的类型// ts: typeof 静态检查阶段运行 识别函数的参数 Partial与Omit关键字123456789101112131415type Preson = &#123; name: string; age: String; sex: string;&#125;;// Partial关键字会将传入的类型处理成为非必填const xiaoMin: Partial&lt;Preson&gt; = &#123; age: &quot;非必填&quot;, name: &quot;非必填&quot;, sex: &quot;非必填&quot;,&#125;;// Omit 会删除第一个参数 类型 中的第二个参数中的变量 并返回结果 例如这里删除 name ageconst shenMiRen: Omit&lt;Preson, &quot;age&quot; | &quot;name&quot;&gt; = &#123; sex: &quot;男&quot; &#125;; 关于css一些不知道的关于remem表示相对于父级的font-size rem表示相对于根元素html的font-size 正常默认font-size为16px，那么1rem &#x3D;&#x3D;&#x3D; 16px 如果希望rem的比例自定义只需要将html的font-size设置为对应的百分就行，例如设置为62.5的时候1rem &#x3D;&#x3D;&#x3D; 10px 关于vhvh的全称为viewport height，100vh就是代表视口的高度 emotion emotion是一个css in js的方案，也就是使用js来写css代码，这样的话就可以在css中直接写逻辑 12345678910111213import styled from &quot;@emotion/styled&quot;;export const Row = styled.div&lt;&#123; gap: number;&#125;&gt;` display: flex; align-items: center; &gt; * &#123; margin-top: 0 !important; margin-bottom: 0 !important; margin-right: $&#123;(props) =&gt; `$&#123;props.gap&#125;rem`&#125;; &#125;`; 自定义hook useAsync的实现 useAsync可以理解为针对请求体再次封装，经过封装之后的请求体，自带请求进度，以及针对catch更加优雅的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; useState &#125; from &quot;react&quot;;interface State&lt;D&gt; &#123; error: Error | null; data: D | null; status: &quot;idle&quot; | &quot;loading&quot; | &quot;error&quot; | &quot;success&quot;;&#125;// 建立初始化的值const defaultState: State&lt;null&gt; = &#123; data: null, error: null, status: &quot;idle&quot;,&#125;;// 实现函数export const useAsync = &lt;D&gt;(initState?: State&lt;D&gt;) =&gt; &#123; // 默认状态 const [state, setState] = useState&lt;State&lt;D&gt;&gt;(&#123; ...defaultState, ...initState, &#125;); // 请求成功的调用 const setData = (data: D) =&gt; &#123; setState(&#123; data, status: &quot;success&quot;, error: null, &#125;); &#125;; // 请求失败的调用 const setError = (error: Error) =&gt; &#123; setState(&#123; data: null, error: error, status: &quot;error&quot;, &#125;); &#125;; // 请求开始的调用 const setLoading = () =&gt; &#123; setState(&#123; data: null, error: null, status: &quot;loading&quot;, &#125;); &#125;; // 对外实际执行的函数 const run = (promise: Promise&lt;D&gt;) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&quot;请传入 promise 类型数据&quot;); &#125; setLoading(); return promise .then((data) =&gt; &#123; setData(data); &#125;) .catch((err) =&gt; &#123; setError(err); &#125;); &#125;; return &#123; isIdle: state.status == &quot;idle&quot;, isLoading: state.status == &quot;loading&quot;, isError: state.status == &quot;error&quot;, isSuccess: state.status == &quot;success&quot;, run, setData, setLoading, setError, ...state, &#125;;&#125;; 使用阶段 12345678// 逻辑顶部应用相关逻辑 const projectData = useAsync&lt;any[]&gt;(); // 泛型为后台返回的数据的类型// 启动请求，传入请求体projectData.run(request);// 请求完成后，projectData中的数据状态会被同步更新let &#123; data, isLoading,isError,...other&#125; = projectData react中实现捕捉边界错误 关于错误边界的概念在react官网中是这样描述的，组件内的JavaScript错误会导致React的内部状态被破坏，并且在下一次的渲染时会产生可能无法追踪的错误，但是部分ui的JavaScript错误不应该导致整个应用的崩溃，所以react16中引入了错误边界的概念， 错误边界是一种react组件，最终组件可以捕获发生在其朱组件树任何位置的JavaScript错误，并打印错误，同时展示降级ui，而并不会渲染发生崩溃的子组件树，错误边界在渲染期间，生命周期方法和整个组件数的构造函数中捕获错误 123456789101112131415161718192021222324252627282930import React, &#123; ReactNode &#125; from &quot;react&quot;;type FallBackRender = (props: &#123; error: Error | null &#125;) =&gt; React.ReactElement;// 1 2 两种写法一致type Components1 = &#123; children: ReactNode; fallbackRender: FallBackRender &#125;;type Components2 = React.PropsWithChildren&lt;&#123; fallbackRender: FallBackRender &#125;&gt;;export class ErrorBoundary extends React.Component&lt; Components2, &#123; error: Error | null &#125;&gt; &#123; state = &#123; error: null, &#125;; // 当子组件抛出异常, state中的errir就会被调用 static getDerivedStateFromError(error: Error) &#123; return &#123; error &#125;; &#125; render() &#123; const &#123; error &#125; = this.state; const &#123; fallbackRender, children &#125; = this.props; if (error) &#123; console.log(&quot;错误执行&quot;, error); return fallbackRender(error); &#125; else &#123; return children; &#125; &#125;&#125; 使用App.tsx 123456789&lt;ErrorBoundary fallbackRender=&#123;fallPageErrorFallback&#125;&gt; &#123;user ? &lt;AuthenicatedApp /&gt; : &lt;UnAuthenicated /&gt;&#125;&lt;/ErrorBoundary&gt;// 发生错误的时候就会渲染这个domexport const fallPageErrorFallback = (&#123; error &#125;: &#123; error: Error | null &#125;) =&gt; ( &lt;p&gt;请求失败了,错误信息&#123;error&#125;&lt;/p&gt;); 阶段性结束 关于react hook的理念学习已经结束了，这段时间学习来看，确实react在很多方面更加易于理解，更加工程化，同时也学会了很多ts的知识，一直以来ts在我手中都是anyscript，本次学习让我对ts的运用更加熟练；在这个过程中也学会了很多hook相关的理念以及实例，并且可以带着这思想去优化项目代码 可惜我是一名vuer，继续学习react的实际编码，意义已经不是很大，所以关于这个课程的学习，本次告一段落；通过本次学习，非常深刻的体会到了hook的优雅，后面会深入学习vue3，在vue3中将hook与业务结合，让代码更加健壮","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"关于“输出”这件事","slug":"日常/关于记录这件事","date":"2021-09-11T16:00:00.000Z","updated":"2022-12-11T13:51:24.090Z","comments":true,"path":"2021/09/12/日常/关于记录这件事/","link":"","permalink":"https://bluedancers.github.io/2021/09/12/%E6%97%A5%E5%B8%B8/%E5%85%B3%E4%BA%8E%E8%AE%B0%E5%BD%95%E8%BF%99%E4%BB%B6%E4%BA%8B/","excerpt":"","text":"​ 这段时间工作比较忙，没有输出，倒也不是懒，不想输出，而是最近工作上事情非常杂乱，并且工作角色发生转变后，工作内容也跟着发生了很大变化，而我又是一个做事追求完美的人，所以这段时间很多杂七杂八的事情让我焦头烂额，关于工作的事情日后再谈吧，今天聊聊输出这件事情 举个栗子​ 在聊聊输出之前，我先说一个日常的例子。 ​ 去年夏天，我爸妈给了一些茶叶，虽然一直没有喝茶叶的习惯，但是本着不浪费的心态，便从犄角旮旯里找到了不知几年前的双层玻璃杯。 大概是这样的 ​ 这种茶杯喝茶叶确实还可以，我逐渐便养成了喝茶叶的习惯，可惜好景不长，不小心摔碎了，之后又从爸妈那里拿了一个双层玻璃杯，依旧好景不长，玻璃杯又碎了，后面我想，这一直碎下去不是个办法，便买了一个茶叶过滤器。 ​ 心想这次不需要再担心杯子碎掉的问题了，到手使用了一段时间后便发现与我现象的不一样，这玩意特别不方便清理，每次拆卸特别麻烦，并且每次都需要手接触，感觉很不卫生，于是喝茶叶的习惯便与我渐行渐远。 ​ ​ 通过这个小事，大家就能发现一个习惯的形成与良好的体验有非常大的关系，并且就算大众方案也不一定就是相对个人的最佳方案 ，例如有些人使用双层玻璃杯易碎（比如我），有些人觉得不美观，这些问题都会导致一个习惯无法形成； ​ 即使当事人存在内在动机，但是不理想的外在因素也会导致最终意愿无法未达成。输出也是这样，即使有一个想输出的心，但是没有良好的输出环境，也可能造成输出习惯的养成失败。 ​ 工欲善其事，必先利其器；一个适合自己的编写环境是如此的重要。 输出工具的选择​ 在我还没有正式工作之前，就接触到了Typora，简单高效的语法 + 所见即所的功能，让我至今都离不开Typora ​ 但是随着1.0版本后的收费以及自身不具备生态能力，让我在多个设备切换上造成了很大的困扰，虽然我几乎所有的文档都在github上，但是因为未知原因，每次pull push失败的可能性很大，所以谈不上好的体验。 ​ 后来接触了【羽雀】 【飞书】 【wolai】 【Notion】，这些专业工具中最让我感觉眼前一亮的是“Notion”，其强大的all-in-one理念确实实现的不错，但是因为他是国外软件，分享出去的链接，别人偶尔会打不开，亦或者打开速度缓慢，这让我心里非常犹豫，结果兜兜转转还是回到Typora（作者使用的是免费版本）。 ​ 关于各种工具，各位同学可以都试用一下，没有好与坏，只有合适或者不合适，目的是选择一个最适合自己的，自己最满意的文档记录工具。 在这个过程中我也参考了别人的一些工具集，最终确定了以下方案 坚果云 + Typora + Picgo + 七牛云 坚果云：同步文件夹资料，补充Typora不具备的云功能 Picgo + 七牛云：解决图片资源上云问题 ​ 目前这一套使用感觉还可以，比较满足个人开发角色的需求，除了安装部署有点麻烦，使用过程·中仅需要关注输出本身；如果大家有什么比较好的方案，也请评论区推荐~ 输出的意义​ 为什么要输出？为什么要把自己的劳动成果开放给还不相关的人？ ​ 因为输出会让你更加了解你正在输出的内容，很多事情，在编程世界，其实过程比结果更加重要，也许某一篇博客的一段话，是作者花费很多时间，经过多方论证得到的结论；而相对于结论，多方论证的过程对于当事人更加具有价值。 ​ 在输出中我个人非常推崇费曼学习法，在写作中我们带入费曼学习法 ​ 首先将文章的全部内容输出出来，再这个过程中带入阅读者角色，思考他们需要知道些什么。 ​ 然后便是回顾，通读自己的文章，看看是否存在论点不足的情况，在这一步可以交给你的同事、同行，从第三者视角在看看 ​ 获得反馈后回到原始资源，再次学习，再次输出，在二次输出的过程中简化文章，查缺补漏； ​ 最后便是传授，在确保自己理解没有问题后，便输出到社区，教会另一个人，经过了费曼学习法的过程，你面对读者的任何问题，都可以给出合理解释。 ​ 在这样长期的成长性思维中，你的深入思考会让你的个人能力越加厚重，同样是三年开发，你的’功力’便更显深厚，同时高质量的输出也帮助了其他人，这样一劳多得的事我们有什么理由不去做呢？ ​ 这里就有同学说了，我做业务开发没啥深度，写的文章也没人看，甚至怕输出错误的关键，没有任何动力啊。 ​ 我想告诉大家，这是非常非常正常的现象，回想刚开始写代码的时候，是不是也是磕磕盼盼不自信，没有人可以一开始就达到高水平状态，都是需要慢慢练习。 遇到实现问题，输出问题记录文章 闲暇时间可以解读、实现一些常用函数的源码解读文章 针对业务难题可以输出核心方案实现文章 ​ 最开始可以仅仅输出给自己看，将自己作为一名读者，看看是否能轻松看懂你想表述的含义，在这个过程中要记住，输出是为了在深度学习中加深自己的理解 ​ 将反复优化的文章发布到社区，是为了验证自己的理解是否正确，是否有价值，在这个过程中如果能帮助到别人，那是锦上添花的事情，即使没人阅读，无人点赞，你已经得到你深度学习的目。 ​ 在这个过程中，你的沉淀会越来越深，核心竞争力越来越强，输出的文章也会越发高质量，进入不断增长的正向循环。 最后​ 说了这么多输出的好处，其实都是内在因素，需要当事人发自内心的认同，正确的认识输出的价值。 ​ 而我们可以控制的外在因素是如果通过工具创造更好的输出环境，这也是我想告诉大家的一点，一个较好的输出环境，会对输出起到正面作用，提升当事人的输出意愿。 ​ 如果在输出上出现太多门槛，最终会造成当事人失去输出意愿；不进行输出世界不会有任何影响，依旧有很多人认识到输出的重要性，损失最大的是失去深度学习机会的自己。","categories":[{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"输出","slug":"输出","permalink":"https://bluedancers.github.io/tags/%E8%BE%93%E5%87%BA/"}]},{"title":"JS文件格式相互转换","slug":"技术文章/JavaScript 文件格式互转","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.086Z","comments":true,"path":"2021/06/15/技术文章/JavaScript 文件格式互转/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/JavaScript%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%92%E8%BD%AC/","excerpt":"","text":"base64 转 File1234567891011121314151617181920/** * base64转file文件 * @param dataurl * @param filename * @returns */ export function dataURLtoFile(dataurl: string, filename: string) &#123; // 获取到base64编码 const arr = dataurl.split(&#x27;,&#x27;) // 将base64编码转为字符串 const bstr = window.atob(arr[1]) let n = bstr.length const u8arr = new Uint8Array(n) // 创建初始化为0的，包含length个元素的无符号整型数组 while (n--) &#123; u8arr[n] = bstr.charCodeAt(n) &#125; return new File([u8arr], filename, &#123; type: &#x27;image/jpeg&#x27;, &#125;)&#125; base64 转 blob12345678910111213141516/** * base64转blob文件 * @param dataURI * @returns */export function dataURItoBlob(dataURI) &#123; var mimeString = dataURI.split(&#x27;,&#x27;)[0].split(&#x27;:&#x27;)[1].split(&#x27;;&#x27;)[0] // mime类型 var byteString = atob(dataURI.split(&#x27;,&#x27;)[1]) //base64 解码 var arrayBuffer = new ArrayBuffer(byteString.length) //创建缓冲数组 var intArray = new Uint8Array(arrayBuffer) //创建视图 for (var i = 0; i &lt; byteString.length; i++) &#123; intArray[i] = byteString.charCodeAt(i) &#125; return new Blob([intArray], &#123; type: mimeString &#125;)&#125; blob转url1234567891011121314151617181920/** * blob 转 url * @param base64 * @param contentType * @returns */export function translateBase64ImgToBlob(base64, contentType) &#123; var arr = base64.split(&#x27;,&#x27;) //去掉base64格式图片的头部 var bstr = atob(arr[1]) //atob()方法将数据解码 var leng = bstr.length var u8arr = new Uint8Array(leng) while (leng--) &#123; u8arr[leng] = bstr.charCodeAt(leng) //返回指定位置的字符的 Unicode 编码 &#125; var blob = new Blob([u8arr], &#123; type: contentType &#125;) var blobImg: any = &#123;&#125; blobImg.url = URL.createObjectURL(blob) //创建URL blobImg.name = new Date().getTime() + &#x27;.png&#x27; return blobImg&#125;","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"在Option API中使用 Custom hook","slug":"技术文章/使用reactivity 在vue2中编写hook函数","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.088Z","comments":true,"path":"2021/06/15/技术文章/使用reactivity 在vue2中编写hook函数/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E4%BD%BF%E7%94%A8reactivity%20%E5%9C%A8vue2%E4%B8%AD%E7%BC%96%E5%86%99hook%E5%87%BD%E6%95%B0/","excerpt":"","text":"适应人群： 项目的vue2.x的版本， 还没在正式环境使用过composition API 但是又想享受hook带来的优势 ​ 注：本文提出的方法并非最佳实践，而是是vue2项目渐进式切换到vue3的方案，保留的大家熟悉的编写方式，也保留了hook的优势，如果开发团队条件允许的话，建议直接使用composition API语法来完成逻辑编写 什么是hook​ hook 翻译过来是钩子，在程序上体现为在行为执行之前，先把行为勾住，不让其继续，优先执行你的hook函数 用一张图来表示即为 左边为正常函数执行流程，右边为存在hook的执行流程 没有hook之前，我们如何对待代码复用​ 我们假设一种场景，你正在开发一个后台管理系统，在这个后台管理系统中，大部分都是查询表单，他们虽然业务不同，但是逻辑上存在一定的共性 共性元素：查询条件 列表数据 分页相关数据 加载状态 以上4个特征几乎每个表单都有，这就意味这你在写每一个表单的时候都需要重复对接相关的逻辑，这个问题在vue2中存在两种解决办法 每次都复制逻辑相同的代码 使用vue mixins完成逻辑公用 然而这2种方式都存在问题 复制代码低效率，虽然相对稳定，但是编码与测试工作量较大 vue mixins可以实现逻辑抽象，但是这种方案过于简单粗暴的方案，数据全局共享，过多使用mixin会导致项目走向失控，是一个比较危险的方案 假设表单页面数据结构如下 12345678&#123; data: [], // 列表数据 currentPage: 1, // 当前页面 pageSize: 0, // 每一个分页的数量 thePageSize: 0, // 本页数量 totalPages: 0, // 总页数 totalSize: 0, // 总记录数&#125; 除了以上后端返回的数据，我们还需要在页面增加一些状态值,用于优化用户体验 1status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;error&#x27; | &#x27;success&#x27; | ... // 当前列表请求的状态 以上的数据 + 状态每一个后台表单页面都存在，这就意味着重复的声明，重复的对接，重复的测试 ​ 复制代码的方式看似稳定，实则不稳定，因为每一次都要对重复逻辑进行测试，并且由于此类工作繁琐且重复劳动，开发人员一般比较抵触此类任务 ​ 这个问题在vue2中并没有非常好的解决方案，针对这个问题隔壁react从mixin到HOC最后到现在hook，给出了还不错的解决方案。 ​ 现在@vue&#x2F;composition-api提供了hook的能力，我们可以在vue中使用hook来优化提出的问题 通过hook来完成逻辑共用​ 接着上面的场景，我们现在假设我们有3个后台表单页面需要写 ​ 传统编码方案（未使用hook） ​ 可以看到我们需要写的三个页面流程上存在很多相似的地方，对接数据环节，虽然是大部分代码相同，但是还是需要重复的编写测试，例如页码相关，状态相关逻辑 ​ 使用hook完成重复逻辑抽象 每次调用useHook都会生成一次独立的状态 虽然状态与逻辑依赖与组件，但是useHook可以在组件外部进行定义，这一点是之前无法做到的 ​ 虽然不同页面的内部逻辑细节都是不一样，但是总体流程、数据结构都是一样的，基于这样的前提，我们就可以针对共性来进行抽象，之后不论多少个页面，我们都使用抽象逻辑，也只需要维护抽象逻辑 提供 组合式 API 的 Vue 2 插件​ 虽然hook是vue3版本才提出的，但是这并不代表hook与vue3是绑定关系，实际上在任何前端应用中都可以使用vue3中提供的hook功能 文档地址：@vue&#x2F;composition-api 所以不论是vue3还是vue2，还是react，甚至html都可以使用这个npm包 关于vue3的响应式核心包 @vue&#x2F;reactivity的具体实现，可以看看之前的文章 简易版Reactivity源码解析，读懂源码之后，自然解答了你对reactivity的全部疑问 实战（useReqList） 为了方便理解，以下代码为vue2.x，使用js进行编写 ​ useReqList是一个自定义hook，作用是帮助我们抽象后台表单的公共逻辑，我们先看看未使用的情况，使用了之后，代码的变化，再看看如何实现 未使用useReqList123456789101112131415161718192021222324252627282930313233// ...data() &#123; return &#123; // ... shopList: [], // 数据 homePage: 0, // 本页有多少数据 allPage: 0, // 总共多少页 totalSize: 0, //总共多少条数据 pageSize: 0, // 每页最多多少条数据 currentPage: 1, // 当前页码 &#125; &#125;,methods:&#123; init() &#123; this.loading = true const data = &#123; currentPage: this.currentPage, //... &#125; request(data) // 请求 .then((res) =&gt; &#123; this.shopList = res.data.data this.currentPage = res.data.currentPage this.pageSize = res.data.pageSize this.totalSize = Number(res.data.totalSize) this.homePage = res.data.thePageSize this.allPage = res.data.totalPages &#125;) .finally(() =&gt; &#123; this.loading = false &#125;) &#125;,&#125; 使用useReqList123456789101112131415161718import &#123; useReqList &#125; from &#x27;@/utils/hook/useReqList&#x27;// ...data() &#123; return &#123; dataList: useReqList() &#125;&#125;,methods:&#123; init() &#123; const data = &#123; currentPage: this.listData.currentPage || 1, //... &#125; this.listData.run(request(data)) // 请求 &#125;,&#125;// let &#123; data, currentPage, pageSize, thePageSize, totalPages, totalSize, status &#125; = this.listData 通过上面的例子可以看到，使用了useReqList之后 公共变量，公共逻辑部分被抽象出去，页面代码变得更加纯粹 因为reactivity的特性，它们都是具备响应式 避免重复编码，重复测试环节，节省开发时间 hook可以给n个接口使用，只要是请求表单接口，都不需要写重复部分的代码，避免调试，测试环节 接下里我们可以看看这是如何实现上面使用的自定义（Custom） Hook useReqList useReqList具体实现 ​ 内部实现就是对公共逻辑的封装，被读取的数据被reactive处理后具备了响应式，每次声明都会因为闭包的特性而开启一片独立的内存来供声明单位使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import &#123; reactive &#125; from &#x27;@vue/reactivity&#x27;/** * 针对后台表单页面逻辑的抽象 * @returns */export function useReqList() &#123; const defaultState = &#123; data: [], // 表格数据 currentPage: 1, // 当前页面 pageSize: 0, // 分页数量 thePageSize: 0, // 当前页面数量 totalPages: 0, // 总页数 totalSize: 0, // 总数量 error: null, // 错误原因 status: &#x27;idle&#x27;, // 当前状态 idle | loading | success | error &#125; let state = reactive(&#123; ...defaultState, &#125;) /** * 请求成功 * @param data */ const setData = (data) =&gt; &#123; state.currentPage = data.currentPage state.pageSize = data.pageSize state.thePageSize = data.thePageSize state.totalPages = data.totalPages state.totalSize = Number(data.totalSize) state.data = data.data state.status = &#x27;success&#x27; &#125; /** * 请求失败 * @param error */ const setError = (error) =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = error state.status = &#x27;error&#x27; &#125; const setLoading = () =&gt; (state.status = &#x27;loading&#x27;) const setPage = (num) =&gt; &#123; state.currentPage = num &#125; const setReset = () =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = null state.status = &#x27;idle&#x27; &#125; const run = (promise) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&#x27;请传入 promise 类型数据&#x27;) &#125; if ([&#x27;loading&#x27;].includes(state.status)) &#123; return Promise.reject(&#x27;当前正在请求中&#x27;) &#125; setLoading() return promise .then((res) =&gt; &#123; setData(res.data) &#125;) .catch((err) =&gt; &#123; console.log(err) setError(err) &#125;) .finally(() =&gt; &#123;&#125;) &#125; return &#123; run, setReset, setData, setPage, setLoading, setError, state, &#125;&#125; ​ 这样的封装体基本适配大部分vue2.x开发的后台管理系统的项目，如果想在项目中使用只需要修改一下setData部分适配一下后端数据即可 更多的vue hook函数​ hook工具库，VueUse，库里面提供了大量的常用方法，掘金上面有该工具库的介绍文章，官网说明该库是兼容vue2文档了 vue项目应当在什么使用下使用hook关于Class API与Composition API​ 从Class API&#x2F;Option API转变向Composition API的过程中是阵痛的，这2种API在思维方式上存在很大差异 ​ 对于长时间写Class、vue2.x的人来说，最初接触vue3几乎发现不了非常明显的优点，setup语法不熟练的情况下基本还是按照Class的思维进行编码，无法发挥Hook的优势，导致写一段时间Vue3后的结论是：在单文件中class的代码组织能力几乎完爆setup语法… ​ 后来组件有一些项目经验，重新学习了react hook，逐渐对hook有了一些理解；Hook主要完成逻辑与逻辑的分离，在react和vue中使用hook可以实现 视图与视图的分析，视图与逻辑的分离，逻辑与逻辑的分离，用这个的方式来实现单一职责，在此基础上完成逻辑与视图的低耦合高内聚代码 ​ 对于vue2的开发者在而言，可以渐进式的从vue2到vue3，先熟悉hook，在熟悉Composition API 关于hook与vuex | observable​ 从普遍意义上来说hook是可以替代vuex的，react中的API useContext就提供了类似功能。 vuex是无法替代hook的，他并不具备闭包的特性，使用vuex的话，那仅仅是拆分逻辑，有多少页面还是要写多少重复逻辑只是重复代码转义到vuex中而已 ​ 但是刚接触hook不久的新手而言，很容易进入一个误区；将变量，逻辑封装在一个hook中的情况下，又在多个页面中使用，就会在内存中创建多个不共享的内容一致的空间，对于公共变量还是要使用全局状态管理库的。 ​ hook风格的全局状态管理库，建议可以试试Pinia 结语​ 使用过了一段时间的setup语法之后，对其看法也是慢慢从谨慎疑惑转变成为拥抱hook，Composition API 在逻辑抽象、类型推导、多方面均占优，虽然目前还存在一些小问题，后面的迭代都会解决的，在未来几年Custom Hook将会越来越普及，拥抱Custom Hook,Vue3吧! 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"使用gitlabCI/CD完成前端自动化部署","slug":"解决方案/使用gitlabCICD完成前端自动化部署","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.094Z","comments":true,"path":"2021/06/15/解决方案/使用gitlabCICD完成前端自动化部署/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8gitlabCICD%E5%AE%8C%E6%88%90%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","excerpt":"","text":"2021年11月16日更新 静态数据提取为变量 增加备份版本 前言为什么使用CI&#x2F;CD？ ​ 目前我们公司更新使用的轻量化更新脚本，更新操作虽然简单,但是不够规范，并且敏感信息存在开发者电脑中，虽然我们git上进行了配置文件忽略，但是依旧存在泄密的风险，为了防止以上情况出现，我们将敏感信息移植到gitlab中，并且将更新操作从人工变为自动化 CI&#x2F;CD的优点自动构建并且状态是每个人都可见的 减少手工的错误，解放了重复劳动力 更好，更快，更加安全，更加稳定的交付 在CI的过程中可以进行代码质量的自动检测，减少人工检查的劳动力 打包环境一致，不会出现编译后代码异常 减少等待时间，更快的交付成果 前置概念CI​ 持续集成（continuous Integration）频繁的将代码继承到主干。目的是让产品可以快速迭代，同时还能保证高质量，他的核心措施就是代码继承到主干之前，必须通过自动化测试，只有存在失败，就不能集成。”持续继承并不能消除bug，而是让他非常容易发现和修改” CD​ 持续交付（continuous Delivery）与持续部署（continuous Deployment）频繁的将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过就会进入生产阶段，持续交付可以看做持续集成的下一步，它强调的是不论怎么更新，软件都是随时随地可以交付的；代码通过评审之后，自动部署到生产环境，持续部署是持续交付的下一步，持续部署的目标是，软件在任何时刻都是可以部署的，可以进入生产阶段 gitLab​ gitLab是一个开源的应用程序，他可以实现私有化的Gti项目仓库，可以通过web界面进行访问公开或者私人项目 gitLab CI&#x2F;CD​ gitLab持续集成，只要在仓库的根目录添加.gitlab-ci.yml文件，并且配置了gitLab runner（运行器），每次代码发生变成的时候就会执行.gitlab-ci.yml中的配置 gitLab Runner​ gitLab Runner是一个开源项目，支持多平台运行，他的作用是每次代码发生变更的时候gitlab CI会根据.gitlab-ci.yml，配置文件执行流水线（Pipeline）中每个阶段Stages中的Jobs，并将结果发送回gitLab。gitLab Runner是基于gitLab CI的API进行构建的相互隔离的机器，所以gitLab Runner 与gitlab本身不需要安装在同一台机器上，并且考虑到执行Runner对资源的消耗，以及安全性问题，所以并不建议安装在同一台机器上 Pipelines​ 流水线，是分阶段的构建任务，比如安装依赖，运行测试，打包部署，流水线由gitLab Runner进行触发，流水线运行的依据是gitlab-ci.yml Stages​ 构建阶段,也就是流水线的每一个环节，我们可以在 Pipelines中建立多个Stages，所有Stages都会按顺序同步进行，只有当所有的Stages都完成了Pipelines才算成功，默认情况下上一个Stages失败，这条流水线则为失败 Jobs​ 表示构建阶段的作业，关于jobs的设置有很多，比如指定手动触发，指定分支触发，同时运行多个jobs，等等，相同的Stages中的jobs会异步进行，Stages中的jobs全部成功了，Stages才为成功，默认情况下存在jobs失败，这条流水线则为失败 .gitlab-ci.yml​ 在gitLab CI&#x2F;CD中，具体如何运行流水线，是由 .gitlab-ci.yml来管理的，这个文件放在项目仓库的根目录 实例代码： 12345678910111213141516# stages：定义Pipeline中的各个构建阶段，并且定义Stages名称stages: - install - build# 定义 install 阶段的一个 jobinstall-job: stage: install script: - echo &quot;hello install&quot;# 定义 build 阶段的一个 jobbuild-job: stage: build script: - echo &quot;Hello, build&quot; 环境搭建​ 此类文章太多了，请自行查找，本文不做搭建介绍 ​ 针对已经搭建好的gitLab以及runner，为了适应前端开发环境，需要安装了node，cnpm，等等依赖 前置技能git：不会git可以退出直播间了，赶快去学吧 linux：常用命令必须会，不然配置runner，以及编写ci.yml脚本的时候会寸步难行 创建组织，导入git的项目 创建组织主要是为了方便配置CI&#x2F;CD的全局变量，也方便项目的集中管理 ​ 在使用gitlab之前，我们的项目可能会在github，gitee，等等其他代码仓库，为了保留之前记录，我们需要将git仓库移植过来 我们之前使用的是gitee，gitlab没有对此做快捷支持，所以我们使用Repo URL,填写好地址与账号，就可以将git仓库导入进来 更新git文件我们将git迁移到gitlab之后，现有项目中的.git文件都需要进行更换，不能再向之前的仓库提交代码。 停止代码提交 获取最新代码，切换到master分支 clone 新的gitlab的仓库 获取新的.git文件，覆盖原本项目中的.git，完成迁移 到目前为止，我们就可以完成git项目的迁移操作 配置组织的CI&#x2F;CD变量​ 组织中的项目大部分都是更新到一个服务器，例如服务器地址与密码，我们可以将这部分数据统一配置到全局变量，这样组织中的项目则无需再次进行设置 注意： 因为我们的项目不仅仅是master分支会运行runner，如果这里不关闭State，除了master（受保护的分支）其他的分支都访问不了这个变量 CI&#x2F;CD的变量功能可以很好的保护项目的隐私数据，可以隔离使用者与项目更新配置 配置gitlab-runner（linux） 注意：本文无搭建gitlab以及gitlab-runner相关教程，一切都是在已经搭建完成的基础上进行使用的 ​ 我们针对项目就要注册一个runner，来完成我们接下来配置中的命令操作，这部分界面操作无法完成，需要对gitlab runner的服务器进行操作 获取配置相关数据 注册自定义runner我们需要注册一个特定的runner，这里官方提示顺序为 安装runner 注册一个runner，并且URL指定为xxx，token指定为xxx 接下来我们就要去runner宿主机上面注册 使用终端工具链接宿主机 输入命令 1gitlab-runner register 完成配置之后，在回到项目CI&#x2F;CD部分的设置,就会发现下面多一个runner 注：刚刚注册的runner状态是黑色的，等会就会变成绿色 到此为止，runner已经准备就绪，他会执行我们项目中的.gitlab-ci.yml文件中的配置 编写.gitlab-ci.yml 具体编写过程请查看官方教程 ps：注意一点，线上静态文件最好不要命名为dist，CI脚本中dist为中转站文件夹，命名为dist会出现问题 1234567891011121314151617181920212223242526272829303132333435363738394041stages: # 分段 - install - build - deploycache: # 缓存 paths: - node_modules - admininstall-job: stage: install only: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - npm install - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./dist $USERNAME@$HOST:$UPLOADDIR/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/xxxx # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/xxxx # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 在配置文件中配置了执行的分支，当我们在prod-pre分支上提交代码的时候，脚本就会自动执行 install项目依赖 build项目 发射到目标服务器 这样就完成我们项目的自动化部署 CI脚本的优化优化自动化部署速度上面我们完成了一个简单的流水线，他可以完成 install build delay，已经满足了基本要求，但是还存在一些小问题 流水线任务时间过长 频繁install存在失败的概率 我们需要优化我们的CI，让速度更快更加稳定 build环节与delay环节没有太大的操作空间，并且大部分的时间都花在install环节，我们启用了gitlab的cache，实际上并不需要每次都打包，针对这个思路我们修改我们job中的 install，在job中增加当前是否存在**node_modules&#x2F;**的判断 123456789install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot; 这样存在缓存的时候就会跳过install阶段，但是这样还存在一个问题，我们修改了依赖，但是gitlab里面缓存还在，必然会出现打包异常的情况，针对package.json发生变化，我们再增加一个job，监听package.json 是否发生变化 静态数据提取为变量 假如存在多个项目，使用本脚本只需要修改此处的variables即可，不需要改script部分 1234variables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹 增加备份功能 删除原有备份文件(仅在生产环境) 删除原有文件 备份原本的代码(仅在生产环境) 将打包完成的文件复制到目标服务器 将目标文件改为服务端真正文件 .gitlab-ci.yml（正式版本） 指定了prod分支，根据实际项目进行修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263stages: # 分段 - repInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹cache: # 缓存 paths: - node_modules - distrepInstall-job: stage: repInstall only: refs: - prod changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - echo &quot;发射到目标服务器✨✨✨&quot; - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/backup/$BACKUPDIR # 删除原有备份文件(仅在生产环境) - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/$PRODDIR/ $UPLOADDIR/backup/$BACKUPDIR/ # 删除原有文件 备份原本的代码(仅在生产环境) - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 - echo &quot;完成更新👏👏👏&quot; after_script: - echo &quot;完成更新👏👏👏&quot; .gitlab-ci.yml（简化） 指定了prod-pre分支，根据实际项目进行修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758stages: # 分段 - preInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist_test # 线上文件名cache: # 缓存 paths: - node_modules - distpreInstall-job: stage: preInstall only: refs: - prod-pre changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/$PRODDIR # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 代码地址：github 结语​ 除了使用gitlabCI&#x2F;CD来完成自动化部署之外也可以使用Jenkins+webHook来完成，效果都是一样的，如果这两种方案对你，或者你的公司来说都比较复杂，那么我建议试试轻量化更新方案，我们也在实际项目上使用过很久，可以确保不会出现稳定性，是可以在生产环境使用的 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"使用iframe+postMessage通信实现商城多页面装修","slug":"解决方案/使用iframe实现页面装修方案","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.094Z","comments":true,"path":"2021/06/15/解决方案/使用iframe实现页面装修方案/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8iframe%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E8%A3%85%E4%BF%AE%E6%96%B9%E6%A1%88/","excerpt":"","text":"演示视频演示视频 背景​ 开发项目是多商家的类似有赞的商城后台，需要支持客户端的店铺装修功能 ​ 系统用户多为企业用户对页面效果要求较高，导致首页变化非常频繁 前言2020年第一版本装修上线了，方案是后台“模拟”客户端样式实现可视化，实现首页装修功能 实际上也就是后台写一套与客户端一样的样式解析装修json，实现装修预览的效果 模拟版本的装修上线后，确实解决了多店铺个性化首页的问题，实现了定制化首页，但是随着时间的推移，模拟版本暴露了很多问题，高频率的改版导致需求几乎无法满足 装修数据为静态数据，不会根据商城商品状态而变化，例如某某商品下架了，但是首页装修数据里面依旧存在 每次客户端样式发生变化，后台都需要同步编写一份，否则就无法可视化，导致工作量非常大 不具备扩展性，只能可视化的装修首页，无法可视化装修其他页面，其他页面都是通过一个插槽实现 插槽就是一个json对象的载体，因为不想写2套样式，所以采取这种很抽象的方案 随着业务的拓展，暴露出来的问题也是越来越严重，为了满足需求，很多场景下需要牺牲整个技术部门的效率，以及使用者的体验感，为了解决这个问题必须另辟蹊径，寻找其他解决方案 新方案必须解决以下问题 装修中的商品数据必须为非静态数据 避免2套样式的问题 装修中的商品数据实时刷新可以通过约定有规律的数据结构，后端解析并实时更新商品数据，实现装修中数据的更新 抛弃模拟方案后，也是思考很多方向，但是因为基于业务组件装修是没办法整个装修数据都json化的，所以最终尝试了一个理论上可行的方案，客户端通过iframe嵌入到后台，使用postMessage来完成后台与客户端之间的数据交互，实现装修功能 方案逻辑图 后台装修与客户端的主要思路 装修模式下获取上次的装修记录 建立前后台iframe之前的的联系 后台装修发生变化，触发watch，watch触发postmessage，客户端得到相应，客户端watch触发，实时更新装修数据 装修完成保存到数据库 具体实现方案之前在掘金发布过一篇（开源）从0打造H5可视化搭建系统 - 易动（vue+ts+egg）文章，易动是更加灵活的装修方案，感兴趣的同学可以了解一下 按基础组件定制装修方案，基础模块为： 按钮 文本 图片 轮播图此类数据 等等 本次的装修是基于业务组件进行区分，他的核心原理就是通过iframe进行数据交互实现实时装修功能 定制组件数据结构客户端根据json数据进行组件的展示的，所有首先，我们需要定义好客户端与后台通用的数据结构，用于声明我们的装修数据 例如我定义的数据结构，仅供参考 示例 搜索框 轮播图 1234567891011121314151617181920212223242526272829303132333435363738&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, &#123; id: guid(), compName: &#x27;drag-swiper&#x27;, name: &#x27;轮播图&#x27;, data: [ &#123; interval: 5000, data: [], // 数据 item: &#123; // 单个数据 img: &#x27;https://images.591wsh.com/2021/02/03/thumb_32371580472397824.png&#x27;, isLogin: false, // 是否需要登录, linkType: 2, // 1 无链接 2 商品 3 外部链接 4分类 commodity: &#123;&#125;, // 商品id dataurl: &#x27;&#x27;, // 外部链接 categoryid: &#x27;&#x27;, // 类目id &#125;, isUpdate: true // 告诉服务器是否需更新data里面的商品数据 &#125; ], css: &#123; height: 266, // marginTop: 20 &#125; &#125;, 为装修中的客户端页面增加一个组件 增加，修改，删除都会走如下逻辑，一句话说就是数据后台操作数据，客户端可以做出响应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 后台点击右侧装修组件，例如点击 搜索框// 匹配到搜索框的文字匹配定制的数据结构，得到如下点击的数据结构&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, // 后台通过监听存储装修数据变化的字段通知到客户端 computed: &#123; // ..... // 可使用组件 pageComponents: &#123; get() &#123; let &#123; pageComponents &#125; = this.$store.state.template if (pageComponents instanceof Array) &#123; // 组件数据发生变化的时候需要通知到客户端 this.iframeMessage(pageComponents) return pageComponents &#125; else &#123; return [] &#125; &#125;, set(data) &#123; // 更新组件顺序 this.$store.commit(&#x27;template/update_current&#x27;, data) &#125; &#125; // ...... &#125;, methods:&#123; // iframe加载完成的回调函数 iframeLoad() &#123; console.log(&#x27;iframe加载完成&#x27;) this.frm = document.getElementById(&#x27;iframe&#x27;) // 告诉客户端，目前处于装修中 this.frm.contentWindow.postMessage( &#123; isIframe: true &#125;, &#x27;*&#x27; ) &#125;, // 通知客户端数据发生了更新 iframeMessage(data) &#123; console.log(data) if (this.frm) &#123; this.frm.contentWindow.postMessage( &#123; tempLateData: data &#125;, &#x27;*&#x27; ) &#125; &#125;, &#125; // 客户端通过postMessage进行最新的装修数据接收window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.tempLateData) &#123; store.commit(&#x27;app/setTempLateData&#x27;, event.data.tempLateData) &#125; // ....&#125;// 客户端对应的页面再监听存在在vuex中的装修数据computed: &#123; ...mapState(&#123; tempLateData: state =&gt; state.app.tempLateData, // 后台的装修数据 hoverComponent: state =&gt; state.app.hoverComponent, // 当前鼠标浮动的元素id clickComponent: state =&gt; state.app.clickComponent, // 当前鼠标点击选中的数据 isIframe: state =&gt; state.app.isIframe, // 当前是否在装修模式里面 &#125;),&#125;,// 客户端替换从接口获取的之前的页面装修数据，装修数据显示在页面上watch: &#123; tempLateData() &#123; // 一旦后台通过postMessage更新装修数据，就可以替换原本接口获取的数据，实现实时装修功能 this.indexData = this.tempLateData || [] &#125;,&#125;, 修改装修的组件数据12345678910111213141516// 后台选取选中的组件// 后台针对每个装修组件都建立一个vue文件进行json内数据的改变‘// activeComponent.compName 为选中的组件compName，例如我选中搜索框 这里就是`drag-search-data`组件，这里可以是xxx-xxx-data组件&lt;template&gt; &lt;div class=&quot;template_right&quot;&gt; &lt;component v-if=&quot;activeComponent != false &amp;&amp; activeComponent.compName&quot; :is=&quot;activeComponent.compName + &#x27;-data&#x27;&quot; :compData=&quot;activeComponent&quot; &gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;// 组件内部绑定搜索框的提示文字，每次修改都会触发后台的计算属性·pageComponents·，进而后台通过postMessage通知到客户端，客户端进而存储到vuex，vuex值发生变化，客户端页面的watch起作用，页面发生变化，就吃实现组件数据的变化 点击客户端组件，通知后台并实现选中我们知道，在装修里面点击客户端，就直接点击到了客户端，所以点击客户端的跳转函数，我们必须进行拦截， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 前提须知 客户端每个装修组件的id都会在客户端写入到class中&lt;component :is=&quot;xxxxx&quot;:class=&quot;[`decoration_$&#123;item.id&#125;`,]&quot;&gt;&lt;/component&gt;// 装修监听函数体内window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.isIframe) &#123; console.log(&#x27;装修开发模式启动&#x27;) store.commit(&#x27;app/setIsIframe&#x27;, true) // 拦截跳转函数 uni.navigateTo = () =&gt; &#123;&#125; uni.switchTab = () =&gt; &#123;&#125; // 监听点击(装修用于选中组件) window.addEventListener(&#x27;click&#x27;, _decoratioclick, false) &#125; // ....&#125;function _decoratioclick(event) &#123; let path: string = &#x27;&#x27; // 每次点击的时候都获取一下包含组件id的class event.path.map((res: any) =&gt; &#123; if (res.className &amp;&amp; res.className.includes(&#x27;decoration_&#x27;)) &#123; path = res.className.split(&#x27;decoration_&#x27;)[1] &#125; &#125;) // 选中客户端当前组件 store.commit(&#x27;app/setClickComponent&#x27;, path) // 告知父级当前选中组件 window.parent.postMessage( &#123; activePage: path, // 将当前点击的组件id通过postMessage传递到后台 &#125;, &#x27;*&#x27; )&#125;// 装修后台mounted() &#123; window.addEventListener( &#x27;message&#x27;, e =&gt; &#123; if (e.data.activePage) &#123; // 获取客户端传递过来的当前组件id 这就是实现点击客户端组件装修后台得到数据 this.$store.commit(&#x27;template/set_activeComponent&#x27;, e.data.activePage) &#125; &#125;, false )&#125;, 添加组件到页面的流程图 客户端与装修后台相互传值总结1234567891011121314151617181920212223242526// 客户端发送window.parent.postMessage( &#123; activePage: path, &#125;, &#x27;*&#x27;)// 客户端接收window.addEventListener(&#x27;message&#x27;, （）=&gt; &#123; // ....&#125;)// 装修后台发送this.frm = document.getElementById(&#x27;iframe&#x27;)this.frm.contentWindow.postMessage( &#123; // ..... &#125;, &#x27;*&#x27;)// 装修后台接收window.addEventListener(&#x27;message&#x27;,e =&gt; &#123; // ...&#125;) postMessage的数据都是实时监听的，所以任意一边传值另一边都可以快速接收到，这是实现本方案的核心，通过postMessage解决了通信上的所有问题，例如 装修后台点击对应组件，客户端可以得到当前点击的组件的id 客户端点击组件可以告知后台，当前用户选中的组件 包括没实现的拖拽排序，都是可以实现的 多页面装修 做页面装修一定要想明白一件事，我们玩的不是装修，只是在操作页面抽象的数据结构 根据上面的想法，我们可以明白，活动页面很多仅仅是换换商品，换换链接，不会动不动就改页面 那个就可以抽象活动页的json数据结构 那么这里对应的就是图片组件 图片组件（优惠券也是图片样式） 商品组件 商品组件 在装修的时候我们定义好数据结构，依次添加这几个组件，客户端活动增加一行watch代码，就可以完美的实现活动页的装修，以及更新活动商品 注：公司项目无法透露，具体逻辑需要大家自己理解了 iframe装修方案优势 100%的完美还原装修样式 可以动态更新装修里面选中的商品的数据，需要数据结构统一化，后端即可按规律解析装修json 如果出现新组件，不需要写2套样式 后台装修定义好数据结构，客户端约定项目结构不变化，理论上整个项目所有页面都可以配置化 iframe装修方案弊端​ 通过iframe实现的前后台交互装修方案中，不仅需要动后台的装修代码，还需要客户端进行“兼容处理”，即客户端需要识别装修模式，与不断更新后台传入的装修数据，存在一定的耦合性 ​ 这种装修方案的弊端就是，如果希望操作起来更加便捷就需要在客户端进行功能的实现，并通过postMessage提交给装修后台 最后大家可以再看一下演示视频 联系我欢迎大家加入qq群吹吹水,一起成长 或者关注我的公众号，不定期更新各种文章：吴凯的随笔","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"使用Prettier完成代码提交的自动格式化","slug":"解决方案/使用gitHook来完成代码的自动格式化","date":"2021-05-31T16:00:00.000Z","updated":"2022-12-11T13:51:24.094Z","comments":true,"path":"2021/06/01/解决方案/使用gitHook来完成代码的自动格式化/","link":"","permalink":"https://bluedancers.github.io/2021/06/01/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8gitHook%E6%9D%A5%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/","excerpt":"","text":"最终效果 执行git commit 代码自动完成我们定制规则的格式化功能，并提交到本地 使用的npm包prettier：功能依赖包 husky：提供gitHook相关功能 lint-staged：让命令只对发生更改的文件生效 为什么做（WhyHow）​ 在未建立规范之前，每个人的代码风格都是不一致的，并且开发过程中可能会出现忘记格式化，手误的问题，如果在提交之前，可以自动抹平差异统一多人开发风格，这时候作用就体现出来了 ​ 代码风格是每一个程序员都要面对的问题，不论是在个人开发还是在团队协作中，都明白较好的代码风格是保证日后可维护性的关键，所以连不懂的开发或许都知道，要注意代码风格 怎么做（How）​ 到了正在的推进时期，就会面对很多难题，无法确定一个所有人都满意的方案，而就算是少数服从多数，在实际开发中落实也会遇到一大堆问题，例如，编辑器的不同，格式化工具不同，或者说完全没这个习惯，好不容易决定推进了，每次代码审核都需要修改这种细节问题，一来二去就搁置了，实在是头疼，到底该如何将事情完美的落实下去呢？ ​ 这里我们就需要一个权威的规范来帮助我们约束成为一个风格，Prettier表示我先给一个规范，大家先用起来，保证代码的可读性与可维护性，然后大家都遵循这和规则。 ​ 而prettier本身是一个An opinionated code formatter 的格式化工具，我是一个规矩非常严格的框架，并不会给你很多的配置项，喜欢用就用，不喜欢就不用，绝大部分的编辑器集成了prettier，在编辑器的约束下，大家都遵循这个方案就好了 具体配置（What）Vscode下载插件 prettier 项目按下依赖prettier，按文档完成步骤prettier官网 配置commit钩子 ​ 安装好之后，会在项目下生成文件.husky，并修改你的package.json，到目前为止，其实已经配置好了，他会在你每次commit之前执行npx lint-staged，这个命令会执行prettier --write，并且只对本次修改的文件生效 具体命令（躲懒不看文档的看这里~） 当前的prettier版本是2.4.1，如果版本号不一致，建议还是看官网 vscode安装prettier 项目安装prettier 1npm install --save-dev --save-exact prettier 创建配置文件 1echo &#123;&#125;&gt; .prettierrc.json 创建说明不需要格式化的文件 创建文件.prettierignore 写入内容 123# Ignore artifacts:buildcoverage 执行命令npx prettier --write .,格式化现有代码，测试功能是否正常 编写配置文件 1234567891011// json文件改为js文件（看个人习惯）写入内容module.exports = &#123; singleQuote: true, // 单引号 trailingComma: &#x27;es5&#x27;, // 对象属性最后有 &quot;,&quot; semi: false, // 是否需要分号 printWidth: 110, // 一行最多120 jsxSingleQuote: true, // jsx使用单引号 tabWidth: 2, // 一个tab代表几个空格数，默认就是2 useTabs: false, // 不使用缩进符，而使用空格 jsxBracketSameLine: true,&#125; 再次执行npx prettier --write .，对格式化规则有建议参考文档对配置进行修改，知道自己满意 配置gitHook钩子(必须先加入git仓库，不然会无效果) 1npx mrm@2 lint-staged 将代码格式改乱，尝试commit一下，查看功能是否正常（提交之前会被自动格式化） 一些注意事项win电脑.prettierrc.json写入失败这个问题在同事电脑上发现的，使用vscode中powershell执行echo &#123;&#125;&gt; .prettierrc.json,会无写入内容，后面执行的命令也会失败，这里请使用电脑的cmd打开目标文件夹，执行该命令，这样测试是可行的 配置gitHook之后 commit不会自动格式化vue文件这里需要修改在package.json中默认写入的lint-staged中的命令 这里根据项目中是否存在eslint，会写入不太一致，但是问题不打 123&quot;lint-staged&quot;: &#123; &quot;*.js&quot;: &quot;eslint --cache --fix&quot;&#125; 统一改成 123&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,css,md,vue&#125;&quot;: &quot;prettier --write&quot;&#125; 这样每次commit的时候就会自动格式化代码了 结语​ 如果查看本文遇到了一些问题，请到QQ群 530496237，一起吹吹水~","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"同域名下通过一级路由区分实现“前端微构架”","slug":"解决方案/单域名下通过子路由区分项目的实现方案","date":"2021-05-31T16:00:00.000Z","updated":"2022-12-11T13:51:24.094Z","comments":true,"path":"2021/06/01/解决方案/单域名下通过子路由区分项目的实现方案/","link":"","permalink":"https://bluedancers.github.io/2021/06/01/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E5%9F%9F%E5%90%8D%E4%B8%8B%E9%80%9A%E8%BF%87%E5%AD%90%E8%B7%AF%E7%94%B1%E5%8C%BA%E5%88%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 公司的客户端项目比较庞大，并且由于改动相对频繁，导致更新频率较高，web项目高频率的更新就会引发一系列的问题，例如公众号缓存问题，尤其是ios手机容易出现白屏的情况，访问过程中的用户回退页面会出现白屏的情况，等等很多未知的bug，虽然更新在一瞬间完成，但是还是会影响到部分用户的使用，针对现存的条件以及项目需求 思考到如下优化方案 更新时间上尽量选择用户访问量小的时间段 程序内频繁变化的图片，文字的页面，尽量后台配置装修化，达到减少更新的效果，此处参考使用iframe+postMessage通信实现商城多页面可视化装修 项目能否进行拆分，权重不高的页面（例如：活动页面），与主程序分离，达到减少主程序包更新频率 思考与分析 第一条与第二条非本文重点，只做简要说明 更新时间主要参照我们的客户端监控平台提供的检测数据，一般选择用户访问量较小的时候进行更新 对于项目中频繁改动，但是数据格式固定的活动页，我们使用装修功能，达到不更新代码，只更新数据的效果 ​ 而项目拆分就是我们本文要说到的重点，在调查过程中也了解过微前端，但是我们的客户端项目是uniapp完成的，考虑到技术难度与改动成本，最终放弃了微前端的方案 要怎么做到一个路径下面的项目拆分呢？ 拆分的项目需要满足一下2个条件 拆分的项目必须在同域名下，不可出现跨域名的情况，不然就会出现无法共享localStorage的问题 本次改动不能影响到线上已经存在的业务，不能出现主程序的路由变动 为了满足以上2个条件，则主程序不能进行任何改动，同时需要在当前域名下，想办法再指向一个项目，在同一个域下，localStorage被共享，虽然是2个项目但是在同一个域下 最开始一直在思考客户端如何修改实现，但是一直没想到完美方案，后来，我们另辟蹊径，通过nginx实现通过子路由进行项目区分 nginx进行一级路由区分 通过nginx进行一级路由的判断实现访问不同的静态资源 理想情况下方案是可行的，nginx配置也比较简单 12345678910111213server &#123; // ..... server_name xxxx.com // ..... location / &#123; root /xxx/xxx/xxxx/packageA; try_files $uri $uri/ /index.html; &#125; location ~ /activity/ &#123; root /xxx/xxx/xxxx/packageB try_files $uri $uri/ /index.html; &#125;&#125; 只要访问的项目路由 xxxx.com&#x2F;activity&#x2F;xxxxx,就会访问到项目包packageB，其他的一级路由都会访问到packageA 部署因为项目activityB的访问路由是确定的，所以我们在webpack的配置中就需要对publicPath进行修改 1publicPath: &#x27;/activity/&#x27;, ​ 然后我们nginx会去访问项目包下面的index.html，而经过我们上面对publicPath的修改，打包之后的index.html里面的路径应用就变成了 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/activity/favicon.ico&quot; /&gt; &lt;title&gt;xxxxx&lt;/title&gt; &lt;link href=&quot;/activity/css/app.xxxx.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/activity/js/chunk-vendors.xxx.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/activity/js/app.xxxxx.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时打包上线就会遇到资源访问不到的问题，因为webpack编译出来的程序包里面没有activity这个文件夹，所以对indexPath,outputDir也要进行修改 最终我们的vue.config.js 1234567891011module.exports = &#123; publicPath: &#x27;/activity/&#x27;, // 资源路径 outputDir: &#x27;./dist/activity&#x27;, // 生产环境构建文件的目录 indexPath: &#x27;../index.html&#x27;, // 指定生成的index.html的输出路径 configureWebpack: (config) =&gt; &#123; // .. &#125;, chainWebpack: (config) =&gt; &#123; // .. &#125;,&#125; 到此为止，通过一级路由区分项目已经完成了全部配置 优点 对项目进行拆分，对于非核心程序的页面，例如活动页面等等，即可与主程序进行区分，上线活动页面不干涉主程序 项目分离后，单个项目的页面变少，单个代码包打包速度得到提升，增加项目可维护性 缺点没办法共享公共逻辑代码，例如支付模块，登录模块，等等模块，因为跨项目了，当然这是有解决办法的，即公共模块打包成为npm包，但是这存在一定的工作量 最后欢迎大家加入qq群吹吹水（群号：530496237）一起成长","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"轻量化前端更新方案","slug":"解决方案/轻量化前端更新方案","date":"2021-05-31T16:00:00.000Z","updated":"2022-12-11T13:51:24.095Z","comments":true,"path":"2021/06/01/解决方案/轻量化前端更新方案/","link":"","permalink":"https://bluedancers.github.io/2021/06/01/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BD%BB%E9%87%8F%E5%8C%96%E5%89%8D%E7%AB%AF%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 一句话介绍：它是可以一行命令将代码更新到服务器的脚本 ​ 轻量级更新方案最开始源于掘金的文章，后来我们从零实现了一个更新脚本，并且已在是生产环境中进行使用很长时间，算是非常稳定的版本，个人认为轻量化更新方案是非常使用小型开发团队 ​ 现在我们切换到了gitlab的CI&#x2F;CD。所以这种方案已经不再是我们的主流方案，但是一路使用过来，非常稳定的解决了更新问题，还是非常不错的 优点： 快速，稳定，自动备份指定文件夹（灵活性高，但是需要自己实现） 缺点：需要手动回滚（自动回滚需要编码），相对来说没那么规范，没有留下记录，敏感数据存储在电脑中，配置文件可以git忽略 核心流程 确认并打包项目 通过node-ssh连接线上服务器 将打包代码指定名称进行压缩 备份之前的代码，删除以前的代码包，并解压压缩包 删除本次打包代码，断开ssh链接 如何使用代码地址 将仓库文件放入项目 安装依赖 1npm install node-ssh inquirer archiver -D 修改upload.config.js内容 增加脚本命令 1&quot;upload&quot;: &quot;node build/upload.js&quot; 运行命名，验证是否功能正常 核心代码build/upload.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const &#123; NodeSSH &#125; = require(&#x27;node-ssh&#x27;)const archiver = require(&#x27;archiver&#x27;)const inquirer = require(&#x27;inquirer&#x27;)const exec = require(&#x27;child_process&#x27;).execconst ssh = new NodeSSH()const uploadFun = require(&#x27;../upload.js&#x27;)/** * 获取当前平台 */let objName = process.argv[2] // 更新名字let startTime = null // 程序开始更新的时间// 获取上传服务器配置let config = uploadFun(objName)const verifyList = [ &#123; type: &#x27;input&#x27;, message: &#x27;您正在更新到线上环境,请确认接口域名&#x27;, name: &#x27;objName&#x27;, &#125;,]inquirer.prompt(verifyList).then(() =&gt; &#123; uploadBuild()&#125;)function uploadBuild() &#123; startTime = new Date() console.log(`$&#123;objName&#125;开始更新`) let buildcmd = exec(config.buildScript, (error, stdout, stderr) =&gt; &#123; if (!error) &#123; console.log(&#x27;打包完成&#x27;, stdout) app() &#125; else &#123; console.error(&#x27;打包出现错误&#x27;, stderr) process.exit(0) &#125; &#125;) buildcmd.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(data.toString()) &#125;)&#125;/** * 通过ssh链接服务器 */function app() &#123; ssh .connect(&#123; host: config.host, username: config.username, password: config.password, &#125;) .then((res) =&gt; &#123; // 上传代码压缩包 uploadData() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)&#125;/** * 上传代码 压缩现有代码 */function uploadData() &#123; // 创建文件输出流 let output = fs.createWriteStream(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`) // 设置压缩级别 let archive = archiver(&#x27;zip&#x27;, &#123; zlib: &#123; level: 8, &#125;, &#125;) // 存档警告 archive.on(&#x27;warning&#x27;, function(err) &#123; if (err.code === &#x27;ENOENT&#x27;) &#123; console.warn(&#x27;stat故障和其他非阻塞错误&#x27;) &#125; else &#123; throw err &#125; &#125;) // 存档出错 archive.on(&#x27;error&#x27;, function(err) &#123; throw err &#125;) // 通过管道方法将输出流存档到文件 archive.pipe(output) archive.directory(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.buildobj&#125;`, &#x27;/&#x27;) archive.finalize() // 文件输出流结束 output.on(&#x27;close&#x27;, function() &#123; console.log(`总共 $&#123;(archive.pointer() / 1024 / 1024).toFixed(2)&#125; MB,完成源代码压缩`) ssh .putFile( `$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, `$&#123;config.uploadDir&#125;/$&#123;config.objname&#125;.zip` ) .then(() =&gt; &#123; console.log(&#x27;程序zip上传成功,判断线上是否需要备份&#x27;) runcmd() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;)&#125;/** * 执行ssh命令 判断当前是否存在备份 */function runcmd() &#123; ssh .execCommand(&#x27;ls&#x27;, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stdout) &#123; let fileList = res.stdout.split(&#x27;\\n&#x27;) if (config.objname == config.backObject) &#123; if (fileList.includes(config.objname)) &#123; console.log(&#x27;当前更新为线上正常环境,开始进行备份&#x27;) backupData() &#125; else &#123; console.log(&#x27;当前更新为线上正常环境,并且是第一次,将跳过备份&#x27;) cmdunzip() &#125; &#125; else &#123; console.log(&#x27;当前为测试环境,无需备份,直接解压上传压缩包&#x27;) cmdunzip() &#125; &#125; else if (res.stderr) &#123; console.log(&#x27;查询指定目录失败&#x27;) &#125; else &#123; console.log(&#x27;ssh链接发生了错误&#x27;) &#125; &#125;)&#125;/** * 备份项目 */function backupData() &#123; ssh .execCommand(`mv $&#123;config.objname&#125; backup/$&#123;config.objname&#125;_backup$&#123;new Date().getTime()&#125;`, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stderr) &#123; console.log(&#x27;备份发生错误&#x27;, res.stderr) &#125; else &#123; console.log(&#x27;完成备份,解压最新代码&#x27;) cmdunzip() &#125; &#125;) .catch((err) =&gt; &#123; console.log(&#x27;备份发生未知链接错误&#x27;, err) &#125;)&#125;/** * 解压最新代码zip */function cmdunzip() &#123; // 解压程序 ssh .execCommand( `rm -rf $&#123;config.objname&#125; &amp;&amp; unzip -o -d $&#123;config.uploadDir&#125;/$&#123;config.objname&#125; $&#123;config.objname&#125;.zip &amp;&amp; rm -f $&#123;config.objname&#125;.zip`, &#123; cwd: config.uploadDir, &#125; ) .then(() =&gt; &#123; console.log(`项目包完成解压,$&#123;config.objname&#125;项目部署成功了!`) console.log(`项目更新时长$&#123;(new Date().getTime() - startTime.getTime()) / 1000&#125;s`) return deletelocalFile().then(() =&gt; &#123; console.log(&#x27;本地缓存zip清除完毕&#x27;) &#125;) &#125;) .then(() =&gt; &#123; ssh .execCommand(`rm -rf $&#123;config.objname&#125;/static/.DS_Store`, &#123; cwd: config.uploadDir, &#125;) .then(() =&gt; &#123; console.log(&#x27;线上项目.DS_Store删除完成&#x27;) ssh.dispose() process.exit(0) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;) .catch((err) =&gt; &#123; console.log(&#x27;解压出现错误&#x27;, err) &#125;)&#125;/** *删除本地生成的压缩包 */function deletelocalFile() &#123; return new Promise((resolve, reject) =&gt; &#123; fs.unlink(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, (err) =&gt; &#123; if (err) &#123; reject(err) throw err &#125; else &#123; resolve() &#125; &#125;) &#125;)&#125; 配置文件upload.config.js 123456789101112131415161718192021222324// 打包核心配置文件let Available = [&#x27;dist-a&#x27;, &#x27;dist-b&#x27;] // dist-a 环境a代码包 dist-b 环境b代码包 npm run upload dist-a/** * 获取更新配置 * @param &#123;String&#125; objName 当前更新名称 * @returns */module.exports = (objName) =&gt; &#123; if (!Available.includes(objName)) &#123; console.log(&#x27;当前项目不存在您输入的更新命令,请检查更新名称&#x27;) process.exit(0) &#125; return &#123; host: &#x27;xx.xx.xx.xx&#x27;, // 服务器地址 username: &#x27;root&#x27;, password: &#x27;xxxxxxxxxx&#x27;, buildPath: &#x27;&#x27;, // 本地打包项目地址(多层路径用这个) buildobj: &#x27;dist&#x27;, // 本地打包文件名称 uploadDir: &#x27;/xx/xx/xx&#x27;, // 服务端项目地址 objname: objName, // 打包项目名称 backObject: &#x27;objName&#x27;, // 备份的文件夹名称 buildScript: &#x27;npm run build&#x27; // 更新命令 &#125;&#125; 触发命令最后在package.json增加一行命令，运行前面的脚本文件 1234&quot;scripts&quot;: &#123; // ...... &quot;upload&quot;: &quot;node build/upload.js&quot; &#125;, 依赖版本​ 因为更新脚本是在项目里面的，所以需要额外安装依赖 推荐版本号 123&quot;node-ssh&quot;: &quot;^12.0.0&quot;,&quot;inquirer&quot;: &quot;^7.3.3&quot;,&quot;archiver&quot;: &quot;^3.1.1&quot;, 实际使用1npm run upload xxxx // 线上代码文件夹名称 upload 命令后面的字符串就是服务器上的文件夹名称，这里为了防止更新命名敲错了，需要首先在upload.config.js中进行更新白名单声明，如果配置都正确的情况下，你就可以看到，这就代表成功了~ 最后​ 脚本文件还存在很高的上限，可以优化一下备份部分的备份代码生成规则，再增加一个回滚代码的脚本，就可以实现线上的无感知回滚了 ​ 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"一些算法题","slug":"算法与数据结构/一些题目","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.091Z","comments":true,"path":"2021/03/22/算法与数据结构/一些题目/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/","excerpt":"","text":"题目 两个数组的交集思路： 在一个while循环中不断寻找两个链表的最小值，将其加入结果链表，同时该数据指针向后一位，结果链表也许要向后一位，假如while循环完成还存在某一个未处理的链表数据，直接加入到结果链表 https://leetcode-cn.com/problems/merge-two-sorted-lists/ 时间复杂度：O(n) 空间复杂度：O(1) 123456789101112131415161718192021222324252627282930/** * @param &#123;ListNode&#125; list1 * @param &#123;ListNode&#125; list2 * @return &#123;ListNode&#125; */var mergeTwoLists = function (list1, list2) &#123; let res = new ListNode(0) // 结果 let p0 = res; let p1 = list1 // 指针 let p2 = list2 // 指针 while (p1 &amp;&amp; p2) &#123; // 找到小的值,将其被指向p0,同时概念表后移一位 if (p1.val &lt; p2.val) &#123; p0.next = p1 p1 = p1.next &#125; else &#123; p0.next = p2 p2 = p2.next &#125; // 每次p0都会增加指向,,所以需要每次都手动指向最后一位 p0 = p0.next &#125; // p1或者p2其中一个还存在值,则全部消化掉 if (p1) &#123; p0.next = p1 &#125; else if (p2) &#123; p0.next = p2 &#125; return res.next&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://bluedancers.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树","slug":"算法与数据结构/二叉树","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.091Z","comments":true,"path":"2021/03/22/算法与数据结构/二叉树/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"一种分层数据的抽象模型，例如dom，菜单，树形控件，多层联动选择器 JavaScript中没有树，但是可以用Object和Array构建树 常见操作 深度&#x2F;广度有限遍历，先中后序遍历 二叉树: 树中的每个节点最多只能两个子节点，在JavaScript 中使用Object进行模拟 深度优先遍历含义： 尽可能深的搜索树的分支 12345// 深度优先遍历function inter1(tree) &#123; console.log(tree.value); tree.child.map(e =&gt; inter(e)) // 递归调用&#125; 广度优先遍历含义： 先访问离根节点最近的节点 12345678910111213// 广度优先遍历function inter2(tree) &#123; const q = [tree] // 使用队列存储广度数据 while (q.length &gt; 0) &#123; let c = q.shift() // 每次取队列最后一个 console.log(c.value); c.child.forEach(e =&gt; &#123; q.push(e) // 再次将下一层数据加入队列 &#125;) &#125;&#125;inter2(tree) 先序遍历二叉树定义：先根节点，后左子树，再右子树 123456789// 先序遍历function preorder(root) &#123; if (!root) &#123; return &#125; console.log(root.key); // 首先访问 preorder(root.left) preorder(root.right)&#125; 中序遍历二叉树定义：先左子树，后根节点，再右子树 123456789// 中序遍历function inorder(root) &#123; if (!root) &#123; return &#125; inorder(root.left) console.log(root.key); inorder(root.right)&#125; 后序遍历二叉树定义：先左子树，后右子树，再根节点 123456789// 后序遍历function postorder(root) &#123; if (!root) &#123; return &#125; postorder(root.left) postorder(root.right) console.log(root.key);&#125; 先序遍历二叉树（非递归）1234567891011121314// 先序遍历function preorder(root) &#123; if (!root) return const task = [root] while (task.length) &#123; const n = task.pop() console.log(n.key); if (n.right) task.push(n.right) if (n.left) task.push(n.left) // pop拿最后面的,数组需要保证后进先出,所以left放后面,这样每次循环都会优先使用left,直到left用完,就会用right,当前层级全部用完就会到更加深处或者右边的二叉树 &#125;&#125;preorder(bt) 中序遍历二叉树（非递归）123456789101112131415161718192021function inorder(root) &#123; if (!root) return const task = [] let p = root while (task.length || p) &#123; while (p) &#123; task.push(p) p = p.left &#125; const n = task.pop() console.log(n.key); p = n.right &#125;&#125;inorder(bt)// 首先找到最右边的全部节点,在从最左边开始递归// 在每次将右节点放入下一次循环,因为当前一定是中节点// 右节点完成后找上的中节点,中节点完成后找下右节点,完成二叉树的从左到右的覆盖// task存储所有左节点,当前阶段存在右节点的情况下,数组最后一位是右节点,下次一定会被抛出// p存储下一个右节点,开始下级树的查询 后序遍历二叉树（非递归）12345678910111213141516171819// 后序遍历(非递归)function postorder(root) &#123; if (!root) return const task = [root] const outputTask = [] while (task.length) &#123; const n = task.pop() outputTask.push(n.key) if (n.left) task.push(n.left) if (n.right) task.push(n.right) &#125; while (outputTask.length) &#123; let n = outputTask.pop() console.log(n); &#125;&#125;// 后序的顺序是 先右 再左 再中 首先倒叙先序遍历,获取先中 再左 再右// 最后倒序输出postorder(bt) 题目 二叉树的最大深度https://www.youtube.com/watch?v=H8SjbVxGB1c&amp;list=PLwIrqQCQ5pQmjH6YyFvH2A9FYL6bBB4Ra 时间复杂度：O(n) 空间复杂度：O(n) 思路：使用深度优先遍历（先序）,记录最大递归数量，最后返回 12345678910111213141516171819202122/** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function (root) &#123; let res = 0 /** * * @param &#123;*&#125; n 树 * @param &#123;*&#125; l 层级 */ const dfs = (n, l) =&gt; &#123; if (!n) return if (!n.left &amp;&amp; !n.right) &#123; res = Math.max(res, l) &#125; dfs(n.left, l + 1) dfs(n.right, l + 1) &#125; dfs(root, 1) return res&#125;; 题目 二叉树的最小深度时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历，同时记录当前层级，当遇到没有叶子节点，则说明找到最小深度，最后返回 12345678910111213141516171819/** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var minDepth = function (root) &#123; if (!root) return 0; let task = [ [root, 1] ] while (task.length) &#123; let [n, l] = task.shift() if (!n.left &amp;&amp; !n.right) &#123; return l &#125; if (n.right) task.push([n.right, l + 1]) if (n.left) task.push([n.left, l + 1]) &#125;&#125;; 题目 二叉树的层序遍历（广度遍历解法）https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历二叉树，同时记录当前层级，以层级为数组下标，完成层序遍历结果记录 12345678910111213141516171819202122/** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function (root) &#123; if (!root) return [] let task = [ [root, 0] ] let res = [] while (task.length) &#123; let [n, level] = task.shift() if (!res[level]) &#123; res.push([n.val]) &#125; else &#123; res[level].push(n.val) &#125; if (n.left) task.push([n.left, level + 1]) if (n.right) task.push([n.right, level + 1]) &#125; return res&#125;; 题目 二叉树的层序遍历（新陈代谢+广度遍历解法）https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历二叉树，在遍历中，每次都将本层级全部遍历完成，再进行下一个层级的遍历，这样在同一个循环里面把当前数据都放入遍历结果的最后，循环累加完成结果记录 123456789101112131415161718192021/** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function (root) &#123; if (!root) return [] const q = [root] const res = [] while (q.length) &#123; let len = q.length res.push([]) // 每次while之前都把上一层的全部提出,下一层的全部记录下来 while (len--) &#123; const n = q.shift() res[res.length - 1].push(n.val) if (n.left) q.push(n.left) if (n.right) q.push(n.right) &#125; &#125; return res&#125;; 题目 二叉树的中序遍历(递归)https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function (root) &#123; const res = [] const rec = (n) =&gt; &#123; if (!n) return; rec(n.left) res.push(n.val) rec(n.right) &#125; rec(root) return res&#125;; 题目 二叉树的中序遍历(非递归)https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function (root) &#123; const res = [] const task = [] // 遍历数据 let p = root // 指针 while (task.length || p) &#123; // 找到所有左子树 while (p) &#123; task.push(p) p = p.left &#125; // 获取最后一个节点 初始化的时候都是左子树 后面可能为右子树 const n = task.pop() res.push(n.val) p = n.right &#125; return res&#125;; 题目 路径总和https://leetcode-cn.com/problems/path-sum/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：使用深度遍历所有节点的值，在这个过程中不断累加，直到遇到最底部节点，对比与目标是否一致，如果一致则说明有，没有则继续找 12345678910111213141516171819/** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;boolean&#125; */var hasPathSum = function (root, targetSum) &#123; if (!root) return false; let res = false const dfs = (n, s) =&gt; &#123; // console.log(n.val); if (!n.left &amp;&amp; !n.right &amp;&amp; targetSum == s) &#123; res = true &#125; if (n.left) dfs(n.left, s + n.left.val) if (n.right) dfs(n.right, s + n.right.val) &#125; dfs(root, root.val) return false&#125;; 深度优先遍历json的全部节点1234567891011121314151617const json = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;, d: [1, 2]&#125;function dfs(json, path) &#123; console.log(json, path); Object.keys(json).map(e =&gt; &#123; dfs(json[e], path.concat(e)) &#125;)&#125;dfs(json, [])","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图","slug":"算法与数据结构/图","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/图/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/","excerpt":"","text":"深度优先遍历12345678910111213141516171819const graph = &#123; 0: [1, 2], 1: [2], 2: [0, 3], 3: [3]&#125;let visited = new Set() // 存储已经被访问数据const dfs = (n) =&gt; &#123; console.log(n) visited.add(n) graph[n].forEach(e =&gt; &#123; if (!visited.has(e)) &#123; dfs(e) // 未访问数据继续递归 &#125; &#125;)&#125;dfs(2) // 确定起点 广度优先遍历12345678910111213let visited = new Set() // 存储已经被访问过的数据visited.add(2) // 增加起点值let q = [2] // 设定起点while (q.length) &#123; let n = q.shift() // 弹出开头的 console.log(n); graph[n].map(e =&gt; &#123; if (!visited.has(e)) &#123; // 不存在才遍历节点 q.push(e) visited.add(e) &#125; &#125;)&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"字典","slug":"算法与数据结构/字典","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/字典/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8/","excerpt":"","text":"与集合类似，字段也是一种存储唯一值的数据结构吗，但是他是以键值对的形式来存储 ES6中增加了字段，也就是Map 123456789let a = new Map([ // 默认值 [&#x27;a&#x27;, &#x27;aa&#x27;]])a.set(&#x27;b&#x27;, &#x27;bb&#x27;) // 加入值a.delete(&#x27;b&#x27;, &#x27;bb&#x27;) // 删除a.set(&#x27;a&#x27;, &#x27;aaa&#x27;) // 替换值console.log(a.get(&#x27;a&#x27;), a.get(&#x27;b&#x27;)); // 读取值 题目 两个数组的交集时间复杂度：O(n) 空间复杂度：O(n) 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; // 集合的方式 // return [...new Set(nums1.filter(e =&gt; nums2.includes(e)))] // 字典的方式 const map = new Map(); nums1.forEach(e =&gt; &#123; map.set(e, true) &#125;) const res = [] nums2.map(e =&gt; &#123; if (map.get(e)) &#123; res.push(e) map.delete(e) &#125; &#125;) return res&#125;; 题目 有效的括号时间复杂度：O(n) 空间复杂度：O(n) 12345678910111213141516171819202122232425/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function (s) &#123; const stack = [] var map = new Map([ [&#x27;(&#x27;, &#x27;)&#x27;], [&#x27;&#123;&#x27;, &#x27;&#125;&#x27;], [&#x27;[&#x27;, &#x27;]&#x27;], ]) for (let i = 0; i &lt; s.length; i++) &#123; if (map.has(s[i])) &#123; stack.push(s[i]) &#125; else &#123; if (map.get(stack[stack.length - 1]) === s[i]) &#123; stack.pop() &#125; else &#123; return false &#125; &#125; &#125; return stack.length === 0&#125;; 题目 两数之和时间复杂度：O(n) 空间复杂度：O(n) 思路： 循环中每次判断map中，是否存在匹配项，如果没有，加入到map中，等到被匹配，如果匹配到了，直接返回被匹配到的与当前元素 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123; let map = new Map() for (let i = 0; i &lt; nums.length; i++) &#123; let e = nums[i] let n = target - e if (map.has(n)) &#123; return [map.get(n), i] &#125; else &#123; map.set(e, i) &#125; &#125;&#125;; 题目 无重复字符的最长子串时间复杂度：O(n) 空间复杂度：O(n) 思路：使用双指针 + 字典的方式实现，就像剪切视频时候的滑动窗口一张 右边指针不断向前，每次向前的时候，判断当前窗口中是否存在已有元素，如果存在，就将左边指针调整到存在的问题 同时每次都判断滑动窗口的长度，最终获取到最长子串 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function (s) &#123; let res = 0 // 最长长度 let a = 0 // 滑动窗口起点 const map = new Map() // 存储字符的字典 for (let b = 0; b &lt; s.length; b++) &#123; const e = s[b]; if (map.has(e) &amp;&amp; map.get(e) &gt;= a) &#123; // 如果存在重复元素 // 如果是abba 这样的情况,需要防止滑动窗口起始点变小,已经在滑动窗口外面了,不应当考虑 a = map.get(e) + 1 // 滑动窗口左边前进一位 &#125; map.set(e, b) // 存储当前值的最后的下标 用于下次计算起始点 res = Math.max(res, b - a + 1) // 当前长度与已知最大长度 &#125; return res&#125; 题目 最小覆盖子串（困难）https://leetcode-cn.com/problems/minimum-window-substring/ 时间复杂度：O(n2) 空间复杂度：O(n) 思路: 采用字典 + 双指针滑动窗口来实现最小覆盖子串的查找，因为题目不限制子串被覆盖的顺序，所以首先将子串通过Map结构转化为 数值:数量（abc &#x3D;&gt; {‘a’ &#x3D;&gt; 1,’b’ &#x3D;&gt; 1,’c’ &#x3D;&gt; 1 }） ​ 完成了Map的构建后，开始滑动右指针，知道map中数据都为0，代表当前滑动窗口覆盖了最小子串，这时候再开始左指针的滑动，知道左指针当前值在Map中，代表已经无法覆盖最小子串，此时左指针停止，再次开始滑动右指针，再次进入循环 ​ 最后在每次滑动左边指针的时候，截取当前的最小覆盖子串，最后得到最小覆盖子串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;string&#125; */ var minWindow = function (s, t) &#123; // 最小子串大于字符串s，毕竟不存在最小子串，直接返回空 if(t.length &gt; s.length) &#123; return &#x27;&#x27; &#125; let start = 0 // 指针开头 let end = 0 // 指针结尾 let result = &#x27;&#x27; // 存储最小覆盖子串 const need = new Map() // 存储最小子串数据 for (let i = 0; i &lt; t.length; i++) &#123; const e = t[i]; need.set(e, need.has(e) ? need.get(e) + 1 : 1) &#125; // need 为 &quot;ABC&quot; =&gt; &#123;&#x27;A&#x27; =&gt; 1,&#x27;B&#x27; =&gt; 1,&#x27;C&#x27; =&gt; 1 &#125; let needType = need.size // 最小子串的长度,用于记录滑动窗户口还未包含几位数 // 先走后指针 while (end &lt; s.length) &#123; const c = s[end] // 滑动窗口右边向前 if (need.has(c)) &#123; // 判断当前元素是否在map中 need.set(c, need.get(c) - 1) // 如果在map中,其值减1 if (need.get(c) == 0) &#123; // 如果当前值,在map中为0了,说明当前滑动窗口包含了当前值的所有数量 // 所以对记录map数量的数值再减1 needType -= 1 &#125; &#125; // 如果needType为0了,说明次数滑动窗口已经包含所有子串 while (needType === 0) &#123; // 获取当前子串 let carry = s.substring(start, end + 1) // 对比存储子串与当前子串,获取最小的 if (result == &#x27;&#x27; || result.length &gt; carry.length) &#123; result = carry &#125; const c2 = s[start] if (need.has(c2)) &#123; // 判断当前元素是否在map中,在,这说明某个值移出了,此时已经不是最小子串,因此map中的当前值,+1 // 因为去除了存在的值,当前子串已经不符合标准,needType记录值+1 // 左指针停止,开始右指针行动,知道它再次覆盖了子串 need.set(c2, need.get(c2) + 1) if (need.get(c2) === 1) &#123; needType += 1 &#125; &#125; start += 1 // 左指针前进 &#125; end += 1 // 右指针前进 &#125; return result&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"排序算法","slug":"算法与数据结构/排序算法","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/排序算法/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序先找最大，从右到左 时间复杂度：O(n2) 空间复杂度：O(n) 思路：内层循环通过依次比较，将最大值放到最后面，在此基础上增加外部循环，每次外部循环都会排除已经完成排序的下标，再算出最大值，并放到排除已经排序的数组最后 1234567891011121314151617181920/** * 冒泡排序 * @param &#123;Array&#125; arr * @returns */function bubbleSort(arr) &#123; for (let j = 0; j &lt; arr.length - 1; j++) &#123; // 为什么循环体减1,因为循环体里面是当前的比较后一个,不减1,就会溢出 // 减去j是为了减少无意义的循环次数 for (let i = 0; i &lt; arr.length - 1 - j; i++) &#123; // 比较当前的与后一个大小,前面的大则换位子 if (arr[i] &gt; arr[i + 1]) &#123; let temp = arr[i] arr[i] = arr[i + 1] arr[i + 1] = temp &#125; &#125; &#125; return arr&#125; 选择排序先找最小，从左到右 时间复杂度：O(n2) 空间复杂度：O(n) 思路：内层循环每次找到最小的下标并放到数组最前面，再此基础上增加外部循环，外部循环每次以循环下标为坐标，寻找最小值换位到坐标中，一次完成排序 123456789101112131415161718192021/** * 选择排序 * @returns */function selectionSort() &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; let indexMin = i for (let j = i; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[indexMin]) &#123; indexMin = j &#125; &#125; if (indexMin != i) &#123; // 最小值就是自己,不需要交换 let temp = arr[i] arr[i] = arr[indexMin] arr[indexMin] = temp &#125; &#125; return arr&#125; 插入排序从第二开始，依次从右到左开始比较最小值 时间复杂度：O(n2) 空间复杂度：O(n) 思路：从第二位开始，和前面的进行比较，如果前面的大于后面，则后面的等于前面的，继续向前找，如果找到了前面的小于后面都，则停止查找，覆盖该下标，如果到最开始都没有找到最小的，则将第一位变成比较值 123456789101112131415161718192021222324/** * 插入排序 * @param &#123;*&#125; arr * @returns */function inSetrSort(arr) &#123; // 从第二位开始 for (let i = 1; i &lt; arr.length; i++) &#123; let j = i let temp = arr[j] while (j &gt; 0) &#123; if (temp &gt; arr[j - 1]) &#123; // 如果当前值大于前一个值,直接弹出,并且得知插入位置 break &#125; // 如果当前值小于前一个值,当前值就等于前一个字 arr[j] = arr[j - 1] j-- &#125; // 在弹出的下标填入缓存的值 arr[j] = temp &#125; return arr&#125; 归并排序难度较大，后续再看 快速排序难度较大，后续再看 顺序搜索在目标函数中寻找目标值，找不到则返回-1 时间复杂度：O(n) 123function searchSort(list, carry) &#123; return list.findIndex(e =&gt; e == carry)&#125; 二分搜索针对有序数组的单项查找方法，找到会返回下标，未找到则返回-1，他的性能要高于顺序搜索，每次搜索都会将现有数组批成两半 时间复杂度：O(logN) 1234567891011121314151617181920let bin = [1, 2, 3, 4, 5, 6, 7, 8, 9]function binarySearch(list, carry) &#123; let low = 0 let high = list.length - 1 while (low &lt;= high) &#123; const mid = Math.floor((low + high) / 2) const ele = list[mid] if (carry &gt; ele) &#123; low = mid + 1 &#125; else if (carry &lt; ele) &#123; high = mid - 1 &#125; else if (carry == ele) &#123; return mid &#125; &#125; return -1&#125;console.log(binarySearch(bin, 1));","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://bluedancers.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈","slug":"算法与数据结构/栈","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/栈/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/","excerpt":"","text":"一个后进先出的数据结构,例如蜂窝煤，先放进去的蜂窝煤是被后拿出来的，后放进去的先拿出来，放进去（push）拿出来（pop） JavaScript虽然没有栈，但是可以通过array进行实现 123456const stack = []stack.push(1)stack.push(2)const item1 = stack.pop()const item2 = stack.pop() 题目 有效括号https://leetcode-cn.com/problems/valid-parentheses/ 思路：使用栈的特性实现 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var obj = &#123; &#x27;(&#x27;: &#x27;)&#x27;, &#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;[&#x27;: &#x27;]&#x27;&#125;var isValid = function (s) &#123; if (s.length % 2 === 1) &#123; return false &#125; const stack = [] for (let i = 0; i &lt; s.length; i++) &#123; if (obj[s[i]]) &#123; stack.push(s[i]) &#125; else &#123; if (obj[stack[stack.length - 1]] === s[i]) &#123; stack.pop() &#125; else &#123; return false &#125; &#125; &#125; return stack.length === 0&#125;; 函数调用堆栈","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"链表","slug":"算法与数据结构/链表","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.093Z","comments":true,"path":"2021/03/22/算法与数据结构/链表/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表数组：增加或者删除非首尾元素时，需要移动元素 链表：增加或者删除非首尾元素时，不需要移动元素，只需要修改其next的指向即可 注： JavaScript 没有链表结构，所以我们需要用Object来模拟链表 题目 删除链表中的节点https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 时间复杂度：O(1) 空间复杂度：O(1) 12345678/** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function (node) &#123; node.val = node.next.val // 将自己变成别人 node.next = node.next.next // 干掉别人，达到自己消失的目的&#125;; 题目 反转链表https://leetcode-cn.com/problems/reverse-linked-list/ 时间复杂度：O(n) 空间复杂度：O(1) &#x2F;&#x2F; p2里面都是p1的，所以不是新内存，temp因为是单个值，不是数组与矩阵，所以是O(1) 思路：每次循环的时候首先保存之后的链表，再讲当前链表指向新的链表，最后循环”之后的链表“，进而实现 123456[1,2,3,4,5] =&gt; [][2,3,4,5] =&gt; [1][3,4,5] =&gt; [1,2][4,5] =&gt; [1,2,3][5] =&gt; [1,2,3,4][] =&gt; [1,2,3,4,5] 写法1 双指针123456789101112131415/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; let p1 = head // 链表 let p2 = null while (p1) &#123; const temp = p1.next // 首先保存当前的下一个指针 p1.next = p2 // 将当前指针指向新链表 p2 = p1 // 替换之前的链表 [] =&gt; [1] =&gt; [2,1] =&gt; [3,2,1] p1 = temp // 为了下次循环,将下一个链表给p1(本次循环的已经被弹出) [1,2,3] =&gt; [2,3] =&gt; [3] &#125; return p2 // 返回反转后的链表&#125;; 写法2 递归123456789101112131415161718/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; // 递归写法 return reverse(null, head)&#125;;function reverse(now, old) &#123; if (!old) &#123; // 老数据没了,递归反转完成 return now &#125; let temp = old.next // 首先保存链表(除了自己) old.next = now // 将当前指针指向新链表 return reverse(old, temp) // 将2个链表再执行一遍&#125; 题目 两数相加https://leetcode-cn.com/problems/add-two-numbers/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：同时循环两个链表，在将数据放入一个新的链表中，对十位数需要进行额外的处理 12345678910111213141516171819202122232425262728/** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function (l1, l2) &#123; let all = new ListNode(0) // 新建空链表 let three = all // 向新链表追加元素是需要指针,直接用all,链表头就没了 let carry = 0 // 记录超出的十位数 while (l1 || l2) &#123; // 同时循环2个链表 let val = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry // 同位数相加,并且加上上一位的超出的十位数 carry = Math.floor(val / 10) // 获取超出的十位数 three.next = new ListNode(val % 10) // 记录当前的余数 three = three.next // 指向下一个链表 if (l1) &#123; // 2个链表长度不一致,需要判断 l1 = l1.next &#125; if (l2) &#123; l2 = l2.next &#125; &#125; // 最后一位可能存在余数 if (carry) &#123; three.next = new ListNode(carry) three = three.next &#125; return all.next&#125;; 题目 删除排序链表中的重复元素https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 时间复杂度：O(n) 空间复杂度：O(1) 思路：遇到同样的，删除自己，没遇到，指针向后一位 1234567891011121314151617/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var deleteDuplicates = function (head) &#123; let all = head // 当前指针 while (all &amp;&amp; all.next) &#123; if (all.val == all.next.val) &#123; // 和下个一个节点一致,删除本阶段 all.next = all.next.next &#125; else &#123; // 没有重复的,指针到下一个 all = all.next &#125; &#125; return head&#125; 题目 环形链表https://leetcode-cn.com/problems/linked-list-cycle/ 题目解析: 给定一个特殊的链表，链表的最后一位再次指向链表中的某一个，这样会形成一个环，pos参数是未知的，通过算法判断该链表是否有环 写法1 特殊值法时间复杂度:O(n) 空间复杂度：O(1) 特殊值一定要保证不能在链表中出现 12345678910111213141516171819202122/** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; let all = head; while(all) &#123; // 定一个特殊值，将遇到的每一项都变成这个特殊值 // 如果有遇到了，就说明是存在环 if(all.val == &#x27;123456789&#x27;) &#123; all = null return true &#125; else &#123; all.val = &#x27;123456789&#x27; all = all.next &#125; &#125; // 如果一次都没遇到这说明没有环 return false&#125;; 写法2 快慢指针 为什么快指针与慢指针一定会相遇? 一旦快指针进入环中，每次都离慢指针进一步，因为到了追上的时候，要么相隔1步，下一步相遇，要么相隔2步，下下次一定相遇 快指针与慢指针相遇的时候，慢指针是否绕环超过了一圈 不会，假设环长为N，环外长度为n，N一定大于n；并且根据第一题可知每次快指针都距离慢指针进一步，所以N与n最终会距离n，所以N&gt;n 时间复杂度:O(n) 空间复杂度：O(1) 12345678910111213141516/** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; let p1 = head let p2 = head while(p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123; p1 = p1.next p2 = p2.next.next if(p1 === p2) &#123; return true &#125; &#125; return false&#125;; JavaScript原型链123obj -&gt; Object.prototype -&gt; null // 对象func -&gt; Function.prototype -&gt; Object.prototype -&gt; null // 方法arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null // 数组 如果A沿着原型链能找到B.protype，那么 A instanceof B一定为true 如果A对象上面没有找到X属性，那么就会沿着原型链找到X属性 例如：Object.prototype.x &#x3D; ‘x’,那么函数func.x也会为x,因为Function.prototype指向Object.prototype instanceof如何实现？（遍历原型链） 遍历链表，寻找是否存在一致的 12345678910function instanceOf(params, type) &#123; let p = params while (p) &#123; if (p === type.prototype) &#123; return true &#125; p = p.__proto__ &#125; return false&#125; 应用 使用链表获取json的值 在知道全部键的情况下，或者说知道json中数据的的某个值，可以使用链表，嵌套for过于暴力 123456789101112131415const json = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;&#125;const path = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]let p = jsonpath.map(e =&gt; &#123; p = p[e]&#125;)console.log(p); 总结 链表中的元素不是连续的，而是通过next指针连接的 JavaScript没有链表，但是Object可有模拟链表 常用操作：遍历链表，修改链表next JavaScript的原型链也是链表，使用__proto__进行连接","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"队列","slug":"算法与数据结构/队列","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.093Z","comments":true,"path":"2021/03/22/算法与数据结构/队列/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/","excerpt":"","text":"一个先进先出的数据结构，先放进去的后拿出来，先进先出，保持有序 JavaScript中虽然没有队列但是可以通过array进行实现 123456const stack = []stack.push(1)stack.push(2)const item1 = stack.shift()const item2 = stack.shift() 题目 最近请求次数https://leetcode-cn.com/problems/number-of-recent-calls/ 思路： 使用栈实现 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415var RecentCounter = function () &#123; this.q = []&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function (t) &#123; this.q.push(t) while (this.q[0] + 3000 &lt; t) &#123; this.q.shift() &#125; return this.q.length&#125;; 事件循环于任务队列 ​ 如果执行事件的过程中，如果遇到了异步任务，比如dom操作，ajax，setTimeout，就会将事件交给webApi执行， 不会加入任务队列 ​ 直到异步任务结束，回调函数加入任务队列，如果回调函数里面还有异步任务，就继续做放入wenAPI里面做事件循环","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"集合","slug":"算法与数据结构/集合","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.093Z","comments":true,"path":"2021/03/22/算法与数据结构/集合/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/","excerpt":"","text":"一种无序且唯一的数据结构 ES6增加了集合，Set 常用操作：去重 判断是否在集合中，求交集，差集 123456789101112// 去重const arr = [1,2,3,4,4,4,4]const arr2 = [...new Set(arr)]// 判断是否在集合中const set = new Set(arr)const has = set.has(2)// 求交集const set1 = new Set([1,2,3,4])const set2 = new Set([3,4,5,6])const set3 = new Set([...set1].filter(e =&gt; set2.has(e))) // 将其中一个变成数组，另一个has，最终结果转为Set 题目 两个数组的交集https://leetcode-cn.com/problems/intersection-of-two-arrays/ 时间复杂度：O(n^2) 空间复杂度：O(1) 12345678/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; return [...new Set(nums1.filter(e =&gt; nums2.includes(e)))]&#125;; JavaScript中Set的一些操作1234567891011121314151617181920212223242526let my = new Set()my.add(1) // 正常加入my.add(2) // 正常加入my.add(2) // set保证不会重复,依旧只有一个2my.add(&#x27;313&#x27;) // 正常加入let o = &#123; a: 1&#125;my.add(o) // 正常加入my.add(&#123; // 正常加入 a: 1&#125;)const has1 = my.has(&#123; a: 1&#125;) // 返回false 引用类型不在内存的同一个地方const has2 = my.has(o) // 返回true console.log(has1);my.delete(1) // 正常删除for (const item of my) &#123; // 迭代函数 这个不使用my 使用my.values my.keys 都可以 都是一样的 console.log(item);&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"Javascript-2023","slug":"Javascript-2023","permalink":"https://bluedancers.github.io/categories/Javascript-2023/"},{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"},{"name":"阅读-2023","slug":"阅读-2023","permalink":"https://bluedancers.github.io/categories/%E9%98%85%E8%AF%BB-2023/"},{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"},{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"},{"name":"Javascript-2022","slug":"Javascript-2022","permalink":"https://bluedancers.github.io/categories/Javascript-2022/"},{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"},{"name":"杂谈","slug":"杂谈","permalink":"https://bluedancers.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/categories/JavaScript/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"https://bluedancers.github.io/categories/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"},{"name":"随想集","slug":"随想集","permalink":"https://bluedancers.github.io/categories/%E9%9A%8F%E6%83%B3%E9%9B%86/"},{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/tags/chatGPT/"},{"name":"关于proxy","slug":"关于proxy","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8Eproxy/"},{"name":"记录","slug":"记录","permalink":"https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"阅读","slug":"阅读","permalink":"https://bluedancers.github.io/tags/%E9%98%85%E8%AF%BB/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"},{"name":"产品分析","slug":"产品分析","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"},{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"},{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"},{"name":"Hexo","slug":"Hexo","permalink":"https://bluedancers.github.io/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://bluedancers.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"价值观","slug":"价值观","permalink":"https://bluedancers.github.io/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"},{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"兼容性","slug":"兼容性","permalink":"https://bluedancers.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"设计模式","slug":"设计模式","permalink":"https://bluedancers.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"无障碍","slug":"无障碍","permalink":"https://bluedancers.github.io/tags/%E6%97%A0%E9%9A%9C%E7%A2%8D/"},{"name":"随选朗读","slug":"随选朗读","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB/"},{"name":"童年","slug":"童年","permalink":"https://bluedancers.github.io/tags/%E7%AB%A5%E5%B9%B4/"},{"name":"随想","slug":"随想","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E6%83%B3/"},{"name":"低代码","slug":"低代码","permalink":"https://bluedancers.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"h5装修","slug":"h5装修","permalink":"https://bluedancers.github.io/tags/h5%E8%A3%85%E4%BF%AE/"},{"name":"Vue3","slug":"Vue3","permalink":"https://bluedancers.github.io/tags/Vue3/"},{"name":"关于C端","slug":"关于C端","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8EC%E7%AB%AF/"},{"name":"产品日常","slug":"产品日常","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E6%97%A5%E5%B8%B8/"},{"name":"vue3","slug":"vue3","permalink":"https://bluedancers.github.io/tags/vue3/"},{"name":"webpack5","slug":"webpack5","permalink":"https://bluedancers.github.io/tags/webpack5/"},{"name":"响应式","slug":"响应式","permalink":"https://bluedancers.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"vw","slug":"vw","permalink":"https://bluedancers.github.io/tags/vw/"},{"name":"输出","slug":"输出","permalink":"https://bluedancers.github.io/tags/%E8%BE%93%E5%87%BA/"},{"name":"算法","slug":"算法","permalink":"https://bluedancers.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}