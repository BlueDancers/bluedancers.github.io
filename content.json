{"meta":{"title":"vkcya Blog","subtitle":"","description":"","author":"vkcyan","url":"https://vkcyan.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2022-05-23T07:18:39.272Z","updated":"2022-05-23T07:18:39.272Z","comments":true,"path":"links/index.html","permalink":"https://vkcyan.github.io/links/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-05-23T07:15:23.068Z","updated":"2022-05-23T07:15:23.068Z","comments":true,"path":"about/index.html","permalink":"https://vkcyan.github.io/about/index.html","excerpt":"","text":""},{"title":"书籍","date":"2022-05-23T07:18:11.740Z","updated":"2022-05-23T07:18:11.740Z","comments":true,"path":"books/index.html","permalink":"https://vkcyan.github.io/books/index.html","excerpt":"","text":""},{"title":"类别","date":"2022-05-23T07:18:32.733Z","updated":"2022-05-23T07:18:32.733Z","comments":true,"path":"categories/index.html","permalink":"https://vkcyan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-23T07:19:05.313Z","updated":"2022-05-23T07:19:05.313Z","comments":true,"path":"tags/index.html","permalink":"https://vkcyan.github.io/tags/index.html","excerpt":"","text":""},{"title":"存储库","date":"2022-05-23T07:18:59.980Z","updated":"2022-05-23T07:18:59.980Z","comments":true,"path":"repository/index.html","permalink":"https://vkcyan.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"针对免登录的一些实践与思考","date":"2022-05-23T06:29:52.233Z","updated":"2022-05-12T01:22:41.901Z","comments":true,"path":"2022/05/23/针对免登录的一些实践与思考/","link":"","permalink":"https://vkcyan.github.io/2022/05/23/%E9%92%88%E5%AF%B9%E5%85%8D%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"针对打通免登录的一些实践与思考我最近一直再想一句话，听用户说，但是不要照着做。这人","categories":[],"tags":[]},{"title":"JS数据结构与算法","slug":"JS数据结构与算法","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:22:09.379Z","comments":true,"path":"2022/03/15/JS数据结构与算法/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"数据结构为算法提供服务，算法围绕数据结构操作 时间复杂度 一个函数用大O表示，比如O(1)，O(n)，O(logN)… 定性描述该算法的运行时间 O(1)12let a = 1a += 1 每次执行改逻辑的时候，之后执行一次，复杂度不会随着时间的变化而变化 O(n)123for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; for循环里面的代码执行n次 O(1) + O(n) &#x3D; O(n)123456let a = 1a += 1for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; 两个时间复杂度先后排列就需要相加，相加的情况下低的的忽略不计，取更高的时间复杂度 O(n) * O(n) &#x3D; O(n ^ 2)12345for (let i = 0; i &lt; n; i += 1) &#123; for (let j = 0; j &lt; n; j += 1) &#123; console.log(i, j) &#125;&#125; 两个时间复杂度嵌套排列，时间复杂度就需要相乘 O(logN)$$对数函数：如果ax&#x3D;N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x&#x3D;loga$$ 12345let i = 1while(i &lt; n) &#123; console.log(i) i *= 2&#125; 这里的logN以2为底数，目的是就是求2的多少次方为N， 上面的代码while循环每次*2，实际上就是求2的多少次方为N，所以时间复杂度就是O(logN) 空间复杂度 一个函数用O表示，比如O(1)，O(n)，O(n^2) 算法在运行过程中临时占用存储空间的大小的量度 O(1)12let i = 0i += 1 声明了变量i，单个变量所占用的内存为1，所以空间复杂度为O(1) O(n)1234let list = []for (let i = 0; i &lt; n; i += 1) &#123; list.push(i)&#125; 声明了变量list，通过循环我们增加了n个值，相当于占用了n个内存单元，所以这段代码的空间复杂度为O(n) O(n^2)1234567const matrix = []for (let i = 0; i &lt; n; i += 1) &#123; matrix.push([]) for (let j = 0; j &lt; n; j += 1) &#123; matrix[i].push(j) &#125;&#125; O(n^2)实际上就是一个矩阵，矩阵的本质就是一个二维数据，存储了n的二次方的变量 小知识调试工具栏每个图标的作用 第一个箭头：程序运行到下一个断点，没有断点，程序执行完毕 第二个图标：一行一行执行代码 第三个图标：当前处如果调用了fun，点击此图标就会进入函数里面 第四个图标：点击跳出当前函数 第五个图标：重启调试 第六个图标：停止调试","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vue3 + jsx开发指南","slug":"Vue3 使用jsx开发指南","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:18.409Z","comments":true,"path":"2022/03/15/Vue3 使用jsx开发指南/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/Vue3%20%E4%BD%BF%E7%94%A8jsx%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"","text":"​ 在2021年，vue3发布了正式版本，并且经过一年的维护已经越来越稳定，我们在公司项目中也小范围的上线了vue3的项目，总体还是很不错的 ​ 但是setup语法需要return比较麻烦，还有.value问题，尝试过setup语法糖，依旧觉得setup语法的api记忆负担比较重 ​ 所以下半年逐渐拾起了jsx的语法，并在开源项目中使用，总体感觉还是相当不错的，前人栽树后人乘凉，本文对jsx for vue的常见问题进行说明 jsx学习成本更低，这么多年jsx没有大改动； 无记忆负担，同时足够灵活，如果你是vue开发者，同时对setup语法并不是太合得来， vue3 + jsx也是非常不错的选择~ 前置知识​ 在vue3中使用jsx需要安装@vitejs&#x2F;plugin-vue-jsx（webpack版本的不了解，有需要者执行搜索），根据文档配置一下就行了，官方提供了文档供参考，提供了相关示例jsx-next,有react基础的同学可以先看官方文档，在开发过程中出现问题再看本文 指令v-modelJSX for vue是支持v-model语法的，这一点比react的setState,体验感确实要好 1234567891011// 正常写法&lt;input v-model=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;value&#125; /&gt; // jsx// 指定值写法&lt;input v-model:modelValue=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;]&#125; /&gt; // jsx // 修饰符写法&lt;input v-model:modelValue.trim=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;,[&#x27;trim&#x27;]]&#125; /&gt; // jsx v-show这个api与在vue中的表现形式一致 12&lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt; // vue&lt;div v-show=&#123;isShow&#125;&gt;&lt;/div&gt; // jsx v-bind1234567891011121314// vue&lt;a-modal :width=&quot;&#x27;400px&#x27;&quot; :title=&quot;&#x27;设置组件名称&#x27;&quot; &gt; // ....&lt;/a-modal&gt;// jsx&lt;a-modal width=&#123;&quot;400px&quot;&#125; title=&#123;&quot;设置组件名称&quot;&#125; &gt; // ....&lt;/a-modal&gt; v-if在jsx for vue中没有这个api，我们需要用jsx风格来实现v-if的效果 可以简单理解为jsx直接将if搬到html中 12&lt;div v-if=&quot;isShow&quot;&gt; ... &lt;/div&gt; // vue&#123;isShow &amp;&amp; &lt;div&gt; ... &lt;/div&gt;&#125; // jsx 事件事件语法jsx for vue，所有的事件都按照react风格来 所有事件有on开头 所有事件名称首字母大写 例如：@click &#x3D;&gt; onClick @change &#x3D;&gt; onChange @drop &#x3D;&gt; onDrop 事件修饰符这里没有找到权威的资料，有小伙伴知道也请告知一下，目前建议大家通过原生JavaScript来实现vue事件修饰符的效果 .stop ： 阻止事件冒泡，在JSX中使用event.stopPropagation()来代替 .prevent：阻止默认行为，在JSX中使用event.preventDefault() 来代替 APIref与reactivevue3的template会自动解析ref的.value,在jsx中ref的.value是不会被自动解析的 1234//声明变量 let type = ref(1)&lt;p&gt;&#123;&#123; type &#125;&#125;&lt;/p&gt; // vue&lt;p&gt;&#123;type.value&#125;&lt;/p&gt; // jsx props在jsx for vue中，props的语法使用的就是setup的语法，实际表现形式完全一致 1234567891011export default defineComponent(&#123; props: [&#x27;title&#x27;], setup(props) &#123; onMounted(() =&gt; &#123; console.log(props.title); &#125;) return () =&gt; ( &lt;div&gt;&#123;props.title&#125;&lt;/div&gt; ) &#125;&#125;) emit同样与vue3的setup语法保持一致，注意子父方法需要符合react规范 123emit(&#x27;changeVisible&#x27;, false) // 子组件 &lt;xxx onChangeVisible=&#123;(params) =&gt; xxxFun(params)&#125;&gt;&lt;/xxx&gt; // 父组件 solt如何写插槽这里以antd for vue的Popover 气泡卡片，为例子 Vue3语法123456&lt;a-popover title=&quot;Title&quot;&gt; &lt;template #content&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/template&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; jsx for vue语法123456789&lt;a-popover title=&quot;Title&quot; content=&#123; &lt;&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/&gt; &#125;&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; 基础模板12345678910111213import &#123; defineComponent, onMounted, ref &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; // props: [&#x27;xx&#x27;], setup(props,&#123; emit &#125;) &#123; onMounted(() =&gt; &#123; // ... &#125;) return () =&gt; ( &lt;div&gt;&lt;/div&gt; ) &#125;&#125;) 结语 国内这方面资料比较少，查问题的时候注意vue版本，以及jsx的使用（render方式本文不适用） 如果代码里面存在问题，如果是ui框架，建议直接看react版本的代码，例如antdv的jsx版本直接看antd的实例代码 直接看jsx语法的项目代码，H5-YD.v2 不接受杠精，例如写jsx为啥不去用使用react 如果在学习过程中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vite配置alias（设置别名）","slug":"vite配置alias","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:16.257Z","comments":true,"path":"2022/03/15/vite配置alias/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/vite%E9%85%8D%E7%BD%AEalias/","excerpt":"","text":"Vite配置alias需要两步进行（TS项目） 1、修改vite.config.ts（让程序支持） 2、修改tsconfig.json（让编辑器支持） 修改vite配置12345678910111213141516171819import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;function _resolve(dir: string) &#123; return path.resolve(__dirname, dir)&#125;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], // 配置项目别名 resolve: &#123; alias: &#123; &#x27;@&#x27;: _resolve(&#x27;src&#x27;), &#125;, &#125;,&#125;) 修改tsconfig.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;noImplicitAny&quot;: false, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true, &quot;importHelpers&quot;: true, // 不让同样的辅助函数重复的出现在多个文件中 &quot;allowSyntheticDefaultImports&quot;: true, // 允许对不包含默认导出的模块使用默认导入。 &quot;baseUrl&quot;: &quot;.&quot;, // 非相对模块的导入可以相对于baseUrl或通过下文会讲到的路径映射来进行解析 &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot; ], &quot;paths&quot;: &#123; // 配置导出路径（这里根据自己项目执行修改） &quot;@/stores*&quot;: [ &quot;./src/stores*&quot; ], &quot;@/components*&quot;: [ &quot;./src/components*&quot; ], &quot;@/modules*&quot;: [ &quot;./src/modules*&quot; ], &quot;@/utils*&quot;: [ &quot;./src/utils*&quot; ], &#125;, &quot;types&quot;: [ &quot;element-plus/global&quot; ] &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot;, ], &quot;include&quot;: [ &quot;src/*&quot;, &quot;src/**/*.vue&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.jsx&quot;, &quot;src/**/*.ts&quot;, &quot;src/**/*.js&quot; ]&#125; 结语 修改后请重启编辑器 本文验证与2022年1月10号，mac，win双平台均有效，如果以上配置无效了，请查看相关api的改动 如果帮助你解决了问题，动动小手点个赞吧！:)","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vue3.x 预渲染 Unable to prerender all routes错误排查","slug":"vue3.x 预渲染 Unable to prerender all routes错误排查","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:22:23.794Z","comments":true,"path":"2022/03/15/vue3.x 预渲染 Unable to prerender all routes错误排查/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/vue3.x%20%E9%A2%84%E6%B8%B2%E6%9F%93%20Unable%20to%20prerender%20all%20routes%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/","excerpt":"","text":"前言​ BOOS最近对前几年做的公司官网不太满意，觉得没有有效体现公司的优势，表明随着公司这几年的努力发展，我们将会接触到更大规模的合作伙伴，自然要展示更好的企业形象，所以官网重做。 需求分析 没有交互的静态页面，但是存在大量动画 需要支持良好的SEO ​ 最早期的官网是vue2.x + webpack3.x + vue-cli-plugin-prerender-spa进行实现的，效果挺不错，很快各大搜索引擎就收录了我们的网站，所以这次我们打算沿用此方案，不过使用最新技术栈； 为什么不用vite​ 查阅vite的生态后，未找到类似prerender-spa的plugin，没办法支持预渲染，所以vite就被淘汰了。 为什么不用unxtjs​ 我们的官网不具备大量的接口交互，用Nnxtjs多少有点杀鸡用牛刀了，并且还需要使用pm2部署代码，付出于收获不成正比，被淘汰。 最终方案​ 我们部门是vue技术栈，团队不考虑react，通过以上排除法，只能使用vue3.x + webpack5.x + prerender-spa进行业务实现了。 技术实现基础模板我们使用最新的vue-cli进行项目搭建，选择vue3版本，最近的cli默认就是webpack5 安装预渲染插件1npm i prerender-spa-plugin -D 增加配置123456789101112131415161718const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)const path = require(&#x27;path&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, &#x27;dist&#x27;), routes: [&#x27;/xxx&#x27;], &#125;) ) &#125; &#125;,&#125;) 打包测试1npm run build 然后就出现一个错误 1[prerender-spa-plugin] Unable to prerender all routes! 让我们一起抽丝剥茧，看看报错的具体原因。 错误排查因为报错提示很模糊，我们打开他的源码，在源码line144发生错误的地方增加log，了解具体报错。 再次执行npm run build，得到真正的错误。 1Building for production...error TypeError: compilerFS.mkdirp is not a function ​ 我们继续最终源码发现 compilerFS 由webpack进行提供，我们带着错误前往webpack官网查询错误，于是就找到了Filesystems，因为这个插件已经好几年没有更新，而我们当前使用的是webpack5，出现了API变更的情况。 ​ 于此同时，根据错误提示，我们也在该库的issues中找到了历史讨论。 在讨论中，找到了两种解决方案 修改node_modules源码，使其兼容webpack5 1234567891011// From https://github.com/ahmadnassri/mkdirp-promise/blob/master/lib/index.js const mkdirp = function (dir, opts) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;\\ndir&#x27;, dir, opts, &#x27;\\n&#x27;); try &#123; compilerFS.mkdirp(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; catch(e) &#123; compilerFS.mkdir(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; &#125;) &#125; 使用已经被修改的库，感谢这位大哥 1npm i @dreysolano/prerender-spa-plugin 我们使用第二种方案，重新修改vue.config.js 12- const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)+ const PrerenderSPAPlugin = require(&#x27;@dreysolano/prerender-spa-plugin&#x27;) 然后再次打包测试 打包成功，通过启动本地服务器curl命令测试得知，SEO功能正常，未发现问题。 总结​ 使用prerender-spa-plugin打包出现报错[prerender-spa-plugin] Unable to prerender all routes!，更换库为**@dreysolano&#x2F;prerender-spa-plugin**，即可解决问题。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"写给前端新人的nginx教程","slug":"前端工程师的nginx教程","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:07.710Z","comments":true,"path":"2022/03/15/前端工程师的nginx教程/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84nginx%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言​ 我相信大部分前端新手是接触不到部署相关的工作的，一般都是将代码包交给后端，或者通过CI，FTP完成代码的更新，至于代码如何部署，如何从域名到前端代码包，很多前端仔没有实际操作过，自然是不知道的，这篇文章就是要帮助未接触过部署的人学会在服务器上线部署一个前端项目，在这个主线中带大家慢慢的熟悉nginx ​ 记得在2017年暑假，那时候大二还没开学，当时我只会写一点简单代码，linux和运维完全没接触过，一冲动在阿里云购买了一个服务器，外加一个域名，好像还是xiaowuasy.top,现在已经不能访问了；那时候单纯的兴趣使然，想搭建一个网站，因为实力不足，也不知道求助别人，前前后后折腾了一个月，最终竟然成功在服务器上面部署了wordpress服务，后面域名备案也成功了； ​ 这段经历是曲折的，依稀记得在盛夏的傍晚，我坐在慢慢暗下来的客厅，头上还残留着因为紧张流下的细汗，眼睛因为专注而干涩，面对不太看得懂的文档，一遍一遍尝试；我自然不希望大家在这上面浪费时间，这也是写这篇文章的初衷 前置知识 一个云服务器，阿里云，腾讯云，xx云都行，首次购买或者学生认证都是有很大的优惠（本文以阿里云为例子） 了解linux基础命令，也就是对各种文件的增删改查 本教程基于CentOS 7.5系统，如果是图形化界面，或者其他系统，命令可能不完全一致，但是流程都是一致的，建议看对应教程 如果linux基础命令不会。下面的也不用看了，立刻去学 搭建环境连接服务器通过远程工具（CRT，Xshell）或者自带的远程连接进入自己的服务器，连接方式选择公网ip 安装nginx CentOS自带yum命令，这个命令很关键，自行了解 执行命令 1yum install nginx // 终于遇到需要确认的，直接确认即可 安装完成后,主机中便有了nginx服务，相关命令如下，启动完成后 1nginx 启动完成后，浏览器访问公网IP,就可以访问到nginx的默认主页 到这一步就算是nginx部署成功了 nginx相关文件路径12/etc/nginx/ // 配置文件/usr/share/nginx/ // 默认前端代码存放处 ​ 默认配置在/etc/nginx/nginx.conf,nginx根据默认配置，监听80端口，80端口指定了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html这个文件夹，于是你访问公网ip -&gt; 公网ip:80 -&gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html,于是”Welcome to CentOS“便呈现在你的面前 ​ 如果你希望不显示默认的页面，而是显示你自己写的项目，直接替换/etc/nginx/nginx.conf中的root,字段为自己程序包的路径 在6666端口上搭建一个站点​ 我们的代码除了部署在默认80端口上面，还可以其他端口上，例如8888，7777，等等 ​ 接下来我们就在一个自定义的端口上面部署一个站点 ​ 这里我们需要注意nginx.conf中的一行配置 含义：在&#x2F;etc&#x2F;nginx&#x2F;conf.d下面所有nginx的配置文件都会自动生效 根据配置文件的提示我们到目标文件夹下面，建立test.conf，名字无所谓，配置文件里面是通配符匹配的 并通过vi 写入内容 123456server &#123; listen 7777; server_name _; root /usr/share/nginx/test;&#125; 再去文件夹/usr/share/nginx/test下建立一个index.html 123mkdir test cd testvi index.html 将一下内容放入index.html种 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是7777端口&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后重启nginx 1nginx -s reload 访问我们部署的项目ip:7777 然后你会发现访问不了，最终访问超时(&#x3D;&#x3D;)，这是因为服务器限制了可访问端口，此时需要到云管理后台设置安全组 在阿里云后台增加安全组规则 之后就可以正常访问了！ 至此，便完成了第一个nginx项目的部署 部署一个vue项目​ 通过上面的例子，我们已经可以完成一个自定义站点的部署了，那么真实项目呢，例如将一个vue项目部署到3006端口 首先编写xxx.conf 1234567891011121314151617181920server &#123; listen 3006; server_name _; # 开启gzip相关配置 gzip on; gzip_static on; gzip_min_length 2k; gzip_buffers 4 8k; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/x-icon application/javascript; gzip_comp_level 9; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 站点代码路径 root /usr/share/nginx/client; # 单页应用必须设置（刷新404问题） location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 将打包之后的代码，通过FTP上传代码到目标文件夹/usr/share/nginx/client（注意文件夹名称） ftp 重启nginx nginx -s reload 这边完成了一个站点的部署！是不是很简单 绑定域名​ 直接拿ip+端口给别人访问是不太好的，大家都给自己站点绑定上一个好记忆的域名，那么nginx如何绑定域名呢？ 购买一个域名https://wanwang.aliyun.com/domain/，备案域名，这个流程很麻烦，需要10-30天 备案完成后，域名就可以使用了 我们需要去修改我们的nginx配置，将server_name的值修改为需要绑定的域名即可； 1234server &#123; listen 3006; server_name xxx.com;// .... 增加https支持 申请一个https证书，数字证书管理，以阿里云为例子，国内云厂商都有 将证书放在服务器中你可以记得住的文件夹里面 修改nginx配置 12345678910111213141516171819202122232425server &#123; // # 将当前域名的http自动打到https listen 80; server_name xxx.com; rewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123; listen 443 ssl http2; server_name xxx.com; ssl_certificate xxxx/yy.pem; # 证书 ssl_certificate_key xxxx/yy.key; # 证书秘钥 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; root /usr/share/nginx/client; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 结语​ 虽然部署一个站点，仅仅是用到nginx，但是涉及到的知识点还是很多的 ​ 如果遇到了错误，一定要仔细检查报错信息，问题百度百度基本都能得到答案，如果实在搞不定，直接重做云服务器系统，重头再来；遇到问题并把它解决了，便成了你的技能 ​ 一个有经验的开发人员部署一个站点，可能半小时就弄完了，想要熟练的话，一定要多练习多实践，从0到1部署一个项目还是一件很酷的事情！ 如果搭建中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"浏览器读取xls并生成二维码下载到本地","slug":"浏览器读取xls生成二维码并下载","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:04.591Z","comments":true,"path":"2022/03/15/浏览器读取xls生成二维码并下载/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96xls%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"需求一次普通的技术需求会议 ​ 项目经理首先发言 我们技术这边需要将xls表格中的几千条数据变成二维码，并且中间镶嵌logo，图片底部放置编号，由于xls表格数据私密，不能通过第三方完成 ​ 平常这个事情都是后端处理的，前端就是来摸鱼的，但是这次一反常态，后端脸黑了，带样式搞不来，脚一蹬，直接装死 ​ 项目经理用期盼的眼神看着我，顿时我紧张了起来，眼神飘忽，我已经好多年没搞过node了啊！！会议室都沉默了，在项目经理不断精神攻击下，后端装死的情况下，看来注定要大前端来拯救世界了，毕竟JavaScript万能语言，俺来试试吧！ 实现方案​ 以上情节纯属虚构，但是需求确实是这样的，虽然好几年没碰过node，好歹年轻记性好，用过的基本都还记得，调研实现方案上没出现太多问题，有如下方案 puppeteer地址：https://github.com/puppeteer/puppeteer ​ 使用基于node环境的puppeteer，进行二维码绘制，图片绘制，是JavaScript开发者面对此类需求的主流选择 node-canvas地址：https://github.com/Automattic/node-canvas ​ 同样是在服务端完成渲染，但是这个库依赖node-gyp，如果不安装python2，那安装过程懂得都懂，不过这也是很不错的方案 浏览器​ 通过浏览器canvas绘制，然后下载下来，会有刷刷刷下载图片的炫酷效果 很明显有刷刷刷下载图片炫酷效果的方案更好，所以就选择你了 浏览器方案！ 问题分解确定了技术方案，就要考虑具体实现了 JavaScript读取execl文件，并处理成理想格式 将读取到的execl中的网址字段生成一张二维码 将二维码写入canvas，在其中间加上logo，并在底部加一行文字 将canva转化为DataURL，下载它 不断递归生成，直到xls数据全部处理完毕 理论存在，实践开始！ 具体实现启动一个本地服务器首先我们通过VScode Live Server 启动一个本地服务器 这里有好奇宝宝要问了，为啥第一步是这？ 答：因为浏览器是访问不了电脑的文件系统的，所以只能通过启动一个本地服务器的方案，来读取我们的资源文件 创建html，引入资源库分析需要用到的第三方开源库 解析xls https://github.com/sheetjs/sheetjs 生成QRcode https://github.com/soldair/node-qrcode 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生成二维码&lt;/title&gt; &lt;script src=&quot;./qrcode.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./xlsx.full.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 用于生成载体 最终生成的图片大小，按自己的需求来 --&gt; &lt;canvas width=&quot;260&quot; height=&quot;310&quot; id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; const ctx = initCanvas(); // 获取ctx实例 // 初始化画布 function initCanvas() &#123; const canvas = document.getElementById(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); return ctx; &#125; &lt;/script&gt;&lt;/html&gt; 解析xls文件1234567891011121314151617181920212223242526272829303132333435363738readWorkbookFromRemoteFile().then((res) =&gt; &#123; // res 为实际解析代码 [&#123;key:&#x27;xxxx&#x27;,value:&#x27;xxxx&#x27;&#125;,....]&#125;);// 读取xls信息，并处理function readWorkbookFromRemoteFile() &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;http://127.0.0.1:5500/xls.xls&quot;, true); xhr.responseType = &quot;arraybuffer&quot;; xhr.onload = (e) =&gt; &#123; if (xhr.status == 200) &#123; var data = new Uint8Array(xhr.response); var workbook = XLSX.read(data, &#123; type: &quot;array&quot; &#125;); // 获取实际表格长度（去除表头） let carryLen = 0; for (const key in workbook.Sheets[&quot;Sheet&quot;]) &#123; const ele = workbook.Sheets[&quot;Sheet&quot;][key]; if (key.includes(&quot;A&quot;)) &#123; carryLen++; &#125; &#125; // 解析数据 let xls = []; for (let i = 2; i &lt;= carryLen; i++) &#123; let data = workbook.Sheets[&quot;Sheet&quot;]; xls.push(&#123; key: data[&quot;A&quot; + i].w, value: data[&quot;B&quot; + i].w, &#125;); &#125; resolve(xls); &#125; &#125;; xhr.send(); &#125;);&#125; 看到这里肯定也有细心的好奇宝宝问，为啥循环体中的i为2呢? 答案：因为表格中的A1，B1为表格的第一行，而第一行是表头，要去除 将链接生成为二维码12345678910111213141516171819new Promise((resolve, reject) =&gt; &#123; // 生成二维码 QRCode.toDataURL( &#x27;xxxxxxx&#x27;, &#123; width: 260, height: 260, margin: 3, &#125;, (error, url) =&gt; &#123; if (error) console.error(error); const code = new Image(); code.src = url; code.onload = () =&gt; &#123; ctx.drawImage(code, 0, 0); resolve(code); &#125;; &#125; ); 写入中间logo12345678return new Promise((resolve, reject) =&gt; &#123; const code = new Image(); code.src = &quot;http://127.0.0.1:5500/logo.jpeg&quot;; code.onload = () =&gt; &#123; ctx.drawImage(code, 260 / 2 - 20, 260 / 2 - 20, 40, 40); resolve(); &#125;;&#125;); 写入底部文字123456// 写入编号ctx.font = &quot;24px Arial&quot;;ctx.fillStyle = &quot;#000&quot;;ctx.textAlign = &quot;center&quot;;ctx.textBaseline = &quot;middle&quot;;ctx.fillText(xls[index].value, 130, 270); canvas转化为图片，并下载到本地1234567// 用于预览let url = document.getElementById(&quot;canvas&quot;).toDataURL(&quot;image/png&quot;);var a = document.createElement(&quot;a&quot;); // 生成一个a元素var event = new MouseEvent(&quot;click&quot;); // 创建一个单击事件a.download = xls[index].value; // 将a的download属性设置为我们想要下载的图片名称，若name不存在则使用‘下载图片名称’作为默认名称a.href = url; // 将生成的URL设置为a.href属性a.dispatchEvent(event); // 触发a的单击事件 第一张图片，完成生成 递归调用我们修改发起逻辑代码，逻辑尾部增加递归调用就好啦 12345678910111213141516171819202122232425262728readWorkbookFromRemoteFile().then((res) =&gt; &#123; createImg(res, 0); // 递归生成&#125;);// ......// 实际生成逻辑function createImg(xls, index) &#123; new Promise((resolve, reject) =&gt; &#123; // 生成二维码 &#125;) .then((res) =&gt; &#123; // 生成中间logo &#125;) .then(() =&gt; &#123; // 写入编号 &#125;) .then(() =&gt; &#123; // 下载图片 &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; if (xls.length &gt; index + 1) &#123; ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); // 初始化画布 createImg(xls, index + 1); &#125; &#125;, 20); // 爱惜机器，加个延时，也可以去掉延时，体会机器的极致速度 &#125;);&#125; 最终效果 至此，终于实现了刷刷刷下载图片炫酷效果，此时可以脑部一段很快的rap，如果华佗再世，崇洋可以医治，外邦来学汉字…………… 最终生成的文件 最终代码地址 一定要针对该项目启动一个本地服务器，否则资源无法访问 web-Output-QRcode 结语​ 首先纠正一点，JavaScript开发者针对生成二维码类似的任务，首选肯定是puppeteer，使用浏览器绕个弯这种实现方案，多少带点科研味道，长期项目自然是不推荐的 ​ 带着学习的态度去完成需求，并且不断优化代码、总结问题，将遇到的未知知识点学会，（比如创建a链接，自动触发点击事件），这才是本文的目的。 ​ 感谢阅读，觉得还不错就点个赞吧~ ​ QQ交流群：530496237 大佬解答疑惑~（内有微信群二维码） ​","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"三个案例带你理解Event Loop流程","slug":"聊一聊宏任务与微任务以及EventLoop","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:01.480Z","comments":true,"path":"2022/03/15/聊一聊宏任务与微任务以及EventLoop/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E8%81%8A%E4%B8%80%E8%81%8A%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEventLoop/","excerpt":"","text":"为什么 JavaScript 需要 Event Loop JavaScript 在创建之初就确认了一点，JavaScript 是一门单线程语言，因为 JavaScript 主要提供用户互动以及操作 DOM，假定存在两个线程，同时对一个 Dom 进行操作，那究竟以谁为准呢，为了避免这种复杂性，JavaScript 确认了单线程这个核心概念 在单线程中，除了 JavaScript 本身的逻辑之外，还存在一些 IO 操作，例如从服务端获取数据，在单线程中就需要等待结果的返回才能继续下面的逻辑，这时候机器是挂起状态，为了避免这个低效问题，这里就引入了同步任务与异步任务的概念，依旧是是单线程，但是有些任务不等待其运行结果 于是同步任务都在函数执行栈（Stack）上执行，所有的异步任务，在有了运行结果之后，就会将其放入任务队列（callback queue），如果 Stack 中任务执行完毕，就会再去检查任务队列是否存在待执行的回调任务，将其任务放入 Stack，再执行，这里就会不断循环此操作 Stack 执行 - Stack 执行完毕 - 检查任务队列 - 将任务加入 Stack - Stack 执行，这样重复的过程就需要 Event Loop 来持续不断的循环检查任务队列，确保异步任务被准时加入到 Stack 相关名词介绍函数执行栈（Stask）：遵循后进先出原则，同步函数执行栈 webAPIs：异步任务的发起者，事件是首先进入 stack，例如 click，change，再将 callback 加入任务队列 回调队列（callback queue）：也可以被称为任务队列，回调函数到达了执行时机就会进入任务队列，他们将会被 Event Loop 持续打入函数执行栈 事件循环解析我们用 Event Loop 来解释一个简单的 demo 1234567consoleo.log(&quot;1&quot;);setTimeout(() =&gt; &#123; console.log(&quot;2&quot;);&#125;, 5000);console.log(&quot;3&quot;); 我相信大部分人都知道，这里打印的顺序为 1 3 2，下面我们用事件循环的流程来说明为什么是这个结果 注： cb 为 callback console.log(&#39;hi&#39;)，进栈 执行 出栈，打印 1 setTimeout进栈 执行 cb 加入异步队列 自身出栈 console.log(&#39;end&#39;)，进栈 执行 出栈 打印 3 5s 后，cb 加入任务队列，event Loop 检查当前执行栈是否存在函数，检查发现不存在，将 cb 加入函数执行栈 cb进栈 执行 出栈 打印 2 我们通过 event Loop 的角度进行解析，就能很轻易的解释为什么代码执行顺序是 1 3 2，这是非常简单的场景，接下来我们会分析一些更加有难度的代码 关于宏任务与微任务 通过上面的介绍，我相信大部分人都事件循环有一个基础的认知的，但是与以上我们通过简单的示例，演示了异步代码在事件循环中的运行流程，并没有涉及宏任务与微任务，这两货是什么呢，为什么要在这里出现？ 首先，宏任务（macrotask），微任务（microtask）都是异步任务 宏任务：setTimeout setInterval setImmediate I/O 键盘事件 网络事件 UI rendering 微任务：pormise MutationObserver process.nextTick 他们在执行层面上存在一定差异 例子 1123456789101112131415console.log(&quot;script start&quot;);setTimeout(function () &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);Promise.resolve() .then(function () &#123; console.log(&quot;promise1&quot;); &#125;) .then(function () &#123; console.log(&quot;promise2&quot;); &#125;);console.log(&quot;script end&quot;); 结果为 script start script end promise1 promise2 setTimeout pormise 与 setTimeout 虽然都是异步任务，但是上图的代码你会发现，promise 仿佛插队了，这便是宏任务与微任务在任务队列最大的不同之处 event Loop 在事件循环中,首先解析 script，将宏任务加入宏任务队列，将微任务加入微任务队列，栈空了之后，执行当前微任务，第一轮事件循环结束 在第二轮事件循环中，首先执行宏任务 callback 中的第一个，执行完毕，栈空了之后，再执行当前微任务，后面同理 例子 212345678910111213141516171819202122232425console.log(&quot;a&quot;);setTimeout(() =&gt; &#123; console.log(&quot;b&quot;); setTimeout(() =&gt; &#123; console.log(&quot;g&quot;); &#125;, 0); new Promise((resolve) =&gt; &#123; resolve(); &#125;).then(() =&gt; &#123; console.log(&quot;h&quot;); &#125;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&quot;c&quot;); resolve();&#125;) .then(function () &#123; console.log(&quot;d&quot;); &#125;) .then(function () &#123; console.log(&quot;e&quot;); &#125;);console.log(&quot;f&quot;); 大家可以先别看答案，自己先尝试将答案推算出来 第一轮事件循环console.log(&quot;a&quot;);进入栈 执行 出栈 打印 a setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 console.log(&quot;c&quot;);进入栈 执行 出栈 打印 c new Promise.then 进入微任务队列 console.log(&quot;f&quot;);进入栈 执行 出栈 打印 f new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;d&quot;)进入栈 执行 出栈 打印 d console.log(&quot;e&quot;)进入栈 执行 出栈 打印 e –微任务执行完毕 第一轮事件循环完毕– 结果为 a c f d e 第二轮事件循环第一轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;b&quot;) 进入栈 执行 出栈 打印 b setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 new Promise.then 进入微任务队列 new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;h&quot;)进入栈 执行 出栈 打印 h –微任务执行完毕 第二轮事件循环完毕– 结果为 b h 第三轮事件循环第二轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;g&quot;);进入栈 执行 出栈 打印 g —宏任务完毕，开始执行微任务— –微任务队列为空 第三轮事件循环完毕– 结果为 g 结果a c f d e b h g 宏&#x2F;微任务的结论通过上面三个例子，我们可以得出以下结论 函数执行栈中如果还存在函数，则等待其结束，才会继续事件循环 Event Loop 先执行同步任务，再微任务，下一轮循环，宏任务加入队列，执行，所以说先微任务，再宏任务是合理的 单次 Event Loop 中，只会执行一次宏任务，但是微任务可以一次执行多个 推荐文章做一些动图，学习一下 EventLoop 通过动图看 Event Loop 更加便于理解 总结 JavaScript 单线程语言的特性注定其需要异步队列，让网页交互体验上更加友好，对于开发来说，需要尽量了解其特性 首先我们需要了解事件循环机制，搞懂代码执行栈 异步队列的概念，再后面搞懂宏任务与微任务，读懂异步队列的运行机制，这样基本上就可以解决大部分 Event Loop 问题，了解宏任务 微任务 将会对代码执行顺序有更加底层的理解，这样就可以解决","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"基于PromiseA+，从零实现Promise","slug":"promise的源码解读","date":"2021-12-14T16:00:00.000Z","updated":"2022-05-23T08:22:14.257Z","comments":true,"path":"2021/12/15/promise的源码解读/","link":"","permalink":"https://vkcyan.github.io/2021/12/15/promise%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"ECMAScript6中promise是划时代的API，他的出现解决了一直困扰前端开发者的异步问题，从此面对异步回调，我们有了更好的武器 前言​ 面对天天都能见面的promise，不知道你是否有以下的一些问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 为什么resolve之后才会执行then或者catch？ 为什么可以链式.then，并且还都会按同步进行？ 为什么执行promise.resolve()，后面的函数就支持promise了？ promise.all是如何实现的？ 是否被面试题中的promise题目迷惑的头晕目眩？ 让我们了解Promise的实现原理，所有问题答案自然浮出水面~ ​ promise在潜移默化之间帮助我们简化了复杂的异步代码，降低逻辑难度，说promise是划时代的异步解决方案也不为过，他很好的提现了开放封闭原则，解决耦合性过高的问题 ​ 说一个小知识，es6发布之前类似prmise的异步方案已经存在，在jquery的ajax中已经应用了类似的技术方案的jQuery.deferred()，感兴趣的同学可以去了解一下 123$.ajax(&quot;test.html&quot;).done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;).fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 简化版Primise 基础版本的实现虽然简单，但是解释了很多问题 建议将代码复制到本地，通过断点的方式查看代码的执行流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const PEDDING = &#x27;pending&#x27; // 等待状态const FULFILLED = &#x27;fulfilled&#x27; // 成功状态const REJECTED = &#x27;rejected&#x27; // 失败状态class APromise &#123; constructor(executor) &#123; this.status = PEDDING // 初始化状态 this.value = undefined // 成功的数据 this.reason = undefined // 失败的原因 this.onFulfilledCallbacks = [] // 保存成功状态的回调队列 this.onRejectCallbacks = [] // 保存失败状态的回调队列 const resolve = (data) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = FULFILLED this.value = data &#125; this.onFulfilledCallbacks.map((e) =&gt; e()) &#125; const reject = (err) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = REJECTED this.reason = err &#125; this.onRejectCallbacks.map((e) =&gt; e()) &#125; try &#123; executor(resolve, reject) &#125; catch (error) &#123; rejected(error) &#125; &#125; then(onFulfilled, onRejected) &#123; if (this.status == FULFILLED) &#123; onFulfilled(this.value) &#125; if (this.status == REJECTED) &#123; onRejected(this.reason) &#125; if (this.status == PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(this.value) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; &#125;&#125;new APromise((resolve, reject) =&gt; &#123; console.log(&#x27;开始回调&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;执行回调&#x27;) resolve(11111) &#125;, 1000)&#125;).then( (value) =&gt; &#123; console.log(&#x27;成功回调&#x27;, value) &#125;, (err) =&gt; &#123; console.log(&#x27;失败回调&#x27;, err) &#125;) 代码运行流程 初始化APromise，开始执行class中的constructor 在constructor中初始化当前promise的一些状态值以及resolve，reject函数 最后将resolve函数与reject函数以参数的形式给promise的回调函数，同时执行函数，打印开始回调 运行setTimeout，并且开始解析then函数 如果是成功，或者失败状态，直接执行回调，如果是pedding状态，则存储成功与失败回调函数 1s之后，setTimeout执行完毕，resolve执行触发constructor中的resolve resolve函数中执行之前初始化.then时候存储的回调函数，打印 成功回调，11111或者失败回调 逻辑流程图 基础版本的实现，不支持链式调用，不支持then穿透，不支持catch，只实现了最基础的逻辑 我们在这里解答一下前言中提出的问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 答：new的时候执行Promise中的constructor，声明了resolve与reject，并且在执行Promise回调函数的时候将参数传入到函数中 为什么resolve之后才会执行then或者catch？ 答：因为在初始化阶段，pedding状态下，我们存储了当前Promise的成功与失败回调，当执行resolve的时候，当前Promise的状态发生变化，开始执行之前存储的回调函数，如果不是padding，则立即执行回调函数 后面的问题我们暂时还无法解释，但是随着我们进一步的实现，答案都会浮出水面 正式版（链式回调，then值穿透，.catch 等）链式回调​ 我们一般写promise都会写多个.then，在多个.then中我们将异步代码变成同步代码块，但是我们基础版本的promise中无法显示链式调用，因为执行.then之后函数没有任何返回值，自然不会存在.then方法，在这个思路上，我们对promise的.then解析过程进行改写,尝试让其支持链式调用 每次.then中都需要返回一个promise来触发下一个.then 对then回调函数的各种情况需要进行判断，例如。then中返回的是一个string还是返回了一个promise，如果是则需要增加链式回调触发父级的resolve then函数执行需要通过settimeout进行包裹，让其加入宏任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * then可能返回的是普通值,也可能返回一个promise，这里的写法参照PromiseA+标准进行完成 * 逻辑较为复杂，可以先看静态变量代码逻辑，再看针对promise的处理逻辑 * @param &#123;*&#125; promise 当前promise * @param &#123;*&#125; x 当前返回值 * @param &#123;*&#125; resolve 成功回调 * @param &#123;*&#125; reject 失败回调 */const resolvePromise = (promise, x, resolve, reject) =&gt; &#123; if (promise === x) &#123; return reject(new TypeError(&#x27;检测到promise的循环调用&#x27;)) // &#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27; &#125; let called = false if ((typeof x === &#x27;object&#x27; &amp;&amp; x !== null) || typeof x === &#x27;function&#x27;) &#123; try &#123; const then = x.then if (typeof then === &#x27;function&#x27;) &#123; then.call( x, (y) =&gt; &#123; if (called) return called = true resolvePromise(promise, y, resolve, reject) &#125;, (r) =&gt; &#123; if (called) return called = true reject(r) &#125; ) &#125; else &#123; resolve(x) &#125; &#125; catch (err) &#123; if (called) return called = true reject(err) &#125; &#125; else &#123; resolve(x) &#125;&#125;then(onFulfilled, onRejected) &#123; let apromise = new APromise((resolve, reject) =&gt; &#123; if (this.status === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) &#125; &#125;) return apromise&#125; 经过上面的内部promise处理，函数的运行逻辑发生了很大的变化 我们直观看到的逻辑是 ​ 实际的运行逻辑是每次.then中都会再次创建一个Promise，以便于下次进行调用，并且对.then的回调函数进行处理，区分.then中返回了Promise对象还是普通对象，这样的思路实现了.then链式调用 当then中存在return promise的情况，逻辑会发生一些变化，这些主要体现在resolvePromise函数中 then值穿透首先查看一种场景 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then() .then() .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) ​ 这里我们就会发现，then的回调函数都不存在，自然无法将resolve的值传递到最下面的.then中，所以这里我们需要对这种情况做一些处理 123456789then(onFulfilled, onRejected) &#123; // 值穿透问题 如果then是空的话,就手动的将上一个resolve的值带入到下一个then中 onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : (data) =&gt; data onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err &#125; let apromise = new APromise((resolve, reject) =&gt; &#123; // .... &#125;) return apromise&#125; 当我们对then值中的回调函数进行处理后，实际运行的函数变成 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then((data) =&gt; data) .then((data) =&gt; data) .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) 这样便实现了then穿透问题 .catch目前我们错误回调在.then的第二个参数中，并不支持.catch的写法，我们可以在原型链上面增加catch方法 catch其实也是对.then方法的封装，只不过不存在成功回调，只有失败回调 123APromise.prototype.catch = function (errCallback) &#123; return this.then(null, errCallback)&#125; .finally 由于finally无法预知promise的最终状态，所以finally的回调函数中不接受任何参数，他仅用于无论最终结果都要执行的情况 需要注意的一点是如果finally中存在Promise，这需要等待promise执行完毕 123456789101112APromise.prototype.finally = function (callBack) &#123; return this.then( (data) =&gt; &#123; return APromise.resolve(callBack()).then(() =&gt; data) &#125;, (err) =&gt; &#123; return APromise.reject(callBack()).then(() =&gt; &#123; throw err &#125;) &#125; )&#125; 关于finally的小知识123Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 此时传递下去的是undefinedPromise.resolve(2).finally(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 传递下去的是 2，finally本身未接收参数，但是将上次的回调数据放入到了下次的回调 Promise.resolve() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回成功回调 12345APromise.resolve = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; resolve(data) &#125;)&#125; Promise.reject() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回失败回调 12345APromise.reject = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; reject(data) &#125;)&#125; Promise.race() 当调用race方法的时候，必须传入一个数组，数组中可以存在不同类型以及函数类型，在初始化过程中会再次创建一个promise，当数组中的某个promise对象最先执行的时候，触发自身的.then在回调函数中触发了race本身的resolve，后面执行完毕之后，因为race的状态已经发生了变化，自然无法再执行 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 同时执行多个promise,但是最返回最先返回的结果 * @param &#123;*&#125; promiseList * @returns */APromise.race = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须传递数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; promiseList.forEach((item) =&gt; &#123; if (item &amp;&amp; typeof item.then == &#x27;function&#x27;) &#123; item.then(resolve, reject) &#125; else &#123; resolve(item) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;ok2&#x27;) &#125;, 2000)&#125;)APromise.race([1, p1, p2]).then( (data) =&gt; &#123; console.log(&#x27;success1&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error1&#x27;, err) &#125;) Promise.all() all的实现逻辑非常简单，all的时候创建一个promise，内部记录当前传入的列表状态成功的单个数据，当所有的then数据都成功，调用自己的resolve，当有一个失败的时候，调用自己的reject 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 同时执行多个promise,会等待每次promise的结果,最后一起返回,有一个失败,这都不会返回 * @param &#123;&#125; promiseList * @returns */APromise.all = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resulteArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (key, val) =&gt; &#123; resulteArr[key] = val if (++currentIndex == len) &#123; resolve(resulteArr) &#125; &#125; for (let i = 0; i &lt; len; i++) &#123; const val = promiseList[i] if (val &amp;&amp; typeof val.then === &#x27;function&#x27;) &#123; val.then((data) =&gt; &#123; getResult(i, data) &#125;, reject) &#125; else &#123; getResult(i, val) &#125; &#125; &#125;)&#125;let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;); &#125;, 1000);&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;); &#125;, 2000);&#125;)Promise.all([1,2,3,p1,p2]).then(data =&gt; &#123; console.log(&#x27;success&#x27;, data);&#125;, err =&gt; &#123; console.log(&#x27;error&#x27;, err);&#125;) Promise.any() 实现方法与all非常相似，是all完全相反的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * any与all完全相反,只要有个一个成功就会返回成功,全部失败才会返回失败 * @param &#123;*&#125; promiseList * @returns */APromise.any = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, err) =&gt; &#123; resultArr[index] = err if (++currentIndex == len) &#123; reject(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then(resolve, (err) =&gt; &#123; getResult(index, err) &#125;) &#125; else &#123; resolve(res) &#125; &#125;) &#125;)&#125;let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.any([p3, p4]).then( (data) =&gt; &#123; console.log(&#x27;success&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error&#x27;, err) &#125;) Promise.allSettled() allSettled是ES2020加入的工具方法，一句话总结：他是永远都不会失败处理的promise.all 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 保存所有的成功与失败 * @param &#123;*&#125; promiseList * @returns */APromise.allSettled = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, data, status) =&gt; &#123; if (status == FULFILLED) &#123; resultArr.push(&#123; status: status, value: data, &#125;) &#125; if (status == REJECTED) &#123; resultArr.push(&#123; status: status, reason: data, &#125;) &#125; if (++currentIndex == len) &#123; resolve(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then( (data) =&gt; &#123; getResult(index, data, FULFILLED) &#125;, (err) =&gt; &#123; getResult(index, err, REJECTED) &#125; ) &#125; else &#123; getResult(index, res, FULFILLED) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;) &#125;, 2000)&#125;)let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.allSettled([1, 2, 3, p1, p2, p3, p4]).then((res) =&gt; &#123; console.log(&#x27;success&#x27;, res)&#125;) 测试函数首先需要安装测试脚本 npm install -g promises-aplus-tests 测试命令 promises-aplus-tests xxxx.js 测试文件末尾需要加入如下代码 不存在错误则为符合promiseA+标准 12345678910APromise.defer = APromise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new APromise((resolve, reject) =&gt; &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd&#125;module.exports = APromise 源码地址github-promise 可以通过chrome DevTool或者Vscode Debug的方式，加上断点，查看代码运行流程，便于理解promise运行逻辑 参考链接重学Promise，基于A+规范实现它，感谢掘金@关er的promise解读文章，大大降低了深入promise的门槛 PromiseA+规范 MDN-Promise 45道Promise面试题","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"简易版Reactivity源码解析","slug":"简易版Reactivity源码解析","date":"2021-11-30T16:00:00.000Z","updated":"2022-05-23T08:17:48.866Z","comments":true,"path":"2021/12/01/简易版Reactivity源码解析/","link":"","permalink":"https://vkcyan.github.io/2021/12/01/%E7%AE%80%E6%98%93%E7%89%88Reactivity%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 首先感谢__mxin同学的简易版本，没有这个简化版本，我大概率也没办法沉下心来将代码读下去，再次表示感谢，通读下来简化之后的逻辑清晰，只需要对几个JavaScript原生API进行了解，走完代码流程，便了解了核心流程 代码地址：传送门 前置知识Proxy Reflect WeakMap 核心流程图​ 尝试绘制了一遍代码流程图，主要流程就是初始化时候对reactive，computed，effect的依赖收集，以及在触发set事件的时候，对收集到的依赖的触发 reactive123456789const object = &#123; r: 0, g: 0, b: 0, o: &#123; a: 1, &#125;, &#125; const proxy = reactive(object) ​ reactive是一个赋予对象响应式特征的方法，传入的数据会被proxy代理，变量一旦被代理，就将会被加入reactiveMap，以后都会触发reactiveMap内的proxy 12345678910111213141516171819202122232425262728/** * 定义响应式对象，返回proxy代理对象 * @param &#123;*&#125; object */function reactive(object) &#123;// 判断是否已经代理，已经存在直接取自 if (reactiveMap.has(object)) return reactiveMap.get(object) // 第一次进行处理，进行proxy代理 const proxy = new Proxy(object, &#123; // 处理器对象，定义捕获器 get(target, key) &#123; console.log(&#x27;get方法&#x27;, target, key) // 针对effect，computed依赖进行处理 track(target, key) // 如果当前代理的值为object类型，将会对当前的值再次进行proxy,否则直接获取数据 return typeof target[key] === &#x27;object&#x27; ? reactive(target[key]) : Reflect.get(...arguments) &#125;, set(target, key) &#123; console.log(&#x27;设置的值&#x27;, ...arguments) // 在set事件中对原本的数据进行修改 Reflect.set(...arguments) // trigger(target, key) &#125;, &#125;) reactiveMap.set(object, proxy) return proxy&#125; 完成代理的数据 effect effect会在依赖的经过reactive处理后的对象发生变化的时候，自动执行一次回调函数，通常称它为副作用函数 effect的实现是Reactivity最核心的部分，也是比较难理解的部分，依赖WeakMap进行实现，如果不了解WeakMap，务必先去看一下文档 1234567const computedObj = computed(() =&gt; &#123; return proxy.r * 2&#125;)effect(() =&gt; &#123; console.log(`proxy.o.a: $&#123;proxy.o.a&#125;`)&#125;) 初始化的过程中触发effect，将函数fn放入effectStack，同时执行effect中的函数，一旦执行，必定会触发经过reactive代理的get函数，进行数据获取 123456789101112131415161718192021222324252627282930313233343536373839404142const effectStack = [] // 收集副作用函数/** * 副作用函数 */function effect(fn) &#123; try &#123; // 将需要执行的effect入栈 effectStack.push(fn) // **** 执行该effect，进入proxy的get拦截 **** return fn() &#125; finally &#123; // 依赖收集完毕及所有get流程走完，当前effect出栈 effectStack.pop() &#125;&#125;// ......// get方法触发了track方法get(target, key) &#123; // .... track(target, key) // ....&#125;/** * 依赖收集 */function track(target, key) &#123; // 初始化依赖Map let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; // 第二层依赖使用Set存放key对应的effect let dep = depsMap.get(key) if (!dep) &#123; targetMap.get(target).set(key, (dep = new Set())) &#125; // 取当前栈中的effect存入第二层依赖中 const activeEffect = effectStack[effectStack.length - 1] activeEffect &amp;&amp; dep.add(activeEffect) // 最后触发effect函数的finally，将处理完毕的effect进行弹出，完成依赖收集&#125; 初始化完成后，effect全部完成处理，我们可以看一下targetMap的数据 我们可以看到，变量a与effect中的函数关联在了一起，经过track处理后，effect内部用到的变量都与effect建立了某种关联，至此我们就完成了依赖收集 computedReactivity计算属性的实现是依赖effect进行实现，仅仅是增加了一个value函数进行包裹 12345678910/** * 计算属性 */function computed(fn) &#123; return &#123; get value() &#123; return effect(fn) &#125;, &#125;&#125; 变量发生变化数据发生变化的时候，例如我们将proxy.o.a&#x3D;1,他是如何完成响应式，以及effect的触发的呢？ 首先一定是触发proxy的set函数 123456789101112131415161718192021222324set(target, key) // 修改代理的值 Reflect.set(...arguments) // 等同于arguments[0][arguments[1]] = arguments[2] // 触发依赖收集器 trigger(target, key)&#125;, /** * 依赖收集触发器 */function trigger(target, key) &#123; // target: &#123;a:1&#125; key: a // 获取当前修改的值 const depMap = targetMap.get(target) // 开始执行effect方法 if (depMap) &#123; // 如果存在，开始寻找Map的value，在通过key找到对应的回调函数 const effects = depMap.get(key) effects &amp;&amp; effects.forEach((run) =&gt; &#123; // 执行收集的effect函数 run() &#125;) &#125;&#125; 至此完成数据的响应式，effect的函数触发完成 关键概念reactive 创建响应式对象 effect 副作用函数，存储匿名函数，同时调用自身收集依赖，最后弹出匿名函数 computed 计算属性，其原理是对effect的包装 track 收集依赖，绑定变量与使用该变量的effect trigger 触发依赖，根据变量触发对应的effect 总结​ 这个文章是一个代码记录贴，希望大家看到可以静下心来看看__mxin同学的文章，或者传送门代码，了解了基础的原理后再去看@vue&#x2F;Reactivity的代码，将会事半功倍； ​ 日积月累，将知识变成你的财富吧","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"React17学习记录","slug":"react17学习","date":"2021-10-14T16:00:00.000Z","updated":"2022-05-23T08:22:16.813Z","comments":true,"path":"2021/10/15/react17学习/","link":"","permalink":"https://vkcyan.github.io/2021/10/15/react17%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"为什么学习React17​ 公司使用的是vue技术栈，并且因为历史原因，以及外部因素，可能不会使用react来做生产环境的项目，最近vue3走上正轨，大家都需要抛弃vue2.x的编码思想，在vue3中，hook思想开始越发明显，所以学习react17也是想借此加深对hook的理解，同时取长补短，综合vue与react的优点，在实际的开发中更好的完成开发任务 useState的疑问​ 关于react的useState有一个疑问，useState里面是一个对象，我想要修改对象里面的某一个字段，每次都需要...state,把之前的数据预先填入，这做法感觉有点傻 自定义hookhook是在特定换下调用自己的代码 实现自定义hook必须使用关键字use开头，这是ESLint的规则 自定义hook一般用于需要持续监听的值，而针对纯工具函数则不需要进行处理 实现一个hook风格的防抖函数1234567891011121314151617181920212223242526const [param, setParam] = useState(&#x27;ha ha&#x27;);const debounceParam = useDebounce(param, 2000);useEffect(() =&gt; &#123; console.log(&#x27;log log&#x27;)&#125;, [debounceParam]);/** * 去抖函数 * @param value 监听的值 * @param delay 防抖时间 * @returns 变化后变量 */export function useDebounce(value, delay) &#123; // 声明一个保存防抖结果的字段 const [debounceValue, setDebounceValue] = useState(value); useEffect(() =&gt; &#123; // 每次value,delay发生变化的时候生成一个定时器 const timeout = setTimeout(() =&gt; &#123; setDebounceValue(value); &#125;, delay); // 在执行下一个useEffect之前,会执行上一个useEffect的返回函数 return () =&gt; clearTimeout(timeout); &#125;, [value, delay]); return debounceValue;&#125; useDebounce是一个hook风格的函数 每次param发生变化都会触发useDebounce中的useEffect 而在2000ms时间内如果重复触发就会执行上一个effect return的函数 进而不修改debounceValue，直到2000ms内无任何操作，触发setDebounceValue修改属性，改变了debounceParam 第一个useEffect触发，触发打印log log react中使用TS做代码静态检查 函数类型 fn: () =&gt; void any类型是危险的，应当尽量不用，但是对于模糊的类型，我们可以在标注类型为unknown，这样就不会对赋值做任何校验，但是ts不允许我们对unknown类型做出任何处理，所以可以吧unknown理解成为加强版any 针对参数不固定，返回值不确定的场景，应当使用泛型，在方法名称后面加,然后在参数上指定某一个为T，则T跟这参数的类型而变化 自定义hook useArray 传入一个hook，我们返回针对这个hook的可使用的对应方法，总体来说实现一个hook还是一个比较简单 1234567891011121314151617181920212223242526/** * hook处理的Array * @param value * @returns */export function useArray&lt;V&gt;(value: V[]) &#123; const [arrayValue, setArrayValue] = useState(value); const clear = () =&gt; &#123; setArrayValue([]); &#125;; const add = (value: V) =&gt; &#123; setArrayValue([...arrayValue, value]); &#125;; const removeIndex = (index: number) =&gt; &#123; let value = [...arrayValue]; value.splice(index, 1); setArrayValue(value); &#125;; return &#123; value: arrayValue, add, clear, removeIndex, &#125;;&#125; 关于TS中interface的属性继承123456789101112131415161718interface a &#123; a: number;&#125;interface b extends a &#123; b: number;&#125;let c: b = &#123; a: 1, b: 2,&#125;;function test(p: a) &#123; console.log(p);&#125;test(c); // 不会报错，因为b包含了a，所以这个传入b也不会出现错误 useContext useContext主要用于多个组件之间共享状态 在parent组件中存在child1.child2，child3组件，我们希望这些组件之前都共享一个状态1 生成createContext 1const TestContext = React.createContext(&#123;&#125;); 使用createContext.Provider包裹parent组件 1234567891011&lt;TestContext.Provider value=&#123;&#123; username: &#x27;我是变量&#x27;, &#125;&#125;&gt; &lt;div className=&quot;parent&quot;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;Child3 /&gt; &lt;/div&gt;&lt;TestContext.Provider/&gt; 在子组件中就可以使用useContext来获取父级创建的TestContext 12345678const Child1 = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext); return ( &lt;div className=&quot;child1&quot;&gt; &lt;p&gt;1 message for &#123;username&#125;&lt;/p&gt; &lt;/div&gt; )&#125; 通过useContext就可以做到子组件共享一个状态，如果状态被改变，所有使用变量的都放都会发生变化 TS类型的一些知识Parameters 获取函数的全部参数，并且以元祖类型进行返回,Utiltity Types 123456function test(a: string, b: number, c: number[], d: any) &#123;&#125;// 直接继承test函数的全部参数类型function testPlus(...[a, b, c, d]: Parameters&lt;typeof test&gt;) &#123; console.log(a, b, c, d);&#125; 联合类型12345678910111213141516let a:string | number; // 可以是多种类型// 抽象联合类型type aType:string | number;let a:aType// 也可以通过interface可以实现类型功能，但是指定单个类型是无法实现的，但是interface的全部功能type都可以实现// 例如：interface aaa &#123; a:string&#125;type aaa = &#123; a:string&#125;// 以上2种效果都是一致的 js的typeof与ts的typeof123// js: typeof runtime阶段运行 检查参数的类型// ts: typeof 静态检查阶段运行 识别函数的参数 Partial与Omit关键字123456789101112131415type Preson = &#123; name: string; age: String; sex: string;&#125;;// Partial关键字会将传入的类型处理成为非必填const xiaoMin: Partial&lt;Preson&gt; = &#123; age: &quot;非必填&quot;, name: &quot;非必填&quot;, sex: &quot;非必填&quot;,&#125;;// Omit 会删除第一个参数 类型 中的第二个参数中的变量 并返回结果 例如这里删除 name ageconst shenMiRen: Omit&lt;Preson, &quot;age&quot; | &quot;name&quot;&gt; = &#123; sex: &quot;男&quot; &#125;; 关于css一些不知道的关于remem表示相对于父级的font-size rem表示相对于根元素html的font-size 正常默认font-size为16px，那么1rem &#x3D;&#x3D;&#x3D; 16px 如果希望rem的比例自定义只需要将html的font-size设置为对应的百分就行，例如设置为62.5的时候1rem &#x3D;&#x3D;&#x3D; 10px 关于vhvh的全称为viewport height，100vh就是代表视口的高度 emotion emotion是一个css in js的方案，也就是使用js来写css代码，这样的话就可以在css中直接写逻辑 12345678910111213import styled from &quot;@emotion/styled&quot;;export const Row = styled.div&lt;&#123; gap: number;&#125;&gt;` display: flex; align-items: center; &gt; * &#123; margin-top: 0 !important; margin-bottom: 0 !important; margin-right: $&#123;(props) =&gt; `$&#123;props.gap&#125;rem`&#125;; &#125;`; 自定义hook useAsync的实现 useAsync可以理解为针对请求体再次封装，经过封装之后的请求体，自带请求进度，以及针对catch更加优雅的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; useState &#125; from &quot;react&quot;;interface State&lt;D&gt; &#123; error: Error | null; data: D | null; status: &quot;idle&quot; | &quot;loading&quot; | &quot;error&quot; | &quot;success&quot;;&#125;// 建立初始化的值const defaultState: State&lt;null&gt; = &#123; data: null, error: null, status: &quot;idle&quot;,&#125;;// 实现函数export const useAsync = &lt;D&gt;(initState?: State&lt;D&gt;) =&gt; &#123; // 默认状态 const [state, setState] = useState&lt;State&lt;D&gt;&gt;(&#123; ...defaultState, ...initState, &#125;); // 请求成功的调用 const setData = (data: D) =&gt; &#123; setState(&#123; data, status: &quot;success&quot;, error: null, &#125;); &#125;; // 请求失败的调用 const setError = (error: Error) =&gt; &#123; setState(&#123; data: null, error: error, status: &quot;error&quot;, &#125;); &#125;; // 请求开始的调用 const setLoading = () =&gt; &#123; setState(&#123; data: null, error: null, status: &quot;loading&quot;, &#125;); &#125;; // 对外实际执行的函数 const run = (promise: Promise&lt;D&gt;) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&quot;请传入 promise 类型数据&quot;); &#125; setLoading(); return promise .then((data) =&gt; &#123; setData(data); &#125;) .catch((err) =&gt; &#123; setError(err); &#125;); &#125;; return &#123; isIdle: state.status == &quot;idle&quot;, isLoading: state.status == &quot;loading&quot;, isError: state.status == &quot;error&quot;, isSuccess: state.status == &quot;success&quot;, run, setData, setLoading, setError, ...state, &#125;;&#125;; 使用阶段 12345678// 逻辑顶部应用相关逻辑 const projectData = useAsync&lt;any[]&gt;(); // 泛型为后台返回的数据的类型// 启动请求，传入请求体projectData.run(request);// 请求完成后，projectData中的数据状态会被同步更新let &#123; data, isLoading,isError,...other&#125; = projectData react中实现捕捉边界错误 关于错误边界的概念在react官网中是这样描述的，组件内的JavaScript错误会导致React的内部状态被破坏，并且在下一次的渲染时会产生可能无法追踪的错误，但是部分ui的JavaScript错误不应该导致整个应用的崩溃，所以react16中引入了错误边界的概念， 错误边界是一种react组件，最终组件可以捕获发生在其朱组件树任何位置的JavaScript错误，并打印错误，同时展示降级ui，而并不会渲染发生崩溃的子组件树，错误边界在渲染期间，生命周期方法和整个组件数的构造函数中捕获错误 123456789101112131415161718192021222324252627282930import React, &#123; ReactNode &#125; from &quot;react&quot;;type FallBackRender = (props: &#123; error: Error | null &#125;) =&gt; React.ReactElement;// 1 2 两种写法一致type Components1 = &#123; children: ReactNode; fallbackRender: FallBackRender &#125;;type Components2 = React.PropsWithChildren&lt;&#123; fallbackRender: FallBackRender &#125;&gt;;export class ErrorBoundary extends React.Component&lt; Components2, &#123; error: Error | null &#125;&gt; &#123; state = &#123; error: null, &#125;; // 当子组件抛出异常, state中的errir就会被调用 static getDerivedStateFromError(error: Error) &#123; return &#123; error &#125;; &#125; render() &#123; const &#123; error &#125; = this.state; const &#123; fallbackRender, children &#125; = this.props; if (error) &#123; console.log(&quot;错误执行&quot;, error); return fallbackRender(error); &#125; else &#123; return children; &#125; &#125;&#125; 使用App.tsx 123456789&lt;ErrorBoundary fallbackRender=&#123;fallPageErrorFallback&#125;&gt; &#123;user ? &lt;AuthenicatedApp /&gt; : &lt;UnAuthenicated /&gt;&#125;&lt;/ErrorBoundary&gt;// 发生错误的时候就会渲染这个domexport const fallPageErrorFallback = (&#123; error &#125;: &#123; error: Error | null &#125;) =&gt; ( &lt;p&gt;请求失败了,错误信息&#123;error&#125;&lt;/p&gt;); 阶段性结束 关于react hook的理念学习已经结束了，这段时间学习来看，确实react在很多方面更加易于理解，更加工程化，同时也学会了很多ts的知识，一直以来ts在我手中都是anyscript，本次学习让我对ts的运用更加熟练；在这个过程中也学会了很多hook相关的理念以及实例，并且可以带着这思想去优化项目代码 可惜我是一名vuer，继续学习react的实际编码，意义已经不是很大，所以关于这个课程的学习，本次告一段落；通过本次学习，非常深刻的体会到了hook的优雅，后面会深入学习vue3，在vue3中将hook与业务结合，让代码更加健壮","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"JS文件格式相互转换","slug":"JavaScript 文件格式互转","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:22:06.432Z","comments":true,"path":"2021/06/15/JavaScript 文件格式互转/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/JavaScript%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%92%E8%BD%AC/","excerpt":"","text":"base64 转 File1234567891011121314151617181920/** * base64转file文件 * @param dataurl * @param filename * @returns */ export function dataURLtoFile(dataurl: string, filename: string) &#123; // 获取到base64编码 const arr = dataurl.split(&#x27;,&#x27;) // 将base64编码转为字符串 const bstr = window.atob(arr[1]) let n = bstr.length const u8arr = new Uint8Array(n) // 创建初始化为0的，包含length个元素的无符号整型数组 while (n--) &#123; u8arr[n] = bstr.charCodeAt(n) &#125; return new File([u8arr], filename, &#123; type: &#x27;image/jpeg&#x27;, &#125;)&#125; base64 转 blob12345678910111213141516/** * base64转blob文件 * @param dataURI * @returns */export function dataURItoBlob(dataURI) &#123; var mimeString = dataURI.split(&#x27;,&#x27;)[0].split(&#x27;:&#x27;)[1].split(&#x27;;&#x27;)[0] // mime类型 var byteString = atob(dataURI.split(&#x27;,&#x27;)[1]) //base64 解码 var arrayBuffer = new ArrayBuffer(byteString.length) //创建缓冲数组 var intArray = new Uint8Array(arrayBuffer) //创建视图 for (var i = 0; i &lt; byteString.length; i++) &#123; intArray[i] = byteString.charCodeAt(i) &#125; return new Blob([intArray], &#123; type: mimeString &#125;)&#125; blob转url1234567891011121314151617181920/** * blob 转 url * @param base64 * @param contentType * @returns */export function translateBase64ImgToBlob(base64, contentType) &#123; var arr = base64.split(&#x27;,&#x27;) //去掉base64格式图片的头部 var bstr = atob(arr[1]) //atob()方法将数据解码 var leng = bstr.length var u8arr = new Uint8Array(leng) while (leng--) &#123; u8arr[leng] = bstr.charCodeAt(leng) //返回指定位置的字符的 Unicode 编码 &#125; var blob = new Blob([u8arr], &#123; type: contentType &#125;) var blobImg: any = &#123;&#125; blobImg.url = URL.createObjectURL(blob) //创建URL blobImg.name = new Date().getTime() + &#x27;.png&#x27; return blobImg&#125;","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"使用gitlabCI/CD完成前端自动化部署","slug":"使用gitlabCICD完成前端自动化部署","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:21:57.486Z","comments":true,"path":"2021/06/15/使用gitlabCICD完成前端自动化部署/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/%E4%BD%BF%E7%94%A8gitlabCICD%E5%AE%8C%E6%88%90%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","excerpt":"","text":"2021年11月16日更新 静态数据提取为变量 增加备份版本 前言为什么使用CI&#x2F;CD？ ​ 目前我们公司更新使用的轻量化更新脚本，更新操作虽然简单,但是不够规范，并且敏感信息存在开发者电脑中，虽然我们git上进行了配置文件忽略，但是依旧存在泄密的风险，为了防止以上情况出现，我们将敏感信息移植到gitlab中，并且将更新操作从人工变为自动化 CI&#x2F;CD的优点自动构建并且状态是每个人都可见的 减少手工的错误，解放了重复劳动力 更好，更快，更加安全，更加稳定的交付 在CI的过程中可以进行代码质量的自动检测，减少人工检查的劳动力 打包环境一致，不会出现编译后代码异常 减少等待时间，更快的交付成果 前置概念CI​ 持续集成（continuous Integration）频繁的将代码继承到主干。目的是让产品可以快速迭代，同时还能保证高质量，他的核心措施就是代码继承到主干之前，必须通过自动化测试，只有存在失败，就不能集成。”持续继承并不能消除bug，而是让他非常容易发现和修改” CD​ 持续交付（continuous Delivery）与持续部署（continuous Deployment）频繁的将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过就会进入生产阶段，持续交付可以看做持续集成的下一步，它强调的是不论怎么更新，软件都是随时随地可以交付的；代码通过评审之后，自动部署到生产环境，持续部署是持续交付的下一步，持续部署的目标是，软件在任何时刻都是可以部署的，可以进入生产阶段 gitLab​ gitLab是一个开源的应用程序，他可以实现私有化的Gti项目仓库，可以通过web界面进行访问公开或者私人项目 gitLab CI&#x2F;CD​ gitLab持续集成，只要在仓库的根目录添加.gitlab-ci.yml文件，并且配置了gitLab runner（运行器），每次代码发生变成的时候就会执行.gitlab-ci.yml中的配置 gitLab Runner​ gitLab Runner是一个开源项目，支持多平台运行，他的作用是每次代码发生变更的时候gitlab CI会根据.gitlab-ci.yml，配置文件执行流水线（Pipeline）中每个阶段Stages中的Jobs，并将结果发送回gitLab。gitLab Runner是基于gitLab CI的API进行构建的相互隔离的机器，所以gitLab Runner 与gitlab本身不需要安装在同一台机器上，并且考虑到执行Runner对资源的消耗，以及安全性问题，所以并不建议安装在同一台机器上 Pipelines​ 流水线，是分阶段的构建任务，比如安装依赖，运行测试，打包部署，流水线由gitLab Runner进行触发，流水线运行的依据是gitlab-ci.yml Stages​ 构建阶段,也就是流水线的每一个环节，我们可以在 Pipelines中建立多个Stages，所有Stages都会按顺序同步进行，只有当所有的Stages都完成了Pipelines才算成功，默认情况下上一个Stages失败，这条流水线则为失败 Jobs​ 表示构建阶段的作业，关于jobs的设置有很多，比如指定手动触发，指定分支触发，同时运行多个jobs，等等，相同的Stages中的jobs会异步进行，Stages中的jobs全部成功了，Stages才为成功，默认情况下存在jobs失败，这条流水线则为失败 .gitlab-ci.yml​ 在gitLab CI&#x2F;CD中，具体如何运行流水线，是由 .gitlab-ci.yml来管理的，这个文件放在项目仓库的根目录 实例代码： 12345678910111213141516# stages：定义Pipeline中的各个构建阶段，并且定义Stages名称stages: - install - build# 定义 install 阶段的一个 jobinstall-job: stage: install script: - echo &quot;hello install&quot;# 定义 build 阶段的一个 jobbuild-job: stage: build script: - echo &quot;Hello, build&quot; 环境搭建​ 此类文章太多了，请自行查找，本文不做搭建介绍 ​ 针对已经搭建好的gitLab以及runner，为了适应前端开发环境，需要安装了node，cnpm，等等依赖 前置技能git：不会git可以退出直播间了，赶快去学吧 linux：常用命令必须会，不然配置runner，以及编写ci.yml脚本的时候会寸步难行 创建组织，导入git的项目 创建组织主要是为了方便配置CI&#x2F;CD的全局变量，也方便项目的集中管理 ​ 在使用gitlab之前，我们的项目可能会在github，gitee，等等其他代码仓库，为了保留之前记录，我们需要将git仓库移植过来 我们之前使用的是gitee，gitlab没有对此做快捷支持，所以我们使用Repo URL,填写好地址与账号，就可以将git仓库导入进来 更新git文件我们将git迁移到gitlab之后，现有项目中的.git文件都需要进行更换，不能再向之前的仓库提交代码。 停止代码提交 获取最新代码，切换到master分支 clone 新的gitlab的仓库 获取新的.git文件，覆盖原本项目中的.git，完成迁移 到目前为止，我们就可以完成git项目的迁移操作 配置组织的CI&#x2F;CD变量​ 组织中的项目大部分都是更新到一个服务器，例如服务器地址与密码，我们可以将这部分数据统一配置到全局变量，这样组织中的项目则无需再次进行设置 注意： 因为我们的项目不仅仅是master分支会运行runner，如果这里不关闭State，除了master（受保护的分支）其他的分支都访问不了这个变量 CI&#x2F;CD的变量功能可以很好的保护项目的隐私数据，可以隔离使用者与项目更新配置 配置gitlab-runner（linux） 注意：本文无搭建gitlab以及gitlab-runner相关教程，一切都是在已经搭建完成的基础上进行使用的 ​ 我们针对项目就要注册一个runner，来完成我们接下来配置中的命令操作，这部分界面操作无法完成，需要对gitlab runner的服务器进行操作 获取配置相关数据 注册自定义runner我们需要注册一个特定的runner，这里官方提示顺序为 安装runner 注册一个runner，并且URL指定为xxx，token指定为xxx 接下来我们就要去runner宿主机上面注册 使用终端工具链接宿主机 输入命令 1gitlab-runner register 完成配置之后，在回到项目CI&#x2F;CD部分的设置,就会发现下面多一个runner 注：刚刚注册的runner状态是黑色的，等会就会变成绿色 到此为止，runner已经准备就绪，他会执行我们项目中的.gitlab-ci.yml文件中的配置 编写.gitlab-ci.yml 具体编写过程请查看官方教程 ps：注意一点，线上静态文件最好不要命名为dist，CI脚本中dist为中转站文件夹，命名为dist会出现问题 1234567891011121314151617181920212223242526272829303132333435363738394041stages: # 分段 - install - build - deploycache: # 缓存 paths: - node_modules - admininstall-job: stage: install only: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - npm install - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./dist $USERNAME@$HOST:$UPLOADDIR/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/xxxx # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/xxxx # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 在配置文件中配置了执行的分支，当我们在prod-pre分支上提交代码的时候，脚本就会自动执行 install项目依赖 build项目 发射到目标服务器 这样就完成我们项目的自动化部署 CI脚本的优化优化自动化部署速度上面我们完成了一个简单的流水线，他可以完成 install build delay，已经满足了基本要求，但是还存在一些小问题 流水线任务时间过长 频繁install存在失败的概率 我们需要优化我们的CI，让速度更快更加稳定 build环节与delay环节没有太大的操作空间，并且大部分的时间都花在install环节，我们启用了gitlab的cache，实际上并不需要每次都打包，针对这个思路我们修改我们job中的 install，在job中增加当前是否存在**node_modules&#x2F;**的判断 123456789install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot; 这样存在缓存的时候就会跳过install阶段，但是这样还存在一个问题，我们修改了依赖，但是gitlab里面缓存还在，必然会出现打包异常的情况，针对package.json发生变化，我们再增加一个job，监听package.json 是否发生变化 静态数据提取为变量 假如存在多个项目，使用本脚本只需要修改此处的variables即可，不需要改script部分 1234variables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹 增加备份功能 删除原有备份文件(仅在生产环境) 删除原有文件 备份原本的代码(仅在生产环境) 将打包完成的文件复制到目标服务器 将目标文件改为服务端真正文件 .gitlab-ci.yml（正式版本） 指定了prod分支，根据实际项目进行修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263stages: # 分段 - repInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹cache: # 缓存 paths: - node_modules - distrepInstall-job: stage: repInstall only: refs: - prod changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - echo &quot;发射到目标服务器✨✨✨&quot; - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/backup/$BACKUPDIR # 删除原有备份文件(仅在生产环境) - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/$PRODDIR/ $UPLOADDIR/backup/$BACKUPDIR/ # 删除原有文件 备份原本的代码(仅在生产环境) - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 - echo &quot;完成更新👏👏👏&quot; after_script: - echo &quot;完成更新👏👏👏&quot; .gitlab-ci.yml（简化） 指定了prod-pre分支，根据实际项目进行修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758stages: # 分段 - preInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist_test # 线上文件名cache: # 缓存 paths: - node_modules - distpreInstall-job: stage: preInstall only: refs: - prod-pre changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/$PRODDIR # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 代码地址：github 结语​ 除了使用gitlabCI&#x2F;CD来完成自动化部署之外也可以使用Jenkins+webHook来完成，效果都是一样的，如果这两种方案对你，或者你的公司来说都比较复杂，那么我建议试试轻量化更新方案，我们也在实际项目上使用过很久，可以确保不会出现稳定性，是可以在生产环境使用的 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"使用iframe+postMessage通信实现商城多页面装修","slug":"使用iframe实现页面装修方案","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:21:59.779Z","comments":true,"path":"2021/06/15/使用iframe实现页面装修方案/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/%E4%BD%BF%E7%94%A8iframe%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E8%A3%85%E4%BF%AE%E6%96%B9%E6%A1%88/","excerpt":"","text":"演示视频演示视频 背景​ 开发项目是多商家的类似有赞的商城后台，需要支持客户端的店铺装修功能 ​ 系统用户多为企业用户对页面效果要求较高，导致首页变化非常频繁 前言2020年第一版本装修上线了，方案是后台“模拟”客户端样式实现可视化，实现首页装修功能 实际上也就是后台写一套与客户端一样的样式解析装修json，实现装修预览的效果 模拟版本的装修上线后，确实解决了多店铺个性化首页的问题，实现了定制化首页，但是随着时间的推移，模拟版本暴露了很多问题，高频率的改版导致需求几乎无法满足 装修数据为静态数据，不会根据商城商品状态而变化，例如某某商品下架了，但是首页装修数据里面依旧存在 每次客户端样式发生变化，后台都需要同步编写一份，否则就无法可视化，导致工作量非常大 不具备扩展性，只能可视化的装修首页，无法可视化装修其他页面，其他页面都是通过一个插槽实现 插槽就是一个json对象的载体，因为不想写2套样式，所以采取这种很抽象的方案 随着业务的拓展，暴露出来的问题也是越来越严重，为了满足需求，很多场景下需要牺牲整个技术部门的效率，以及使用者的体验感，为了解决这个问题必须另辟蹊径，寻找其他解决方案 新方案必须解决以下问题 装修中的商品数据必须为非静态数据 避免2套样式的问题 装修中的商品数据实时刷新可以通过约定有规律的数据结构，后端解析并实时更新商品数据，实现装修中数据的更新 抛弃模拟方案后，也是思考很多方向，但是因为基于业务组件装修是没办法整个装修数据都json化的，所以最终尝试了一个理论上可行的方案，客户端通过iframe嵌入到后台，使用postMessage来完成后台与客户端之间的数据交互，实现装修功能 方案逻辑图 后台装修与客户端的主要思路 装修模式下获取上次的装修记录 建立前后台iframe之前的的联系 后台装修发生变化，触发watch，watch触发postmessage，客户端得到相应，客户端watch触发，实时更新装修数据 装修完成保存到数据库 具体实现方案之前在掘金发布过一篇（开源）从0打造H5可视化搭建系统 - 易动（vue+ts+egg）文章，易动是更加灵活的装修方案，感兴趣的同学可以了解一下 按基础组件定制装修方案，基础模块为： 按钮 文本 图片 轮播图此类数据 等等 本次的装修是基于业务组件进行区分，他的核心原理就是通过iframe进行数据交互实现实时装修功能 定制组件数据结构客户端根据json数据进行组件的展示的，所有首先，我们需要定义好客户端与后台通用的数据结构，用于声明我们的装修数据 例如我定义的数据结构，仅供参考 示例 搜索框 轮播图 1234567891011121314151617181920212223242526272829303132333435363738&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, &#123; id: guid(), compName: &#x27;drag-swiper&#x27;, name: &#x27;轮播图&#x27;, data: [ &#123; interval: 5000, data: [], // 数据 item: &#123; // 单个数据 img: &#x27;https://images.591wsh.com/2021/02/03/thumb_32371580472397824.png&#x27;, isLogin: false, // 是否需要登录, linkType: 2, // 1 无链接 2 商品 3 外部链接 4分类 commodity: &#123;&#125;, // 商品id dataurl: &#x27;&#x27;, // 外部链接 categoryid: &#x27;&#x27;, // 类目id &#125;, isUpdate: true // 告诉服务器是否需更新data里面的商品数据 &#125; ], css: &#123; height: 266, // marginTop: 20 &#125; &#125;, 为装修中的客户端页面增加一个组件 增加，修改，删除都会走如下逻辑，一句话说就是数据后台操作数据，客户端可以做出响应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 后台点击右侧装修组件，例如点击 搜索框// 匹配到搜索框的文字匹配定制的数据结构，得到如下点击的数据结构&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, // 后台通过监听存储装修数据变化的字段通知到客户端 computed: &#123; // ..... // 可使用组件 pageComponents: &#123; get() &#123; let &#123; pageComponents &#125; = this.$store.state.template if (pageComponents instanceof Array) &#123; // 组件数据发生变化的时候需要通知到客户端 this.iframeMessage(pageComponents) return pageComponents &#125; else &#123; return [] &#125; &#125;, set(data) &#123; // 更新组件顺序 this.$store.commit(&#x27;template/update_current&#x27;, data) &#125; &#125; // ...... &#125;, methods:&#123; // iframe加载完成的回调函数 iframeLoad() &#123; console.log(&#x27;iframe加载完成&#x27;) this.frm = document.getElementById(&#x27;iframe&#x27;) // 告诉客户端，目前处于装修中 this.frm.contentWindow.postMessage( &#123; isIframe: true &#125;, &#x27;*&#x27; ) &#125;, // 通知客户端数据发生了更新 iframeMessage(data) &#123; console.log(data) if (this.frm) &#123; this.frm.contentWindow.postMessage( &#123; tempLateData: data &#125;, &#x27;*&#x27; ) &#125; &#125;, &#125; // 客户端通过postMessage进行最新的装修数据接收window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.tempLateData) &#123; store.commit(&#x27;app/setTempLateData&#x27;, event.data.tempLateData) &#125; // ....&#125;// 客户端对应的页面再监听存在在vuex中的装修数据computed: &#123; ...mapState(&#123; tempLateData: state =&gt; state.app.tempLateData, // 后台的装修数据 hoverComponent: state =&gt; state.app.hoverComponent, // 当前鼠标浮动的元素id clickComponent: state =&gt; state.app.clickComponent, // 当前鼠标点击选中的数据 isIframe: state =&gt; state.app.isIframe, // 当前是否在装修模式里面 &#125;),&#125;,// 客户端替换从接口获取的之前的页面装修数据，装修数据显示在页面上watch: &#123; tempLateData() &#123; // 一旦后台通过postMessage更新装修数据，就可以替换原本接口获取的数据，实现实时装修功能 this.indexData = this.tempLateData || [] &#125;,&#125;, 修改装修的组件数据12345678910111213141516// 后台选取选中的组件// 后台针对每个装修组件都建立一个vue文件进行json内数据的改变‘// activeComponent.compName 为选中的组件compName，例如我选中搜索框 这里就是`drag-search-data`组件，这里可以是xxx-xxx-data组件&lt;template&gt; &lt;div class=&quot;template_right&quot;&gt; &lt;component v-if=&quot;activeComponent != false &amp;&amp; activeComponent.compName&quot; :is=&quot;activeComponent.compName + &#x27;-data&#x27;&quot; :compData=&quot;activeComponent&quot; &gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;// 组件内部绑定搜索框的提示文字，每次修改都会触发后台的计算属性·pageComponents·，进而后台通过postMessage通知到客户端，客户端进而存储到vuex，vuex值发生变化，客户端页面的watch起作用，页面发生变化，就吃实现组件数据的变化 点击客户端组件，通知后台并实现选中我们知道，在装修里面点击客户端，就直接点击到了客户端，所以点击客户端的跳转函数，我们必须进行拦截， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 前提须知 客户端每个装修组件的id都会在客户端写入到class中&lt;component :is=&quot;xxxxx&quot;:class=&quot;[`decoration_$&#123;item.id&#125;`,]&quot;&gt;&lt;/component&gt;// 装修监听函数体内window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.isIframe) &#123; console.log(&#x27;装修开发模式启动&#x27;) store.commit(&#x27;app/setIsIframe&#x27;, true) // 拦截跳转函数 uni.navigateTo = () =&gt; &#123;&#125; uni.switchTab = () =&gt; &#123;&#125; // 监听点击(装修用于选中组件) window.addEventListener(&#x27;click&#x27;, _decoratioclick, false) &#125; // ....&#125;function _decoratioclick(event) &#123; let path: string = &#x27;&#x27; // 每次点击的时候都获取一下包含组件id的class event.path.map((res: any) =&gt; &#123; if (res.className &amp;&amp; res.className.includes(&#x27;decoration_&#x27;)) &#123; path = res.className.split(&#x27;decoration_&#x27;)[1] &#125; &#125;) // 选中客户端当前组件 store.commit(&#x27;app/setClickComponent&#x27;, path) // 告知父级当前选中组件 window.parent.postMessage( &#123; activePage: path, // 将当前点击的组件id通过postMessage传递到后台 &#125;, &#x27;*&#x27; )&#125;// 装修后台mounted() &#123; window.addEventListener( &#x27;message&#x27;, e =&gt; &#123; if (e.data.activePage) &#123; // 获取客户端传递过来的当前组件id 这就是实现点击客户端组件装修后台得到数据 this.$store.commit(&#x27;template/set_activeComponent&#x27;, e.data.activePage) &#125; &#125;, false )&#125;, 添加组件到页面的流程图 客户端与装修后台相互传值总结1234567891011121314151617181920212223242526// 客户端发送window.parent.postMessage( &#123; activePage: path, &#125;, &#x27;*&#x27;)// 客户端接收window.addEventListener(&#x27;message&#x27;, （）=&gt; &#123; // ....&#125;)// 装修后台发送this.frm = document.getElementById(&#x27;iframe&#x27;)this.frm.contentWindow.postMessage( &#123; // ..... &#125;, &#x27;*&#x27;)// 装修后台接收window.addEventListener(&#x27;message&#x27;,e =&gt; &#123; // ...&#125;) postMessage的数据都是实时监听的，所以任意一边传值另一边都可以快速接收到，这是实现本方案的核心，通过postMessage解决了通信上的所有问题，例如 装修后台点击对应组件，客户端可以得到当前点击的组件的id 客户端点击组件可以告知后台，当前用户选中的组件 包括没实现的拖拽排序，都是可以实现的 多页面装修 做页面装修一定要想明白一件事，我们玩的不是装修，只是在操作页面抽象的数据结构 根据上面的想法，我们可以明白，活动页面很多仅仅是换换商品，换换链接，不会动不动就改页面 那个就可以抽象活动页的json数据结构 那么这里对应的就是图片组件 图片组件（优惠券也是图片样式） 商品组件 商品组件 在装修的时候我们定义好数据结构，依次添加这几个组件，客户端活动增加一行watch代码，就可以完美的实现活动页的装修，以及更新活动商品 注：公司项目无法透露，具体逻辑需要大家自己理解了 iframe装修方案优势 100%的完美还原装修样式 可以动态更新装修里面选中的商品的数据，需要数据结构统一化，后端即可按规律解析装修json 如果出现新组件，不需要写2套样式 后台装修定义好数据结构，客户端约定项目结构不变化，理论上整个项目所有页面都可以配置化 iframe装修方案弊端​ 通过iframe实现的前后台交互装修方案中，不仅需要动后台的装修代码，还需要客户端进行“兼容处理”，即客户端需要识别装修模式，与不断更新后台传入的装修数据，存在一定的耦合性 ​ 这种装修方案的弊端就是，如果希望操作起来更加便捷就需要在客户端进行功能的实现，并通过postMessage提交给装修后台 最后大家可以再看一下演示视频 联系我欢迎大家加入qq群吹吹水,一起成长 或者关注我的公众号，不定期更新各种文章：吴凯的随笔","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"在Option API中使用 Custom hook","slug":"使用reactivity 在vue2中编写hook函数","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:22:02.513Z","comments":true,"path":"2021/06/15/使用reactivity 在vue2中编写hook函数/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/%E4%BD%BF%E7%94%A8reactivity%20%E5%9C%A8vue2%E4%B8%AD%E7%BC%96%E5%86%99hook%E5%87%BD%E6%95%B0/","excerpt":"","text":"适应人群： 项目的vue2.x的版本， 还没在正式环境使用过composition API 但是又想享受hook带来的优势 ​ 注：本文提出的方法并非最佳实践，而是是vue2项目渐进式切换到vue3的方案，保留的大家熟悉的编写方式，也保留了hook的优势，如果开发团队条件允许的话，建议直接使用composition API语法来完成逻辑编写 什么是hook​ hook 翻译过来是钩子，在程序上体现为在行为执行之前，先把行为勾住，不让其继续，优先执行你的hook函数 用一张图来表示即为 左边为正常函数执行流程，右边为存在hook的执行流程 没有hook之前，我们如何对待代码复用​ 我们假设一种场景，你正在开发一个后台管理系统，在这个后台管理系统中，大部分都是查询表单，他们虽然业务不同，但是逻辑上存在一定的共性 共性元素：查询条件 列表数据 分页相关数据 加载状态 以上4个特征几乎每个表单都有，这就意味这你在写每一个表单的时候都需要重复对接相关的逻辑，这个问题在vue2中存在两种解决办法 每次都复制逻辑相同的代码 使用vue mixins完成逻辑公用 然而这2种方式都存在问题 复制代码低效率，虽然相对稳定，但是编码与测试工作量较大 vue mixins可以实现逻辑抽象，但是这种方案过于简单粗暴的方案，数据全局共享，过多使用mixin会导致项目走向失控，是一个比较危险的方案 假设表单页面数据结构如下 12345678&#123; data: [], // 列表数据 currentPage: 1, // 当前页面 pageSize: 0, // 每一个分页的数量 thePageSize: 0, // 本页数量 totalPages: 0, // 总页数 totalSize: 0, // 总记录数&#125; 除了以上后端返回的数据，我们还需要在页面增加一些状态值,用于优化用户体验 1status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;error&#x27; | &#x27;success&#x27; | ... // 当前列表请求的状态 以上的数据 + 状态每一个后台表单页面都存在，这就意味着重复的声明，重复的对接，重复的测试 ​ 复制代码的方式看似稳定，实则不稳定，因为每一次都要对重复逻辑进行测试，并且由于此类工作繁琐且重复劳动，开发人员一般比较抵触此类任务 ​ 这个问题在vue2中并没有非常好的解决方案，针对这个问题隔壁react从mixin到HOC最后到现在hook，给出了还不错的解决方案。 ​ 现在@vue&#x2F;composition-api提供了hook的能力，我们可以在vue中使用hook来优化提出的问题 通过hook来完成逻辑共用​ 接着上面的场景，我们现在假设我们有3个后台表单页面需要写 ​ 传统编码方案（未使用hook） ​ 可以看到我们需要写的三个页面流程上存在很多相似的地方，对接数据环节，虽然是大部分代码相同，但是还是需要重复的编写测试，例如页码相关，状态相关逻辑 ​ 使用hook完成重复逻辑抽象 每次调用useHook都会生成一次独立的状态 虽然状态与逻辑依赖与组件，但是useHook可以在组件外部进行定义，这一点是之前无法做到的 ​ 虽然不同页面的内部逻辑细节都是不一样，但是总体流程、数据结构都是一样的，基于这样的前提，我们就可以针对共性来进行抽象，之后不论多少个页面，我们都使用抽象逻辑，也只需要维护抽象逻辑 提供 组合式 API 的 Vue 2 插件​ 虽然hook是vue3版本才提出的，但是这并不代表hook与vue3是绑定关系，实际上在任何前端应用中都可以使用vue3中提供的hook功能 文档地址：@vue&#x2F;composition-api 所以不论是vue3还是vue2，还是react，甚至html都可以使用这个npm包 关于vue3的响应式核心包 @vue&#x2F;reactivity的具体实现，可以看看之前的文章 简易版Reactivity源码解析，读懂源码之后，自然解答了你对reactivity的全部疑问 实战（useReqList） 为了方便理解，以下代码为vue2.x，使用js进行编写 ​ useReqList是一个自定义hook，作用是帮助我们抽象后台表单的公共逻辑，我们先看看未使用的情况，使用了之后，代码的变化，再看看如何实现 未使用useReqList123456789101112131415161718192021222324252627282930313233// ...data() &#123; return &#123; // ... shopList: [], // 数据 homePage: 0, // 本页有多少数据 allPage: 0, // 总共多少页 totalSize: 0, //总共多少条数据 pageSize: 0, // 每页最多多少条数据 currentPage: 1, // 当前页码 &#125; &#125;,methods:&#123; init() &#123; this.loading = true const data = &#123; currentPage: this.currentPage, //... &#125; request(data) // 请求 .then((res) =&gt; &#123; this.shopList = res.data.data this.currentPage = res.data.currentPage this.pageSize = res.data.pageSize this.totalSize = Number(res.data.totalSize) this.homePage = res.data.thePageSize this.allPage = res.data.totalPages &#125;) .finally(() =&gt; &#123; this.loading = false &#125;) &#125;,&#125; 使用useReqList123456789101112131415161718import &#123; useReqList &#125; from &#x27;@/utils/hook/useReqList&#x27;// ...data() &#123; return &#123; dataList: useReqList() &#125;&#125;,methods:&#123; init() &#123; const data = &#123; currentPage: this.listData.currentPage || 1, //... &#125; this.listData.run(request(data)) // 请求 &#125;,&#125;// let &#123; data, currentPage, pageSize, thePageSize, totalPages, totalSize, status &#125; = this.listData 通过上面的例子可以看到，使用了useReqList之后 公共变量，公共逻辑部分被抽象出去，页面代码变得更加纯粹 因为reactivity的特性，它们都是具备响应式 避免重复编码，重复测试环节，节省开发时间 hook可以给n个接口使用，只要是请求表单接口，都不需要写重复部分的代码，避免调试，测试环节 接下里我们可以看看这是如何实现上面使用的自定义（Custom） Hook useReqList useReqList具体实现 ​ 内部实现就是对公共逻辑的封装，被读取的数据被reactive处理后具备了响应式，每次声明都会因为闭包的特性而开启一片独立的内存来供声明单位使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import &#123; reactive &#125; from &#x27;@vue/reactivity&#x27;/** * 针对后台表单页面逻辑的抽象 * @returns */export function useReqList() &#123; const defaultState = &#123; data: [], // 表格数据 currentPage: 1, // 当前页面 pageSize: 0, // 分页数量 thePageSize: 0, // 当前页面数量 totalPages: 0, // 总页数 totalSize: 0, // 总数量 error: null, // 错误原因 status: &#x27;idle&#x27;, // 当前状态 idle | loading | success | error &#125; let state = reactive(&#123; ...defaultState, &#125;) /** * 请求成功 * @param data */ const setData = (data) =&gt; &#123; state.currentPage = data.currentPage state.pageSize = data.pageSize state.thePageSize = data.thePageSize state.totalPages = data.totalPages state.totalSize = Number(data.totalSize) state.data = data.data state.status = &#x27;success&#x27; &#125; /** * 请求失败 * @param error */ const setError = (error) =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = error state.status = &#x27;error&#x27; &#125; const setLoading = () =&gt; (state.status = &#x27;loading&#x27;) const setPage = (num) =&gt; &#123; state.currentPage = num &#125; const setReset = () =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = null state.status = &#x27;idle&#x27; &#125; const run = (promise) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&#x27;请传入 promise 类型数据&#x27;) &#125; if ([&#x27;loading&#x27;].includes(state.status)) &#123; return Promise.reject(&#x27;当前正在请求中&#x27;) &#125; setLoading() return promise .then((res) =&gt; &#123; setData(res.data) &#125;) .catch((err) =&gt; &#123; console.log(err) setError(err) &#125;) .finally(() =&gt; &#123;&#125;) &#125; return &#123; run, setReset, setData, setPage, setLoading, setError, state, &#125;&#125; ​ 这样的封装体基本适配大部分vue2.x开发的后台管理系统的项目，如果想在项目中使用只需要修改一下setData部分适配一下后端数据即可 更多的vue hook函数​ hook工具库，VueUse，库里面提供了大量的常用方法，掘金上面有该工具库的介绍文章，官网说明该库是兼容vue2文档了 vue项目应当在什么使用下使用hook关于Class API与Composition API​ 从Class API&#x2F;Option API转变向Composition API的过程中是阵痛的，这2种API在思维方式上存在很大差异 ​ 对于长时间写Class、vue2.x的人来说，最初接触vue3几乎发现不了非常明显的优点，setup语法不熟练的情况下基本还是按照Class的思维进行编码，无法发挥Hook的优势，导致写一段时间Vue3后的结论是：在单文件中class的代码组织能力几乎完爆setup语法… ​ 后来组件有一些项目经验，重新学习了react hook，逐渐对hook有了一些理解；Hook主要完成逻辑与逻辑的分离，在react和vue中使用hook可以实现 视图与视图的分析，视图与逻辑的分离，逻辑与逻辑的分离，用这个的方式来实现单一职责，在此基础上完成逻辑与视图的低耦合高内聚代码 ​ 对于vue2的开发者在而言，可以渐进式的从vue2到vue3，先熟悉hook，在熟悉Composition API 关于hook与vuex | observable​ 从普遍意义上来说hook是可以替代vuex的，react中的API useContext就提供了类似功能。 vuex是无法替代hook的，他并不具备闭包的特性，使用vuex的话，那仅仅是拆分逻辑，有多少页面还是要写多少重复逻辑只是重复代码转义到vuex中而已 ​ 但是刚接触hook不久的新手而言，很容易进入一个误区；将变量，逻辑封装在一个hook中的情况下，又在多个页面中使用，就会在内存中创建多个不共享的内容一致的空间，对于公共变量还是要使用全局状态管理库的。 ​ hook风格的全局状态管理库，建议可以试试Pinia 结语​ 使用过了一段时间的setup语法之后，对其看法也是慢慢从谨慎疑惑转变成为拥抱hook，Composition API 在逻辑抽象、类型推导、多方面均占优，虽然目前还存在一些小问题，后面的迭代都会解决的，在未来几年Custom Hook将会越来越普及，拥抱Custom Hook,Vue3吧! 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"使用Prettier完成代码提交的自动格式化","slug":"使用gitHook来完成代码的自动格式化","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-23T08:05:05.679Z","comments":true,"path":"2021/06/01/使用gitHook来完成代码的自动格式化/","link":"","permalink":"https://vkcyan.github.io/2021/06/01/%E4%BD%BF%E7%94%A8gitHook%E6%9D%A5%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/","excerpt":"","text":"最终效果 执行git commit 代码自动完成我们定制规则的格式化功能，并提交到本地 使用的npm包prettier：功能依赖包 husky：提供gitHook相关功能 lint-staged：让命令只对发生更改的文件生效 为什么做（WhyHow）​ 在未建立规范之前，每个人的代码风格都是不一致的，并且开发过程中可能会出现忘记格式化，手误的问题，如果在提交之前，可以自动抹平差异统一多人开发风格，这时候作用就体现出来了 ​ 代码风格是每一个程序员都要面对的问题，不论是在个人开发还是在团队协作中，都明白较好的代码风格是保证日后可维护性的关键，所以连不懂的开发或许都知道，要注意代码风格 怎么做（How）​ 到了正在的推进时期，就会面对很多难题，无法确定一个所有人都满意的方案，而就算是少数服从多数，在实际开发中落实也会遇到一大堆问题，例如，编辑器的不同，格式化工具不同，或者说完全没这个习惯，好不容易决定推进了，每次代码审核都需要修改这种细节问题，一来二去就搁置了，实在是头疼，到底该如何将事情完美的落实下去呢？ ​ 这里我们就需要一个权威的规范来帮助我们约束成为一个风格，Prettier表示我先给一个规范，大家先用起来，保证代码的可读性与可维护性，然后大家都遵循这和规则。 ​ 而prettier本身是一个An opinionated code formatter 的格式化工具，我是一个规矩非常严格的框架，并不会给你很多的配置项，喜欢用就用，不喜欢就不用，绝大部分的编辑器集成了prettier，在编辑器的约束下，大家都遵循这个方案就好了 具体配置（What）Vscode下载插件 prettier 项目按下依赖prettier，按文档完成步骤prettier官网 配置commit钩子 ​ 安装好之后，会在项目下生成文件.husky，并修改你的package.json，到目前为止，其实已经配置好了，他会在你每次commit之前执行npx lint-staged，这个命令会执行prettier --write，并且只对本次修改的文件生效 具体命令（躲懒不看文档的看这里~） 当前的prettier版本是2.4.1，如果版本号不一致，建议还是看官网 vscode安装prettier 项目安装prettier 1npm install --save-dev --save-exact prettier 创建配置文件 1echo &#123;&#125;&gt; .prettierrc.json 创建说明不需要格式化的文件 创建文件.prettierignore 写入内容 123# Ignore artifacts:buildcoverage 执行命令npx prettier --write .,格式化现有代码，测试功能是否正常 编写配置文件 1234567891011// json文件改为js文件（看个人习惯）写入内容module.exports = &#123; singleQuote: true, // 单引号 trailingComma: &#x27;es5&#x27;, // 对象属性最后有 &quot;,&quot; semi: false, // 是否需要分号 printWidth: 110, // 一行最多120 jsxSingleQuote: true, // jsx使用单引号 tabWidth: 2, // 一个tab代表几个空格数，默认就是2 useTabs: false, // 不使用缩进符，而使用空格 jsxBracketSameLine: true,&#125; 再次执行npx prettier --write .，对格式化规则有建议参考文档对配置进行修改，知道自己满意 配置gitHook钩子(必须先加入git仓库，不然会无效果) 1npx mrm@2 lint-staged 将代码格式改乱，尝试commit一下，查看功能是否正常（提交之前会被自动格式化） 一些注意事项win电脑.prettierrc.json写入失败这个问题在同事电脑上发现的，使用vscode中powershell执行echo &#123;&#125;&gt; .prettierrc.json,会无写入内容，后面执行的命令也会失败，这里请使用电脑的cmd打开目标文件夹，执行该命令，这样测试是可行的 配置gitHook之后 commit不会自动格式化vue文件这里需要修改在package.json中默认写入的lint-staged中的命令 这里根据项目中是否存在eslint，会写入不太一致，但是问题不打 123&quot;lint-staged&quot;: &#123; &quot;*.js&quot;: &quot;eslint --cache --fix&quot;&#125; 统一改成 123&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,css,md,vue&#125;&quot;: &quot;prettier --write&quot;&#125; 这样每次commit的时候就会自动格式化代码了 结语​ 如果查看本文遇到了一些问题，请到QQ群 530496237，一起吹吹水~","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"同域名下通过一级路由区分实现“前端微构架”","slug":"单域名下通过子路由区分项目的实现方案","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-23T08:04:01.733Z","comments":true,"path":"2021/06/01/单域名下通过子路由区分项目的实现方案/","link":"","permalink":"https://vkcyan.github.io/2021/06/01/%E5%8D%95%E5%9F%9F%E5%90%8D%E4%B8%8B%E9%80%9A%E8%BF%87%E5%AD%90%E8%B7%AF%E7%94%B1%E5%8C%BA%E5%88%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 公司的客户端项目比较庞大，并且由于改动相对频繁，导致更新频率较高，web项目高频率的更新就会引发一系列的问题，例如公众号缓存问题，尤其是ios手机容易出现白屏的情况，访问过程中的用户回退页面会出现白屏的情况，等等很多未知的bug，虽然更新在一瞬间完成，但是还是会影响到部分用户的使用，针对现存的条件以及项目需求 思考到如下优化方案 更新时间上尽量选择用户访问量小的时间段 程序内频繁变化的图片，文字的页面，尽量后台配置装修化，达到减少更新的效果，此处参考使用iframe+postMessage通信实现商城多页面可视化装修 项目能否进行拆分，权重不高的页面（例如：活动页面），与主程序分离，达到减少主程序包更新频率 思考与分析 第一条与第二条非本文重点，只做简要说明 更新时间主要参照我们的客户端监控平台提供的检测数据，一般选择用户访问量较小的时候进行更新 对于项目中频繁改动，但是数据格式固定的活动页，我们使用装修功能，达到不更新代码，只更新数据的效果 ​ 而项目拆分就是我们本文要说到的重点，在调查过程中也了解过微前端，但是我们的客户端项目是uniapp完成的，考虑到技术难度与改动成本，最终放弃了微前端的方案 要怎么做到一个路径下面的项目拆分呢？ 拆分的项目需要满足一下2个条件 拆分的项目必须在同域名下，不可出现跨域名的情况，不然就会出现无法共享localStorage的问题 本次改动不能影响到线上已经存在的业务，不能出现主程序的路由变动 为了满足以上2个条件，则主程序不能进行任何改动，同时需要在当前域名下，想办法再指向一个项目，在同一个域下，localStorage被共享，虽然是2个项目但是在同一个域下 最开始一直在思考客户端如何修改实现，但是一直没想到完美方案，后来，我们另辟蹊径，通过nginx实现通过子路由进行项目区分 nginx进行一级路由区分 通过nginx进行一级路由的判断实现访问不同的静态资源 理想情况下方案是可行的，nginx配置也比较简单 12345678910111213server &#123; // ..... server_name xxxx.com // ..... location / &#123; root /xxx/xxx/xxxx/packageA; try_files $uri $uri/ /index.html; &#125; location ~ /activity/ &#123; root /xxx/xxx/xxxx/packageB try_files $uri $uri/ /index.html; &#125;&#125; 只要访问的项目路由 xxxx.com&#x2F;activity&#x2F;xxxxx,就会访问到项目包packageB，其他的一级路由都会访问到packageA 部署因为项目activityB的访问路由是确定的，所以我们在webpack的配置中就需要对publicPath进行修改 1publicPath: &#x27;/activity/&#x27;, ​ 然后我们nginx会去访问项目包下面的index.html，而经过我们上面对publicPath的修改，打包之后的index.html里面的路径应用就变成了 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/activity/favicon.ico&quot; /&gt; &lt;title&gt;xxxxx&lt;/title&gt; &lt;link href=&quot;/activity/css/app.xxxx.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/activity/js/chunk-vendors.xxx.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/activity/js/app.xxxxx.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时打包上线就会遇到资源访问不到的问题，因为webpack编译出来的程序包里面没有activity这个文件夹，所以对indexPath,outputDir也要进行修改 最终我们的vue.config.js 1234567891011module.exports = &#123; publicPath: &#x27;/activity/&#x27;, // 资源路径 outputDir: &#x27;./dist/activity&#x27;, // 生产环境构建文件的目录 indexPath: &#x27;../index.html&#x27;, // 指定生成的index.html的输出路径 configureWebpack: (config) =&gt; &#123; // .. &#125;, chainWebpack: (config) =&gt; &#123; // .. &#125;,&#125; 到此为止，通过一级路由区分项目已经完成了全部配置 优点 对项目进行拆分，对于非核心程序的页面，例如活动页面等等，即可与主程序进行区分，上线活动页面不干涉主程序 项目分离后，单个项目的页面变少，单个代码包打包速度得到提升，增加项目可维护性 缺点没办法共享公共逻辑代码，例如支付模块，登录模块，等等模块，因为跨项目了，当然这是有解决办法的，即公共模块打包成为npm包，但是这存在一定的工作量 最后欢迎大家加入qq群吹吹水（群号：530496237）一起成长","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"轻量化前端更新方案","slug":"轻量化前端更新方案","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-23T08:04:51.111Z","comments":true,"path":"2021/06/01/轻量化前端更新方案/","link":"","permalink":"https://vkcyan.github.io/2021/06/01/%E8%BD%BB%E9%87%8F%E5%8C%96%E5%89%8D%E7%AB%AF%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 一句话介绍：它是可以一行命令将代码更新到服务器的脚本 ​ 轻量级更新方案最开始源于掘金的文章，后来我们从零实现了一个更新脚本，并且已在是生产环境中进行使用很长时间，算是非常稳定的版本，个人认为轻量化更新方案是非常使用小型开发团队 ​ 现在我们切换到了gitlab的CI&#x2F;CD。所以这种方案已经不再是我们的主流方案，但是一路使用过来，非常稳定的解决了更新问题，还是非常不错的 优点： 快速，稳定，自动备份指定文件夹（灵活性高，但是需要自己实现） 缺点：需要手动回滚（自动回滚需要编码），相对来说没那么规范，没有留下记录，敏感数据存储在电脑中，配置文件可以git忽略 核心流程 确认并打包项目 通过node-ssh连接线上服务器 将打包代码指定名称进行压缩 备份之前的代码，删除以前的代码包，并解压压缩包 删除本次打包代码，断开ssh链接 如何使用代码地址 将仓库文件放入项目 安装依赖 1npm install node-ssh inquirer archiver -D 修改upload.config.js内容 增加脚本命令 1&quot;upload&quot;: &quot;node build/upload.js&quot; 运行命名，验证是否功能正常 核心代码build/upload.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const &#123; NodeSSH &#125; = require(&#x27;node-ssh&#x27;)const archiver = require(&#x27;archiver&#x27;)const inquirer = require(&#x27;inquirer&#x27;)const exec = require(&#x27;child_process&#x27;).execconst ssh = new NodeSSH()const uploadFun = require(&#x27;../upload.js&#x27;)/** * 获取当前平台 */let objName = process.argv[2] // 更新名字let startTime = null // 程序开始更新的时间// 获取上传服务器配置let config = uploadFun(objName)const verifyList = [ &#123; type: &#x27;input&#x27;, message: &#x27;您正在更新到线上环境,请确认接口域名&#x27;, name: &#x27;objName&#x27;, &#125;,]inquirer.prompt(verifyList).then(() =&gt; &#123; uploadBuild()&#125;)function uploadBuild() &#123; startTime = new Date() console.log(`$&#123;objName&#125;开始更新`) let buildcmd = exec(config.buildScript, (error, stdout, stderr) =&gt; &#123; if (!error) &#123; console.log(&#x27;打包完成&#x27;, stdout) app() &#125; else &#123; console.error(&#x27;打包出现错误&#x27;, stderr) process.exit(0) &#125; &#125;) buildcmd.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(data.toString()) &#125;)&#125;/** * 通过ssh链接服务器 */function app() &#123; ssh .connect(&#123; host: config.host, username: config.username, password: config.password, &#125;) .then((res) =&gt; &#123; // 上传代码压缩包 uploadData() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)&#125;/** * 上传代码 压缩现有代码 */function uploadData() &#123; // 创建文件输出流 let output = fs.createWriteStream(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`) // 设置压缩级别 let archive = archiver(&#x27;zip&#x27;, &#123; zlib: &#123; level: 8, &#125;, &#125;) // 存档警告 archive.on(&#x27;warning&#x27;, function(err) &#123; if (err.code === &#x27;ENOENT&#x27;) &#123; console.warn(&#x27;stat故障和其他非阻塞错误&#x27;) &#125; else &#123; throw err &#125; &#125;) // 存档出错 archive.on(&#x27;error&#x27;, function(err) &#123; throw err &#125;) // 通过管道方法将输出流存档到文件 archive.pipe(output) archive.directory(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.buildobj&#125;`, &#x27;/&#x27;) archive.finalize() // 文件输出流结束 output.on(&#x27;close&#x27;, function() &#123; console.log(`总共 $&#123;(archive.pointer() / 1024 / 1024).toFixed(2)&#125; MB,完成源代码压缩`) ssh .putFile( `$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, `$&#123;config.uploadDir&#125;/$&#123;config.objname&#125;.zip` ) .then(() =&gt; &#123; console.log(&#x27;程序zip上传成功,判断线上是否需要备份&#x27;) runcmd() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;)&#125;/** * 执行ssh命令 判断当前是否存在备份 */function runcmd() &#123; ssh .execCommand(&#x27;ls&#x27;, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stdout) &#123; let fileList = res.stdout.split(&#x27;\\n&#x27;) if (config.objname == config.backObject) &#123; if (fileList.includes(config.objname)) &#123; console.log(&#x27;当前更新为线上正常环境,开始进行备份&#x27;) backupData() &#125; else &#123; console.log(&#x27;当前更新为线上正常环境,并且是第一次,将跳过备份&#x27;) cmdunzip() &#125; &#125; else &#123; console.log(&#x27;当前为测试环境,无需备份,直接解压上传压缩包&#x27;) cmdunzip() &#125; &#125; else if (res.stderr) &#123; console.log(&#x27;查询指定目录失败&#x27;) &#125; else &#123; console.log(&#x27;ssh链接发生了错误&#x27;) &#125; &#125;)&#125;/** * 备份项目 */function backupData() &#123; ssh .execCommand(`mv $&#123;config.objname&#125; backup/$&#123;config.objname&#125;_backup$&#123;new Date().getTime()&#125;`, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stderr) &#123; console.log(&#x27;备份发生错误&#x27;, res.stderr) &#125; else &#123; console.log(&#x27;完成备份,解压最新代码&#x27;) cmdunzip() &#125; &#125;) .catch((err) =&gt; &#123; console.log(&#x27;备份发生未知链接错误&#x27;, err) &#125;)&#125;/** * 解压最新代码zip */function cmdunzip() &#123; // 解压程序 ssh .execCommand( `rm -rf $&#123;config.objname&#125; &amp;&amp; unzip -o -d $&#123;config.uploadDir&#125;/$&#123;config.objname&#125; $&#123;config.objname&#125;.zip &amp;&amp; rm -f $&#123;config.objname&#125;.zip`, &#123; cwd: config.uploadDir, &#125; ) .then(() =&gt; &#123; console.log(`项目包完成解压,$&#123;config.objname&#125;项目部署成功了!`) console.log(`项目更新时长$&#123;(new Date().getTime() - startTime.getTime()) / 1000&#125;s`) return deletelocalFile().then(() =&gt; &#123; console.log(&#x27;本地缓存zip清除完毕&#x27;) &#125;) &#125;) .then(() =&gt; &#123; ssh .execCommand(`rm -rf $&#123;config.objname&#125;/static/.DS_Store`, &#123; cwd: config.uploadDir, &#125;) .then(() =&gt; &#123; console.log(&#x27;线上项目.DS_Store删除完成&#x27;) ssh.dispose() process.exit(0) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;) .catch((err) =&gt; &#123; console.log(&#x27;解压出现错误&#x27;, err) &#125;)&#125;/** *删除本地生成的压缩包 */function deletelocalFile() &#123; return new Promise((resolve, reject) =&gt; &#123; fs.unlink(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, (err) =&gt; &#123; if (err) &#123; reject(err) throw err &#125; else &#123; resolve() &#125; &#125;) &#125;)&#125; 配置文件upload.config.js 123456789101112131415161718192021222324// 打包核心配置文件let Available = [&#x27;dist-a&#x27;, &#x27;dist-b&#x27;] // dist-a 环境a代码包 dist-b 环境b代码包 npm run upload dist-a/** * 获取更新配置 * @param &#123;String&#125; objName 当前更新名称 * @returns */module.exports = (objName) =&gt; &#123; if (!Available.includes(objName)) &#123; console.log(&#x27;当前项目不存在您输入的更新命令,请检查更新名称&#x27;) process.exit(0) &#125; return &#123; host: &#x27;xx.xx.xx.xx&#x27;, // 服务器地址 username: &#x27;root&#x27;, password: &#x27;xxxxxxxxxx&#x27;, buildPath: &#x27;&#x27;, // 本地打包项目地址(多层路径用这个) buildobj: &#x27;dist&#x27;, // 本地打包文件名称 uploadDir: &#x27;/xx/xx/xx&#x27;, // 服务端项目地址 objname: objName, // 打包项目名称 backObject: &#x27;objName&#x27;, // 备份的文件夹名称 buildScript: &#x27;npm run build&#x27; // 更新命令 &#125;&#125; 触发命令最后在package.json增加一行命令，运行前面的脚本文件 1234&quot;scripts&quot;: &#123; // ...... &quot;upload&quot;: &quot;node build/upload.js&quot; &#125;, 依赖版本​ 因为更新脚本是在项目里面的，所以需要额外安装依赖 推荐版本号 123&quot;node-ssh&quot;: &quot;^12.0.0&quot;,&quot;inquirer&quot;: &quot;^7.3.3&quot;,&quot;archiver&quot;: &quot;^3.1.1&quot;, 实际使用1npm run upload xxxx // 线上代码文件夹名称 upload 命令后面的字符串就是服务器上的文件夹名称，这里为了防止更新命名敲错了，需要首先在upload.config.js中进行更新白名单声明，如果配置都正确的情况下，你就可以看到，这就代表成功了~ 最后​ 脚本文件还存在很高的上限，可以优化一下备份部分的备份代码生成规则，再增加一个回滚代码的脚本，就可以实现线上的无感知回滚了 ​ 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]}],"categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"},{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]}