{"meta":{"title":"vkcya Blog","subtitle":"","description":"","author":"vkcyan","url":"https://vkcyan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-05-23T07:15:23.068Z","updated":"2022-05-23T07:15:23.068Z","comments":true,"path":"about/index.html","permalink":"https://vkcyan.github.io/about/index.html","excerpt":"","text":""},{"title":"类别","date":"2022-05-23T07:18:32.733Z","updated":"2022-05-23T07:18:32.733Z","comments":true,"path":"categories/index.html","permalink":"https://vkcyan.github.io/categories/index.html","excerpt":"","text":""},{"title":"书籍","date":"2022-05-23T07:18:11.740Z","updated":"2022-05-23T07:18:11.740Z","comments":true,"path":"books/index.html","permalink":"https://vkcyan.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-23T07:18:39.272Z","updated":"2022-05-23T07:18:39.272Z","comments":true,"path":"links/index.html","permalink":"https://vkcyan.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-23T07:19:05.313Z","updated":"2022-05-23T07:19:05.313Z","comments":true,"path":"tags/index.html","permalink":"https://vkcyan.github.io/tags/index.html","excerpt":"","text":""},{"title":"存储库","date":"2022-05-23T07:18:59.980Z","updated":"2022-05-23T07:18:59.980Z","comments":true,"path":"repository/index.html","permalink":"https://vkcyan.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"针对免登录的一些实践与思考","date":"2022-05-23T06:29:52.233Z","updated":"2022-05-12T01:22:41.901Z","comments":true,"path":"2022/05/23/针对免登录的一些实践与思考/","link":"","permalink":"https://vkcyan.github.io/2022/05/23/%E9%92%88%E5%AF%B9%E5%85%8D%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"针对打通免登录的一些实践与思考我最近一直再想一句话，听用户说，但是不要照着做。这人","categories":[],"tags":[]},{"title":"JS数据结构与算法","slug":"JS数据结构与算法","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T06:55:48.085Z","comments":true,"path":"2022/03/15/JS数据结构与算法/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"JS数据结构与算法数据结构为算法提供服务，算法围绕数据结构操作 时间复杂度 一个函数用大O表示，比如O(1)，O(n)，O(logN)… 定性描述该算法的运行时间 O(1)12let a = 1a += 1 每次执行改逻辑的时候，之后执行一次，复杂度不会随着时间的变化而变化 O(n)123for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; for循环里面的代码执行n次 O(1) + O(n) &#x3D; O(n)123456let a = 1a += 1for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; 两个时间复杂度先后排列就需要相加，相加的情况下低的的忽略不计，取更高的时间复杂度 O(n) * O(n) &#x3D; O(n ^ 2)12345for (let i = 0; i &lt; n; i += 1) &#123; for (let j = 0; j &lt; n; j += 1) &#123; console.log(i, j) &#125;&#125; 两个时间复杂度嵌套排列，时间复杂度就需要相乘 O(logN)$$对数函数：如果ax&#x3D;N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x&#x3D;loga$$ 12345let i = 1while(i &lt; n) &#123; console.log(i) i *= 2&#125; 这里的logN以2为底数，目的是就是求2的多少次方为N， 上面的代码while循环每次*2，实际上就是求2的多少次方为N，所以时间复杂度就是O(logN) 空间复杂度 一个函数用O表示，比如O(1)，O(n)，O(n^2) 算法在运行过程中临时占用存储空间的大小的量度 O(1)12let i = 0i += 1 声明了变量i，单个变量所占用的内存为1，所以空间复杂度为O(1) O(n)1234let list = []for (let i = 0; i &lt; n; i += 1) &#123; list.push(i)&#125; 声明了变量list，通过循环我们增加了n个值，相当于占用了n个内存单元，所以这段代码的空间复杂度为O(n) O(n^2)1234567const matrix = []for (let i = 0; i &lt; n; i += 1) &#123; matrix.push([]) for (let j = 0; j &lt; n; j += 1) &#123; matrix[i].push(j) &#125;&#125; O(n^2)实际上就是一个矩阵，矩阵的本质就是一个二维数据，存储了n的二次方的变量 小知识调试工具栏每个图标的作用 第一个箭头：程序运行到下一个断点，没有断点，程序执行完毕 第二个图标：一行一行执行代码 第三个图标：当前处如果调用了fun，点击此图标就会进入函数里面 第四个图标：点击跳出当前函数 第五个图标：重启调试 第六个图标：停止调试","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vue3 + jsx开发指南","slug":"Vue3 使用jsx开发指南","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T06:56:22.057Z","comments":true,"path":"2022/03/15/Vue3 使用jsx开发指南/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/Vue3%20%E4%BD%BF%E7%94%A8jsx%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"","text":"Vue3 + jsx开发指南 ​ 在2021年，vue3发布了正式版本，并且经过一年的维护已经越来越稳定，我们在公司项目中也小范围的上线了vue3的项目，总体还是很不错的 ​ 但是setup语法需要return比较麻烦，还有.value问题，尝试过setup语法糖，依旧觉得setup语法的api记忆负担比较重 ​ 所以下半年逐渐拾起了jsx的语法，并在开源项目中使用，总体感觉还是相当不错的，前人栽树后人乘凉，本文对jsx for vue的常见问题进行说明 jsx学习成本更低，这么多年jsx没有大改动； 无记忆负担，同时足够灵活，如果你是vue开发者，同时对setup语法并不是太合得来， vue3 + jsx也是非常不错的选择~ 前置知识​ 在vue3中使用jsx需要安装@vitejs&#x2F;plugin-vue-jsx（webpack版本的不了解，有需要者执行搜索），根据文档配置一下就行了，官方提供了文档供参考，提供了相关示例jsx-next,有react基础的同学可以先看官方文档，在开发过程中出现问题再看本文 指令v-modelJSX for vue是支持v-model语法的，这一点比react的setState,体验感确实要好 1234567891011// 正常写法&lt;input v-model=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;value&#125; /&gt; // jsx// 指定值写法&lt;input v-model:modelValue=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;]&#125; /&gt; // jsx // 修饰符写法&lt;input v-model:modelValue.trim=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;,[&#x27;trim&#x27;]]&#125; /&gt; // jsx v-show这个api与在vue中的表现形式一致 12&lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt; // vue&lt;div v-show=&#123;isShow&#125;&gt;&lt;/div&gt; // jsx v-bind1234567891011121314// vue&lt;a-modal :width=&quot;&#x27;400px&#x27;&quot; :title=&quot;&#x27;设置组件名称&#x27;&quot; &gt; // ....&lt;/a-modal&gt;// jsx&lt;a-modal width=&#123;&quot;400px&quot;&#125; title=&#123;&quot;设置组件名称&quot;&#125; &gt; // ....&lt;/a-modal&gt; v-if在jsx for vue中没有这个api，我们需要用jsx风格来实现v-if的效果 可以简单理解为jsx直接将if搬到html中 12&lt;div v-if=&quot;isShow&quot;&gt; ... &lt;/div&gt; // vue&#123;isShow &amp;&amp; &lt;div&gt; ... &lt;/div&gt;&#125; // jsx 事件事件语法jsx for vue，所有的事件都按照react风格来 所有事件有on开头 所有事件名称首字母大写 例如：@click &#x3D;&gt; onClick @change &#x3D;&gt; onChange @drop &#x3D;&gt; onDrop 事件修饰符这里没有找到权威的资料，有小伙伴知道也请告知一下，目前建议大家通过原生JavaScript来实现vue事件修饰符的效果 .stop ： 阻止事件冒泡，在JSX中使用event.stopPropagation()来代替 .prevent：阻止默认行为，在JSX中使用event.preventDefault() 来代替 APIref与reactivevue3的template会自动解析ref的.value,在jsx中ref的.value是不会被自动解析的 1234//声明变量 let type = ref(1)&lt;p&gt;&#123;&#123; type &#125;&#125;&lt;/p&gt; // vue&lt;p&gt;&#123;type.value&#125;&lt;/p&gt; // jsx props在jsx for vue中，props的语法使用的就是setup的语法，实际表现形式完全一致 1234567891011export default defineComponent(&#123; props: [&#x27;title&#x27;], setup(props) &#123; onMounted(() =&gt; &#123; console.log(props.title); &#125;) return () =&gt; ( &lt;div&gt;&#123;props.title&#125;&lt;/div&gt; ) &#125;&#125;) emit同样与vue3的setup语法保持一致，注意子父方法需要符合react规范 123emit(&#x27;changeVisible&#x27;, false) // 子组件 &lt;xxx onChangeVisible=&#123;(params) =&gt; xxxFun(params)&#125;&gt;&lt;/xxx&gt; // 父组件 solt如何写插槽这里以antd for vue的Popover 气泡卡片，为例子 Vue3语法123456&lt;a-popover title=&quot;Title&quot;&gt; &lt;template #content&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/template&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; jsx for vue语法123456789&lt;a-popover title=&quot;Title&quot; content=&#123; &lt;&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/&gt; &#125;&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; 基础模板12345678910111213import &#123; defineComponent, onMounted, ref &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; // props: [&#x27;xx&#x27;], setup(props,&#123; emit &#125;) &#123; onMounted(() =&gt; &#123; // ... &#125;) return () =&gt; ( &lt;div&gt;&lt;/div&gt; ) &#125;&#125;) 结语 国内这方面资料比较少，查问题的时候注意vue版本，以及jsx的使用（render方式本文不适用） 如果代码里面存在问题，如果是ui框架，建议直接看react版本的代码，例如antdv的jsx版本直接看antd的实例代码 直接看jsx语法的项目代码，H5-YD.v2 不接受杠精，例如写jsx为啥不去用使用react 如果在学习过程中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vite配置alias（设置别名）","slug":"vite配置alias","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T06:56:02.108Z","comments":true,"path":"2022/03/15/vite配置alias/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/vite%E9%85%8D%E7%BD%AEalias/","excerpt":"","text":"Vite配置alias（设置别名） Vite配置alias需要两步进行（TS项目） 1、修改vite.config.ts（让程序支持） 2、修改tsconfig.json（让编辑器支持） 修改vite配置12345678910111213141516171819import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;function _resolve(dir: string) &#123; return path.resolve(__dirname, dir)&#125;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], // 配置项目别名 resolve: &#123; alias: &#123; &#x27;@&#x27;: _resolve(&#x27;src&#x27;), &#125;, &#125;,&#125;) 修改tsconfig.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;noImplicitAny&quot;: false, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true, &quot;importHelpers&quot;: true, // 不让同样的辅助函数重复的出现在多个文件中 &quot;allowSyntheticDefaultImports&quot;: true, // 允许对不包含默认导出的模块使用默认导入。 &quot;baseUrl&quot;: &quot;.&quot;, // 非相对模块的导入可以相对于baseUrl或通过下文会讲到的路径映射来进行解析 &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot; ], &quot;paths&quot;: &#123; // 配置导出路径（这里根据自己项目执行修改） &quot;@/stores*&quot;: [ &quot;./src/stores*&quot; ], &quot;@/components*&quot;: [ &quot;./src/components*&quot; ], &quot;@/modules*&quot;: [ &quot;./src/modules*&quot; ], &quot;@/utils*&quot;: [ &quot;./src/utils*&quot; ], &#125;, &quot;types&quot;: [ &quot;element-plus/global&quot; ] &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot;, ], &quot;include&quot;: [ &quot;src/*&quot;, &quot;src/**/*.vue&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.jsx&quot;, &quot;src/**/*.ts&quot;, &quot;src/**/*.js&quot; ]&#125; 结语 修改后请重启编辑器 本文验证与2022年1月10号，mac，win双平台均有效，如果以上配置无效了，请查看相关api的改动 如果帮助你解决了问题，动动小手点个赞吧！:)","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vue3.x 预渲染 Unable to prerender all routes错误排查","slug":"vue3.x 预渲染 Unable to prerender all routes错误排查","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T06:56:39.471Z","comments":true,"path":"2022/03/15/vue3.x 预渲染 Unable to prerender all routes错误排查/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/vue3.x%20%E9%A2%84%E6%B8%B2%E6%9F%93%20Unable%20to%20prerender%20all%20routes%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/","excerpt":"","text":"Vue3.x 预渲染 Unable to prerender all routes错误排查前言​ BOOS最近对前几年做的公司官网不太满意，觉得没有有效体现公司的优势，表明随着公司这几年的努力发展，我们将会接触到更大规模的合作伙伴，自然要展示更好的企业形象，所以官网重做。 需求分析 没有交互的静态页面，但是存在大量动画 需要支持良好的SEO ​ 最早期的官网是vue2.x + webpack3.x + vue-cli-plugin-prerender-spa进行实现的，效果挺不错，很快各大搜索引擎就收录了我们的网站，所以这次我们打算沿用此方案，不过使用最新技术栈； 为什么不用vite​ 查阅vite的生态后，未找到类似prerender-spa的plugin，没办法支持预渲染，所以vite就被淘汰了。 为什么不用unxtjs​ 我们的官网不具备大量的接口交互，用Nnxtjs多少有点杀鸡用牛刀了，并且还需要使用pm2部署代码，付出于收获不成正比，被淘汰。 最终方案​ 我们部门是vue技术栈，团队不考虑react，通过以上排除法，只能使用vue3.x + webpack5.x + prerender-spa进行业务实现了。 技术实现基础模板我们使用最新的vue-cli进行项目搭建，选择vue3版本，最近的cli默认就是webpack5 安装预渲染插件1npm i prerender-spa-plugin -D 增加配置123456789101112131415161718const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)const path = require(&#x27;path&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, &#x27;dist&#x27;), routes: [&#x27;/xxx&#x27;], &#125;) ) &#125; &#125;,&#125;) 打包测试1npm run build 然后就出现一个错误 1[prerender-spa-plugin] Unable to prerender all routes! 让我们一起抽丝剥茧，看看报错的具体原因。 错误排查因为报错提示很模糊，我们打开他的源码，在源码line144发生错误的地方增加log，了解具体报错。 再次执行npm run build，得到真正的错误。 1Building for production...error TypeError: compilerFS.mkdirp is not a function ​ 我们继续最终源码发现 compilerFS 由webpack进行提供，我们带着错误前往webpack官网查询错误，于是就找到了Filesystems，因为这个插件已经好几年没有更新，而我们当前使用的是webpack5，出现了API变更的情况。 ​ 于此同时，根据错误提示，我们也在该库的issues中找到了历史讨论。 在讨论中，找到了两种解决方案 修改node_modules源码，使其兼容webpack5 1234567891011// From https://github.com/ahmadnassri/mkdirp-promise/blob/master/lib/index.js const mkdirp = function (dir, opts) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;\\ndir&#x27;, dir, opts, &#x27;\\n&#x27;); try &#123; compilerFS.mkdirp(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; catch(e) &#123; compilerFS.mkdir(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; &#125;) &#125; 使用已经被修改的库，感谢这位大哥 1npm i @dreysolano/prerender-spa-plugin 我们使用第二种方案，重新修改vue.config.js 12- const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)+ const PrerenderSPAPlugin = require(&#x27;@dreysolano/prerender-spa-plugin&#x27;) 然后再次打包测试 打包成功，通过启动本地服务器curl命令测试得知，SEO功能正常，未发现问题。 总结​ 使用prerender-spa-plugin打包出现报错[prerender-spa-plugin] Unable to prerender all routes!，更换库为**@dreysolano&#x2F;prerender-spa-plugin**，即可解决问题。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"写给前端新人的nginx教程","slug":"前端工程师的nginx教程","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T06:55:30.056Z","comments":true,"path":"2022/03/15/前端工程师的nginx教程/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84nginx%E6%95%99%E7%A8%8B/","excerpt":"","text":"写给前端新人的nginx教程前言​ 我相信大部分前端新手是接触不到部署相关的工作的，一般都是将代码包交给后端，或者通过CI，FTP完成代码的更新，至于代码如何部署，如何从域名到前端代码包，很多前端仔没有实际操作过，自然是不知道的，这篇文章就是要帮助未接触过部署的人学会在服务器上线部署一个前端项目，在这个主线中带大家慢慢的熟悉nginx ​ 记得在2017年暑假，那时候大二还没开学，当时我只会写一点简单代码，linux和运维完全没接触过，一冲动在阿里云购买了一个服务器，外加一个域名，好像还是xiaowuasy.top,现在已经不能访问了；那时候单纯的兴趣使然，想搭建一个网站，因为实力不足，也不知道求助别人，前前后后折腾了一个月，最终竟然成功在服务器上面部署了wordpress服务，后面域名备案也成功了； ​ 这段经历是曲折的，依稀记得在盛夏的傍晚，我坐在慢慢暗下来的客厅，头上还残留着因为紧张流下的细汗，眼睛因为专注而干涩，面对不太看得懂的文档，一遍一遍尝试；我自然不希望大家在这上面浪费时间，这也是写这篇文章的初衷 前置知识 一个云服务器，阿里云，腾讯云，xx云都行，首次购买或者学生认证都是有很大的优惠（本文以阿里云为例子） 了解linux基础命令，也就是对各种文件的增删改查 本教程基于CentOS 7.5系统，如果是图形化界面，或者其他系统，命令可能不完全一致，但是流程都是一致的，建议看对应教程 如果linux基础命令不会。下面的也不用看了，立刻去学 搭建环境连接服务器通过远程工具（CRT，Xshell）或者自带的远程连接进入自己的服务器，连接方式选择公网ip 安装nginx CentOS自带yum命令，这个命令很关键，自行了解 执行命令 1yum install nginx // 终于遇到需要确认的，直接确认即可 安装完成后,主机中便有了nginx服务，相关命令如下，启动完成后 1nginx 启动完成后，浏览器访问公网IP,就可以访问到nginx的默认主页 到这一步就算是nginx部署成功了 nginx相关文件路径12/etc/nginx/ // 配置文件/usr/share/nginx/ // 默认前端代码存放处 ​ 默认配置在/etc/nginx/nginx.conf,nginx根据默认配置，监听80端口，80端口指定了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html这个文件夹，于是你访问公网ip -&gt; 公网ip:80 -&gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html,于是”Welcome to CentOS“便呈现在你的面前 ​ 如果你希望不显示默认的页面，而是显示你自己写的项目，直接替换/etc/nginx/nginx.conf中的root,字段为自己程序包的路径 在6666端口上搭建一个站点​ 我们的代码除了部署在默认80端口上面，还可以其他端口上，例如8888，7777，等等 ​ 接下来我们就在一个自定义的端口上面部署一个站点 ​ 这里我们需要注意nginx.conf中的一行配置 含义：在&#x2F;etc&#x2F;nginx&#x2F;conf.d下面所有nginx的配置文件都会自动生效 根据配置文件的提示我们到目标文件夹下面，建立test.conf，名字无所谓，配置文件里面是通配符匹配的 并通过vi 写入内容 123456server &#123; listen 7777; server_name _; root /usr/share/nginx/test;&#125; 再去文件夹/usr/share/nginx/test下建立一个index.html 123mkdir test cd testvi index.html 将一下内容放入index.html种 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是7777端口&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后重启nginx 1nginx -s reload 访问我们部署的项目ip:7777 然后你会发现访问不了，最终访问超时(&#x3D;&#x3D;)，这是因为服务器限制了可访问端口，此时需要到云管理后台设置安全组 在阿里云后台增加安全组规则 之后就可以正常访问了！ 至此，便完成了第一个nginx项目的部署 部署一个vue项目​ 通过上面的例子，我们已经可以完成一个自定义站点的部署了，那么真实项目呢，例如将一个vue项目部署到3006端口 首先编写xxx.conf 1234567891011121314151617181920server &#123; listen 3006; server_name _; # 开启gzip相关配置 gzip on; gzip_static on; gzip_min_length 2k; gzip_buffers 4 8k; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/x-icon application/javascript; gzip_comp_level 9; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 站点代码路径 root /usr/share/nginx/client; # 单页应用必须设置（刷新404问题） location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 将打包之后的代码，通过FTP上传代码到目标文件夹/usr/share/nginx/client（注意文件夹名称） ftp 重启nginx nginx -s reload 这边完成了一个站点的部署！是不是很简单 绑定域名​ 直接拿ip+端口给别人访问是不太好的，大家都给自己站点绑定上一个好记忆的域名，那么nginx如何绑定域名呢？ 购买一个域名https://wanwang.aliyun.com/domain/，备案域名，这个流程很麻烦，需要10-30天 备案完成后，域名就可以使用了 我们需要去修改我们的nginx配置，将server_name的值修改为需要绑定的域名即可； 1234server &#123; listen 3006; server_name xxx.com;// .... 增加https支持 申请一个https证书，数字证书管理，以阿里云为例子，国内云厂商都有 将证书放在服务器中你可以记得住的文件夹里面 修改nginx配置 12345678910111213141516171819202122232425server &#123; // # 将当前域名的http自动打到https listen 80; server_name xxx.com; rewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123; listen 443 ssl http2; server_name xxx.com; ssl_certificate xxxx/yy.pem; # 证书 ssl_certificate_key xxxx/yy.key; # 证书秘钥 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; root /usr/share/nginx/client; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 结语​ 虽然部署一个站点，仅仅是用到nginx，但是涉及到的知识点还是很多的 ​ 如果遇到了错误，一定要仔细检查报错信息，问题百度百度基本都能得到答案，如果实在搞不定，直接重做云服务器系统，重头再来；遇到问题并把它解决了，便成了你的技能 ​ 一个有经验的开发人员部署一个站点，可能半小时就弄完了，想要熟练的话，一定要多练习多实践，从0到1部署一个项目还是一件很酷的事情！ 如果搭建中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"浏览器读取xls并生成二维码下载到本地","slug":"浏览器读取xls生成二维码并下载","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T06:55:14.983Z","comments":true,"path":"2022/03/15/浏览器读取xls生成二维码并下载/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96xls%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"浏览器读取xls并生成二维码下载到本地需求一次普通的技术需求会议 ​ 项目经理首先发言 我们技术这边需要将xls表格中的几千条数据变成二维码，并且中间镶嵌logo，图片底部放置编号，由于xls表格数据私密，不能通过第三方完成 ​ 平常这个事情都是后端处理的，前端就是来摸鱼的，但是这次一反常态，后端脸黑了，带样式搞不来，脚一蹬，直接装死 ​ 项目经理用期盼的眼神看着我，顿时我紧张了起来，眼神飘忽，我已经好多年没搞过node了啊！！会议室都沉默了，在项目经理不断精神攻击下，后端装死的情况下，看来注定要大前端来拯救世界了，毕竟JavaScript万能语言，俺来试试吧！ 实现方案​ 以上情节纯属虚构，但是需求确实是这样的，虽然好几年没碰过node，好歹年轻记性好，用过的基本都还记得，调研实现方案上没出现太多问题，有如下方案 puppeteer地址：https://github.com/puppeteer/puppeteer ​ 使用基于node环境的puppeteer，进行二维码绘制，图片绘制，是JavaScript开发者面对此类需求的主流选择 node-canvas地址：https://github.com/Automattic/node-canvas ​ 同样是在服务端完成渲染，但是这个库依赖node-gyp，如果不安装python2，那安装过程懂得都懂，不过这也是很不错的方案 浏览器​ 通过浏览器canvas绘制，然后下载下来，会有刷刷刷下载图片的炫酷效果 很明显有刷刷刷下载图片炫酷效果的方案更好，所以就选择你了 浏览器方案！ 问题分解确定了技术方案，就要考虑具体实现了 JavaScript读取execl文件，并处理成理想格式 将读取到的execl中的网址字段生成一张二维码 将二维码写入canvas，在其中间加上logo，并在底部加一行文字 将canva转化为DataURL，下载它 不断递归生成，直到xls数据全部处理完毕 理论存在，实践开始！ 具体实现启动一个本地服务器首先我们通过VScode Live Server 启动一个本地服务器 这里有好奇宝宝要问了，为啥第一步是这？ 答：因为浏览器是访问不了电脑的文件系统的，所以只能通过启动一个本地服务器的方案，来读取我们的资源文件 创建html，引入资源库分析需要用到的第三方开源库 解析xls https://github.com/sheetjs/sheetjs 生成QRcode https://github.com/soldair/node-qrcode 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生成二维码&lt;/title&gt; &lt;script src=&quot;./qrcode.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./xlsx.full.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 用于生成载体 最终生成的图片大小，按自己的需求来 --&gt; &lt;canvas width=&quot;260&quot; height=&quot;310&quot; id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; const ctx = initCanvas(); // 获取ctx实例 // 初始化画布 function initCanvas() &#123; const canvas = document.getElementById(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); return ctx; &#125; &lt;/script&gt;&lt;/html&gt; 解析xls文件1234567891011121314151617181920212223242526272829303132333435363738readWorkbookFromRemoteFile().then((res) =&gt; &#123; // res 为实际解析代码 [&#123;key:&#x27;xxxx&#x27;,value:&#x27;xxxx&#x27;&#125;,....]&#125;);// 读取xls信息，并处理function readWorkbookFromRemoteFile() &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;http://127.0.0.1:5500/xls.xls&quot;, true); xhr.responseType = &quot;arraybuffer&quot;; xhr.onload = (e) =&gt; &#123; if (xhr.status == 200) &#123; var data = new Uint8Array(xhr.response); var workbook = XLSX.read(data, &#123; type: &quot;array&quot; &#125;); // 获取实际表格长度（去除表头） let carryLen = 0; for (const key in workbook.Sheets[&quot;Sheet&quot;]) &#123; const ele = workbook.Sheets[&quot;Sheet&quot;][key]; if (key.includes(&quot;A&quot;)) &#123; carryLen++; &#125; &#125; // 解析数据 let xls = []; for (let i = 2; i &lt;= carryLen; i++) &#123; let data = workbook.Sheets[&quot;Sheet&quot;]; xls.push(&#123; key: data[&quot;A&quot; + i].w, value: data[&quot;B&quot; + i].w, &#125;); &#125; resolve(xls); &#125; &#125;; xhr.send(); &#125;);&#125; 看到这里肯定也有细心的好奇宝宝问，为啥循环体中的i为2呢? 答案：因为表格中的A1，B1为表格的第一行，而第一行是表头，要去除 将链接生成为二维码12345678910111213141516171819new Promise((resolve, reject) =&gt; &#123; // 生成二维码 QRCode.toDataURL( &#x27;xxxxxxx&#x27;, &#123; width: 260, height: 260, margin: 3, &#125;, (error, url) =&gt; &#123; if (error) console.error(error); const code = new Image(); code.src = url; code.onload = () =&gt; &#123; ctx.drawImage(code, 0, 0); resolve(code); &#125;; &#125; ); 写入中间logo12345678return new Promise((resolve, reject) =&gt; &#123; const code = new Image(); code.src = &quot;http://127.0.0.1:5500/logo.jpeg&quot;; code.onload = () =&gt; &#123; ctx.drawImage(code, 260 / 2 - 20, 260 / 2 - 20, 40, 40); resolve(); &#125;;&#125;); 写入底部文字123456// 写入编号ctx.font = &quot;24px Arial&quot;;ctx.fillStyle = &quot;#000&quot;;ctx.textAlign = &quot;center&quot;;ctx.textBaseline = &quot;middle&quot;;ctx.fillText(xls[index].value, 130, 270); canvas转化为图片，并下载到本地1234567// 用于预览let url = document.getElementById(&quot;canvas&quot;).toDataURL(&quot;image/png&quot;);var a = document.createElement(&quot;a&quot;); // 生成一个a元素var event = new MouseEvent(&quot;click&quot;); // 创建一个单击事件a.download = xls[index].value; // 将a的download属性设置为我们想要下载的图片名称，若name不存在则使用‘下载图片名称’作为默认名称a.href = url; // 将生成的URL设置为a.href属性a.dispatchEvent(event); // 触发a的单击事件 第一张图片，完成生成 递归调用我们修改发起逻辑代码，逻辑尾部增加递归调用就好啦 12345678910111213141516171819202122232425262728readWorkbookFromRemoteFile().then((res) =&gt; &#123; createImg(res, 0); // 递归生成&#125;);// ......// 实际生成逻辑function createImg(xls, index) &#123; new Promise((resolve, reject) =&gt; &#123; // 生成二维码 &#125;) .then((res) =&gt; &#123; // 生成中间logo &#125;) .then(() =&gt; &#123; // 写入编号 &#125;) .then(() =&gt; &#123; // 下载图片 &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; if (xls.length &gt; index + 1) &#123; ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); // 初始化画布 createImg(xls, index + 1); &#125; &#125;, 20); // 爱惜机器，加个延时，也可以去掉延时，体会机器的极致速度 &#125;);&#125; 最终效果 至此，终于实现了刷刷刷下载图片炫酷效果，此时可以脑部一段很快的rap，如果华佗再世，崇洋可以医治，外邦来学汉字…………… 最终生成的文件 最终代码地址 一定要针对该项目启动一个本地服务器，否则资源无法访问 web-Output-QRcode 结语​ 首先纠正一点，JavaScript开发者针对生成二维码类似的任务，首选肯定是puppeteer，使用浏览器绕个弯这种实现方案，多少带点科研味道，长期项目自然是不推荐的 ​ 带着学习的态度去完成需求，并且不断优化代码、总结问题，将遇到的未知知识点学会，（比如创建a链接，自动触发点击事件），这才是本文的目的。 ​ 感谢阅读，觉得还不错就点个赞吧~ ​ QQ交流群：530496237 大佬解答疑惑~（内有微信群二维码） ​","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"三个案例带你理解Event Loop流程","slug":"聊一聊宏任务与微任务以及EventLoop","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T06:54:53.668Z","comments":true,"path":"2022/03/15/聊一聊宏任务与微任务以及EventLoop/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E8%81%8A%E4%B8%80%E8%81%8A%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEventLoop/","excerpt":"","text":"三个案例带你理解 Event Loop 流程为什么 JavaScript 需要 Event Loop​ JavaScript 在创建之初就确认了一点，JavaScript 是一门单线程语言，因为 JavaScript 主要提供用户互动以及操作 DOM，假定存在两个线程，同时对一个 Dom 进行操作，那究竟以谁为准呢，为了避免这种复杂性，JavaScript 确认了单线程这个核心概念 ​ 在单线程中，除了 JavaScript 本身的逻辑之外，还存在一些 IO 操作，例如从服务端获取数据，在单线程中就需要等待结果的返回才能继续下面的逻辑，这时候机器是挂起状态，为了避免这个低效问题，这里就引入了同步任务与异步任务的概念，依旧是是单线程，但是有些任务不等待其运行结果 ​ 于是同步任务都在函数执行栈（Stack）上执行，所有的异步任务，在有了运行结果之后，就会将其放入任务队列（callback queue），如果 Stack 中任务执行完毕，就会再去检查任务队列是否存在待执行的回调任务，将其任务放入 Stack，再执行，这里就会不断循环此操作 ​ Stack 执行 - Stack 执行完毕 - 检查任务队列 - 将任务加入 Stack - Stack 执行，这样重复的过程就需要 Event Loop 来持续不断的循环检查任务队列，确保异步任务被准时加入到 Stack 相关名词介绍函数执行栈（Stask）：遵循后进先出原则，同步函数执行栈 webAPIs：异步任务的发起者，事件是首先进入 stack，例如 click，change，再将 callback 加入任务队列 回调队列（callback queue）：也可以被称为任务队列，回调函数到达了执行时机就会进入任务队列，他们将会被 Event Loop 持续打入函数执行栈 事件循环解析我们用 Event Loop 来解释一个简单的 demo 1234567consoleo.log(&quot;1&quot;);setTimeout(() =&gt; &#123; console.log(&quot;2&quot;);&#125;, 5000);console.log(&quot;3&quot;); 我相信大部分人都知道，这里打印的顺序为 1 3 2，下面我们用事件循环的流程来说明为什么是这个结果 注： cb 为 callback console.log(&#39;hi&#39;)，进栈 执行 出栈，打印 1 setTimeout进栈 执行 cb 加入异步队列 自身出栈 console.log(&#39;end&#39;)，进栈 执行 出栈 打印 3 5s 后，cb 加入任务队列，event Loop 检查当前执行栈是否存在函数，检查发现不存在，将 cb 加入函数执行栈 cb进栈 执行 出栈 打印 2 ​ ​ 我们通过 event Loop 的角度进行解析，就能很轻易的解释为什么代码执行顺序是 1 3 2，这是非常简单的场景，接下来我们会分析一些更加有难度的代码 关于宏任务与微任务​ 通过上面的介绍，我相信大部分人都事件循环有一个基础的认知的，但是与以上我们通过简单的示例，演示了异步代码在事件循环中的运行流程，并没有涉及宏任务与微任务，这两货是什么呢，为什么要在这里出现？ 首先，宏任务（macrotask），微任务（microtask）都是异步任务 宏任务：setTimeout setInterval setImmediate I/O 键盘事件 网络事件 UI rendering 微任务：pormise MutationObserver process.nextTick 他们在执行层面上存在一定差异 例子 1123456789101112131415console.log(&quot;script start&quot;);setTimeout(function () &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);Promise.resolve() .then(function () &#123; console.log(&quot;promise1&quot;); &#125;) .then(function () &#123; console.log(&quot;promise2&quot;); &#125;);console.log(&quot;script end&quot;); 结果为 script start script end promise1 promise2 setTimeout pormise 与 setTimeout 虽然都是异步任务，但是上图的代码你会发现，promise 仿佛插队了，这便是宏任务与微任务在任务队列最大的不同之处 ​ event Loop 在事件循环中,首先解析 script，将宏任务加入宏任务队列，将微任务加入微任务队列，栈空了之后，执行当前微任务，第一轮事件循环结束 在第二轮事件循环中，首先执行宏任务 callback 中的第一个，执行完毕，栈空了之后，再执行当前微任务，后面同理 例子 212345678910111213141516171819202122232425console.log(&quot;a&quot;);setTimeout(() =&gt; &#123; console.log(&quot;b&quot;); setTimeout(() =&gt; &#123; console.log(&quot;g&quot;); &#125;, 0); new Promise((resolve) =&gt; &#123; resolve(); &#125;).then(() =&gt; &#123; console.log(&quot;h&quot;); &#125;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&quot;c&quot;); resolve();&#125;) .then(function () &#123; console.log(&quot;d&quot;); &#125;) .then(function () &#123; console.log(&quot;e&quot;); &#125;);console.log(&quot;f&quot;); 大家可以先别看答案，自己先尝试将答案推算出来 第一轮事件循环console.log(&quot;a&quot;);进入栈 执行 出栈 打印 a setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 console.log(&quot;c&quot;);进入栈 执行 出栈 打印 c new Promise.then 进入微任务队列 console.log(&quot;f&quot;);进入栈 执行 出栈 打印 f new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;d&quot;)进入栈 执行 出栈 打印 d console.log(&quot;e&quot;)进入栈 执行 出栈 打印 e –微任务执行完毕 第一轮事件循环完毕– 结果为 a c f d e 第二轮事件循环第一轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;b&quot;) 进入栈 执行 出栈 打印 b setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 new Promise.then 进入微任务队列 new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;h&quot;)进入栈 执行 出栈 打印 h –微任务执行完毕 第二轮事件循环完毕– 结果为 b h 第三轮事件循环第二轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;g&quot;);进入栈 执行 出栈 打印 g —宏任务完毕，开始执行微任务— –微任务队列为空 第三轮事件循环完毕– 结果为 g 结果a c f d e b h g 宏&#x2F;微任务的结论通过上面三个例子，我们可以得出以下结论 函数执行栈中如果还存在函数，则等待其结束，才会继续事件循环 Event Loop 先执行同步任务，再微任务，下一轮循环，宏任务加入队列，执行，所以说先微任务，再宏任务是合理的 单次 Event Loop 中，只会执行一次宏任务，但是微任务可以一次执行多个 推荐文章做一些动图，学习一下 EventLoop 通过动图看 Event Loop 更加便于理解 总结​ JavaScript 单线程语言的特性注定其需要异步队列，让网页交互体验上更加友好，对于开发来说，需要尽量了解其特性 ​ 首先我们需要了解事件循环机制，搞懂代码执行栈 异步队列的概念，再后面搞懂宏任务与微任务，读懂异步队列的运行机制，这样基本上就可以解决大部分 Event Loop 问题，了解宏任务 微任务 将会对代码执行顺序有更加底层的理解，这样就可以解决","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]}],"categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]}