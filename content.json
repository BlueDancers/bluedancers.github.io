{"meta":{"title":"vkcya Blog","subtitle":"","description":"","author":"bluedancers","url":"https://bluedancers.github.io","root":"/"},"pages":[{"title":"书籍","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"books/index.html","permalink":"https://bluedancers.github.io/books/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-12-09T01:09:47.587Z","updated":"2022-12-09T01:09:47.587Z","comments":true,"path":"about/index.html","permalink":"https://bluedancers.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233&#123; name: &quot;vkcyan&quot;, age: 24, gender: &quot;男&quot;, profession: &quot;Web Developer Leader &amp; Product Manager&quot;, experience: &quot;4年&quot;, address: &quot;安徽省合肥市&quot;, education: &quot;本科&quot;, github: &quot;https://github.com/vkcyan&quot;, blog: &quot;https://vkcyan.github.io&quot;, email: &quot;wu.vkcyan@gmail.com&quot;, description: &quot;一切都是为了实现技术的价值&quot;, skills: [ [&quot;Html&quot;, &quot;CSS&quot;, &quot;JavaScript&quot;, &quot;TypScript&quot;, &quot;ES6&quot;, &quot;Node&quot;], [&quot;Webpack&quot;, &quot;Vite&quot;], [&quot;Less&quot;, &quot;Sass&quot;], [&quot;Git&quot;], [&quot;Vue2.x&quot;, &quot;Vue3.x&quot;], [&quot;element-ui&quot;, &quot;element-plus&quot;, &quot;AntdV&quot;], [&quot;竞品分析&quot;, &quot;产品规划&quot;, &quot;挖掘用户需求&quot;, &quot;定制产品策略&quot;], ], devTools: [ [&quot;Visual Studio Code&quot;, &quot;Sublime Text&quot;], [&quot;Chrome DevTools&quot;, &quot;Fiddler&quot;], [&quot;SourceTree&quot;], [&quot;SwitchHosts&quot;], [&quot;Navicat&quot;, &quot;&quot;], [&quot;Sketch&quot;], [&quot;Typora&quot;], ],&#125;;"},{"title":"类别","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"categories/index.html","permalink":"https://bluedancers.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"links/index.html","permalink":"https://bluedancers.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-09T01:09:47.589Z","updated":"2022-12-09T01:09:47.589Z","comments":true,"path":"tags/index.html","permalink":"https://bluedancers.github.io/tags/index.html","excerpt":"","text":""},{"title":"存储库","date":"2022-12-09T01:09:47.588Z","updated":"2022-12-09T01:09:47.588Z","comments":true,"path":"repository/index.html","permalink":"https://bluedancers.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"《经济学的思维方式》读书笔记1-3","slug":"阅读/《经济学的思维方式》读书笔记（1-3）","date":"2024-01-19T16:00:00.000Z","updated":"2024-03-25T08:13:11.639Z","comments":true,"path":"2024/01/20/阅读/《经济学的思维方式》读书笔记（1-3）/","link":"","permalink":"https://bluedancers.github.io/2024/01/20/%E9%98%85%E8%AF%BB/%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881-3%EF%BC%89/","excerpt":"","text":"《经济学的思维方式》读书笔记1-3前言​ 本书来自于“蜜獾吃书”播客的推荐，我一直都经济学都挺感兴趣的，毕竟经济学涉及到每一个人，也涉及到人的决策，大学里面学过一些微观经济学，但是理解比较浅显，工作多年也深感自己浮于表面，所以趁此机会打算好好读读保罗海恩的《经济学的思维方式》，强加一下自己的经济学思维。 第一章：经济学的思维方式Q：经济学的定义 A：一套关于选择以及选择产生的意外之果的理论 Q：介绍优化行为的概念？ A：在进行选择的时候，个体会不断比较各种行为能为他们带来的额外收益和额外预期成本 Q：理解个人决策的重要性 A：所有社会现象都来自于个体的行为和个体之间的互动，而个体在选择行为时只考虑对自身的预期收益和预期成本，而且所谓集体从选择，归根结底仍然是个体的选择。 Q：介绍产权的概念：产权是经济学游戏的重要规则 A：产权是经济学游戏的规则中的关键元素，产权通过法律将稀缺资源的所有权分配到个人。 Q：理解社会互动中“看不见的手”扮演的重要角色 A：这个看不见的手，实际上都是人们面对不断变化的收益和支出，总是做出最优解的集体行为。 当人们习惯某件事情后，就很容易讲起视为天经地义，而难以看清它的本质 人们总是关注失败，而把成功视作理所应当，甚至根本意思不到他的存在。 高峰时段的交通最大的特点不是堵塞，而是流动，每个人都独立选择自己的路线，相互不商量，驾驶技术参差不齐，风险偏好都不一致，礼貌程度天差地别，但是这样的交通系统不仅没有瘫痪，反而仅仅有条，仿佛有一双看不见的手，在引导车辆的运动，着是社会协作的奇迹 ​ 一个社会必须完成大量生产活动，而这些活动一非常复杂的方式相互关联。如何鼓励每个人的紧缺采取行动，形成共同体？也就是说社会协作究竟是如何发生的呢？ ​ 先人在几百年前开始研究这一问题，但是他们他们的社会比我们的要简单的多，也收到了诸多限制，所以直到18世纪 ​ 思想家才开始思考社会究竟是如何运转：个体仅拥有极为有限的信息，且仅关心自己的利益，然而我们得到的结果并非一团混乱，而是令人惊叹的充满秩序、生产力充沛的社会，为什么会这样呢？ ​ 亚当斯密毫无疑问是最有洞察力的思想家，在他的时代，大部分受过教育的人都相信，政治统治者必须进行精心的计划，否则整个社会将会退化到贫困和无序，亚当斯密不同意这个观点，他认为社会的运作依赖于某种协作过程。但是，想要驳倒当时的主流看法，他必须把社会协作描述出来，斯密认为，这个过程能够自发运转，不仅不需要政府随时监管，甚至还能抵消与之相左的政府政策。 ​ 经济学的思维方式：所有社会现象都产生与个体的行为和相互作用，而个体根据行为给自身带来的预期收益和预期成本进行选择。 ​ 经济学不仅关于金钱和利润、商业和金融，也不仅研究人们的竞争性行为。事实上，经济学研究所有类型的选择，以及这些选择所产生的意外之果，也就是人们在选择自己行为时没有预料到的副作用。 ​ 虽然适用于世间万物，但实际这并不是说所有人都是自私、物质，只关心利益，而是一切都取决于如何定义收益与成本，以及他们赋予这些收益和成本的相对价值。 ​ 实际应用这，经济学的思维主要涉及三个方面 行为，强调优化与权衡，或者说取舍 互动，互动是自发性的，没有超级管理员，互动可以良好的分工进而产生更多价值，现代社会，人人靠专业分工与交换为生。 结果 1.5 ​ 经济学理论认为，你的选择、计划会改变他人的机会；人际互动使各种选择的净收益不断变化，人们再根据这些变化不断相互调整，从而完成社会协作的过程。 ​ 想象一条高速公路，在2个方向上各有四条车道，所有的入口和出口，都设置到车道的右侧，为什么有些人还有费事换到最左侧行驶呢？因为右侧车速最慢，那离开最有道后，实际会选择剩下三道的那一道呢？根据经济学的理论，每一条车道的净收益都在不断变化，司机会随时关注这些变化，最终所有车道的车速都会一致，以上协调过程能够自发的快速、准确的完成，如果强制每一辆车到指定车道，效率将会远低于自动协作系统的效率。 ​ 只要稍稍改变某种选择的经济成本和经济收益，就能让很多人改变自己的行为，这个机制就是市场经济的核心机制。 1.6 信号 ​ 要想成功调整自己的行为、适应他人的行为，信息是必不可少的，以路上开车为例子，指示牌、交通灯、转向灯、，简单的行为将信息广播到数不清的人，但是我们通常意识不到这个过程，就像开车的型号，价格也帮助我们决定生产与消费，明确各种选择与权衡，如果没有价格的引导，我们就像失去信号灯一样一样盲目。 1.7 游戏规则 ​ 人们通过一套约定俗称的习惯来协调各种目标与计划，这个习惯就是经济系统，要想一个游戏顺利进行，必须满足以下2个条件 参与者必须大致明白规则并基本同意遵守 游戏规则需要决定一定稳定性。 ​ 如果游戏规则不清晰，或者自相矛盾，都会导致游戏的崩溃，人们会既不明白别人希望你做什么也不知道该期待别人做什么，互惠消息无法再缺乏规则的情况下进行，人们会犹豫试图弄清游戏规则，甚至试图破坏并建立对自己有利的新规则。 1.8 产权是一种游戏规则 ​ 游戏规则的重头戏是产权，私有产权是市场交换型经济体的根基，所谓私有产权，是指法律以所有权的形式将权利明确分配到具体的个人。私有产权清楚界定了谁在法律上拥有什么。任何人都无权在未经你的同意的情况下使用与改变你的财物，哪怕是给你的汽车装一个更好的音响。 ​ 此外，人们可以资源的买卖或者交换私有产权，即放弃自己的产权，换取对其他商品或服务的类似产权，所以购买被视为产权的一种交换，交易完成后你拥有了物品的拥有权，卖家则拥有了你支付的现金的所有权。 ​ 私有产权能够为社会成员提供可靠的信息和激励机制，但是清晰、令人满意的私有产权系统并非一朝一夕的事情，需要相当长的时间进行演化 1.9 经济理论的偏向性：是长处还是弱点 ​ 经济学理论并非完美的理论，不能提供一种毫无偏见的意见，不能同时呈现所有事实，不能赋予所有价值观相同的权重。 经济学总是过于强调个人选择，难道是人们选择成为穷人或者失业吗 经济学家试图将集体（企业、政府、国家）的选择分解为集体中的个人选择。 经济学的思维强化优化过程，强调权衡和计算，强调目的手段的一致性，但是人们真的如此精于计算吗？我们的行为难道不是更多的受无意识的欲望和未经权衡的冲动引导。 经济学的思维方式是一种偏向于市场的思维方式，确实是这样的，经济学家更加喜欢能促成互惠交易和高效生产的社会支付和游戏规则，并让所有参与者获益。 1.10 是偏见还是结论 ​ 经济学是一门关于选择以及选择的意外之果的理论 ​ 很多人对华丽的理论嗤之以鼻，职员椅相信常识和日常经验，但这些人事实上往往相信一些极为模糊笼统的假设，并沦为这些东西受害者。 ​ 仅仅因为几组事实之间具有统计上的相关性就认为这几组事实之间有某种因果关系，这是一种非常常见的错误思维。 1.11 经济学家的技能 ​ 我们可以观察事实，但是要想解释事实发生的原因，就必须建立一套理论，一套关于因果关系的理论。正式有理论的存在，我们才能在大部分情况下从眼花缭乱、头晕目眩的各种事实中找出规律和原因。事实上，我们知道的事情总，只有一小部分来自观察，我们在这里发现一点提示，在那里找到一点线索，剩下的部分都是理论。 ​ 第二章 效率、交换和比较优势Q：区分免费商品、稀缺商品和负商品 A：免费商品是不需要付出任何成本的商品，稀缺商品是需要付出成本的的商品，也要进行取舍，负商品是越少越好的商品 Q：解释经济效率的概念以及这个概念与主观价值的联系 A：经济效率是比较各种决策的成本与收益，预期额外收益与预期额外成本之间的关系，这个取决于当事人的价值观 Q：理解自由交换对交换双方都有益 A：自由交换可以让双发都获取对自己有价值的产品，自由交换不是等价交换，交换也是另一种形式的生产 Q：用生产可能性曲线比较优势 A：生产可能性曲线可以帮助我们找到几乎成本最低的生产方案，实现更多的收益。 Q：探索中间人在较低交易成本和提供细且信息方面发挥的作用 A：中间生可以让双方获取更多信息，以及机会，这些信息会增加参与者的收益。他们协调不同地区之间的市场交易，将本地市场整个进入更大的经济系统中 Q：引入对长期经济增长现象的解释 A： ​ 认为交换不能产生任何真正的收益是一种偏见，人们总是认为从交易中获利的商人一定是对社会进行了某种剥削，农民和工匠生产了所谓真正的产品，而商人似乎并不播种、不劳而获，他们的活动似乎没有创造出任何产品，但是他们竟然从中获利，因此游戏人认为贸易是一种社会浪费。 ​ 实际上这是一种完全错误的观点，交换是一种能产生效益的生产活动，我们说交换能商城效益是因为这种活动能让人获得更多他们想要的东西。 2.1 正商品与负商品 ​ 如果面临选择的人认为某种东西多多益善，那么这种东西就是一种正商品 ​ 免费商品是指不需要做出任何医生就能获得到的商品，而想要获得稀缺商品就必须牺牲某些其他有价值的东西。 ​ 如果只有通过牺牲才能获得一种商品，那么这种商品就是稀缺的。 ​ 免费商品确实都存在，比如空气，但是在潜水场景，空气也是稀缺商品。 ​ 然而大部分商品都是稀缺商品，所以我们必须做出选择，也就是经济学问题，稀缺性。 ​ 负商品：越少越好的东西，比如夏天咬人的蚊子，恐怖袭击。 ​ 同一个东西可以同时是一个人的负商品和另一个人的正商品，比如榴莲。 2.2 物质财务的迷思 ​ 什么是财富？并不是具体的物品，在经济学思维方式下，只要是人认为有价值的东西都是财富。 ​ 人认为有价值的都是财富，对于想要灌溉农田的农民来说，更多的雨水意味着更多财富，对于洪困住的农民来说，雨水显然不是财富。 ​ 积极增长并不是指物品数量的增长，而是指财富的增长，虽然物质的产品能够为财富的创造做出贡献，但是财富的增长与物质产品的体积、数量并没有必然联系，所以我们要否定“财务等于物质产品”的想法。 ​ 专业分工与交换正是亚当斯密所说的商业社会的核心。 2.3 贸易创造财富 ​ 通常认为，交换是等值物品的交换，事实恰好相反，当人们资源进行交换的时候，他们交换的从来不是价值相等的物品，如果2件东西价值相等，那根本就没有必要发生交换。 ​ 参与交换的人相互合作，是为了抓住机会获得更多他们认为有价值的东西，正是因为双方都想获得更加价值，才产生了交换的动机。这是因为参与交易的双方的有着不同的价值观。 ​ 价值观的差异正是交易活动生产效益的根源，交易完成后，双方的财富都增加了。 ​ 也许会有人说，交易并没有使财富发生实质性的增长，因为交易没有正常产出任何东西。没错，确实没有创造新的物质，但是我们想一下“制造”究竟是是那么？ ​ 从技术的角度来说，制造是改变原料的排布方式，让原谅以更有价值的方式组合起来，制造的目的是增加价值，如果不能增加价值，就没必要进行制造活动。 ​ 我们跳出具体的制造，交换的本质也是对物品进行了重组，大家都认为重组后的物品价值更高，所以交易活动为双方创造了价值，交换活动被视为生产的另一种方式，交易双方都通过有价值的商品换来了另一个更有价值的商品。 ​ 自愿交易是一种能同时为双方创造财富的办法，通过在交换活动中与对手合作，交易双方都活动了增加自身财富的机会。 2.4 值不值？效率和价值 ​ 做决策的时候，个人通常会权衡这项决策将带来的所有预期额外收益和所有预期额外成本，并比较两者的关系。 ​ 比如买车，每公里的油耗是技术效率，是客观因素，经济学家所说的效率这是从选择者的角度出发，比较各种决策的额外收益和额外成本，我们将这种效率成为经济效率。 ​ 在个人层面，值不值实际上是一个经济效率的问题，比如同样是上班，有人选择坐地铁，有人选择骑自行车，有人选择开车，每一位员工都会选择从经济角度最有效率的通勤方式 ​ 每个人的选择都反应了他们的偏好和价值观，我们的价值观决定了我们认为什么决策效率高，什么决策效率低 ​ 当产权清晰，稳定并且可以交换的时候，稀缺资源通常具有合理的价格，价格会反应相对稀缺程度，如果有人认为自由市场决定的商品价格是错误的，那么他实际上否定的是决定价格的市场，是现存产权体系以及产前之外的其他游戏规则。 2.5 认识取舍：对生产的机会成本进行比较 生产可能性曲线：在给定资源和给定技术的前提下能够生产的最大组合。 琼斯每三个月可以生产10加仑的淡啤酒或者5加仑的黑啤酒 布朗每三个月可以生产3加仑的淡啤酒，4加仑的黑啤酒 从量度来看，似乎琼斯无论是生产淡啤酒还是黑啤酒都比布朗有效率，但是生产能力的高低本身并不是量度效率，而是看多多的代价是什么？ 若想获得更多啤酒，就必须牺牲某些东西，我们需要比较这种获得和牺牲之间的取舍，这就是研究机会成本。 假设琼斯只生成淡啤酒，那么他生产10加仑淡啤酒的成本是5加仑1的黑啤酒，反之生产5加仑黑啤酒的代价是牺牲10加仑的淡啤酒 布朗生产4加仑黑啤酒的的代价是放弃生产3加仑的淡啤酒 我们可以看出，在淡啤酒方面，琼斯的效率更高，机会成本最小 在黑啤酒方面，布朗的效率更好，因为布朗生产1加仑黑啤酒的机会成本是四分之三淡啤酒，所以在黑啤酒的生产上，布朗机会成本更低。 2.6 分工和交换带来的效益 ​ 如果2人分工，每个人只生产自己相对擅长的产品，并相互按照1:1的方式进行交换，会带来什么样的结果呢？ 两个人的的生产可能曲线都处于自身的外侧，也就是代表他的财富增加了，生产和交换拓展了人们的生产可能性，如果不与布朗交换，他不可能产出这么多啤酒。 ​ 通过只生产自身具有比较优势的产品，他们提高了稀缺资源的使用效率，两位生产者同时提高了自己的财富。 ​ 2.7 为什么要进行专业分工 ​ 专业分工就是选择自己具有优势的工作，因为这样能提高他们的财富水平，人们通过分工拓展自己面对的可能性，他们可以用自己生产的产品去交换那些自己生产成本更高的东西，市场经济的规则允许让你们进行产权交换。 ​ 这种想法被称为比较优势法则，这个概念解释了专业分工的动机，以及专业分工能提高经济增长，也解释了人们自己不生产所有东西，之所以会产生比较优势，也许是因为不同的人天生擅长的不同，或者是练习与学习的技术不同；人们可以通过自己拥有比较优势的活动来获得财富。 2.8 从个人贸易到国际贸易，再从国际贸易到个人贸易 ​ 从本质上来看，交易双方都在用自己出口的产品来交换自己进口的产品。 ​ 无论是组织之间的贸易还是国家与国家之间贸易，本质上都是人在进行交易，只是他们以组织的名义交易，只有个人才能做出选择。 2.9 交易成本 ​ 在私有产权系统下，人们进行专业分工的动机很强，因为比较优势能穿在更多的个人财富，系统的游戏也鼓励人们进行这些活动，但是除了机会生产本外，寻找交易对象的过程也会生产成本，在上述的例子中，我们有意忽略了交易成本，但是实际上发现交易机会并不简单，因为双方可能不在一个国家、不在一个地区，交易因此变得困难。 ​ 我们把这些因素称为交易成本，交易成本是安排相关方达成契约和协议的成本。 2.10 降低交易成本的动机：中间人 ​ 中间人扩大了可供我们选择的机会范围。 ​ 人们常常对中介费颇有微词，因为我们习惯把实际情况和并不存在的更优情况进行比较，但是我们实际进行交易甚少能像“假设我们知道所有信息时可能进行的交易”那样有利，所以我们认定中间人利用我们的无知占我们的便宜。 ​ 实际上，这种中间人和正常岗位没有区别，医生也会利用你对疾病的无知而收费，中间人和医生一样在创造真正的财富，因为他们为我们创造了更多我们想要的选择机会。 2.11 中间人创造信息 ​ 自由市场过程中的供给与需求产生了价格，价格是一种信息，这种信息能帮助人们评估不同商品与服务的稀缺程度，其中市场参与者可以低成本的产生高质量的信息，这是市场最重要却最容易被人忽视的优点之一，这个过程就反映了中间人的优势 ​ 有些市场是有组织的市场比如股票，该市场在较广的地理范围内交易同质化程度很高，另一些市场有组织化药低很多，比如二手家具。 ​ 每一种价格对其他人来说，都是一条潜在的有用信息，这种信息能告诉人们有哪些机会可供选择，人们面临的选择机会越多，人们的财富就越高，更多的选择机会意味着有能力做更多我们想做的事情 。 ​ 中间人的专长就是组织市场，创造有价值的信息，比如ebay的出现，让使用该网站的人生产有价值的信息，降低双方的交易成本，中间人能够减少交易的阻碍。 ​ 如果没有中间人，双方都要付出更高的成本的获取更多信息。 2.12 市场是一种发现的过程 ​ 市场中的个体从事他们自认为具有比较优势的行当。个体衡量自身的成本和收益，并根据这些判断来选择自己的行为。 ​ 比较优势预期生产的效率不是在黑板上被发现，而是通过产权交换在真实的市场中被发现。 ​ 在大多数的决策中，相对价格为决策者提供了极为重要的根本性信息，我们根据自身的情况，选择各种工作能带来的工资，还有选择自己感兴趣的项目、学生选择学位，当然并不是说人们仅仅关注价格，而是多数情况下，相对价格能够对人的决策起到指导作用。 ​ 达到某种目标的最高效的方式就是成本最低的方式，人们不断协调合作互动和相互调整过程，这个过程构成了我们的经济。 2.13 关于经济增长的初步思考 ​ 在人类历史的绝大部分，除了少数特权阶级，贫困是大部分人的生活常态，而大约300年前，欧亚大不了的西北角出现了经济的增长，少部分人是如何致富的呢？这是经济学研究的问题 2.14 寻找一种解释 究竟发生了什么？ ​ 分工是的各种产品能够成倍制造和数量激增。在井然有序的社会里，由于劳动产品极大丰富，以至可以提供到最下层人民。 ​ 马克思认为，一个以私有产权和盈利而生产为特征的社会具有一些深刻的缺陷，这些缺陷将会摧毁整个资本主义系统，但是他并不怀疑这样的社会确实具有创造财富的能力。 2.15 鼓励专业分工和交换的规则如何演进 ​ 尽管人类能够预见劳动分工将袋子普遍赋予，并设法通过劳动分工加以实现，但劳动分工带来的诸多利益并不是人类智慧的结果，是随着时间缓慢、逐渐演化而来的。 ​ 复杂的社会支付是长期演化而来，事先并无蓝图，金钱支付的演化过程与社会分工的演化过程一样：人们自发推进自己感兴趣的事业，并在这个过程中与其他人互动，这个互动自动催生了金钱系统。 ​ 一个国家从最低级的野蛮到最高的富裕状态，只需要和平、轻税赋以及一套合理的司法管理系统，剩下的部分都会自己完成。 ​ 这并不是说预见不重要，也不是说，政府没有对成功的经济系统发展做出贡献，亚当斯密主张：“井然有序的社会”中才能演化出广泛的专业分工，从而提高产出，实现”普遍的富裕“。 ​ 再谈第一章的重要概念，游戏规则以及经济学的最重要特点：界定清晰并受充分保护的产权。如果没有相对安全的产权，人们就不会为未来投资，不会启动任何有成本的事业。 ​ 成功的商业社会，必须满足2个比较条件，第一是相对安全的产权系统，第二是产权的自由交换 简要回顾 ​ 商品交换的本质是产权的交换，社会具有一个清晰的产权，社会产生的价格信息就能指引人们发现自己的比较优势，市场过程能够告诉大家可供选择的机会，有了这些信息，人们就能发现市场参与者创造收益的途径。 第三章 无处不在的替代品：需求的概念 建立”所有稀缺商品都有替代品“的论点 引入”选择都是在边际上做出“的概念 引入需求法则，并解释这个概念 清晰区分需求和去需求量的概念 研究使需求曲线移动的因素 指导需求的价格弹性，并运用这个概念 ​ 之前我们一直讨论取舍的问题，并且我们知道大部分商品都是稀缺商品，也就是说想要获取这些商品必须牺牲其他有价值的东西，现在我们深入讨论稀缺性，任何东西都存在替代品，我们要考虑如何比较不同替代品的预期额外成本与预期额外收益，也就是取舍。 3.1 关于”需要“这个词 ​ 需要并不是一个确定的词，会收到很多因素的影响，所谓需要也可以通过多种方式进行实现，而当我们选择A的方式，就会牺牲掉其他的方式 3.2 边际价值 ​ 当我们在日常生活中，钻石的价值比水的价值更高，当我们在沙漠里面的时候，水的价值比钻石的价值更好，我们的选择是在特定的背景下进行，我们的选择取决与我们面对环境。 ​ 牙缝里面卡住骨头的时候，一根牙签比一个鸡腿更有价值，当你想想上厕所的时候，卫生纸比《莎士比亚全集》更加有价值，价值完全取决于我们面对的情况。 ​ 在经济学上，起作用的价值是边际价值。边际收益和边际成本是决策过程中仅有的两个重要因素。 3.3 分叉路口：日常选择是边际选择 ​ 假设明天你就要进行期末开始，但是晚上9点你正要复习的时候，你的对象打电话给你希望你陪她打游戏，你拒绝的时候，她问你”考试比我还重要吗“？这时候你可以运用你的经济学思维告诉他，在此刻的边际价值上，考试比你重要。 ​ 经济学的思维否定非此即彼的决策方式，而要求我们关注边际收益和边际成本。这一规律适用于所有稀缺商品的优化过程。 3.4 需求曲线 ​ 人们面临各种取舍，为了多获得某样东西，就得少获得另一样东西，正是因为如此所以才有了”需求“的概念。 ​ 需求的概念把人们希望获得的东西的数量和必须付出的代价联系了起来。 ​ 当付出的的代价出现变化，人们希望获得的东西的数量也会随之发生变化 ​ 比如一个小镇上，当水费越贵，居民用的水也就会越少，具体用水与水的费用就呈现出一个关系 ​ 这样的需求就被称为需求曲线，需求曲线描绘了在所有给定价格下消费者计划购买的商品数量。 ​ 当水相对便宜的时候，人们会将水用于饮用、洗澡、烹饪、洗衣、草坪浇水、洗车，但是当水的价格变贵的时候，人们就会改变他们的计划，比如人们可能会降低洗车的频率、洗衣服的频率，水被用于”更重要“的场景，或者个体决策者眼中价值最高的用途。 ​ 他们判定把水用在某些方面不再值得，人们会选择替代方案，比如高压淋浴喷头，取消游泳池，这些都可以算作水的替代品。 3.5 需求法则 ​ 将其他条件保持不变，如果某种商品的价格上升，其需求量就会下降。同样，当其他条件保持不变，如果某个商品的价格下降，其需求量就会上升 ​ 需求法则：当其他条件不变的前提下，价格和需求量之间的关系是负相关的。 3.6 需求和需求量 ​ 需求和需求量并不是一种东西，我们常说的需求的的减少与增加，其实说的是需求量。 ​ 对任何一个商品的需求都不是一个具体的数量，需求永远是一种关系，这种关系将不同的价格下人们愿意购买的数量联系起来。 ​ 无论价格怎么变化，需求本身是不会变的，要想区分需求和需求量，最佳的方式是始终牢记需求这个词永远可以被替换称为需求曲线或者需求表。 3.7 需求本身也可以变化 ​ 对某种特定商品而言，如果商品的价格不变，但人们愿意购买的商品数量却发生了变化，那么这种商品的整体需求就发生了变化。 ​ 我们依旧以小镇居民对水的需求为例子，若是想整体需求提高，就必须发生某件事，比如当地出现了干旱，用水量可能就会上升，当地出现了水源污染，当地的用水量就会下降，这些都会导致需求曲线的上升或者下降，但是需求法则依旧成立，需求与价格依旧是反相关的关系。 3.8 所有东西都取决于其他东西 ​ 有些因素会导致商品需求发生变化，我们要分离并注意这些因素 消费者数量的变化，老年人增加会导致养老类产品需求的增加 消费者的品味和偏好的变化，追求健康的潮流会导致高脂肪视频需求的变化 收入的变化，经济繁荣的时候，去迪士尼玩的人会更多 ​ 消费者收入增加，某些商品的需求曲线开始右移，这是正常商品，如果消费者收入上升，对某种商品的需求反而下降，那么这种商品就是低档商品。 ​ 但是我们不要忘记，价值还是做出选择的人眼中的价值，这是非常动态的。 ​ 对经济学家而言，低档商品和正常商品的区别仅在与收入变化时消费者对这种商品的需求如何变化。 ​ 经济学的思维方式理解所有东西都是相互关联的，所有东西区取决于其他东西。 ​ 单一商品的价格本身没有意义，只有吧这种价格与选择者面对的大量其他商品和服务的价格进行对比，这种价格才有意义。 ​ 所以替代品价格的变化也是影响需求的因素 ​ 在其他条件不变的前提下，如果一个商品的价格上升，其替代品的需求也就会上升。 ​ 互补品的价格变化也会让需求曲线发生移动。 ​ 在其他条件不变的前提下，如果一种商品的价格上升，其互补品的需求就会下降，比如油价上升会导致燃油车的需求下降。 ​ 商品预期价格的变化会导致对这种商品的整体需求的变化，比如油价明天将会上涨，汽油的需求曲线将会右移，这个时刻，你对汽油需求增加了。 3.9 通货膨胀导致的误解 ​ 因为通货膨胀的存在，商品的价格发生了增加，但是需求曲线却并没有左移，这似乎并不符合需求曲线的定义，也就是价格与需求呈反比。 ​ 这是对通货膨胀的误解，通货膨胀是指商品的平均货币价格的增加，现在我们思考一个理想情况，如果人们的收入以及他们使用的所有其他商品的价格同时翻倍了，则所有商品的相对价格都没有发生变化，只是过去的金钱的实际价格变了，只有过去的一半。 ​ 通货膨胀是一个比较特殊的情况，日后我们会单独讨论。 3.10 时间站在我们这边 ​ 价格变化后人们的购买量也许没有太大变化，但是这仅限于价格刚刚变化的时候，有时候这种现象会让人认为价格对消费者没有影响，这是非常错误的结论，因为顾客需要调整的时间。人是习惯性东西，寻找任何东西的替代品都需要一定的时间。 3.11 需求的弹性 ​ 如果某种商品只要价格小幅变化，人们的购买量就会显著改变，那么我们就说对这个商品的需求是有弹性的。相对的，如果某种商品即使价格大幅度改变，需求也不怎么变化，我们就说这种商品的需求缺乏弹性。 ​ 需求的价格弹性精确定义如下：价格弹性等于需求量变化的百分比除以价格变化的百分比，因此，如果鸡蛋价格上升了10%，会使消费者的购买量下降5%，这鸡蛋需求的价格弹性就是5%除以10%，即0.5（忽略负数）。 1需求的价格弹性 = 需求量变化的百分比 / 价格变化的百分比 如果一个商品的价格弹性大于1.0，我们就认为这个需求有弹性 如果一个商品的价格弹性小于1.0，我们就会认为需求缺乏弹性 如果一个商品的价格弹性等于1.0，我们就会任务需求具有单一弹性 需求弹性受到三个因素的影响 时间，价格变化后，供人们调整的时间越长，需求的弹性越大 消费者获得已知替代品的难易程度以及已知替代品与原商品的接近程度，越容易知道替代品，或者替代品越多，弹性越高。 花在这个商品上的钱占总支出的比例，比例越小，需求弹性越低，比例越大，需求弹性越高，也会对价格的变化更加敏感。 3.12 对弹性的思考 ​ 即使盐的价格翻一倍，我还是会买同样数量的盐，因此所谓需求法则并不成立。实际上是因为这些商品 占总支出的比例很小，你没有动机成为一个小心挑剔的消费者。 ​ 盐的价格从5毛到1元，可能你没啥感觉，但是到5元、10元，开始占据较大比例的总支出的时候，你和很难不挑剔了。 ​ 相对于盐这样的刚需产品，汽车的价格弹性就高出了很多，因为替代品非常多。 3.13 弹性与总收入 ​ 如果大学的学费降低20%，大学收到的学会总数其实会上升。 ​ 如果价格变化后收入的变化方向与价格的方向相反，那么需求一定有弹性。 ​ 如果价格变化后总收入的变化方向与价格变化的方向相同，那么需求一定缺乏弹性 ​ 大学是否总能通过降低学费来改善财政呢？并不是的，虽然降低学费可以提高总收入，但是大学必须考虑总收入的提高是否大于总成本的提高。 ​ 另一方面，弹性和总收入的关系也让我们产生一个误解，提高售价可以多挣钱，但是价格的替身会导致商品的需求量下降，企业的总收入也会下降。 3.14 竖直需求曲线的迷思 ​ 需求曲线不可能在价格上完全没有弹性，也就是价格无论怎么变化，需求都不变，这就意味这这个东西没有替代品，在现实世界这是不可能的。 ​ 比如糖尿病患者对胰岛素的需求，这个看起来是没有替代品，因为这是糖尿病一个最好的解决方案，但是即使这样，他的需求弹性曲线也不是竖直的，因为随着价格的升高，人们会采用克制的生活方式、甚至祈祷来降低胰岛素的使用量。价格降低也会有更多人选择胰岛素。 3.15 需求应该扮演怎样的角色 ​ 到目前为止，我们一直把市场价格以及支付这种价格的意愿高低作为决定谁可以获得哪些稀缺商品和服务主要标准。 ​ 除了这个之外，我们现实生活中还有其他系统，而这是一个产权问题。 ​ 按需分配：但是这个评价标准过于含糊，容易被滥用。 ​ 先到先得：就像排队，人们都要花极长的时间，非常低效。 ​ 随机抽签：抽签似乎是一种公平的办法，但是也会让蛋糕小到失去价值 ​ 强权就是正义：稀缺商品属于配得上他的人，不管配得上的原因是什么，但是这样会让弱者没有任何资源，抢着必须浪费资源夺取他和捍卫他们的资源 ​ 论功行赏：就不需要界定什么是功绩，这个只能小范围达成。 ​ 而以上的系统还都忽略了供给的问题，生产者希望自己获得回报，生产者需要系统基于的鼓励。 ​ 现在的系统：鼓励资源以产权交换稀缺商品，并让愿意支付的边际价格最高的人获得稀缺商品。这样的系统会使得每个人都能根据自己的特定条件进行优化，从而扩大人们的自由和权利。 ​ 当某件商品价格上涨，消费者会自信优化，不需要有人来命令他们优化，也不需要经济学家们来告诉他们如何优化。从消费者的自身利益出发，优化是最佳的选择，即使他们从来没有听说过这个词。 ​ 需求让大家为了自己主动选择最优解，社会也达到了最优解的动态平衡。 3.16 金钱是唯一重要的因素吗？货币成本、其他成本和经济计算 ​ 需求的概念绝不说明金钱是人们唯一关心的东西。 ​ 当商品的成本商城，消费者就会少买，这并不意味着人们是自私的，相反经济学的思维方式指出：当某种行为的机会成本上升的时候，决策者就会较少的采取这种行动，当某种行为的机会成本下降的时候，决策者就会较多的采取这种行动 ​ 人们不是仅仅对预期收益的变化做出反应，他们会比较预期额外收益和预期额外成本，不管他们以何种方式度量成本 ​ 货币度量价格使得经济计算成为可能。 小结 需求法则：人们会自己优化自己的行为，不管什么商品，当价格下降的时候，人们就会多买，价格上升的时候，人们就会少买 需求曲线：需求与价格之间关系的曲线。 需求的价格弹性：需求量变化的百分比除以价格变化的百分比 价格弹性的敏感程度主要取决于商品占总支出的比例以及替代品价格的变化 需求曲线上升的影响因素 消费者数量增加 消费者品味和偏好改变 消费者收入上升 互补品的价格下降 替代品的价格商城 消费者预期这种商品未来会涨价 需要不代表一定要得到，需要到得到收到诸多因素的影响，毕竟价格，价格的上升会降低用户购买的欲望。 ps：为什么需求曲线中间的点的收入是最高的？暂时不知道怎么解释这种情况","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"经济学","slug":"经济学","permalink":"https://bluedancers.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"}]},{"title":"《经济学的思维方式》读书笔记4-6","slug":"阅读/《经济学的思维方式》读书笔记（4-6）","date":"2024-01-19T16:00:00.000Z","updated":"2024-03-25T08:14:54.912Z","comments":true,"path":"2024/01/20/阅读/《经济学的思维方式》读书笔记（4-6）/","link":"","permalink":"https://bluedancers.github.io/2024/01/20/%E9%98%85%E8%AF%BB/%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%884-6%EF%BC%89/","excerpt":"","text":"《经济学的思维方式》读书笔记4-6第四章：成本与选择：供给的概念 回顾机会成本的改变 机会成本是选择A这件事，就是去了做其他事情的成本，这个不仅受到选择本身的影响，还有替代品，组合品的影响。 区分沉没成本与边际成本。探索成本的一下性质：成本永远是行为的成本 沉没成本是已经出现的成本而边际成本是本次选择的成本，我们的判断不应该受到沉没成本的影响 确定机会成本如何影响供给决策，用生产可能性曲线推导供给曲线 机会成本越高，供给会越少，反之；生产可能性曲线会影响具体商品的供给曲线的斜率 解释能移动供给曲线的因素 成本、科技创新、竞品 分析供给的价格弹性 供给的价格弹性是供给量的变化除以价格的变化，大于1表示有弹性，小于0表示缺乏弹性。 ​ 激励机制鼓励生产者生产与供应稀缺商品，我们将讨论机会成本和市场价格如何塑造这种激励机制 4.1 回顾机会成本的概念 ​ 机会成本就是做出选择后，放弃其他选择的成本，这个在每个人身上都会做出不同的反应 4.2 成本是行为的成本，而不是东西的成本 ​ 成本不是东西的成本，成本永远与行为、决策、选择有关。 ​ 成本从来都不是客观的，当我们谈论成本的时候，成本永远都是对某人而言的成本。 ​ 主观成本等于某人赋予被放弃的机会的价值。 4.3 我们现在该怎么做？“沉没成本”的无关性 ​ 在考虑成本的时候，最常见的错误就是将此前已经产生的成本与边际成本该混。 ​ 做成本计算时不应该回望过期，因为过去的成本是沉没成本（不可能追回的成本）；正确的做法是向前看，看目前的机会成本。 ​ 假如你中午点了一个外卖，一共20元，吃的时候发现非常难吃，如果这时候你选择不吃，你的成本是什么？ ​ 其实并不是20元，因为20元已经不属于你，无论你吃完还是不吃完，20元都回不来了；这里我们就必须考虑边际成本，也就是获得外卖那一刻开始你新的行动可能带来的成本。 ​ 比如你选择不吃，你的边际成本就是浪费这些粮食，以及再买一份新的午餐，还有一些时间 ​ 如果你选择吃，你的边际成本就是自己的情绪，吃了会不开心，甚至下午会肚子疼，这都是这个决策的成本。 ​ 边际成本就是未来的成本。沉没成本已经无法追回，现在你已经站到了一个新的岔路口，新的岔路口：新的边际。 ​ 在经济学思维下，沉没成本只是过去的历史，因为他不代表未来的选择机会。沉没成本也许会导致苦涩与悔恨，但是不管有什么意义上看，它都不再是与现在的经济决策有关的成本，沉没成本只是一种信息，只是生命中的一个教训。 4.4 生产者的成本是机会成本 ​ 为什么低技术劳动力在印度工资那么低？因为在这个国家，大量能参加工作的潜在劳动者没有机会通过任何方式用自己的劳动力生产队他人更有价值的产品。 ​ 生产者生产的成本取决于他们获取必要的资源需要花多少钱 ​ 与供给决策有关的所有成本都是未来的成本，这些资源可以用于生产其他产品，生产的产品的机会成本等于被牺牲的次最佳机会的价值。 ​ 高技术工人比低技术工人更加有价值，是因为他的技术在别人更加有价值。 ​ 如果一个大企业来到某一个小郑，该地区的相关工作人员的成本都会提升，因为新企业进驻后可能会提供更好的机会，比如工资、福利、环境，医疗，旧企业用原本的机会就会难以留住员工，因为劳动者发现了别人有更加有价值的机会。 ​ 4.5 边际机会成本 ​ 机会成本就是边际成本，只是两个不同的描述角度 ​ 机会成本：为采取某一行为而放弃的其他机会的价值 ​ 边际成本：关注为采取某一行为会对目前的产生的影响 做决策的时候应该考虑的成本只有一种，这种成本的全名是边际机会成本 ​ 4.6 成本与供给 在决定生产什么、生产多少的时候，生产者会考虑生产的边际成本 当生产者判断各种生产计划的边际成本和边际收益时，相对价格为他们提供了进一步的信息 供给曲线描绘的是在不同产量上供应某种商品的边际机会成本，同时生产者也跟从需求法则的体现 4.7 供给曲线 4.8 供给曲线本身也可以变化 生产要素价格上升，导致单位产量的机会成本增加，曲线向上。 成本下降，或者技术创新导致成本下降，曲线向下。 其他商品的变化也会影响统计曲线，比如竞品价格降低了一半，则当前商品的收益会提升一半，供给曲线会下降50%。 生产者预期商品价格未来会变价，产品的总体供给也会随之变价 6个月后降价，则意味着该商品相对未来成本增加，则会增加当前市场投放量 6个月后涨价，则意味着该商品相对未来成本降低，则会减少当前市场投放量 ​ 最后，生产者总数变化，供给曲线也会变化，如果有更多的竞争者进入市场，供给通常会提升，如果竞争者退出市场，供给就会下降，一般来说，预期利润越高，进入市场的供应者越多，市场供给就会提升；预期利润月底，退出市场的供应者就会越多，市场供给就会下降。 4.9 边际成本与平均成本 假设生产一个单位玉米的成本是失去1.1美元的其他农作物，让我们看看生产0、1、2、3单位的总成本、边际成本、平均成本的差异 玉米产量 总成本 边际成本 平均成本 0 0 0 0 1 1 1 1 2 2.1 1.1 1.05 3 3.3 1.2 1.1 每个单位预期生产成本是否小于每个单位商品的预期售价，其实这里的预期成本指的就是边际成本 不论商人是否用平均概念考虑问题，知道决策的仍然是预期边际成本。 平均成本只是历史（历史具备参考意义），而做经济决策时永远应该立足当下、着眼未来。 4.10 志愿兵役制度的成本 ​ 在20世纪90年代，这是一段经济繁荣时期，美国军队在招募新兵和延长老兵的时间方面面临困难，自愿入伍的人越来越少，强制征兵制的呼声越来越高。 ​ 对于潜在入伍的年轻人而言，入伍的成本究竟是多少？这个并没有一个具体的值，而是看每个人放弃其他就业机会以及各种其他价值的成本。 ​ 如果想要在经济繁荣时期自愿参军的人更多，就需要不断提高军事人员的工资，直到工资水平正好能够吸引政府需要的入伍人数。 ​ 也就是说年薪与志愿兵的数量是存在正相关的关系的。 ​ 如果为了召集到指定人数的人，而多付了钱，那么多付的钱就是政府的财富转移。 ​ 如果强制征兵，是否可以降低自愿参军支付下的成本呢？答案是不能，因为强制征兵非自愿的，如果某个人每年的工资是2.4w美元，但是入伍只能拿到0.9美元，则参军者需要承担1.5w美元的成本，强制征兵支付没有降低组建军队的成本，只是把纳税人的成本转嫁给了入伍者。 ​ 爱国情绪越高涨，能吸引人们自愿入伍的货币工资就越低，因为爱国也是人的一种精神上的价值。 4.11 供给的价格弹性 ​ 供给的价格弹性 &#x3D; 供给量变化的百分比 &#x2F; 价格变化的百分比 ​ 在供给中，价格和供给量朝同一个方向变化，只有提高商品的价格，才能诱使生产者提高商品的供应量 ​ 供给具备弹性：供给量变化的百分比大于价格变化的百分比 ​ 供给缺乏弹性：供给量变化的百分比小于价格变化的百分比 ​ 4.12 用成本论证正当性 ​ 针对成本的经济分析是比较复杂的，因为成本不仅有经济上的意义，还有道德和政治上的意义。 ​ 很多人都相信卖家有权收回成本，但是无权把价格订的显著高于成本，如果卖家的价格过高或者过低，几乎可以肯定卖家在谋求某种不正当的利益。 ​ 有些人认为，需求应该与成本关联，其实这个想法是错误，举个例子取暖用的燃气涨价，这就应该允许房东提高房租，但是如果是因为住房的需求增加而涨房租，则被认为是一种投机倒把行为。 ​ 但是租房需求的上升和燃气涨价其实都与成本有关，因为租房的人多了，房子就变的稀缺，人们就会为了争夺有限的房源而竞价，所以房东为了利益最大话，就可以选择出价最高的那个人，就像燃气的使用者也会竞价，燃气使用的人多了，燃气也会涨价。 ​ 成本永远是由需求与供给共同决定的，成本永远不可能独立于需求存在 简要回顾 人们之所以对不同决策的成本有争议，通常是因为他们谈的是此决策对不同人的成本 过去的支出都是沉没成本，做决策时不应考虑这些成本，做决策只应该考虑未来的成本，因为目前的决策不会影响过去已经发生过的事情。 供给取决于成本，但是供应某种商品的成本是为了供应这种商品而牺牲的其他机会的价值。 人们常常对某件东西的“真实”成本有争议，实际上东西是没有成本的，只有行为才意味着牺牲某种机会，因此只有行为才有成本。 谈论成本时，永远不要忘记问自己“对谁而言的成本”，“干什么的成本”。想经济学家一样思考。 书中供给曲线的计算这一块没看懂，因为书中的供给曲线没有斜率，这就意味着任何一段xy轴的变化比例都是一样的，算出来的价格弹性也都是一样的。 第五章 供给与需求：一种协调过程 生产一种商品需要数百万人的合作，描述市场过程如何协调是他们的计划 市场通过价格作为信号协调每个环节的供给与售卖 用供给与需求模型分析市场 供给和需求两个因素去影响价格 区分短缺现象与过剩现象，解释自由市场价格如何调整使市场出清 短缺的时候，需求不足，价格提升，过剩的时候，需求过剩，价格下降，本质上还是通过价格这个信号。 描述自由市场价格如何传递信息 价格反映了市场对于某种商品或者服务的相对稀缺程度 解释金钱如何降低交易成本 金钱是物品与物品之间交易的纽带，方便携带，颗粒度低，从而达到降低交易成本的目的。 分析利率在协调经济活动的过程中扮演怎样的角色 利率增加，存款增加，贷款减少，抑制经济过热，利率减少，存款意愿降低，贷款意愿增加，增长经济热度。 ​ 按照亚当.斯密对分工的理解：如果一个社会的成员能够高效的将工作专业化，这个社会就会富裕起来。 ​ 而在一个富裕、高度专业化的商业社会中，人们享有的商品和服务丰富到不可思议，人们必须相互协作、采取大量相互关联的行为才可能生产出这些商品和服务。 ​ 商业社会究竟是如何鼓励其他人采取行动的呢？ ​ 这个过程里面最基本的问题就是人们知道的太少，任何一个专家不可能知道所有事情，信息和知识对每个人都是稀奇的，也就是说：我们确实具备一些技术和能力，但是同时他们对无数其他技术与能力一无所知。 ​ 哪怕是最普通的2B铅笔，这个世界上也找不到一个人知道怎么从头到尾的制造出来。 ​ 一个人也许知道制作怎么组装一支铅笔，但是会组装的人并不知道如何生成原谅，如何运输，这是其他无数专家发挥自己的比较优势，贡献自己有限的知识与技术，才形成的结果，这些人可能相互不认识，甚至不是一个信仰，不是一个语言，但是却能协调在一起，生产出2b铅笔。 ​ 有人说市场是一个奇迹，这个形容非常恰当。在市场中，数百万人互不相识，却能相互合作。他们不仅合作生产出了2B铅笔，还合作生产出了无数比2B铅笔复杂的多的商品，并且让消费者能够轻松、足量的获取这些商品。这一些并不是政府的规划，而是确定整体的游戏规则。 ​ 市场的有序性看起来想一个奇迹，但事实上并不是神秘的，在商业社会中，人们如何将多种多样的生产计划和消费计划协调在一起，这个过程中，关键信号是价格。价格为数亿人提供重要的信息与信号。 ​ 在本章，我们把需求与供给放在一起，描述市场过程本身的原理。 5.1 市场是计划协调的过程 ​ 很多人把“市场”理解为地点或者集市，这是非常不经济学的思考方式，市场是跨越地区，遍布全球，甚至延伸到宇宙。 ​ 记者和金融人士用各种各样的比喻描述市场，这个比喻常常将市场拟人化，比如市场很经常或者兴奋 ​ 市场系统并不是自动的，也不是自我调整的，而是收到人类干预的，市场也不是一个人，不是一个地方，也不是一个东西，市场是一个过程，买家与卖家通过它协调双方的计划。 5.2 基本过程 ​ 注意供给曲线与需求曲线的交点，这是市场达到完全协调的点，在这个店，生产不会过剩。 ​ 假设市场价格高于500，是700元，此时供给开始提升，但是由于价格的增加，需求量开始下降，商品的供应量大于需求量，就会出现过剩的现象，在市场经济中面对过剩的商品最简单的办法，就是降低商品的售价。 ​ 假设市场价低于500元，是300元，需求就是1200，但是生产者仅仅计划生产800个，这就会导致很多消费者买不到产品，出现了短缺的现象，来不到怎么办？只能提高售价去与其他消费者进行竞争，而面对价格的替身，生产这也会生产更多产品 ​ 无论是以上那种情况，市场最后都趋向于完全协调点。 ​ 5.3 竞争、合作和市场出清 ​ 有一种关心思维，市场经济中卖家与买家是竞争关系，因为一个大家的诉求是对立的，但是资源购买是买家与买家之间互惠交易的本质，你们双方最终是最远的达成了合作。 ​ 在整个市场过程中，竞争与合作一样无处不在，但是竞争双方并不是卖家与买家，，买家通常与买家竞争，卖家通常与卖家竞争；买家与卖家相互合作。 ​ 商品短缺价格升高的时候，卖家将商品与出价最高的买家交换，这是买家与买家的竞争。 ​ 商品过剩价格下降的时候，买家与出价最低的买家交换，这是卖家与卖家的竞争。 ​ 在我们上一节内容我们可以看出，商品短缺价格提升，商品过剩价格下降，最后会走向完全协调点，竞价过剩自动终止。 ​ 此时的时候价格，被称为“均衡价格”，也被称为“市场出清价格”。 ​ 市场出清是指市场上不再出现短缺与过剩的现象，买家的消费计划与卖家的生产计划完全协调。 ​ 任何自由市或者服务市场都具有出清的倾向。 ​ 这里的市场出清并不是并不是政府或者经济学家的干预，而是每个人都做出了对自己最有利的选择，大家相互竞争与合作，最终形成了市场出清的“意外之果”。 5.4 市场情况的变化 ​ 我们之前的讨论都是建立在供给曲线与需求曲线不变的情况下，市场出清的情况，现在我们考虑一下需求或者供给曲线本身移动，会产生什么影响 ​ 假设因为上游原料成本的下降，供给的边际机会成本开始下降，这会导致生产该商品的人变多，最终让生产曲线向下移动，如果这时候还是原来的价格500元，需求就会过剩，所以卖家只能通过降低售价的方式相互竞争，最终形成新的市场出清价格，400元。 ​ 再让我考虑一个例子，因为某些原因，某些商品的需求开始增加了，这将会导致原本价格500元下，商品会脱销，买家与买家竞争，此时需求曲线开始上移，最终形成新的市场出清价格，600元。 5.5 从自由市场价格中获取信息 ​ 没有人会把天冷怪到温度计身上，也没有人真的认为用蜡烛烤温度计就能在冷天让整个房间暖和起来。这是因为人们对气候的变化的原有有先天正确的理解。然后，在某种商品稀缺的时候，人们却责怪价格太高，他们似乎认为只要执行价格管控就能解决商品稀缺的问题。 ​ 稀缺性是购买意愿和供应水平之间的关系，或者说是需求与供给之间的关系。 ​ 稀少与稀缺是两个截然不同的概念，商品是否稀少与消费者的购买意愿无关，比如我在纸上写一个签名，全世界只有一个，非常稀少，同样的周杰伦有2000个签名，但是我的签名的价值一文不值，而周杰伦的签名值1000元，这是因为周杰伦的签名是更加稀缺的，稀缺的原因是远大于供给的需求。 ​ 面对稀缺商品的时候，人们必须建立某种挑选过程或者标准，以决定在想要这种商品的人中谁可以获得多少。 ​ 挑选的标准可以是任何东西，年龄、学历，金钱，才华，颜值，商业社会消费能力是最常见的挑选标准，在其他场合也存在其他标准， ​ 比如哈佛大学每年的申请人数远大于招生名额，哈佛大学会通过成绩、分数、推荐信等等因素去决定录取哪些学生。 ​ 或者很多女孩子想和肖战谈恋爱，他的挑选标准可能是颜值，智力、温柔程度。 ​ 要想在上述竞争中胜出，就需要相互竞争，而这些标准就是竞争的信号。 ​ 竞争的根源是稀缺性，要想彻底消灭竞争，只有彻底的消灭稀缺性。只要决定“谁获得什么”的标准还存在，人们就会努力达到这些标准，竞争随之发生。 ​ 不同标准的竞争，对结果会造成很大的影响，比如社会用支付意愿的高度来协调经济计划，同时作为竞争标准，社会成员遵守这样的规则，就会努力赚钱，如果是体能，就会全民健身，如果是美貌，大家就会全民整容。 ​ 就像中国高考是以考试分数作为标准，优质的大学的招收名额是稀缺的，高中生就需要在考试分数上展开竞争，但是这就仅仅是这一个考试这一个场景的竞争标准，并不是人生。 5.6 计划经济与知识问题 ​ 要想让大量素不相识的个人有效协调他们的加护，交易条件必须清楚、简单、标准化，只有这样的才能保持低廉的交易成本。 ​ 在计划经济中，所有的生产资料都不是私有的，而是由整个社会共有的。一小群专家有权决定这些稀缺商品的最佳用途，这些专家包括，经济专家、社会专家、化学家等，这些人组成一个中央计划委员会，决定生产什么、如何生产以及为谁生产。整个社会经济的运营方式就像一个巨大的国有邮局。市场被废止，金钱也被废止。 ​ 而人们需要种类繁多的商品和服务，中央计划者必须有力、高效的生产和分配这些商品和服务。 ​ 他们靠何种信息来完成上述工作呢？毕竟，具体的生产计划掌握在委员会手上，他们也是根据信息来决定生产什么、如何生产，生产多少。 ​ 比如使用黄金只做公共汽车，在市场经济下，这不会这么做，因为这么做根本没有利润。这些资源的市场价格以及人们愿意为最终产品支付的价格帮助生产者认识到这么做会导致亏损，市场经济下的生产者在生产之前就认识到了这一点。 ​ 但是竞价经济废除了市场过程，计划者能获取什么信号呢？也许是大量工程原理、公式、劳动力，复杂的数据系统，这些数据从经济学角度来说是没用的，这些数据不体现商品的稀缺，这样如何又如何确定商品究竟该制作多少呢？又如何确定不制作商品A，制作商品B是否更加满足大家的需求？ ​ 计划经济废除了经济计算及其提供的信息。 ​ 即使中央经济计划者智慧高超、一心为民，他们也不可能有效管理商业社会的日常运营，因为他们无法完全获取与处理必要的信息。所以问题不在于如何让更加聪明的人通过计划去帮我们实现经济增长，而是如何通过更高效的制度和游戏规则鼓励人们自己发现比较优势，并让每个人将自己有限的知识、信息、资源用在最高效的地方。 ​ 粮食烂在地里面一定是浪费吗？其实不一定，因为如果粮食运到消费者手中的成本高于粮食的价值，那么让粮食烂在地里显然更加值。 ​ 5.7 产权与制度 ​ 在一个允许产权所有者自由交换产权的系统中，有能力高效利用资源的人会快速以低成本获得必要的资源。 ​ 成熟的产权系统下，产权被清晰的界定，人们可以根据自己的选择高度自由的交换产权，人们较频繁或者规律地进行的交易都能因此保持较低的交易成本。 ​ 市场参与者一直努力较低他们希望参与的交易成本，上述网络再此过程中逐渐演化而来，最终自发的形成了专业化的分工。 延伸思考：货币和利息的协调角色 ​ 为什么市场系统中几乎所有交易都是为了交换货币而发生？ ​ 钱可以降低交易成本，货币是交换的通用媒介，在只能以物换物的经济系统中，人们需要花费大量的时间寻找他们愿意交易的对象，这会导致生产者没有时间再去生产。最终会导致人们倾向于生产自己所需要的东西 ​ 货币的另一个优势是，交易的报价非常灵活，在以物换物的经济体中，一个鸡可以换20个玉米，但是我只想要一个玉米，不能给他一小部分鸡，而钱可以毫不费力的多买一点少买一点，也就是调整货币价格。 ​ 调价能力是商业社会达成协作的关键要素，当商品和服务的货币价格上下浮动，人们会做出相应的反应，人们相互配合实际上是因为商品和服务的货币价格不断发出变化的型号，人们根据这些型号协调自己的行为。 ​ 虽然货币在社会运作中发挥了至关重要的作用，但是这与共鸣的品格或道德毫无关系，人们关注货币价格，是因为他们想尽量让自己手上的资源换取更多有价值的东西，货币及价格帮助生产者计算预期成本与预期收益，这种关注价格的自利（自利不是自私）行为，最终变成合作行为。 货币与利息 ​ 借贷意味着获取我们尚未获得的购买力。 ​ 为什么你愿意支付学生贷款的利息，因为你认为现在的逆利息相对学习带来的未来的机会，成本更低，只要借贷的预期收益高于利息，借贷就是合理的。 时间偏好 ​ 现在的商品和未来的商品价值不一样，人们一般喜欢正的时间偏好率：相比于遥远的享受，我们通常认为现在的享受价值更高。 ​ 比如现在你有一张100元的支票，但是3个月后才能兑换，你就会略感失望，但是如果3个月后可以兑换150，你又不会觉得难过，则你的时间偏好率是25%。 储蓄创造了借贷的机会 ​ 借方支付利息，是为了诱使贷方放弃现在享受商品的机会 ​ 银行承诺向储户支付一定的利息汇报，接着银行再将这些美元借给借款者，收取高于支付给储户的利息，这个利息差就是银行潜在的获利机会。 ​ 这个也是符合供给曲线+需求曲线的，利率越高，供给越多、利率越低，需求越大 ​ 借贷的需求量增加，需求曲线上移，银行也会给供给方更多的利息，如果市场借款需求少，需求曲线下降，则利率下降，供给也开始减少， ​ 当供给曲线与需求曲线相交的时候，就产生了市场利率。 利率中的风险因素 ​ 市场反应了时间偏好率，市场利率还包含大小不一的风险溢价，比如信用好的客服支付贷款利率降低，信用较差的用户贷款支付利率较高，这里的溢价利润可以被认为是一种保证金。 实际利率与名义利率 ​ 贷方预见货币未来的购买力会下降，因此为了保持盈利要求，就需要额外考虑通货膨胀的影响，比如原本打算收取3%的利率，但是未来1年会通货膨胀2%，则应当收取5%的利息。 ​ 实际利率 &#x3D; 名义利率 - 通货膨胀率 第六章 意外之果：供给与需求的更多应用 区分行动计划导致的有意之果和意外之果 探索规则如何塑造激励机制，以及激励机制如何影响供给和需求决策 分析和解释价格管控如何使商品短缺或过剩 论证”生产成本通常由价格决定“ 不懂经济学的人会错误的使用供给和需求分析并做出错误的预测，举出一些这样的例子。 ​ 这一章，我们探索一些新的主题，比如价格管控、禁酒令和禁毒令、当代奴隶贸易以及关于成本与价格的偏见。 6.1 灾难中的困惑 ​ 当自然灾难来临的时候，我们常常看见偷窃、抢劫以及其他暴行增多，这不是合作破裂的案例吗？但是这并不是说明市场交换过程失效了，仅仅代表人们冲动的拒绝遵守现行的游戏规则和产权规则 6.2 灾难中的协调 ​ 在自由市场经济体系中，每个人都试图推进国自己的项目，市场出清或者系统化的计划协调是上述行为的意外之果。 ​ 如果一个地方即将发生风暴，那么胶合板的数量将会大大增加，在供给不变的情况下，需求曲线上移，也许还有敏锐的商人选择撤走部分货源，这样供给也会部分减少。 ​ 如果说价格是被贪婪的浪潮推高的，那么买房并不比卖方无辜。 ​ 不懂经济学的人和批评家会说这种涨价行为是”趁火打劫“。这里到底是谁打劫了谁，其实是消费者自己，消费者的竞争者永远是消费者，消费者与商家是互利关系。 ​ 物价飙升说明市场过程正在发挥作用：需求的上升和供给的下降共同导致价格的上涨，商品相对稀缺程度更高了。 ​ 价格升高并非是坏事，这方双方能够继续协调计划，无论是在产品调度，还是原料生产商，更高的价格带来更多的供给，市场鼓励人们采取适当的行动，让他们看起来仿佛在为国家出力，最终随着供给的不断增加，生产曲线开始向右移动，出清价格不断下降。 ​ 将涨价现象认为是”趁火打劫“的批评家不仅没有准确理解这个词的意思，也没有理解市场机制传达的信息和提供的激励机制。 ​ 如果政府长期严格的执行哄抬物价的手段，协调的责任将会落在政府机构身上。 ​ 6.3 解决价格问题的冲动 ​ 虽然说上述协调让大家公共解决了问题，但是其过程中依旧存在物价飙升的问题，我们能否通过价格管控的措施去改变游戏规则，禁止人们以超过上限的价格买卖汽油呢？ ​ 我们首先要面对一个问题，卖多少价格才算公平？以及到底对谁公平？我们价格是倾向于用户，然后定价2美元，法律不允许每升汽油超过2美元； ​ 然后这也会导致另一个问题 ​ 原本市场的出清价格是4美元，供需达成一致，现在变成2美元够，需求增加了到了1200，但是供给却下降到了2，市场每天都会缺少2的汽油。 ​ 这样的情况人下，消费者可能会更多的驾车出行，购买大排量汽车，但是卖方的收入和利润都会下降，面对这样的情况他们不得不做出优化，减产；这个计划是不可能实现的。 ​ 6.4 价格锁定时的竞争 ​ 如果卖方和买方都不能提价，他们如何解决商品短缺问题？面对稀缺商品，必然是存在某种分配标准的，所以我们我们还要看到购买汽油的非货币成本的上升，这个非货币成本可能是某种规则，也可能是自然演化而来。 ​ ​ 比如加油站排起长队，也许就是非货币成本的最佳例子，在限价措施下，让你们发现自己并不能想买多少就卖多少，他们只能赶在汽油售空之间赶到加油站，消费者与消费者开始竞争。 ​ 当然还有一些其他手段，比如雇人买油，走后门交易，为加油工付小费，购买加油站的增值服务，这些做法都会提高汽油的成本，直到需求量降至供应量。 ​ 经济学家认为短缺现象的核心是货币价格。当需求方相互竞争的时候，货币价格应发挥分配稀缺商品的功能；只有当货币价格无法发挥功能时，才会出现商品短缺现象。在现实生活中，每当获取某种稀缺商品或服务的非货币成本上升，我们都会观察到短缺现象。稀缺是不可避免的，但只要允许价格浮动就能避免短缺现象。 6.5 恰当的信号与不恰当的信号 ​ 当一个商品明显短缺，但是法律不允许涨价的时候，供应方会怎么做呢？他们通常会寻找其他方式从当前局面中获利，比如缩短营业实现，如果2小时就可以卖完，又何必买8个小时呢？而最终都会进一步增加买房购买汽油的成本。 ​ 作为供应商，因为商品的稀缺性，需求的主导权就发生了变化，又为您服务，变成为我服务。 ​ 原本我们是为消费者考虑，最终却让消费者承担了更多、更复杂的成本。 ​ 我们的社会和经济系统高度复杂、相互依存，不断变化的货币价格保证其中的协作能有效的发生，我们对这种信号极度依赖。当商品的相对稀缺程度改变的时候，如果不允许物价发送相关信号，供给方和需求方就会收不到恰当的信号，最终变得无序混乱。 ​ 6.6 想在城里找间公寓？去看讣告栏吧 纽约市出租公寓一直短缺，这并不是因为市场失灵，而是存在房租管控制度 因为房租管控的存在，寻找一间出租房的非货币成本极高，阅读讣告就是成本之一 随着出租房需求的是增加，同一间房的租金增加了200美元，人们对此表达不满。 租房的供给曲线比较特殊，其供给曲线是0，短时间内不存在供给数量的变化 增加了房租管控之后，需求量增加到了1000，这将会让250人租不到房子。 公寓还是一样稀缺，当租金无法达到需求量等于供给量的水平，就一定会出现价格以外的其他分配标准，比如性别、年龄、人种，抱有歧视的房东将会更多。 有限的收益以及紧缺的房源，让房东没有维护公寓的动力，甚至会不断恶化，退掉公寓改成停车场或者办公楼，供给进一步减少。 租房管控本来是帮助租客，结果却让他们可以租到的公寓越来越少了。 6.7 烈酒和烈性毒品：犯罪的激励机制 ​ 在美国20年代，出现过禁酒令，这里出现了一些有趣的现象 黑市的高度烈酒流通的更多多，啤酒葡萄酒的产量锐减，是因为人们爱喝高度酒吗？ 芝加哥街头，烈酒的制造商与经销商经常发生野蛮暴力的冲突，为什么做生意会打架呢？ ​ 首先，禁酒令并非摧毁了酒类的供给与需求过程，而是将其定义为非法行为，人们只能通过地下的方式协调自己的活动，所以禁酒令实施后，酒类的生产开始被黑帮、犯罪分子控制。 ​ 禁酒令的出现让酒的供给大幅下滑，但是需求却没有明显降低，这导致了需求曲线左移，酒类价格飙升。 ​ 酒类的生产与分销转移到地下后，在犯罪领域具有比较优势的人成为行业内的佼佼者，他们的游戏规则更加没有下限。 ​ 关于酒类的生产，如果运一车啤酒的风险与运送一车烈酒被抓的概率一样，为什么不做收益更大的事情呢？这导致地下市场上高度酒非常普遍，低度的酒精饮料非常少见，这并非消费者的需求偏好。 ​ 禁酒令的初衷是希望整个社会更加稳定，但是最终却导致黑帮的快速崛起，警匪一家亲整个社会的安全系数下降，大批工人失业，更多的人酒精中毒。 ​ 以上情况的出现，并非市场的失灵，恰恰相反，即使在非法领域，市场依旧表现出惊人的顽强。最只能说是政府的失灵，因为政府没能有效的指定自己指定的游戏规则。 6.8 脱脂奶、全脂奶和牛奶黑帮 ​ 如果不是酒，而是牛奶，也会形成以上场景，更贵的全脂牛奶将会占据地下市场，黑帮会挤走在牛奶行业兢兢业业工作多年的好人。 6.9 价格下限与商品过剩 ​ 通过上述的一些思考，我们知道了","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"经济学","slug":"经济学","permalink":"https://bluedancers.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"}]},{"title":"《如何避免孤独终老》读书笔记","slug":"阅读/如何避免孤独终老","date":"2024-01-03T16:00:00.000Z","updated":"2024-01-04T07:17:07.354Z","comments":true,"path":"2024/01/04/阅读/如何避免孤独终老/","link":"","permalink":"https://bluedancers.github.io/2024/01/04/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AD%A4%E7%8B%AC%E7%BB%88%E8%80%81/","excerpt":"","text":"第一部分为什么现在谈恋爱比以前更难了 我们的身份开始完全由自己决定，而不是上一辈安排 互联网的出现，大大增加了人与人交流的机会，也有了太多选择，这反而导致我们难以选择。 我们都渴望确定性，选择太多导致了大家都不稳定，这不利于感情的建立 社交媒体造成了攀比与绝望，信息的茧房与误导性，会导致人们错误的认知 亲密关系中，我们缺少扮演，我们的上一代自由恋爱不多，很多都是为了生存，我们不知道如何成为亲密的人之间是什么样子的。 在亲密关系中，需要考虑的太多，因为这个世界太自由了 为了做出正确的选择，我们压力都很大 婚恋倾向浪漫主义倾向 期待找到灵魂伴侣 对另一半过于具体与不缺实际的幻想 相信爱情是充满故事性的 对爱情抱有不切实际的幻想 完美主义倾向 不远降低自己的标准 过于理性的去看待爱情，喜欢对比与研究 对对方抱有不缺实际的幻想 自我怀疑倾向 自己没有成为理想的自己 自己还有很多不足 对自己抱有不切实际的幻想 浪漫主义倾向的解决办法 放弃幻想，任何人都有他的缺点，白马王子也会早上口臭，大家都是普通人类 从此以后过上幸福的生活，是一个错误的幻想 爱情的邂逅需要自己主动去寻找，电视剧里面都是骗人的 亲密关系从来没有一帆风顺，都需要人们去可以维护的 敞开心扉，接受一份与你想象的完全不同的爱情 并不是降低标准，而是白马王子是不存在的 完美主义倾向的解决办法 不仅害怕错过，也害怕选错 我们的大脑会自己说服自己，自身合理化 知足常乐者并不是要求低，而是找到了期望的之后，就不在考虑其他选项 如果一个人的婚姻时间是18-40，按照37%法则，那么在26岁的时候，就可以结合之前的经验做出判断了，当我们有足够的数据，则不需要做更多的研究了 送给自己一份知足常乐的礼物吧！ 自我怀疑倾向的解决办法 自我苛求者被恐惧束缚了手脚 不进行行动的自我怀疑成本极高，也会失去学习的机会 每个人都会犯错，最好现在就犯错 设定明确的目标，比如一个月最少认识一位异性 做自己拉拉队长，对自己进行鼓励 一旦决定某件事，你的大脑就会开始不断的合理化。 依恋类型 焦虑型 安全型 回避型 体现在婴儿身上 焦虑型是妈妈离开后会哭泣，回来后，会停止哭泣，但是随后又会愤怒，再次哭泣 安全型是妈妈离开后会哭泣，回来就会停止哭泣，安心玩耍 回避型是妈妈离开后，反应很淡，虽然心跳会加速，但是不会进行表现 体现在成年人身上焦虑型 一刻不停的想念自己的伴侣 会对感情抱有不安全感，阶段性怀疑，它还爱我吗 可能会做出一些过激行为 回避型 觉得不能依赖他人 总是避免和人走的太近，对亲密关系有点抵触 总是会仔细琢磨另一半不好的地方，然后设法离开，幻想单身或者换个人更好 自我评价一下自己，50%的安全、35%的焦虑，15%的回避 寻找终生伴侣而不是舞伴 出去约会到底是为了短暂的快乐，还是长久的亲密关系？ 在爱情上，我们容易过于重视当前的感觉，而忽略了未来的价值，我们实际寻找的是终生伴侣 有意识的摆脱寻找舞伴的思维 没那么重要人们总是会将正在思考的事情认为成更加重要，也就是聚焦错觉 金钱 从金钱中获得的快乐不取决于金钱的多少，而是取决于你周围人多有钱 在亲密关系中考虑这个没错，但是财富不是最重要的 长相 人们看重长相有历史上的进化原因，在现代社会的加持下，这不是大问题 当你习惯了他的长相，或者随着时间的推移，迷恋都会随之消失 不要将长相放在其他更加重要的事情前面 相似的性格 你真的愿意和自己谈恋爱吗 科学研究证明，相似的性格并不意味着亲密关系一定会成功 可以试试互补的人，未来会更加有趣 共同的爱好 没必要一定共同爱好，只要给彼此留出足够的空间与自由 各自探索，对一个未来更好 更加重要的情绪稳定，心地善良 夫妻情绪都稳定，婚姻美满的概念就会大大提升 心地善良的人会最好的伴侣，愿意成为另一半的后盾 忠诚 人生不仅仅是共享荣华富贵，也是共担患难 成长型心态 成长型心态相信，可以通过后天提升自己的智力与技能 一个成长型心态的人更会认真努力 能否激发出你好的一面 要一起变得越来越好，而不是数落与打击 和他理解的开始，是否会觉得无聊，泄气，还是快乐，充满渴望 懂得合理争吵 吵架不是坏事，不要将不满憋在心里 需要人认识到亲密关系中大约有69%的事情是无法解决的 理性表达、采取行动、多加欣赏 目标是合理争吵，而不是避免争吵 很一起做出艰难决定的人 面对困境，能否一起做出合理的解决方案 是否一个乐于领导，一个乐于服从 事情出现了差错，你是否会责怪另一半 一段亲密关系成功的关键：一个人的情绪是否稳定，是否善良、忠诚，以及和这个人在一起的时候，我们感觉如何。 把舞伴留在舞台，寻找长期伴侣吧！ 第二部分你其实并不知道自己想要什么社交媒体上你并不知道自己想要什么 我们过于关注可量化的数字，但是这个常常不是重点 我们错误的使用自己想要的数据把潜在对象过滤掉了 交友软件催生了 购物式恋爱，而不是显示生活的渐进式恋爱，将活生生的人变成了被搜索到商品 交友软件太多的选择，反而让我们约会这件事变得更加困难 放开交友软件中的过滤条件 寻找接受对方的理由，而不是寻找缺点，很多人比档案里面表现的要有趣的多 如何利用社交媒体 挑选几张好照片 抓拍的照片比摆拍的更好 要准确、实际的描述自己，而不是理想中的自己 要写的具体，别人才有兴趣和你交谈，具体喜欢什么电影，具体爱做什么菜 关注自己喜欢什么，而不是不喜欢什么 构思一个巧妙的开场白 尽快进入正题，也就是面对面交流，因为聊的太多，反而不是好事情 现实生活中参加活动 多多参加社交活动，朋友需要自己主动去寻找 可以参考活动决策矩阵 和他人互动多机会有多大 玩的开心的机会有多大 朋友与家人的介绍 开口让别人给你介绍对象，并告诉他们你要找人生伴侣而不是舞伴 同时给你的好朋友发几张照片 要接受朋友们的安排，这都是他费心介绍的 给朋友反馈 为这件事提供奖励 考虑已经认识的人出门在外，勇敢的介绍自己 主动才有缘份，注意分寸就行 如何更好的约会 约会的环境很重要，人们是非常受环境影响的 避免评估式约会，应该体验式约会，多问自己感觉如何，而不是看条件 学会不是工作，不是求职 首次约会的目的并不是结婚，而是是否可以引起对方的好奇心 约会的心态很重要，消极的心态带来消极的结果，积极的心态带来积极的结果，期待会带来快乐 约会前和最好朋友聊聊天，让自己充满自信也更加更讨喜 约会前听听喜剧，保持好心情 做一些简单运动，释放内啡肽 洗个香香的热水澡 不要迷恋一见钟情 一见钟情往往会蒙蔽我们的双眼，一见钟情不代表两个人就合适 一见钟情不是好事，这只能证明一个人有迷人或者自恋 一见钟情，不代表感情就可以很好维持，可能只是站在一见钟情的份子上，不断坚持 然后这辈子都不去辜负这梦幻一般的相逢 不要因为好像找到了正确的人，而沿着错误的道路一直走下去。 开始第二次约会 不想被别人评价，就不要去评价别人 负面偏见，人们总是更加容易记住危险的，批评的话与人，我们要认清这一点 归因错误，这个迟到，就是不守信用，说话大声就还是脾气暴躁，这都是客观的评判，别被自己误解了 去寻找积极的一面，比如看到别人的善良、体贴、聪明 默认选项的重要性，默认自己会开始第二次约会，别给自己思考的机会 识别什么是小毛病什么是大毛病，小毛病别可以容忍，大毛病无法容忍 小毛病， 这个人不是一米八、这个人不够英俊 大毛病，消费观不合、对未来的期待不合 如果要拒绝别人，请不要玩失踪 玩消失会让玩消失的人感觉难受，还不如直接表达自己的感受 根据自我知觉理论，人们不告而别后，会想：我做了一个不好的事情，我大概是个滚蛋 当人们玩消失的时候，他们认为自己走了一条轻松的路，但是他们错了，如果我们选择善良、坦率、礼貌的方式，我们更加能够获得正面回应 第三部分主动决策，而不是顺其自然 主动决策的关系要比顺其自然的关系更加具备信任感 主动明确关系，哪怕得到是不好的回答 同居更加容易让人们因为惯性走到一起，所以要认真对待这件事 既不要说走就走，也不患得患失说走就走型 不给感情发展的机会，过早的选择离开 通常是个完美主义者，追求或者相信自己可以找到更好的 不仅影响被甩的人，也影响自己，没有机会学习如何成为一个长期的好伴侣 说走就走永远都是原地踏步的循环，没人希望这样。 多多发现对方的长处，而不是盯着缺点一直想 患得患失型 感情已经破裂，但是仍然不愿离开 我应该听从内心的声音和她分手吗，我会不会错过一段美好的姻缘？ 因为沉没成本的执念，我在她身上花费了太多时间，现在退出太亏了 因为厌恶损失的影响，我们总是把损失看得比收益更加重要 我们对失去伴侣充满恐惧，胜过我们对新的约会的对象的兴趣 分手不是闸道，而是一个丁字路口，我们总是要做出选择，而不是停滞不前 我应该如何做出决定 想象一下如果你的伴侣是衣柜一面的一件衣服，你认为是哪一种？ 不好的表现是不是暂时的，还是长期这样 是否尝试修复你们的关系 你对长期伴侣的期望是什么样，是否实际？ 在这段感情中，你做到最好的自己了吗？ 征求朋友与家人的意见 定制一个分手计划​ 及时决定分手的人，实际做起来都非常困难，人们害怕艰难的谈话，害怕伤害对方，害怕一个人独处，通常会花几个月，几年的时间去畏缩、迟疑，也许我们需要一个分手计划。 记下你分手的原因 喜欢攀比，看到别的男朋友好就会给我压力。 过于算计，一点亏吃不得。 太多要求让我倍感压力。 与我的长期目标不一致，不想结婚，不想生孩子，不想承担家庭的责任。 大家的脾气都非常尖锐，我们没有做到相互理解与尊重彼此。 我们总是吵架，这人我们都很糟糕，我不喜欢我们的表现。 我做出了挽回感情的努力，我相信现阶段结束是最好的选择。 定制分手计划 写下目标、定制计划会让实现目标的可能性高出33% 选择一个安静的地方，让大家好好交流 选择一个合适的时间，分手是引爆对方生活的炸弹，如果后面它有要紧的事情，别毁了它的计划。 提前思考谈话的目的，核心信息，语气，开场白，内容，对方可能的反应，如何结束对话 和朋友建立一个问责体系 找你的朋友确认一个目标，以及期限。 我们去谈话，不是干其他的事情 我们可能会谈话情绪的波动做出一些不该做的事情，参考尤利西斯契约，不要改变航向。 为自己制定一个分手后的短期计划 考虑好分手后你要做什么 朋友、家人、美食、电影 避免孤独与不安 和前任签订分手协议 改变习惯，避免再次陷入这段感情 分手后，生活中会有很多空洞 换个人来替换和对象经常做的事情吧，一个强有力的策略就是用新的活动、人代替她 不要在分手后，做一个黏黏糊糊的老好人 即使一切都在预料之中，对个人而言也不是一件容易的事情 分手后的一段时间，心情会做过山车，从极度放松到极度后悔，我会孤独终老吗，我为什么要这么做 可能会感到内疚，因为你伤害了在乎你的人 做老好人，很多是为了自己，而不是在帮助对方，给对方精简， ​ 如果我们曾经努力过，但仍然无法解决问题，有觉得彼此的伤害难以忘记，那或许分手是当前最好的选择，尽管还有感情存在，但长期的矛盾和伤害会削弱彼此的幸福感与成长空间， ​ 说实话，我依旧对你还有感情，我也很喜欢我们在一起的很多时光，但是我并不开心，我们都知道我们的感情出了问题，我们也都努力过尝试改善，但是我们一直都没有做出有效的改变； ​ 这很难说出口，因为我不想伤害你，非常感激我们在一起的时光。 把分手看做收获而不是损失如何克服分手后的心碎 要想走出分手，关键是找对描述事物的框架 分手之所以痛苦，是因为大脑对损失非常敏感，分手是绝大的损失，你个伴侣曾经一起构想的未来就此终结，让你悲伤的不仅仅是不堪回首的过往、面目全非的现在、还有再无可能的未来，因为厌恶损失，我们总是尽量避免分手。 一切都都会过去，你的感觉都是暂时的，你终将走出这个阶段 关注分手的积极方面 大脑会帮你合理化，尽量去想一些积极方面的事情 告诉大脑你渴望的东西，为什么这次分手很好 关注亲密关系中消极的部分 思考已经结束的这段感情中不好的地方 不和谐的地方 让你讨厌的事情 重新发现自己 你恢复了单身，会成为什么样的人呢 做一些你们在一起的时候，你想做却没能做的事情 太多独处意味着对自我价值的怀疑，勇敢的出去走走 吸取分手的教训 把分手看成一个学习的机会，反思这段感情学到了什么，没做好什么 试着不把分手看做失败，看成一个机会，促使你在未来做出更好决定。让你的思想升级一下，从时间能治愈一切创伤，变成意义能治愈一切创伤。 需要思考的问题 在上一段感情中，你的地位是什么？ 在下一段感情中你希望扮演什么角色？ 认真反思后，你认为一段长期亲密关系中，什么最重要 你是否在这一次关系中没有考虑到某件事 你希望在下一段关系中，首先从对方身上寻找什么特质？ 在这段感情里面你学到了什么？ 从分手中你学到了什么？ 在这段感情之前的你和现在的你有什么不同？ 这段经历对你的生活带来了什么改变？ 与其让自己被打碎，不如主动打碎自己的枷锁，哪些裂痕、不完美，会让你变的更加坚强。 喜结连理之前要做的事情 婚姻对人生的幸福、自己的身心健康、寿命、财富、子女的幸福都存在巨大的影响，所以要慎重对待 彼此相爱并不够可能会让彼此产生“错误共识效应”，认为对方在生活中和自己想要的东西一样，直到婚后才发现，并不一样 首先问自己若干问题 问我们过去、现在、未来的若干问题 目标明确的爱情 随着婚姻时间的增加，满意度一定是逐渐降低的 现代社会，幸福婚姻的趋势在不断下降 爱情是需要我们认真经营，并不是说要做到最好，最恩爱的，而是营造可以适应变化的亲密关系 建立一个亲密关系的契约，它帮助伴侣们为他们的亲密关系设定一个共同的愿景，在编写亲密关系契约的时候，并不是抱怨对方的缺点，也不是提出要求，而是价值观上的一致：我们承诺支付对方的梦想，并为实现这些梦想做出必要的牺牲。 选择主动决策，而不是任凭感情自然发展，这更有助于亲密关系的实现 契约中要进行例行检查，契约保证你们发展在一个方向，而检查则确保始终沿着正确的轨道前进，这要可以在问题爆发之前，对亲密关系进行调整，一起谈谈身上正在发生的事情，我的生活变成了什么样子？ 牢固亲密关系不会凭空出现，需要你尽心尽力的做出正确的选择 不论怎样，生活都是一次探索之旅，而不是意外事件，主动设计自己的生活，对自己负责，对自己诚实，知道自己是谁，想要什么，最重要的是，必要的时做出改变。你不必按照别人的想法生活，你要按照自己的想法生活。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"恋爱","slug":"恋爱","permalink":"https://bluedancers.github.io/tags/%E6%81%8B%E7%88%B1/"}]},{"title":"2023年终总结-黄金时代的总结","slug":"日常/2023年终总结-黄金时代的总结","date":"2023-12-21T16:00:00.000Z","updated":"2024-03-25T08:16:14.081Z","comments":true,"path":"2023/12/22/日常/2023年终总结-黄金时代的总结/","link":"","permalink":"https://bluedancers.github.io/2023/12/22/%E6%97%A5%E5%B8%B8/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言​ 大家好，我是阿木，马上就2024年，我身边是长江西路高架晚高峰的车水马龙，晚上闲来无事的时候，我很喜欢留在公司学习、看书，或者写点什么，今天就来回顾一下自己的2023年吧。 ​ 我即将来到工作的第6个年头，总的来说，其实今年挺..糟糕的，前几年的年度回顾总是可以找到一些闪光点，今年似乎没有什么值得一提的成就。 ​ 社会的变化会影响到每一个人，人在年轻的时候，总是会觉得自己潜力无限，总是会相信自己可以凭借自己的努力走的更远，甚至改变命运，这让我我又想到《黄金时代》里面有句非常经典的话。 ​ 后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。 ​ 矫情到此结束，正文正式开始。 关于跳槽​ 从18年工作至今，我没有换过工作，咱也是一家公司5年以上的老员工了。 ​ 并不是我对自身实力不自信，或者不敢于去接受新鲜事物，而是一方面现在的公司有恩于我，另一方面外面的薪资比较低。 ​ 工作的第二年，我因为之前比赛的原因获得专升本的机会，真的去学校的那种，和公司领导聊了之后，公司通过远程的方式继续工作，虽然收入要降低一半，但是完全足够我的日常开销，我可以不需要问家里要一分钱，我一边上学，一边每天工作4-6小时。 ​ 后来遇到了口罩事件，就不需要到校了，我也正好回到公司正常工作，白天听听网课，这一点让我很感激。 ​ 23年年初的时候，决定要换一个环境，面试了讯飞的消费者bg（百得思维），面试过程还算顺利，这几年有好好努力学习技术，但是出乎我意料的是，薪资比我现在的要低，我当时一心想换一个环境，跳出舒适圈，便答应了，后面一段时间又想了想，觉得还是不能跳，哪有降薪跳槽的，后面又拒绝了百得的hr，（PS：实在不好意思）。 ​ 后面又陆续看了一些，要么是非常热门的公司，咱这学历和年限不够，剩下的公司基本都达不到的我对薪资的需求，合肥的前端薪资上限真的比想象的还要低。思来想去还是算了吧，工作，不就是为了钱吗？上半年的换工作事件就此终结。 技术全面拥抱vue3+ts​ 在技术上，我个人推进将将公司内运营中的项目，全部逐步更新到vue3，彻底告别vue2。 ​ 在年初的时候，因为过去几年针对项目在产品和技术上考虑不周全，团队内部过于技术思维，导致做出的产品难以使用，运营效率低下，技术维护难度也比较大，对产品的维护与使用造成了影响； ​ 在我个人的推动下，开始了整个项目的重构，其中包含2个后台和一个前台。​ 前端借此机会，我们直接将相关项目的前端部分进行全面的重构。 全面升级为vue3 + ts 使用全新的项目架构，拥抱最新生态能力 ​ 总体来说，转移的工作量没有特别大，部分功能直接重写了，总体来说三个前端项目团队大约花费了5个月的时间，在更新问题上，我们团队在nginx中使用二级路由进行区分，老项目中不断切换到新页面，实现渐进式更新项目。 ​ vue3以及其生态还是非常不错的。无论是开发体验、还是开发速度、开发范式都更加快速与稳定，这件事做的不错~ 解读vue3源码​ 在年初的时候，我给自己立下了一个flag，要解读vue3的源码，这属实有点高估自己了，vue3的源码相当复杂。 ​ 在上半年完成了reacivity模块、runtime模块的源码解读，也在掘金上专门输出了一个专栏Vue3硬核源码解析系列，在watch之后我就没写了，原因是computed的源码实在是过于复杂，我实在没有信心通过简单的话语，一篇文章的方式写清楚computed的核心原理，所以后期就没有再继续输出了。 ​ 看源码还是虽然很痛苦，但是还是好处多多的，拓展技术思维、了解底层原理，知道文档中很多规则背后的原因，当然在code的时候，也具备更高的视野，编写出更优质的代码 ​ 总体来说这个目标也算完成了吧，为什么到compiler就没有继续去理解源码了呢？ ​ 我觉得是我心态变了，这个我下面具体再说。 对技术的思考​ 对于一个5年以上的开发者来说，其实对技术这个名词的理解已经和刚毕业的同学不一样了。 ​ 在我刚毕业的时候，我认为技术岗位非常关键，因为产品最终是由开发者来创造，我觉得自己具备很大的价值与能力，但是随着这几年经历的越来越多，我们会发现很多时候，很多非常重要的、我们不了解的决策、思考、判断才是决定项目走向的关键。 ​ 而技术只是实现的一种方式，本质上来说，不了解业务的的开发者，和工地上打灰的其实没有本质区别，技术仅仅是工具。 ​ 而作为一名业务开发者，我对技术开始有了一种无力感。 ​ 以前我对技术充满兴趣，我可以不问目的的去了解内部逻辑与实现原理，因为我觉得这很有价值，我很享受自己发光发热的感觉，然而有一天，你突然发现，这其实并不能让你变的多强，并不能让你无所不能的时候，便会开始怀疑自己； ​ 下半年某天下班后，在安静的夜晚，我没着急回去，打算学习一会，我打开vue3的源码和教学视频；我无法控制的问自己，了解内部逻辑与实现原理，对我而言真的有用吗？我有天赋成为技术大牛吗？我身处的环境能让我发挥相关价值吗？ ​ 我看源码的本心究竟是什么？ ​ 其实说实话，我大部分时候对源码的理解都是了解，达不到游刃有余的使用，我觉得最能发挥的时候可能就是在面试的时候，证明我看过源码，证明我自驱力强，证明我是一个有追求的技术仔，或者说一名舍得出力的打灰人。 ​ 好吧，其实这几年我逐渐意识到了，在技术领域我和天赋不沾边；况且在合肥这样的小城市，前端技术的上限真的不高，如果一直走技术路线，随着岁数增加，技术竞争力减弱，也许35岁被优化就是我的结局。 ​ 所以我今年一直有思考下一个5年，下一个10年，我如何选择，如果长得更高，走得更远。 ​ 我上面说的这些，并不是想做看源码没用，也并不是看衰技术，只是针对我身处的环境，结合自身的能力，似乎对我而言，技术价值的边际收益已经有限。 学习后端（nest）​ 每个前端都希望成为全栈工程师，在之前几年我一般都是使用koa2写一些后端应用，后来做一些项目的时候觉得不够规范，所以下半年学习了nest，这里推荐光神的nest小册，真的非常不错，简单易懂，比官方文档强百倍。 ​ 如果说koa2太简单，实际使用nest 又会觉得nest太复杂，其实也有点怪怪的，可能是不太喜欢java这门语言的愿意吧。 ​ 总的来说，下半年使用nest做了一些后端项目，还是挺不错的，在没有更好的替代品之前，我还是会继续使用nest。 产品​ 其实上面说到的对技术思考，我前两年就有思考过，不走深度走广度，也是机缘巧合，加上自己的兴趣，我选择了toC产品经理的方向，而今年也是我做产品的第二年了。 ​ 目前在团队里面基本可以承担产品的全部职责了，对产品的流程，对用户需求的分析也更加的熟练与高效；而作为一名95后，初中的时候就接触手机的年轻人，所以对用户体验这一块尤其敏感，所以在toC的产品上，可以基于自己的认知，以及对技术的理解，做出一些更好的用户体验，以及做出能产生积极影响的产品方案。 ​ 但是23年，在产品领域并不顺利，首先我们公司并不是独立产品，或者说还没有发展到独立产品的程度，我们的产品用户基本都是依托于异业，我们为异业提供能力，异业同时会我们提供流量，因为某些原因，今年这方面的业务遇到了重大挫折，自然我也失去了发挥的空间。 ​ 所以有时候面对这些事情，身为一名开发，真的深感无力，技术能决定的事情，其实很少； ​ 有时候大家看某人天天摸摸鱼讲讲ppt，对技术发号施令，却拿着很高的薪资，也许并不是人家和老板有关系，或者组织架构有问题，而是人家真的对行业、用户、甲方、产品都有深刻理解，可以相对快速与简单的判断出正确的方向以及具备很强的总结与输出能力。 ​ 今年没有看太多产品方面的书，其实很多产品的工具书并没有什么营养，产品的关键从来都不是书上方法论。 ​ 有一本薄薄的书《微信背后的产品观》，我觉得很不错，我非常同意书中的一些观点，当时我写了一篇文章 从读《微信背后的产品观》到思考前端工程师的“35岁”。建议对产品有兴趣的同学都读读，这本书会告诉你一些做产品的理念，非常有意思。 GPT​ chatgpt3首次公开是22年的10月，作为互联网人，应该也算是最前沿的一波人了，但是我的认知有限，没有很强的敏锐性，当时没有发现gpt对理解自然语言的巨大威力，只是觉得他挺聪明的，和他聊天很有意思。 从兴奋到理性​ 到了今年3月，chatGPT开始出圈，我看到很多人对GPT的理解与看法，我才慢慢理解了GPT的巨大的前景。当时非常兴奋，火速开发了一个套壳网站，回头看，其实惊叹于GPT对自然语言强大的理解能力，而作为开发者，我当时只会写prompt，没有任何壁垒与技术含量； ​ 社区里面也看到过很多基于gpt做产品的，甚至还有辞职创业的，因为墙的原因，内地也存在需求，所以还是有成功的产品。 ​ 但是他们更多的是通过对产品的宣传与圈子的传播，而不是对gpt有深刻的理解。所以在我的理解看来，这个今年能通过gpt挣到钱的，都是自媒体玩的好的人，或者打着危言耸听的旗号，利用信息差割韭菜的人， ​ 有多少人真的提升了生产力呢？可能并不多。 始终在尝试公司内的应用场景​ 这一年我断断续续的在寻找gpt的应用场景，真正的从有用的角度去出发，学习了基于向量数据库的知识库的搭建，以及calling Function等等。 ​ 关于知识库，本质上是在询问gpt之前，首先从向量数据库中匹配你的问题的相关文字，最后把问题与匹配的文字发给gpt，让他总结再输出，文本内容质量较高，内容较少，效果还可以，但是相对的作用就有限。 ​ 如果是大量文本，最终的回答就会非常不佳，况且还需要人不断去维护知识库，这不是一件简单的事情。 ​ 关于calling Funtion，这个挺厉害的，我们可以通过该方式给予gpt链接世界的窗口，进行联网、总结文章、查询天气等等，都可以做到，下半年也基于calling Funtion做一些企业内部的工具，最终感觉对生产力的提升也有限，对效率的提升也有限。所以在生产力方式，总是给我一种食之无味弃之可惜的感觉。 ​ 也许并不是gpt的问题，我个人并不是相关专业，研究的比较浅显，但是从我个人研究来看，虽然gpt很强，能够理解人类语言，但是脚踏实地的回到现实来看，在23年，GPT能够针对单一场景辅助人类已经是极限了； ​ 但是我依旧认可它在未来具备巨大潜力。 生活输出​ 今年大约输出了20篇文章，关于技术类文章的输出不多，主要是因为业务上没有太多值得输出的亮点，我本人对输出这件事也从来没有抱有很强的目的性，有想法就写，贯彻费曼学习法； ​ 随着见多了优秀的文章与作品，我对我自己输出的文章的要求也越来越高，这更加导致找到一篇合适的输出变得不容易；还是对技术的重新思考，也让我对纯技术领域的思考与折腾变少。 ​ 产品类文章输出了几篇，但是没有发布在掘金，主要发布在自己的公众号与人人都是产品经理，其中有一篇关于优惠券的文章反响出乎意料的好，得到了一些我认为比较大的平台的推荐与转载，倍感荣幸。 ​ 朋友们，无论什么时候，无论未来是否还在做技术，都要坚持输出，输出是思考的结果，是碎片化知识的整合，好的内容不仅造福别人，也是造福自己。 读书​ 上学的时候不好好学习，上班了开始坚持读书。 ​ 人真的很怪，拥有的时候觉得理所当然不去珍惜，失去了再去怀念。 ​ 今年看了堪堪100个小时的书，还是要多多自律啊。 ​ 英语也坚持学习了一整年，再次推荐多邻国，每天学习十几分钟无痛学习英语~ ​ 阅读是一件美好的事情，希望你也能从中得到属于自己的价值。 ​ 健身​ 也不知道是不是人以类聚，还是现代人对未知的恐惧，95后似乎年纪轻轻的都比较怕死，我也是其中一员，去年体检的时候，体检报告写我的颈椎曲度变直，吓得我哪一天都弯腰不敢低头，后脖颈的肌肉绷的像石头。 ​ 于是重拾了锻炼计划，每周在楼下公园跑步2次，今年9月的公司附近新开了乐刻，价格也比较低，就顺理成章的办卡了，对我来说坚持锻炼似乎并不是一件很难的事情。 ​ 年底体检的时候，颈椎曲度变直已经消失，今年体重也维持在130，明年继续坚持 ​ 尝试一些新方向B站​ 尝试发了一个视频，做视频真的是时间能麻烦的事情，本人还是一个i人，日常里面偏向于不苟言笑的那种，所以和有趣这个词似乎并不是太合拍，所以内容应该也不是特别优秀。 ​ 最终的结果就是数据很差劲，对视频自媒体直接丧失信心，我大概还没有准备好。 小红书​ 今年在小红书上分享了一些图文，职场类，主要是针对互联网黑话的一些解读，内容非常简单，其实这个方向很一般，但是苦于找不到更好的输出方向，最终今年收货了接近500的粉丝与1万的阅读量（太少了），也算是一点心理上的慰藉吧。 ​ 相当于视频，还是图文的方式更加低门槛一点，也更加是个入门，关于自媒体，持续探索吧。 最后​ 马上元旦了，先祝大家元旦快乐，2023年作为口罩之后的一年，似乎大家都过得不太如意，人生在世，活的就是经历，多留意身边一直被忽略的景色与可爱的人吧，让每一天都过得精彩，让每一天，都有意义； ​ 2024年让我们一起共度时艰，明年年度总结，我们再见👋🏻","categories":[{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://bluedancers.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"《四万万顾客》读书笔记","slug":"阅读/《四万万顾客》读书笔记","date":"2023-12-21T16:00:00.000Z","updated":"2024-03-25T08:12:41.037Z","comments":true,"path":"2023/12/22/阅读/《四万万顾客》读书笔记/","link":"","permalink":"https://bluedancers.github.io/2023/12/22/%E9%98%85%E8%AF%BB/%E3%80%8A%E5%9B%9B%E4%B8%87%E4%B8%87%E9%A1%BE%E5%AE%A2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"《四万万顾客》读书笔记前言​ 作者卡尔克劳在中国生活了了25年，1911年以新闻记者的身份进入中国，1918年创建了克劳广告公司，1937年因为抗战爆发而离开。 ​ 通过外国人的视角，他是看待中国的顾客？又是如何理解中国人，让我们借用他的视角去再次了解一遍作为中国人的自己。 ​ 接下来是针对每一章内容的带有个人色彩的概括，以及摘抄，我的描述不代表作者的描述，具体内容还请阅读原文 不同寻常的顾客 只要足够便宜，中国人都会买，这是一个错误的观念，没人比中国人更加享受讨价还价 中国消费者喜欢相对固定的消费，或者说认牌子，一旦习惯了某种东西，即使更好的东西出现，他们也不会立刻改变选择。 中国认对自己喜欢什么，不喜欢什么非常执着，一旦养成消费喜欢，就会成为世界上最忠诚的客户。 中国人对任何微小的改变，都会起疑心，比如包装上英文字母的变化 洋货在中国市场享有主导权利，完全得益于长久以来的口碑 即使货品一样，中国人也更加看重品牌，不接受替代品 顾客一般非常清楚自己的需求，对其他的一律不感兴趣 中国小姐发现美腿 中国人绝不会亲口告诉你真实的原因，若想知道，你只能拿出认真的精神，专业的做调研。 美妆类产品并非新时代的产物，中国女孩很早就开始除毛、涂抹胭脂了 几百年前中国女人就发现了若能保持自身魅力，丈夫就会心甘情愿雇佣仆人洗衣做饭，因此，中国女人是梳妆打扮是全球最完美的。 只有上了年纪的寡妇才不爱慕这些虚荣之物，这是因为会别人觉得她放荡 为了美丽，中国小姐非常善于利用道具，比如一种用于缓解牙疼的小热水袋在中国畅销，原因是小姐买过来敷脸可以产生自然的光泽，模仿羞涩红晕 中国女人一旦冲出了传统重视家庭的限制，没什么再可以把他们拉回去了 中国女人更加注重身材 中国女人魅力的出发点多半是为了丈夫（异性） 无利润销售也可以发财 中国商人都非常聪明，如果发现某个产品卖的特别快，就会挂出低于正常售价出售，最后导致大家都不挣钱，用户到店的时候，因为挣不到钱，会推销其他品牌 因为赊账灵活，所以批发商总是有账期，手头上便重视存在现金流，在中国，有了现金流，赚钱的方法就很多了，也就是投资，这就是无利润销售也能发财的原因之一 中国的学徒不拿工资，理由是店主会提供必要的衣物，生意好的时候还会得到额外的收益与奖赏，还可以缓解父母的压力，还能学会一项技能，这是很多中国人的抱负，也是两情相悦的事情。 尽管打杂的伙计工资很低，但是很多废品都是店员的，可以二次售卖，店员更加愿意售卖包装更加精美的货品，因为有转售价值。 中国人懂得艰辛，看见掉在地上的无主铜板都会捡起来，他们无法理解赠品的存在，所以哪怕是赠品，只要有价值他们也会付钱。 赠品到了中国会失去他原本的目的，并且中间商转售，最终导致品牌受损，与达不到营销的预期。 中国的男人一般不会逃避或分担养家糊口的责任，常被称为家里顶梁柱 中国的企业偏向于家族化，所以邀请一个家族的年轻人就以为着获得一个家族的生意 一个原因在门面上花几千块的人，终究会想办法把钱从顾客手上赚回来，卖家的本能告诉他们，比起简陋的门面，热衷于花哨摆设人更加贪图利益，更应该被提防 在中国，毫无商业价值的东西，也会被排上用场，被做成鞋垫、做成好看的信封、装点家具 海鸥到这里都会挨饿 上海中国人聚居区街道烟蒂都没有，外国人抽烟浪费，还剩半英寸的时候就会扔掉，老人们会捡起来，再手动卷制，这个小生意让街道保持整洁。 在1937年日本入侵的时候，所以政府岗位都停止了，只有清洁工哈在工作，他们会带着扫帚和篓子，蜂拥到街上回收弹壳和武器的肥料。 上海港口是世界上最干净的港口，并不是水有多干净，而是没有浮渣于弃物，因为这些都是有价值的东西，会被辛勤的乞丐船打捞，所以上海海鸥都没有 每当大商船在上海抛锚，因为会存在很多垃圾与被判定不适合的食物，打捞船就会一拥而上。 在中国，任何东西都具有价值，可以转化为现金 在中国，家庭苦力不会放在任何一件废弃物，总是可以被排上用场，无法使用的布料可以做鞋垫、旧面粉袋可以做船帆、废纸的另一面可以书写。 二手市场非常繁荣，并且人们非常具备商业头脑。 推销无须推销员 美国人之所以可以组建全球史无前例的销售大军，是美国人心里使然，美国同胞非常享受推销员来访，他们像鉴赏家一样用评估推销员的技巧，遇到精彩的表演就会心情大好，这个过程中，签单的决定性因素并非产品的价格于质量，而是推销员的技能，美国人确实比其他国家的民众更加容易接受推销 中国推销员没有合适的心理材料，国内没有这个文化 大多中国人，知道自己想吃什么，知道自己想买什么，倘若他面对的事情不在自己的经验范围之内，就会向东航的朋友寻求建议 中国人对任何一种口若悬河、旨在让他们掏腰包的人都更加重点防范，因为在儒家文化看来这种人往往没有原则，没有良心 陌生人在商务与上交场合是不受欢迎的，挨家挨户兜售的人还没有开讲就已经被打败了，因为中国仆人将主人免收侵扰收为己任。 中国人更加愿意和朋友做生意，或者朋友的朋友，猜忌会烟消云散，双方直奔交易细节。后续如果出现问题有中间人帮忙摆平，这是一种简单高效的优良传统。 一个中国人最想和自家人做生意，其次是朋友，有可能的情况下，会尽量避免陌生人 他们这些人做的非常成功，但是于推销能力无关，主要取决于他们同特定品类经销商的友谊于关系。 因为将生意控制在家族于朋友圈的强烈渴望，某些行业被特定的地区与省份垄断了，丝绸基本都是苏州的，茶叶基本都是安徽的。 找工作，保工作 90%的中国商号除了过年之外不打烊，一天10-12工作时长也是家常便饭，老板或者经理的亲戚重视优先获得提升与奖金。 相对而言国外公司要好非常多，午休、双休、法定节假日、晋升机会，上海的中国男孩都希望进入外国公司。 英文读写于口语表达能力是进入国外公司的基本条件，但是中国人不不依靠学校活着课本学出漂亮的英语，而是尽可能的走捷径。比如在某些书中照抄面试申请，如果真的面试就会发现这些行文流畅的写信人大多口语非常不自信，一般他们的解释是没有机会对话。 很多人原因0报酬进入，活着底薪，让任何人找不到辞退的理由，步步为营，再提升自己的收入 求职信的威力其实有限，因为一个职位的空权，会有数不清的带就业的表亲、探亲等着再，如果真的被新员工拿到，也未必是好事，因为其他员工会说这名员工不好的话，让其失去希望。 受雇的中国人会想方设法的体现自己的价值，不怕事情多，就怕事情少，没事会让他怀疑自己的对雇主的价值。 中国人喜欢自己的不可替代性，劝中国人休假是非常困难的事情，因为这意味着另一个人接手他的工作，这样他就不是不可或缺的人了；如果真的需要，会找一个亲戚。 中国人会自己行程部门化，各自的权责一旦确认，一般别人就不在过问，也不会抢别人的饭碗。 中国人因为本身思想观念问题，融入大公司其实并不容易，为什么要拼死拼活为一群既不是朋友也不是亲戚的人创造利润。 中国一般没有大公司买因为所谓的规则在他们眼中是虚假效忠的行为，这会导致最终会形成家族企业，员工名册变成了家族谱，这棵树接不了果，却始终活着，因为根部汲取了大量的养分，并且不产出利润的果实。 一个非家族的人会被排挤，压榨，也无法投诉，这会导致事情的进一步恶化。 工作斗志与驱鬼记 相信风水 他的祖先普遍认为，替你劳动者的工作不可或缺，并且他们发现，若是在雇主能看到的地方辛勤脑洞，主人家会更加愿意付钱， 劳动者多半不害怕辛苦，黄包车夫不介意包裹堆的多高，拉的货发多，在其他黄包车中穿行的时候，喊的越有派头。 中国人对工作抱有很高的热情，希望办公室忙碌起来，如果办公室不够忙，就就要想办法让它看起来很忙。 他们并不介意工作超时，似乎很享受偶尔的加班，热热闹闹的、愉快的做出忙碌的表面工作，能给中国员工极其公司带来自信。 中国人非常在意风水，一个看似相同的环境，某种行动有时能带来成功，有时却有会失败，必然是因为受到了恶灵的影响。 某地因为竖起了一个大大的香烟广告牌，后来庄稼歉收，患病者增加，还有数人死亡，请了风水先生提出专业意见，得出结论是香烟广告牌是恶鬼聚集之地；正对这件事，最终决定购买大量鞭炮将恶鬼吓走，鞭炮表演之后，小村子繁荣发展，再也没抱怨过了。 凛遵 凛遵：严格遵循 毋违：不得违误 中国古代多少个世纪，将这些套话放在官文的政客，深谙自己同胞的弱点与习性，仅仅服从命令，大多很愉快，倘若搞砸了，也会说，我都是按照指令办事，失败不怪我，所以针对重大命令，需要增加一个毋违！防止执行者推诿借口，简单来说，就是事情没办成别找借口！ 中国人一般非常害怕负责，即使知道某个政策没错，也会由于是否要热烈赞成，倘若进入失败了，他就需要承担责任。最后终于有人小心翼翼的再提出一个谨慎无比的建议，大家都能撇清个人责任，才可以再谈论政策的细节。 中国人会根据直觉或者个人喜好得出结论，所以他们总是具体问题具体解决，但是如果一定要该出原因，这对中国人来说是一件困难的事情。 中国人有时候喜欢拖延，并不是懒惰，而是小心回避责任，或者需要再承担之前找出一个合理的借口。 无论一个中国人造成了多大的错误，都会给自己找一个天衣无缝的理由，一想到酿成大错的头脑和自圆其说的竟然是同一个，我就会惊叹不已。 大部分中国人缺乏做出决定，承担后果的勇气，但是当被比如复杂绝境的时候，却可以展示出惊人的谋略，非常善于随机应变。 比如我（卡尔.克劳）的的司机在战火中走丢了，当我认为他必输无疑的时候，他将几个伤员塞进汽车，然后一路开到上海； 快听！狗真的叫了 作者是一个非常善于观察的人，会留意动物对不同人的区别对待 外国人来到中国后，总是喜欢探索他和他的同胞们在哪些方面比所访问国家的人民要更加优越，对于这种行为，作者喜欢带他去小村庄逛逛，感受一下狗对外国人的狂吠 狗总是能精准识别外国人，即使使用了国际大牌的香皂，依旧骗不过它们。 村庄的水牛通常很温顺，但是白人也总是充满敌意，外国人闻起来似乎像他的老对手，激发他仇恨的本能。 中国的水牛，耕耘十载或者更久后，老到无法工作会被宰杀，这种牛肉做牛排都嫌老，但是给上海的外国人炖牛肉还凑合，他们以诶自己吃的是牛类某个更高贵的品种。 相较于狗与牛的区别对待，骆驼对任何人类都是一视同仁，当游客视图爱抚骆驼，可能会被咬一口，或者被喷口水，深谙世事的人绝对不会靠近与抚摸骆驼。 鱼和绳，西瓜子 在中国进行商务交易的，总是有很多意料之外的事情，倘若交易尚未彻底结束，买家尚未付款，商品尚未使用，没人敢确定交易细节是否不再发现变动。 中国人在误解方面很有天分，他们能从方方面面充分利用误解。 等到付钱的时候，之前敲定的价格总会处于这种或者那种的原因上涨 比如轿夫在一段旅途结束后总是会异口同声的说对我超重的身体表示诧异，他们相互喊话，说向我这样的外国人不是血肉之躯，而是石头之躯，当然这是一种恭维的话，因为胖是泰安处世之道的体现。 中国人总是喜欢讨价还价，双方信口开河、自由欢快、但是不会心生芥蒂，但是如果让他们争辩半天却一无所获，则会证明我们是吝啬的小气鬼，不配接受乡下人的热情招待，所以，就算没有道理，我们也会多给一些酒钱。 一个挂在绳子上的鱼即使买下来，绳子也是需要另付钱的，但是没有绳子将无法使鱼存活并保险，就要再商量绳子的价格。 如果你觉得中国人讨价还价，主要目标是从不加提防的人哪里敲诈几个铜板的话，那我必须纠正这个印象，他们讨价还价不仅是为了利润，更是从中找乐子。 很少有人能读报 报纸是最廉价、有效的宣传方式，因为清朝把所有保持都禁了 中国的报纸读者最乐观估计不超过人口的百分之五，但是已经是15年前的2倍多了 中国文盲率很高，这并不是因为笨，而是没有学习机会、需要承担更紧急的义务 文盲不代表一定生活在底层，没有用纸笔也能成功度过一生 在刊登广告的时候，会利用图画语言来辅助文盲阅读报纸上的广告 虽然很多人目不识丁，但是不影响他们享受文学，因为有职业说书人 无论大小报刊，刊登广告的价格都一样，因为价格低就相当于亲口承认低人一等了 中国报纸更加职权分散、缺乏纪录，但是也可以正常运作 顺子和同花 翻译扑克规则是我们承接的最难的工作之一，但是当我们开始为汽车做广告的时候，发现汽车术语翻译成为中文也很困难 我们做出的第一份目录在上海畅通无阻，但是送到香港、汉口，哪里人就会看不懂，因为不同地方的术语都不同。 发明行话的中国人不仅限于司机，实际上每个行业都有一套外行不可能听懂的行话。 在其他国家家喻户晓的产品，在中国需要重新命名，品牌的中文名称要简单，朗朗上口，有特色，不能被轻易模仿，还要注意是否会引起粗俗的联想。 中国疗方 每个人都愿意购买用于治疗的药物，但很少有人服用预防剂，哪怕是免费的。 中华民族大部分人住在通风极差的房间里面，也不怎么运动量，按理来说他们身体应该很差，但是事实并非如此，只是新生儿的死亡率比较高，只有强壮的婴儿才能活到中年。 如果真的病的厉害，急需寻医问药，那么他十有八九回去看中医，或者去中药铺抓草药 尽管中医疗法看似粗糙并且不完善，却赢得了无数同胞长达数个世纪的信任，中医界也不乏名医，不乏对科学事实的耐心求索。 中医实践从未列入正式的科学研究体系，以学徒制传授，每个医生讲自己的技艺传授给一名或多名徒弟，并且缺少监管，这给了江湖庸医可乘之机。 鱼翅和皮蛋 中国人和其他人一样爱吃各种糖，但是他们的一日三餐却不含甜品，不过中国人喜欢在正餐之间吃小吃。 尽管中国人搜遍了地上跑的、水里游的、天上飞的食物，但是却没有学会享受乳制品，他们的食物中没有牛奶和黄油。 炒杂碎虽然是中国菜，但是在中国却非常不流行。 保面子，丢面子 丢面子：被羞辱，保面子：避免遭到公开羞辱。这种简短的定义在中国生活的方方面面中所扮演的重要角色起到了小小的提示作用。它包含了一套人类关系的行为准则，规定每个人在任何情况下都要帮助自己的同胞维持自尊、昂首挺胸。 每个人的面子都需要被尊重，你可以频繁的斥责中国仆人，让他反复做自己搞砸的工作，即便如此，家里也会波澜不惊，但是如果你斥责他的时候又其他人在场，尤其是又仆人在场的时候，就是另一回事了， 大部分的袭击既可以直接归咎于丢面子，工作时间长、干活累、薪资低这些他们都可以冷静的忍耐，只要不受羞辱。 有钱的中国父亲会通过贿赂的方式让儿子进银行，这种工作让雇员有面子，也让全家有面子。这让中国产生了一种特有的诈骗计划。 如果印刷商像我们提交了质量很差的印刷品，我们不会和他讨论公正，我们会说这样的印刷品交给客户，我们会丢面子，客户也会拒绝接受。 中国裁缝会在我丢弃的旧衣服的时候，将伦敦的商标取下来，缝在我的新衣服上，因为伦敦商标会让我更加有面子。 以前的面子都是私事，到了现代生活，主事者的领导下，他也开始了对城市的改造，街道肮脏不堪，城市就会丢了面子，居民也会丢了面子 仕途也是如此，一个野心勃勃的军阀发生叛乱，反对中央集权，反叛被镇压，在任何一个国家，判断将领都会被剥夺军衔，投入大牢，再被处决，但是在中国，也许不会这样，这会让军阀颜面扫地，相反他会得到一个较高的头衔，然后奉命到一个偏远地区执行人畜无害的使命；这样做的政治目的是避免败北将军的准随则产生强烈的敌意，巧妙的赢得他们的忠心。 中国人会买下牌号靠前的二手车，许多外国人按说出不了手的破二手车竟然可以买个好价钱（早期买车的基本都是外国人） 中国富商会觉得晚一点去公司很有面子，证明自己不是准点打卡的打工仔，于是这也形成了一个传统，商务拜访应该在下午进行。 神圣的饭碗 万万不可让人丢了面子蒙羞，也玩不可摧毁他谋生的机会 在商务活动中你可以占尽他的便宜，把他的价格压到最低，但是如果你让他一贫如洗，承受不必要的损失，坚持让人走投无路的履行合同，这些都被视为极其不人道的可怕行径。 中国人对同胞饭碗的体贴到了不合逻辑的程度，比如裁员的时候，会将最优秀的员工裁掉，留下庸才，因为他们知道庸才一旦被裁掉就找也找不到新工作了。 面对黄包车主收租过高的问题，横幅提议减少租金，这样的行为中国人并不感兴趣，但是后续黄包车主拒减租金，并拒绝出租黄包车，导致3.5w名黄包车主失业，这群强盗资本家瞬间被置于众怒之下，最后黄包车住妥协。 如果有人剥夺了他人谋生的手段，无论出于各种原因，中国人都不会让他逃过责任。 相对应的，你一旦喊出，你不能砸了我的饭碗，这也会得到很好的效果，在大多数国家向税收员博得同情是无效的，因为他们没有更高数字的权限，但是中国的处理方式更加讲道理，，在这里合理性和妥协精神比方法规程更加有分量，这里的税收人员虽然不能改变上级定制的税率，但是可以不跑出去清点到底有多少张广告牌，然后商量好，为15个广告牌收税，实际上竖起来20个。这样一来，人人愉快，税率符合标准，大家的饭碗也保住了，面子也保住了。 中国人能在专制政府下的统治下相对民主，全归功于行会，清政府的地方官员几乎拥有无限的权利，但是他们在具体实践中，力求减少冲突，避免民愤，否则行会就会发挥作用，出现罢市，停工，起义，孕育出民主精神。 几种黑心事 中国人在交易中讲究公平诚信，但是还有很多走邪门歪道的黑心事 中国的传统领域都有这很高的道德水平，比如丝绸，或者带有银匠铺的银器，自始至终都保持着高标准 其他商务领域就没那么高的标准了，比如建筑，还有制造业、出版业、出后贸易等等新兴行业，尚未建立起有模有样的职业道德标准。无一例外会陷入恶性循环，凿除优质商品 - 大卖 - 品质变差 - 销量下降 - 公司倒闭 - 下一个人收购。 子果子早上会恬不知耻的模仿知名品牌，也许只要是因为没有能力自主研发 在出口贸易上，发现出售不合格商品有利可图，而且出口贸易的风险下，因为到遥远的地方才会被打开，会想出口的蚕豆中掺假 如果没有赚快钱的手段，中国商人还有一招，略微夸张的发票，外国公司向中国一共假发票也是十分常见的事情，或者多给几个空发票，由经销商自己填写 出口商约翰牛和山姆大叔 山姆大叔：美国 约翰牛：英国 上海是中国对外贸易的中心，来寻找代理商的品牌非常多，代理往往供不应求。 相对于英国、德国的制造商，美国制造商的变化无常邻人不满 如果代理的美国的产品销量很好，美国人就会撤销代理，建立分公司，代理商就会悲哀的发现，自己创造了令人满意的销售额，但是也因此失去了代理权 美国制造商喜欢频繁更换代理，似乎心怀一种徒劳的希望，新的一定比旧的好，相比较之下，英国厂商的代理就要稳定的多，仿佛拥有一份大胆付出努力的永久价值资产。许多英国公司更加悠然自得，不愿为了增加销量做任何努力，他们满足于不费吹灰之力的获取佣金。 美国商人写信之多、写信之长，远超其他国家的商人，相反英国人的信件非常简短。 在营销、包装、广告方面美国人做的更好，但是美国人更加短期主义，英国人更加长期主义，美国人求变，英国保守，有时候，诚恳热情的努力并不能带来相应的回报，比如中国市场本来也比较保守。 日本的优势在价格，通过无耻剥削廉价劳动力实现低成本生产，而德国制造商更加拼命，更加精益求精 每天一个苹果 如果我们可以让潜在的四万万中国顾客相信“每天一个苹果，医生远离我”，那该多美妙啊。 只要一个国家的人还在制造东西卖给其他人，只要海运和国际贸易依然存在，向数亿勤勉中国人出售商品的金色幻想始终具有强大的诱惑力。无论卖什么，你都能在中国大赚一笔，前提是该买你东西的中国人的确愿意掏腰包。 中国对外买一有这长达两千年的历史，外商到中国并非出售而是采购，很长一段时间里，中国都是全球最大的制造国，例如丝绸、瓷器、茶叶 中国人本以为何种状态会永远维持下去，对外国人在售的物品还不在意，等他们发现蛮夷竟然可以制造出好东西的时候，傲气遭到了沉重的打击，到19世纪下半叶，潮流逆转，卖给中国人的洋货，反而比卖给洋人的中国人更加重要，更加有利可图了。 每一代制造商都会为全球市场贡献新产品，他们都在中国找到了市场，获得了新的财富。新的商品会替代老的商品成为生财之道，而未来的新产物又将取代它们。 中国人花了很长时间才决定要买西方制造的现代物件，可一旦开始，他们就发现，买得起的都想买，买不起的也又很多想买 司机上，中国四万万顾客经常遇到的问题是清单上写了10元，但是口袋里面只有5美元，买任何东西之前，都需要货比三家，还要把它拿来和其他性质迥异的物品做对比，比如6月西瓜丧尸，很多人不能同时享受西瓜和香烟，所以一部分人就会放弃香烟选择西瓜，香烟的消费到吃瓜季节结束后才能恢复正常。 我们做市场调查，推测他们会购买那些物品，这些东西应该怎么包装，怎么打广告，采用怎样定点推销方式比较有效，我们在自己的国家也需要解决相同的问题，但是在这里还需要面对其他复杂状况和难题，以及来自其他各国厂家的竞争，我们的付出于经济回报不成正比，却之其他方面得到了补偿，我们的工作始终充满了趣味性，尽管多年来市场遭遇幻觉破灭，但是我们依旧默默怀揣这样的念想：或许明年，着四万万顾客中就又了相当一部分会买我们的东西了。 结语​ 尤其说作者是一名广告代理商，比如说他是一名优秀的人类观察学家，该本书出版于1937年，依旧是说书中的观点都是作者来华20多年的见闻，没有上流社会，也没有宏达需求，只有对每个个具体的，真实的中国人的观察，虽然已经过去了几十年，但是我们依旧可以在书中找到他对中国人的认知，比如对包装变化的敏感、充分利用一切，对推销员的反感，在公司不忙也要假装忙碌。 ​ 作者对信息的输入，不来源于统计属于，而是来源于身边一个个具体的人，他更加善于发现具象的事实与观点，这来源于作者的记者身份，以及研究“中国人真实想法”的营销分析需求，并且基本看不见外国人看其他国家人的高高在上的感觉，而是尊重、融入其中。 ​ 另外就是行文风格偏幽默，很多苦难被描绘成为乐天精神，真正的也许并非如此，只是客观情况下的无奈之举，总的来说这本书还是很不错的，值得一看。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"四万万顾客","slug":"四万万顾客","permalink":"https://bluedancers.github.io/tags/%E5%9B%9B%E4%B8%87%E4%B8%87%E9%A1%BE%E5%AE%A2/"}]},{"title":"（23年12月）chatGPT绑虚拟卡并开通plus会员","slug":"chatGPT/chatGPT plus开通指南","date":"2023-12-11T16:00:00.000Z","updated":"2024-01-04T07:14:06.974Z","comments":true,"path":"2023/12/12/chatGPT/chatGPT plus开通指南/","link":"","permalink":"https://bluedancers.github.io/2023/12/12/chatGPT/chatGPT%20plus%E5%BC%80%E9%80%9A%E6%8C%87%E5%8D%97/","excerpt":"","text":"看完这篇文章你将学会 购买加密货币，包括BTC、ETH、USDT 注册虚拟银行卡，并充值美元 开通chatGPT PLUS会员 绑卡的好处 可以使用gpt 4的api能力 gpt 3.5的api请求速率从每分钟3次到每分钟3500次，避免429状态码 可以进一步开通Plus会员 平台简介DuPay ​ 前身为depay，可开通虚拟银行卡进行全球通用支付，并可使用加密货币进行充值。 欧易OXK ​ 加密货币交易所，可以购买绝大部分的加密货币，类似平台还是币安。个人推荐使用欧易，国内使用更加方便。 如何下载相关APP​ 功能上APP相对网站更加齐全，体验感更好，所以推荐使用APP去完成相关操作，IOS的用户需要美区APPID才能下载，android手机可根据官方提供的下载地址，或者第三方资源完成下载与安装。 ​ 亲测使用环节均不需要梯子。 关于货币流转名词解释 为了方便理解，下文使用中文进行描述 USDT：中文名称为泰达币，价值与美元挂钩，一个USDT相当于一美元 USD：美元 流转过程 为什么流程这么复杂？depay不接受人民币，仅支持泰达币的方式进行充值，或者内部转账 人民币 - 泰达币 - 美元 在欧易中完成人民币转化为泰达币 在dupay中获取加密钱包地址，将欧易中的泰达币充值到dupay（每次大约2泰达币的手续费） 花费20泰达币完成虚拟卡的申请，或者50泰达币，取决于购买者的需求 将大约30泰达币转化为30美元，并充值到虚拟卡中 在openAI侧进行消费 大概费用开卡费20泰达币，后续每月卡费0.5泰达币（或者使用50泰达币，获得无需开卡费的虚拟银行卡） 虚拟卡充值单次最少30美元 各个流程的手续费累计在一起大约消耗2-3美元 所以建议一次性充值大约56-60泰达币，也就是430元人民币，注意每次充值都需要手续费，所以尽量一次充值到位 整体流程 注册DuPayhttps://dupay.one/ 建议通过手机号完成注册（使用的时候不要挂梯子，否则会注册失败） 根据要求完成实名认证 注册欧易OXK https://www.okx.com/cn 根据网站要求完成手机号的注册 根据要求完成实名认证 使用人民币购买泰达币 购买后存在一定的T+N的安全保护，大约1-3天后才可以进行后续的操作。这里就只能等待了 充值到DuPay欧易那边的T+N的安全保护结束后，我们就可以把泰达币充值到DuPay中了 DuPay中点击钱包 - 充币，获取到钱包地址 欧易中点击资产 - 提币，提取数字货币，选择USDT，在选择链上提币。 填写正确的钱包地址，与提币网络即可完成充值 注意：每次充值都会两头收取手续费，大约2泰达币，所以尽量一次充值到位 开卡+存款​ 泰达币充值到账之后，我们就可以开卡了，现在已经没有免费卡了，横向对比，应该只有这个20泰达币的高级卡是性价比最高了。 支付20泰达币之后，开通成功。 接下来我们在钱包中将剩下的泰达币转化为美元，再点击首页的充值，这里需要注意一定要准备30美元以上，这是DuPay的充值限制 完成以上步骤后，我们就成功完成了开卡与充值；接下里让我们到openAI侧进行绑卡操作。 openAI侧绑卡登录进入自己的账号，并选择个人的 先使用https://www.dizhishengcheng.com/ 生成美国人虚构信息。 建议使用免税州的信息，免税州包括阿拉斯加州（Alaska）、特拉华州（Delaware）、蒙大拿州（Montana）、新罕布什尔州（New Hampshire）和俄勒冈州（Oregon）。 信息全部输入成功，点击continue即可，在这个环节我没有遇到被银行卡被拒绝的情况。 后续流程会建议你设置自动充值计划，这个按照自己的需要进行配置。 最后​ 绑卡成功后，即可直接购买plus会员；就算不进行购买，chatgpt3.5的api也享受每分钟3500次请求的速率限制，还是非常不错的。 ​","categories":[{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/categories/chatGPT/"}],"tags":[{"name":"chatgpt PLUS","slug":"chatgpt-PLUS","permalink":"https://bluedancers.github.io/tags/chatgpt-PLUS/"},{"name":"虚拟币","slug":"虚拟币","permalink":"https://bluedancers.github.io/tags/%E8%99%9A%E6%8B%9F%E5%B8%81/"},{"name":"depay","slug":"depay","permalink":"https://bluedancers.github.io/tags/depay/"},{"name":"dupay","slug":"dupay","permalink":"https://bluedancers.github.io/tags/dupay/"}]},{"title":"chatgpt的calling Funtion让贾维斯不再遥远","slug":"chatGPT/chatgpt的calling Funtion让贾维斯不再遥远","date":"2023-12-11T16:00:00.000Z","updated":"2024-01-04T07:15:07.042Z","comments":true,"path":"2023/12/12/chatGPT/chatgpt的calling Funtion让贾维斯不再遥远/","link":"","permalink":"https://bluedancers.github.io/2023/12/12/chatGPT/chatgpt%E7%9A%84calling%20Funtion%E8%AE%A9%E8%B4%BE%E7%BB%B4%E6%96%AF%E4%B8%8D%E5%86%8D%E9%81%A5%E8%BF%9C/","excerpt":"","text":"后续编写","categories":[{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/categories/chatGPT/"}],"tags":[{"name":"calling Funtion","slug":"calling-Funtion","permalink":"https://bluedancers.github.io/tags/calling-Funtion/"}]},{"title":"搭建一个企业内部的实用AI","slug":"chatGPT/搭建一个企业内部的实用AI","date":"2023-12-11T16:00:00.000Z","updated":"2024-01-04T07:15:41.718Z","comments":true,"path":"2023/12/12/chatGPT/搭建一个企业内部的实用AI/","link":"","permalink":"https://bluedancers.github.io/2023/12/12/chatGPT/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%94%A8AI/","excerpt":"","text":"参考文章 https://longbig.github.io/2023/02/19/ChatGPT%E6%8E%A5%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%90%E4%B8%BA%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/ https://dingyx99.me/post/wechat-work-nodejs/ https://juejin.cn/post/7133543712977584142","categories":[{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/categories/chatGPT/"}],"tags":[{"name":"ai机器人","slug":"ai机器人","permalink":"https://bluedancers.github.io/tags/ai%E6%9C%BA%E5%99%A8%E4%BA%BA/"}]},{"title":"正确的理解技术，可以让我们走的更远","slug":"关于程序员/正确的理解技术，可以让我们走的更远","date":"2023-11-24T16:00:00.000Z","updated":"2023-11-29T09:35:34.578Z","comments":true,"path":"2023/11/25/关于程序员/正确的理解技术，可以让我们走的更远/","link":"","permalink":"https://bluedancers.github.io/2023/11/25/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C/","excerpt":"","text":"​ 我们小时候都听过这样的一个故事， ​ 为什么大家都说35岁是技术岗的危机，甚至现在还出现了更加提前的趋势，30岁危机就已经出现。在本文开始之前，我也先丢几个问题给大家，一起思考一下以下现象的原因是什么？ 软件开发是否是劳动密集型行业？ 为什么在中国，为何倾向于更加年轻的程序员，多年经验的程序员反而越发艰难？ 当程序员们意识到危机的时候，他们遇到了什么挑战？ 如何应对程序员的”35岁危机”？ ​ 接下来我来谈一谈我这6年对技术的理解的变化，以及学习与适应变化的过程，从中我们一起寻找上述问题的答案。 ​ 技术是代码（0-3年） 那时候我就像是一个在技术的门外不断窥探的孩子，迷茫、思索，不断寻找属于我的自己的打开技术大门的钥匙。 ​ 当我在大学中刚开始接触代码的时候，我和大多数人一样苦于如何完成老师的课后作业，回想起来，我对技术这个词的理解非常直观，技术就是代码，要如何做好一名合格的技术呢？多多学习与理解代码。实话说，谈不上有写代码的天赋，大学中学的第一个语言课是C语言，学的也比较糟糕，后来慢慢培养了一点技术思维，学java的时候又败给了面向对象。 ​ 我时常为自己的天赋平庸而烦恼。如果技术就是代码，那时候我的技术能力简直就是灾难。 ​ 上帝还是给了我机会，偶然之间让我接触到了JavaScript，这并不是学校授课的语言，但是这确实一个令人着迷的语言，在面向过程的的JavaScript（ES5）中，我找到了突破点，顺着这条藤蔓，我找到了适合我的对技术的打开方式，技术思维逐渐被打开，以前不理解种种逻辑，面向对象、指针，也很自然的就理解了。 ​ 再后来参加全国比赛，凭借兴趣与努力不断学习，逐渐成为我们计院的top，这才算走上了编程这条路。 ​ 在我那短暂而又高强度的学习编程的经历中，我始终都有一个明确的理念，技术 &#x3D; 代码，要想编程能力进步，想成为更加厉害的程序员，就要拼命写代码，所以我知行合一，延续了在学校比赛时期的作息时间，工作时间外，晚上也继续学习技术，我非常积极的接触所有前端范畴的技术的上的工作，主动挑战任何技术难点，因为我坚信，代码写的好不好，是评价技术的唯一标准。 ​ 就这样，在我写代码的前3年我几乎把前端范畴中能接触的所有技术，都学习了一遍，而对于重要的技术，也会重点学习与了解，通常会想方设法的了解实现原理；同时坚持费曼学习法，保持输出的习惯，这些年我的juejin博客的阅读量也还不错，大部分文章的内容也还说得过去。 ​ 所以在我迈入职场的头几年，我的收入和社会认同感都有肉眼可见的增加，这些成果一方面激励我继续努力，但是另一方面我内心的疑惑也越来越大。 对技术的疑虑​ 某一天晚上我在公司无所事事，学习ng，在学习的过程中，我突然开始思考起来，学习ng对我而言真的有用吗？ ​ 公司不可能用ng的技术栈，不好招人、国内生态差、文档不友好，那在学习ng的过程中我能了解到什么？ng的一些编程思想，企业级的项目架构；可是我没有应用场景，怎么能有深刻的理解？最多只能扩大自己的知识面。自那之后我在学习新技术的时候我都会开始思考，我花这么多时间去学习这些我很难用到的技术，再随着知识慢慢被遗忘或者过期，是不是已经产生不了什么效果呢？ ​ 我们时常说，技术为业务服务，若是学习的技术并没有在实际业务中发挥作用，没有让开发效率更高、没有让软件的速度更快、没有让团队成员开发体验更好，那岂不就是没用的技术。 ​ 所以我转变了思路，决定不在走马观花式的学习，要打技术纵深，看axios、promise、vue2.x、vuex的底层实现，然而源码的复杂程度超乎我的现象，首先我个人不具备独立阅读源码的能力，在阅读的过程中，我需要搭配别人的博客，以及源码解读视频才能理解其核心逻辑，在这个过程中我充分认识到了一点就是这些人的水平，我一辈子都达不到。 ​ 不过另一方面我还是要为阅读源码正名，这个确实有用，这就像数学公式一样，不理解原理就只能背诵，照搬硬套，但了解原理后，就能解释很多为什么，开发的能力得到很大的加强。 对没有结果的疑虑​ 在我工作的前三年，我做过很多产品和需求、开源，有些是公司的，有些私人的，但是绝大部分都是失败，投入了很多精力，没有产生任何价值，我非常幼稚的认为技术是非常重要的一环，但是反复的失败，让我非常茫然，也让我逐渐意识到技术能决定的事情，并不多，也意识到做出一款被大家接受的产品是一件极难的事情， ​ 那段时间和我的领导聊了很多，这里我尊称一句w老师，w老师通过各种例子慢慢纠正我的对技术片面的理解，反复和我论述技术为业务服务，那时候我对这句话依旧是半知半解，我想技术当然是为了业务服务，技术好才能完成各种各样复杂的业务，这人我一度想不明白，w老师想和我表达什么，但是这还是埋下了一颗种子，为了我的下一个阶段做好了准备。 所以后面，我想明白了一些道理，也看到了我对技术理解上的局限性 技术只是工具，本身没有价值，有价值的是技术形成的产品。 程序员不仅需要怎么做，更需要知道为什么要做。 对0-3年的建议从我的精力看，我觉得从小白 - 初级前端开发者 - 前端组长，3年时间足矣，需要做到以下几点 学习技术的第一源动力是出于兴趣、与技术的喜爱，而不是为了获得一份工作或者高薪资 打好计算机基础，良好的编程基础是程序员头三年高速进步的前提。 要多写代码，量变才能产生质变，尽快成长为前端团队中的顶梁柱是这个阶段的核心目标。 重视业务，千万不要觉得业务与自己无关，理解业务流程是工作的一部分 要客观的认清自己，是否真的有编程天赋？与大牛的距离有多大？避免盲目学习与努力 技术是需求（3-5） 既然技术的最终呈现方式是业务，我直接关注业务不就好了？ ​ 业务的落地由多个角色协作完成，后端、ui、运营、产品、项目经理，我大学期间学习了经济学相关知识，并且对此一直很感兴趣，我选择了与前端最贴近的产品经理。同时在公司，我也走向了基层管理岗位，前端组长。 ​ 同时我与我的上级表明我想做产品的想法，并希望在现有项目中，发挥自己的产品的作用，上级欣然应允，同时也非常鼓励我继续做下去。 ​ 所以在这个阶段，我从原本的纯技术开发，变成了技术 + 产品 + 管理齐头并进。 ​ 学习产品思维是一个艰难的过程，在这个阶段，我系统性的学习了NPDP国际产品经理认证课程，看了《增长黑客》《人人都是产品经理》《幕后产品》《微信背后的价值观》等一系列产品经理相关的书籍，慢慢形成了产品逻辑。 ​ 这个阶段，我经常问自己产品方面的问题。 ​ 为什么拼多多不做购物车？难道是因为拼多多技术能力太差吗？ ​ 为什么美团会员规则是这样的？如何演变形成的？ ​ 为什么双11的优惠券规则如此复杂？为什么不直接给用户优惠？ ​ 为什么最近上线的某个需求效果很差，为什么某个功能点又非常受到大家欢迎？ ​ 羊了个羊爆火，我会尝试去分析，为什么他可以火，他是如何做的？ ​ 参考竞品的时候，我会去思考，为什么他这样设计？ ​ 在如何做的基础上，我更进一步的思考了，为什么这么做？别人做得好，我会去分析，为什么他做得好，自己做的不好，我也会分析，自己为何做的不好的原因，而不是团队一起拍脑袋，或者个人主义去理解与看到需求。 ​ 在这几年，我做过很多需求与产品，大部分需求都成功落地，并达到预期效果，但是绝大部分产品都失败了，只有零星的几个产品在某个场景下做出了效果；随着在产品方面的经验越来越多，我对需求的理解越来越准确，逐渐在团队中的产品角色站稳脚步 ​ ​ ​ 如何平衡 技术与其他工作？ ​ 如何学习产品相关知识？ 技术是产品（5-？）技术是？","categories":[{"name":"关于程序员","slug":"关于程序员","permalink":"https://bluedancers.github.io/categories/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"营销工具(3) - 从游戏名词到电商营销，我们一起来聊聊“秒杀”","slug":"产品相关文章/营销工具（3） - 从游戏名词到电商营销，我们一起聊聊秒杀","date":"2023-10-29T16:00:00.000Z","updated":"2023-11-27T03:13:59.522Z","comments":true,"path":"2023/10/30/产品相关文章/营销工具（3） - 从游戏名词到电商营销，我们一起聊聊秒杀/","link":"","permalink":"https://bluedancers.github.io/2023/10/30/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%883%EF%BC%89%20-%20%E4%BB%8E%E6%B8%B8%E6%88%8F%E5%90%8D%E8%AF%8D%E5%88%B0%E7%94%B5%E5%95%86%E8%90%A5%E9%94%80%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%81%8A%E8%81%8A%E7%A7%92%E6%9D%80/","excerpt":"","text":"历史上的“秒杀”​ 在1980美国的11月24号，这一天是美国最重要的传统节日感恩节，我们的主角小帅一家聚会到深夜才结束，但是他们并没有休息，反而穿着厚厚的大衣，前往附近早已停止营业的沃尔玛。 ​ 但是当小帅抵达沃尔玛的时候，门前却排上了长长的队伍，超市关门了反而门前开始排队了？ ​ 因为明天就是黑色星期五！ 感恩节后的黑色星期五标志着圣诞购物季的开始，美国人民通常会利用这一天购买圣诞礼物或者需要的商品。 ​ 小帅早早来的原因是他在11月22号沃尔玛的宣传单上看到的限时限量优惠！，只要1元就可以获得一个崭新的柯比吸尘器，但是限量500个；虽然现在寒风凛冽，但是捡漏的快乐还是让小帅充满干劲，美国的11月还谈不上太冷，就这样等到11月25号的凌晨5点，沃尔玛开门了！ ​ 排在前面的人都是冲着限时限量商品去的，都一个劲往里挤，事后发现大门都被挤坏了。 ​ 尽管沃尔玛出动了大量安保人员维持秩序，但是还是出现了小范围踩踏事件，我们主角小帅非常幸运的挤在队伍的前列，在丧尸一般的人潮中成功抢到了仅售1元的限量商品柯比吸尘器，当然小帅不会立刻结账走人，他还会在沃尔玛购买圣诞节礼物、自己需要的东西。 ​ 最后付款离场，小帅心满意足回家。 ​ 但是感恩节之后，沃尔玛决定明年不再做限时限量优惠活动了。 线下商超为何对“秒杀”又爱又恨？我们一般认为，秒杀活动存在3个主要特征，限时、限量、高值低价。 线下秒杀在大多数情况下，都会获取预期效果，并且可以达到增加销售额、增加客流量的核心目的，具体来说作用如下 通过制造热点吸引潜在用户、老用户、引导到店消费。 被吸引到的用户多半会购买一些产品，增加商超的销售额 秒杀活动会增加品牌、商超自身的知名度 这么看挺不错的啊，能抓到老鼠就是好猫，能完成目标就是好活动，那何来的恨呢？ 虽然秒杀能带来一些用户，但是也许要付出很多显性与隐性的成本。 线下商超的目标是提供广泛而优质的服务，有可预期的周边几公里顾客，并不是很需要通过秒杀低价这种”激进“的营销策略来获取用户的青睐。 由于价格便宜并且限量，而黑色星期五本身就存在庞大的人流量，会出现人员拥挤与混乱的情况，不稳定因素大大增加。 秒杀活动会导致顾客之间发生冲突与纠纷的概率大幅增加，有损商超的的形象与品牌建设。 比如这样 还有这样 而黑色星期五的人流量是这样 ​ ​ 总的来说就是线下秒杀是一把双刃剑，相对来说雨露均沾式的优惠更加适合线下商超的价值定位；商超会根据自己的营销目的，选择不同的促销方式去吸引客户。 ​ 也正是以上的一些原因，在线下商超出现之前，秒杀一直不是非常主流的营销方式，比我们之前聊的优惠券差远了。 互联网时代，”秒杀“为什么破圈了？​ 1989年发生了一件影响人类历史进程的事情：由美国国家科学基金会推动的商业互联网正式成立，互联网开始走向大众。 ​ 亚马逊为代表的电子商务公司开始兴起。2004年亚马逊推出了一项叫做Gold Box的业务，专门提供各种产品的打折促销和限时特惠。 ​ 该功能一上线，取得了非常好的的效果，手机上点点就可以花少量的钱购买想要的产品，消费者对此类限时限量优惠的商品自然是很有兴趣，线上秒杀也开始被更多人注意到，Gold Box类型的营销方式开始电子商务领域被使用。 ​ 我们考虑一下线上秒杀相对于线下秒杀有什么优势？解决了以前的什么问题？为什么线下不温不火的秒杀业务，到了线上就成了常见的营销方式？ ​ 我们先分析一下线下秒杀的痛点到底是什么。 ​ 用户参与秒杀的成本高 ​ 对于用户而言，提前一晚上到超市门口排队，抢到了还好，要是没抢到直接破防，这要是有啥烦心事，做出过激举动，身边人都遭殃。 ​ 对于大型商超来说，成本可能大于收益 ​ 面对线下秒杀这样的活动，一方面商家需要增加额外的人力，另一方面还存在不可控的风险，比如损伤商超形象、影响顾客消费，等等一系列问题，除了新店开业需要快速拉新，稳定期间的经营者一定会慎重选择该营销策略。 ​ 而且大型线下商超是存在区域性，比如在你家距离2公里处有一个沃尔玛，距离第二的超市可能就是5公里以上，你几乎不可能来回多跑6公里去距离更远的超市。而站在商超的视角看，除了特殊的开业阶段，应该多做老客户的维护，培养用户习惯。 ​ 而互联网的出现，几乎弥补了以上所有痛点。 ​ 用户参与门槛极低 ​ 在手机上就可以秒杀抢购，足不出户，就算抢不到，无非就是吐槽有内幕，付出的成本微乎其微。 ​ 对于电子商务来说，收益大概率大于成本 ​ 相较于线下秒杀，线上开展这样的活动，主要成本在研发，用的辐射的人越多边际会成本越低，只要提前考虑到可能的意外情况，加上优质的运营方案，几乎不存在风险。 ​ 另外，不同于线下商超固定的辐射圈，电子商务不存在物理空间的限制，这就意味着理论上网络上的任何一个人都是潜在用户，这样的前提下，平台的增长潜力是极大的，上升期也是极长的，秒杀这样吸引眼球的活动就成了一个非常不错的选择。 ​ 那线上秒杀有什么缺点呢？ ​ 存在技术难度，瞬间巨量的访问，会直接让服务器宕机，相信经历过早期国内双11的用户都深有体会，而伴随秒杀业务的火热，一系列的技术方案都火起来了，所以技术难度也随着生态的完善而降低。 ​ 亚马逊的秒杀业务在2000年左右开始发展壮大，除了日常折扣和限时促销的Gold Box之外，还细分出了Lightning Deals（闪电交易）、Deal OF The Day（团购）、7-day Deals（7天优惠），等等针对不同类型商品的秒杀活动，直到现在，相关业务依旧是亚马逊促销策略中重要的一环。 ​ 相比于线下秒杀，线上秒杀只能说是：优雅，实在是太优雅了！ ​ 国内为什么叫“秒杀”？​ 不知道大家注意到没有，我们上面谈论了很多秒杀，都是打引号的，国外这种模式不叫秒杀，电商领域的”秒杀“是一个本土词汇。 ​ 以前的人怎么想到这个名字的？，为啥不叫限时抢购？ ​ 秒杀这个词在电商之前高频出现在竞技、游戏中，在国内电商兴起的同时，网游也在蓬勃发展，众多RPG游戏进入中国市场，比如大名鼎鼎的《红月》；大概就是看起来像是兄弟就来砍我、一刀999的游戏。 ​ 这个游戏可以升级到1000级，每次升级会给技能点，有些玩家将这些技能点全部加到攻击上，几百级之后，就会出现极其脆弱的身板 + 极其变态的攻击力，要么自己秒死，要么对方秒死，玩的就是心跳。 ​ 秒杀一词也慢慢在社区流行起来，而玩游戏的多半是年轻人，这部分年轻人与电商领域从业者产生交叉，电商从业者目睹限时限价低价商品在电商平台瞬间抢购一空，发出了惊呼：”一下子就没了，就秒了！“。 ​ 这时候人们转念一想，抢购没有体现极致的速度与紧迫感，哎！秒杀这个词很不错，商品直接售空，与游戏中的血条消失场景非常类似。 ​ 有了这样的先例后，9.9秒杀、限时秒杀，京东秒杀、秒杀专区、老板娘生日，全场秒杀….在电商领域犹如雨后春笋般出现，直到现在几乎成了电商平台的专用名词。 ​ 从专业角度看，人们为何喜爱秒杀​ 可能会有小伙伴说了，这个问题很简单，因为大家都喜欢物超所值！其实不仅仅是简单的价格对比，限时限量抢购活动能够被人类选择，是有他的底层逻辑的。 ​ 收益不最大化（商家）：在秒杀的场景下，用户支付比心里预期更低的价格就可以获得商品，用户会自发性的通过已知渠道进入秒杀活动中，而目标用户的参与动机，与需要支付的金额数量成反比，对于商家来说，秒杀场景下收益肯定不最大化的，这也是秒杀的显性成本。 ​ 厌恶损失：根据科学验证，失去的痛苦是的得到的快乐的2倍以上，丢掉100元的痛苦远高于捡到100元的快乐，人们聪明的脑瓜自然能推理出，如果不通过此刻稀缺的秒杀活动购买到商品，后续多支付的部分金额，就是我的损失，则会进一步强化用户参与秒杀的动机 ​ 稀缺效应：秒杀的特征，都是在加强稀缺这一点，限时、限量、高值低价，用户对稀缺的感知直线上升，从而增加购买的兴奋度与成就感。 ​ 从众效应：我们想象一个场景，你的面前有2家超市，一家门可罗雀，一家人人潮汹涌，你会选择哪一家店？我相信绝大多数人都会无意识的认为，人多的肯定好，其实秒杀的场景也是这样，只是换了舞台，从线下变成了互联网上，如果秒杀活动可以在一个圈子中被炫耀、宣传，人们就会被这种“火热场景”所“迷惑”。 秒杀的目是什么？​ 聊了这么多，我们还是要回到最关键的问题上。 ​ 为什么要秒杀，我们的目的是啥？线上秒杀与几十年前的线下秒杀还是一个东西吗？ ​ 我们先看线下商超做秒杀的目的是什么？ ​ 用限时限量低价把用户吸引过来，然后为用户提供消费空间，并让更多用户了解与记住产品。 ​ 几十年前线下秒杀受到现实世界的限制，无法发挥全部实力，而有了互联网加持之后，弥补了现实世界的缺陷，秒杀进化为完全体状态，其核心目的没有根本变化； ​ 很多新人产品只理解了前半句话，把用户吸引过来，让用户参与”秒杀“，人气确实吸引过来了，但是人家只秒杀，花钱赚吆喝，就是不挣钱，甚至羊毛党越来越多。 ​ 线上商城不像线下商超，用户来线下商超参与秒杀活动，来都来了，大概率会消费，线上则不是这样，无论用户是否”秒杀“成功，没兴趣了会直接右划走人，这就达不到开展秒杀活动的目的了。 ​ 所以线上秒杀的运营目的并非秒杀活动进行状态，而是秒杀活动开始前后的活动运营，以及产品的曝光与留存。 ​ 等待秒杀的用户运营 ​ 店铺付出较高成本开展秒杀活动，吸引来的新老用户都是极其宝贵的，如何引导这些用户转化为店铺的忠实用户，如何引导用户增强与店铺的粘性都是极其重要的，在这段时间可以做的事情很多，社交互动、相关营销活动曝光、强化品牌价值等等；只要能加强与用户的粘性，用户强化用户认知的目的，营销方案的形态都是可以畅想的。 ​ 秒杀之后的用户运营 ​ 秒杀之后有些用户抢到了，有些用户没抢到，抢到的用户必然会增加对店铺的信任，我们再引导用户多下单，并在下单过程中继续曝光产品能力，比如签到、会员、让用户发自内心的认可产品； ​ 而没抢到的用户呢？我们也不能白白浪费宝贵的流量，时刻记住我们秒杀的目的。 ​ 猜测一下”秒杀“失败用户的心理，可能还对抢到抱有一丝希望，是否还有下一波?是否可以捡漏？这时候我们是否可以提示用户，没抢到没关系，预约下一次的秒杀，还有机会抢！或者贴出其他相对优惠的非秒杀的商品，来安慰用户；总之就是拉升用户的心情曲线，给予用户继续操作的空间，也是将用户留存下来。 ​ 所以秒杀并不是简单的低价抢购，短期吸引巨量人气的活动，因为如果没有合理的运营策略，最后陷入只能花钱赚吆喝的虚假繁荣之中。 一定是秒杀吗?​ 我们纵观人类发展史，无论是工业革命时代的路边小卖部，还是信息化时代的全球电商平台，总有时代的先驱者找到了当下时代的技术与底层逻辑的结合，归根结底其实研究的还是是人与组织、交易。 ​ 互联网秒杀此类业务模式的出现是在特定历史阶段的产物，而我们真正要关注的是此类活动的底层逻辑以及我们的营销目的，最终以什么样的形态展示到用户面前，一定不是永恒不变的，秒杀是手段，不是目的。而在高速发展的当下，已经有了相对于传统秒杀更加有效的活动模式，以及电商突破物理限制后，能够触达的新业态。 ​ 万变不离其宗，了解消费者，了解底层逻辑，与自身资源有机结合，形成可落地的面向用户的活动形式，最后落地的一定是秒杀吗？我想一定不是的。 ​ 谢谢朋友们的观看，我是懂点技术的saas电商产品经理狗阿木，如果您觉得我的文章对您有帮助，记得点赞关注~ ​ 参考资料 曾将中文带火的韩国网游，却被自己搞凉，15年后又想复活捞一笔？ “秒杀起源”，电商年代告诉你什么是真正的秒杀","categories":[{"name":"产品","slug":"产品","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"营销工具","slug":"营销工具","permalink":"https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"},{"name":"秒杀","slug":"秒杀","permalink":"https://bluedancers.github.io/tags/%E7%A7%92%E6%9D%80/"}]},{"title":"营销工具(2) - 细致解读,Saas商城必备的优惠券产品设计攻略","slug":"产品相关文章/营销工具（2） - 优惠券的产品设计逻辑","date":"2023-10-19T16:00:00.000Z","updated":"2023-11-27T03:12:56.458Z","comments":true,"path":"2023/10/20/产品相关文章/营销工具（2） - 优惠券的产品设计逻辑/","link":"","permalink":"https://bluedancers.github.io/2023/10/20/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89%20-%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91/","excerpt":"","text":"前言​ 在上一篇文章中，我们了解了优惠券的起源，以及随着互联网的出现，优惠券的能力进一步被挖掘的发展历程；今天直接上干货，聊一聊Saas商城系统的优惠券产品逻辑究竟要如何设计。 优惠券的框架设计优惠券的生命周期如下 我们的优惠券设计的目的，也就是解决生命周期每个环节的问题。 店铺如何发布优惠券？ 店铺中的用户如何领取到优惠券？ 领取到优惠券的用户如何使用优惠券？ 店铺通过那些维度去复盘优惠券的效果？ ​ 其中的问题1、2是放在一起考虑的，发布优惠券的时候，我们不仅需要考虑优惠券的基本信息，也需要提前思考优惠券通过什么渠道发放到目标用户手中。 ​ 我们首先聚焦于发布优惠券的产品逻辑。 发放优惠券发布优惠券中我们可以将其分为2个大类，基础设置与发放规则。 ​ 基础设置包含优惠券名称、优惠券类型、发放数量，等的优惠券的基本信息，这样的基本信息在任何商城几乎都是通用的。 ​ 发放规则是发放渠道、定向发放、发布平台、领取限制，等等平台独特的，配合运营而存在的设置。 基础设置 ​ 这部分产品逻辑无论哪一家的saas都是大同小异的，都是对现实优惠券的抽象。 ​ 有的saas系统中，将优惠券的设置单独抽出来，叫做优惠券模板，其产品流程为，首先发布优惠券模板，然后发布优惠券的时候再选择模板，随后设置发放规则，才算发放成功，比如微盟； ​ 绝大部分saas都没有这样做的必要，因为如果不是极其复杂的产品，过于细化产品逻辑，反而增加了技术、运营的使用难度。 券名称（用户见） + 券名称（店铺见）​ 券名称不仅需要设置用户可见的优惠券名称，还需要设置后台独有的优惠券名称 ​ 为什么存在这样一个字段呢？ ​ 因为同名称 + 规格的优惠券可能被发布在不同的渠道，如果不存在字段在后台进行区分，店铺运营人员就无法通过用户见的优惠券名称快速区分同名优惠券的具体渠道； ​ 为了满足运营人员快速区分渠道的目的，系统内部就需要针对优惠券增加一个内部可见的名字 ​ 也许有小伙伴会说，将不同的渠道信息写到优惠券备注里面不就好了，这样确实可以，但是优惠券备注字段一般是不支持搜索的，这就需要运营人员手动筛选，所以店铺见的券名称字段是非常有必要的。 ​ 这2个字段在优惠券列表页面都需要支持搜索。 优惠券类型​ 尽管优惠金额千变万化，我们始终可以用满减券、折扣券这2个抽象纬度进行归纳；当然虽然场景的精细化，还可以衍生出更加细分的优惠券类型，我们先说通用的。 ​ 折扣券除了设置具体折扣之外，一般还要设置门槛与优惠上限，我们归纳一下，一般这样设置 优惠内容 满xx元，打xx折 无门槛，打xx折 优惠上限 无优惠上限 最多优惠xx元 满减券的逻辑和折扣券类似，不过满减券已经设置了具体的优惠金额，所以不再需要设置优惠上限，一般存在以下设置 优惠内容 满xx元，减xx元 无门槛，减xx元 ​ 以上2种类型几乎包含了通用saas商城90%以上的应用场景，所以如果不是非常重视用户运营，或者行业需要，增加额外的优惠券类型是不划算的。 ​ 趣味性的包含随机金额券，则需要设置随机区间、商品兑换券，需要设置指定商品、买一送一券、赠品券，此类优惠券使用频率与场景相对低频，所有在开发优先级上，需要慎重考虑。 应用范围​ 回想一下，我们拿到的线下优惠券，是不是基本都会指定单品或者指定类目，这样指定优惠范围的逻辑在saas商城系统的发布优惠券中是不可或缺的，一般应用范围存在以下几种纬度。 指定商品、指定类目、指定供货商、全场通用 注意一点，这里的指定都是可以指定多个的，并非只能指定一个，比如指定多个商品、指定多个类目。 另外就是关于全场通用，这个选项saas商城谨慎添加，因为该应用范围存在以下特点 应用范围太大 同时使用频率不高 全场通用券容易被撸羊毛，偏离效果预期 一旦运营人员点错，后果不堪设想 ​ 所以如果全场通用类型优惠券在业务上不是必要的，则不进行添加。 发放数量​ 这就是指优惠券具体的发放数量。 ​ 要注意的是，发放数量在编辑的时候，一般只能添加，不允许减少，这是因为减少优惠券可能导致已领取的优惠券数量超出实际库存，也会对系统的稳定性造成风险。 有效期与活动时间​ 在店铺后台发券的时候可以指定优惠券可使用时间，一般存在2种类型 用券时间 指定用券时间范围，比如指定xxxx - xxxx时间段可用 指定领券后有效期，比如领券后x天内有效 活动时间 执行之间端，优惠券是 ​ 用券时间的限制，大家都比较好理解，存在时间限制的券，会增加用户的使用动机，存在有效期的优惠券也降低了程序的运行负担。 ​ 而活动时间，我调研多数竞品看是不存在的，而我站在店铺运营者的角度来看，觉得这个字段是有存在的必要的。 ​ 我们可以想象一个场景，在春节节假日期间运营需要发布了一张全场优惠券，用户领券后，30天内可用，春节之后无法领券。如果不存在活动时间，运营人员就需要在春节节假日结束的时候手动关闭优惠券，或者活动入口。 ​ 这样的事情，完全可以交给程序完成，就是增加活动时间的概念。 ​ 还有一点需要注意的是，当活动时间小于优惠券的使用时间的时候，优惠券不会随着活动时间的过期而过期，而是按照自己的使用有效期规则。 ​ 到此为止，我们的发布优惠券的基础模块就完成了，这一部分的产品设计是比较简单的，大部分的产品逻辑都是类似的，无论是参考竞品，还是自行设计，最终都会走向类似的终点，将尽力聚焦于商家运营需求，或者用户需求才是重点； 基础设置的示例图 ​ 完成了如何发布优惠券，下一步，我们就要看看用户如何获得优惠券。 发放规则 发放渠道（重点）​ 我们可以想象一下，在我们的日常生活中，有多少种途径可以完成领券动作 在商品详情页领券。 在社群中的优惠券链接完成领券。 在线下海报完成领券。 通过特定的卡密兑换优惠券。 在签到、抽奖活动中获取优惠券。 …. ​ 我们可以想到很多很多领券的途径，在我们发布优惠券的时候，需要控制优惠券可以在什么渠道被领取，如果没有渠道的概念，原本打算发给社群的优惠券，在商城类就可以领取，券就会被截胡了；后期的数据统计也无法细分查看不同渠道的转化率。 ​ 另外优惠券有了渠道的区分，即使是同样规格的优惠券，在后期的优惠券数据统计上，也可以看到不同渠道的效果如何，总之，优惠券渠道的区分对于店铺运营来说都有很重要的意义。 ​ 一般存在什么样的发放渠道呢？ 商城渠道​ 用户可在商城内的优惠券集合页面、可用商品的商品详情页面领取优惠券 手工渠道​ 一般用于客服为用户补发优惠券，用户无法手动领取。 外部渠道​ 运营可以导出可兑换优惠券的券码，并分配给第三方，第三方的用户通过兑换、购买等等方式获取到指定券码，最后按照活动提示，回到商城中，将兑换码兑换成可使用的优惠券；一般用于异业合作。 以上3个渠道为基本渠道，几乎每个saas商城都存在的，而下面的渠道则和具体的业务绑定，属于个性化的渠道 券包渠道​ 券包渠道优惠券无法直接被用户领取，而是需要运营人员在后台的券包管理模块，选择多个该渠道的优惠券，发布成一个券包，用户再通过指定渠道、或者首页弹窗，领取券包，自动获取券包中的所有优惠券。 抽奖渠道​ 发布在抽奖渠道的优惠券，可以在发布抽奖活动的配置中，配置指定优惠券，用户即可通过抽奖获得该优惠券。 签到渠道​ 发布在签到渠道的优惠券，可以在发布签到活动的配置中，配置指定优惠券，用户即可通过指定的签到天数获取该优惠券。 标签渠道​ 发布在标签渠道的优惠券，可以在标签管理中配置指定优惠券，用户达成某种条件，自动获得标签的时候，也就会自动获取优惠券。 ​ 自动标签可以有效的完成用户精细化运营的需求，我文中所写的方式是，先发券，再去标签管理中进行绑定，如果精细化运营要求比较高，可以在发布优惠券的时候就指定标签，这样操作上更加直观。 ​ 关于 券包、抽奖、签到、标签与活动运营存在强关联的优惠券渠道，如果对运营不存在精细化的需求，可以不在进行划分，统称为自动渠道。 ​ 细分的渠道虽然可以让系统更加稳健，让后期的统计更加简单直观，但是也不是没有缺点，增加了实际运营的理解难度，也增加了操作步骤，所以到底是精细化还是简单直观，需要根据自己的产品特性进行判断。 领取限制​ 券的数量是有限的，一个用户可消费的量也是有限的，如果不对券的领取加一限制，会造成券的浪费，也会造成潜在订单的流失，所以发放优惠券的领取限制是很有必要的 ​ 领取限制一般存在以下几种 不限次数 每人限制x次 每人每天限制x次 每人每月限制x次 ​ 领取限制并非一成不变的，究竟是什么样的领取限制，在设计产品的时候，我们需要根据服务对象的需求来决定。 领取与使用平台​ 很多saas商城不仅支持微信小程序，可能还支持h5、微信公众号、xx小程序，等等。 ​ 首先，不同平台的运营规则是不一样的，比如虚拟类商品就不允许在小程序中进行售卖，那么虚拟类商品的优惠券就不可以在微信小程序中被领取与使用；或者某些运营需求，我们希望用户在指定渠道领取与使用，这些运营需求的实现都需要再发布优惠券的时候限制领取与使用平台。 是否加入微信券包​ 如果saas商城支持微信公众号、微信小程序，我们的ToC的商城用到微信的鉴权能力，技术上就没有阻碍了。 ​ 开启该功能后，用户在商城中完成领券的时候，我们也可以将券加入到用户的微信券包，加入微信券包的券存在过期提醒，可以快过期的时候二次唤醒用户，也可以通过优惠券直达商城，是不错的功能。 ​ 不过要注意的是，加入微信券包的券，尽量是高价值的，低价值的优惠券无法引起用户的兴趣，快过期了再提示用户使用，会加剧用户的反感，甚至导致用户的投诉，所以该功能也需要慎重使用。 外部优惠券的发放逻辑​ 在上述优惠券发放渠道中，存在一个比较特殊的优惠券渠道，就是我们的外部渠道，外部渠道的券，是我们发放给第三方产品，或者公开区域，用户无法在站内获取的优惠券。 ​ 因为站内无法获取，则需要我们导出券码，让用户可通过站外渠道进行领取，所有我们的后台需要支持导出优惠券的功能。 ​ 为了更好的运营效果，优惠券也不是一股脑全部导出的，因为可能存在多个外部渠道，A渠道需要1000张，b渠道需要2000张，不能让运营人员去手动拆分做这种工作，所以我们需要先生成指定渠道，再导出优惠券。 ​ 外部优惠券在优惠券列表表格中会多出2个按钮，第一个是生成，第二个是导出。 ​ 假设我发布了10000张优惠券，分别导出给A、B、C渠道，则发布完成后，点击生成，生成的时候填写生成数量、导出渠道，完成指定渠道的外部优惠券的生成，B、C同理。 ​ 外部优惠券生成完成后，再点击导出，再选择上一步声明的指定渠道，即可导出指定渠道的所有优惠券兑换码，同时还可以在导出时设置券码状态，未领取、未使用、已使用或者全部，针对性导出。 ​ 最后，我们将导出的csv文件，给到第三方的外部渠即可。 ​ 到此为止，我们发放优惠券的全部功能就梳理完成了。 用户使用优惠券​ 在C端用户使用优惠券的逻辑就非常简单了，为了更好的用户体验，领券页面到下单的产品路径一定是越短越好，一般存在如下特征 商城内存在一个“我的优惠券”页面，我的优惠券页面需要有券码兑换功能，方便用户兑换发放出去的外部优惠券 如果优惠券是指定单商品，点击使用优惠券，则直接进入指定单商品，如果是多商品可用，则进入一个可用商品集合页面，确保最短产品路径。 在最终下单环节，自动帮助用户选择最便宜的优惠券，同时为用户提供切换可用优惠券的产品功能。 关于ToC的产品逻辑可参考竞品非常多，也不是本文的重点，所以这里就不做过多赘述了。 优惠券效果复盘​ 每当我们的优惠券活动结束后，并且用户的券已经全部被使用，或者失效，我们便可以根据优惠券的多维数据建立漏斗模型。 ​ 发券数量 - 领券数量 - 使用数量 ​ 另外还有优惠券成本、优惠券支付金额、优惠券新老用户数，等等偏向于业务维度的数据统计。 ​ 假设数据分析发现，大量用户没有领券，我们则需要反思我们渠道是否存在问题，导致优惠券的曝光不足。 ​ 亦或者领取到使用的转化低于预期，我们则需要考虑，领券用户是否对商品不感兴趣，或者券的价值过小，最终导致用户领券，但没有足够的下单动机。 ​ 总之，在领券与使用2个环节的转化漏斗结合用户画像，以及渠道的，等相关影响因素，可以分析出一些宝贵的结论，再反哺下一次的优惠券营销活动。 最后​ 优惠券作为saas电商系统最常见的营销活动，在用户的拉新、促活、转化，等多个维度都可以发挥作用，是作用极大的，贯穿整个系统的功能，所以各位产品，一定要思考用户的需求，慎重做产品决策，构建出操作便捷、功能强大的优惠券模块。","categories":[{"name":"产品","slug":"产品","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"营销工具","slug":"营销工具","permalink":"https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"},{"name":"优惠券","slug":"优惠券","permalink":"https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"}]},{"title":"runtime运行时","slug":"vue3源码解读/runtime相关","date":"2023-09-28T16:00:00.000Z","updated":"2023-11-27T02:44:34.885Z","comments":true,"path":"2023/09/29/vue3源码解读/runtime相关/","link":"","permalink":"https://bluedancers.github.io/2023/09/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/runtime%E7%9B%B8%E5%85%B3/","excerpt":"","text":"虚拟dom存在2个非常核心的概念 挂载：mount 更新：patch h函数作用，生成vnode render函数的作用，解析vnode并生成真实dom h函数源码地址在：packages&#x2F;runtime-core&#x2F;src&#x2F;h.ts 首先进入h函数 h函数存在3个参数 12345type：当前节点类型propsOrChildren：props或者childrenchildren：子节点 该函数的作用就是处理好以上三个函数的传参的多种情况。 然后再将处理好的type，props，children传入到createVNode函数中 createVNode最终会执行_createVNode函数，只不过开发环境会做一些额外的处理 对于初始化的组件来说，_createVNode的主要目的就是给当前组件增加组件类型标识shapeFlag 然后进入createBaseVNode，在该出构建了完成的VNode，并根据children的字段，重新计算shapeFlag，最终返回vnode 小结：h - createVNode - _createVNode - createBaseVNode h函数 处理入参，使其标准化的进入到vnode创建流程 根据type类型预先赋值shapeFlag，并增强处理class与style 构建VNode基础数据 根据children的类型，再次刷新ShapeFalg，完成对组件类型的全部标识。 h函数最终就是要生成可用于render函数渲染的vnode数据 render函数在h函数中处理过去的vnode，将会在render函数中被渲染为真实dom render的核心代码在runtime-core中进行实现，核心代码与平台式无关的，runtime-dom中存放所有dom渲染相关的代码 在导出render之前，首先会将dom相关方法放入render函数，我们使用的render其实已经被处理过了 代码执行流程大概如下 render：传入vnode与挂载阶段 patch：判断阶段类型，进入对应渲染函数 processElement：文本组件进入这里，首先判断是更新还是新增 mountElement：新增文本组件进入该函数 （创建节点 填充数据 设置props 插入dom）","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"营销工具(1) - 人人都爱用的优惠券，背后逻辑竟然这么复杂？","slug":"产品相关文章/营销工具（1） - 人人都爱用的优惠券，背后逻辑竟然这么复杂？","date":"2023-09-28T16:00:00.000Z","updated":"2023-11-27T03:03:54.999Z","comments":true,"path":"2023/09/29/产品相关文章/营销工具（1） - 人人都爱用的优惠券，背后逻辑竟然这么复杂？/","link":"","permalink":"https://bluedancers.github.io/2023/09/29/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%881%EF%BC%89%20-%20%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%88%B1%E7%94%A8%E7%9A%84%E4%BC%98%E6%83%A0%E5%88%B8%EF%BC%8C%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F/","excerpt":"","text":"带着问题思考 为什么淘宝要把优惠券规则设计的那么复杂？ 为什么不直接降低价格，而是使用优惠券才可以优惠? 商家发放优惠券的目的究竟是什么？ 为什么公司就算被消费者唾弃，也要大数据杀熟。 看完这篇文章，你将理解以上这些令人费解的事情。 前言​ 最近负责的Saas商城系统中的优惠券模块开始重构，借此机会作者也打算深入学习与理解优惠券，了解优惠券的前世今生，为后续的产品功能设计环节做好知识储备，避免浅尝辄止的借鉴竞品。 ​ 让我们搭乘时光机，先回到工业革命时代，看看优惠券是如何“诞生”与“破圈”的，成为人们生活中的一部分。 时间的齿轮开始转动 ​ 根据广告学中目前公认的说法，全世界首张优惠券是美国著名广告文案撰写人克劳德.霍普金斯发明的，他为一款炼乳产品在报纸上设计了一张优惠券，消费者撕下报纸的优惠券，再凭借优惠券去购物便可以享受到优惠。 ​ 19世纪中后期，美国工业革命走向巅峰，随着工业化的兴起与城市化的快速发展，商店、百货公司的数量开始高速增加，购物流程上已经开始现代化，从早期的顾客将想要的商品告知店员，店员将商品从货架拿到顾客手中，演变成了自助选购模式。 ​ 商店数量的增加以及早期供应链的完善，产品与服务开始同质化，竞争也随之变得越发激烈，百货公司与百货公司、品牌与品牌之间逐渐开始相互内卷； ​ 在19世纪后期，广告成本非常低廉，主要有以下原因 由于科技水平的限制，广告多为报纸、海报，广告覆盖与传播的范围有限 19世纪后期并不是信息过载的时代，竞争不算激烈，消费者对广告的接受度较高。 电子印刷术进入普及阶段，同时简单的文字与配图被被用户广泛接受，制作成本低。 没有广告法的限制，进一步降低广告的制作成本 ​ 而一部分人已经看到了营销对产品的巨大影响，大批企业开始肆无忌惮的投放广告，巨幅墙体海报、有轨电车海报、报纸、促销宣传单，广告开始越来越多的，以各种各样的形式出现在大家的生活中，还有公开分发优惠券以及在用户消费后赠送固定折扣券的行为； ​ 不过19世纪末期，整个市场仍处于增量阶段，所以那时宣传依旧具有良好的效果，优惠券这样的营销方式还没有引起大家足够的注意。 ​ 到这里，我们没法不谈谈这个世界上最伟大的公司之一Coca Cola，根据互联网现存资料的主流声音，优惠券模式通过可口可乐完成被更多人所了解。 ​ 同样在19世纪末期，可口可乐的营销负责人非常相信广告曝光的巨大价值，他采用各种平面海报、免费饮品券的方式，来开展可口可乐的营销工作，后续靠产品的上瘾性形成复购（上瘾是因为那时候的可口可乐里面含有可卡因）。 ​ 当时谁也没想到，那时候不受待见的免费饮品券综合下来竟然是效果最好的，因为早期彭伯顿（coca cola创始人）认为免费券不挣钱了，因为可口可乐的上瘾性，用户侧反映出极高复购率，让彭伯顿不禁相信，专业的事情还是应该专业的人来做。 ​ 于是免费饮品券开始被大力使用，甚至通过邮寄的方式直接送到你家门口，优惠券玩法第一次出圈，当然可口可乐的成功是非常复杂的，优惠券仅仅是一段小小的佳话。 ​ 非常幸运的是，这样的一张优惠券，目前在互联网上依旧可以找到 this card entitles you to one glass of free coca cola at the fountain of any dispense of genuine coca cola 图片的中文是：这张卡可以让您在任何出售真正可口可乐的饮料机处免费领取一杯可口可乐。 我们来简单分析一下，coca cola免费饮品券发挥的作用是什么，或者说传统优惠券有何作用？ 极大降低用户的首次消费门槛，用户面对折扣与免费的优惠，倾向于立即行动，可快速刺激销量。 创新与新颖性，免费优惠券是新颖的概念，用户收到免费优惠券后，会存在兴趣与好奇心。 其实除此之外，传统优惠券还有以下作用 增加品牌忠诚度，用户通过优惠券获取额外的价值的时候，会对品牌产生积极的情感。 清除库存与滞销商品，通过该优惠券的方式来达到快速周转的目的。 ​ 总的来说，传统优惠券就一个点：无套路！真的优惠了！ ​ 虽然初代优惠券的方式很原始，但是已经符合大部分人对优惠券的认知了，而在美国19世纪前中期的大萧条阶段，消费者为了省钱，经常会收集各种优惠券，优惠券进一步受到用户的青睐。 ​ 在后来的几十年中，互联网时代来临之前，优惠券早已被大众广泛接受，不过其核心玩法和概念没有变化，只不过是表现形式上会变的更加新颖，产品描述、售价依旧是重点、如果是免费的会写一个大大的FREE。 在互联网时代优惠券发生变化了吗？​ 当我们了解了优惠券的历史后，现在让我们搭乘时光机器回到互联网时代，看看100多年后的出现的电子优惠券有何变化。 ​ 先说结论：互联网的电子优惠券玩法相对传统优惠券是颠覆式的改变 ​ 到底改变了什么？我先卖个关子，这100年间发生了太多改变人类事情，所以在讲电子优惠券之前，我们首先了解一些极其重要又简单的经济学概念。 需要提前了解的经济学概念差别定价​ 差别定价又被称为价格歧视，表示生产者针对相同生产成本的产品，以不同的价格售予不同的买家，这并非是一个贬义词，只是商家为了利益最大化的一种方式。 简单来说就是有钱多花点，没钱少花钱。 消费者剩余消费者剩余 &#x3D; 用户可接受最高价 - 实际售卖价 比如一个手机，张三本来打算5000块钱买，但是这时候突然拿到了一个500块优惠券，张三最终以4500块就买下了的手机。 此时，消费者剩余就是5000 - 4500 &#x3D; 500，而商家的成本是3500，生产者剩余为4500 - 3500 &#x3D; 1000，虽然商家挣了1000块，但是他原本是可以挣消费者1500块，所以消费者剩余越大，商家越不赚钱。 利润最大化​ 我们还是看上面的案例，张三可接受的最高价是5000元，实际消费了4500元，消费者剩余是500元，理想情况下，商家希望用户都通过可接受最高价进行购买，这样的情况下商家利润最大，消费者也依旧愿意购买。 ​ 而针对这个5000的手机，张三消费能力强，5000块愿意购买，李四消费能力弱，最多愿意4500元购买，王五是个学生，最多愿意4000元购买，那么最理想的情况则是，大家分别按照自己的能接受的最高价进行购买。 ​ 张三消费5000、李四消费4500、王五消费4000，张三、李四、王五的消费者剩余均为0，这样的情况下，商家看起似乎打折少挣钱了，实际上却是最挣钱的状态，也就是利润最大化。 线下优惠券的局限性​ 在互联网到来的前夕，企业就已经在讨论如何利用优惠券实现收益最大化。大家都发现了一个非常难以解决的问题，精准投放无法实现。 ​ 比如同样在纽约的张三与李四，张三相对富裕，而李四是一个穷苦大学生，他们都喜欢吃肯德基的单人套餐。 ​ 假设肯德基的单人套餐原价是30元，张三没有觉得原价贵，无论是否有券，他都会直接买，而李四不是，只有在打折到8折及以下的时候，他才会有消费动机。 ​ 最后让我们假设，肯德基的单人套餐综合成本是15元 ​ 在不发券的情况下，张三30元购买，消费者剩余是0，商家实现了收益最大化，但是李四不会买，没有收益； ​ 在发券的情况下，张三与李四都会获取优惠券，假设是8折券，此时张三和李四都会去消费了，张三平时30元也会买，但是现在他只需要花24元，而李四呢，8折优惠券达到了他可下单的最高价，他使用8折券进行下单了； ​ 现在在让我们看一下发券场景下，张三与李四的消费者剩余 ​ 张三可接受最高价30，实际消费 24，商品成本价15，消费者剩余6元，没有实现收益最大化 ​ 李四可接受最高价24，实际消费 24，商品成本价15，消费者剩余0元，实现了收益最大化 ​ 虽然少挣了张三的钱，但是多获得了李四的钱，似乎比不发券的效果好；但是这依旧不是理想的效果，因为张三还存在消费者剩余。 ​ 但是券也不能一直发，长时间这样会降低品牌形象，影响消费者对品牌的信心，并提升用户对价格的敏感度，造成不可逆的严重影响，到那时候再想提价就极其困难了。 ​ 最理想的结果应该是让大家都按照自己可接受最高价购买，用户愿意购买，商家收益最大化 ​ 张三消费能力强，不应该给他发券，他使用原价30元进行消费，消费者剩余为0 ​ 李四消费能力弱，从高折扣券陆续发到低折扣券，不断试探用户可接受的最高价，直到消费者剩余为0 ​ 只有这样，商家才能实现收益最大化。 ​ 但是线下优惠券由于投放不精准问题，是无法达到理想效果的，所以商家极难实现收益最大化。但是互联网的出现改变了这一切。 线上优惠券的出现​ 我们的主角终于要登场了，时间来到了21世纪初期，并将视野聚焦到我们身边的国家，日本。 ​ 日本的移动互联网的发展在当时是全球领先的，2010年3G网络几乎就达到了100%的覆盖率，在这样的背景下，日本麦当劳找到了优惠券投放不精准的解法。 ​ 日本麦当劳此前一直想尽量收集消费者信息，比如用户的性别、年龄，来为用户提供更加精准的优惠券，具体做法就是需要用户自行填写个人信息，但是收效甚微。 ​ 但是如果大家都通过线上进行消费呢？通过交易系统的将可以准确的采集到每个人的消费信息，并记录在数据库。 ​ 基于用户数据 + 用户信息挖掘系统，分析用户的消费频次、消费门店、消费金额、购买品种，便可以猜测出用户的消费水平与消费习惯，进而通过电子优惠券的方式实现精准营销 对于经常购买汉堡的用户，发放小食优惠券，增加用户消费上限 对于一段时间未关顾的用户发放以前经常购买产品的优惠券 对于价格敏感型用户，这发放更加大幅的优惠券刺激用户的消费 ​ 线上优惠券的出现完全改写了传统优惠券的定义，从商家决定优惠券是什么，变成由用户自己的消费习惯决定优惠券是什么，完全脱离了以前的单纯的打折促销的作用。 ​ 而是经过数据分析、精准营销，再通过电子优惠券的方式，实现了不同用户的相同产品的差别定价，更大限度的实现消费者满意，商家利润最大化的理想状态。 ​ 电子优惠券带着他无法取代的优势开始被大众所熟知，用户分群、基于用户的消费习惯动态给予优惠券的精准营销逻辑开始进入大家的生活，优惠券进入了全新的时代； ​ 那么问题来了，新时代的优惠券还可以为大家省钱吗？ ​ 优惠券真的是为了给大家省钱吗？​ 电子优惠券的出现确实让消费者省钱了，但是商家也挣钱了，这看似不合理，买家更省钱，卖家更挣钱，钱还能凭空变出来不成？ ​ 只有一种可能，省钱的消费者和不省钱的消费者不是一拨人，而电子优惠券做到了用户分群。 ​ 让我们看看这几年的双十一购物节，淘宝令人诟病的复杂优惠券机制，站在用户视角，一定是让大部分人不耐烦的，直接把优惠给我不就行了吗？站在淘宝的视角，给用户优惠，但是不能无脑给，给的同时要实现收益最大化，想要收益最大化就需要让尽可能多的人使用可接受的最高价下单，大家在淘宝花时间玩游戏也好，活跃也好，如果感觉价格合适了，一般就不存在足够的动机继续下去，于是为了商家、平台的利益最大化，淘宝设定了一套复杂的优惠机制，让消费者利用时间与精力换取优惠。 ​ 当价格高于心理可接受的最高价的时候，时间与精力的价值小于优惠的价值，用户会自发性的参与活动，获取优惠。 ​ 当价格低于心理可接受最高价的时候，用户则没有足够的动机继续参与活动获取优惠，而是进入下单流程。 ​ 通过这样一个付出成本获取优惠的机制，实现了针对不同用户的动态优惠，完成了用户分层与针对每个用户的区别定价；最终不同消费能力的用户都认为省钱了，同时消费者剩余为0，商家+平台利润最大化状态。 相比较与传统优惠券，电子优惠券有一些非常突出的优点 电子优惠券实现了动态定价，让商品覆盖到了更多的维度，同时更大限度的实现了消费者剩余为0。 价格标高 + 复杂的优惠券规则，实现对用户的分层，动态实现利润最大化，这个本质上是优惠券 + 大数据 &#x3D; 卡用户心里最高价。 传统优惠券与现代优惠券​ 当我们用传统的优惠券思维，去理解电子优惠券的时候，一切似乎都不合理，而看懂了基于互联网的优惠券的逻辑，我们才能解释现代世界中发生很多事情。 为什么会存在大数据杀熟？ 为什么不直接降价而是让用户通过优惠券的方式来购买？ 为什么商家千方百计的想获取你的信息？ 为什么现如今数据是极其宝贵的资源？ ​ 商家、平台在满足用户需求的情况下，都是为了收益最大化而努力，凭借消费者的用户信息、用户标签、消费习惯，等等信息，实现收益最大化； ​ 通过以上案例与分析，我们可以发现电子优惠券和传统优惠券早已经不是一种东西，虽然他们都叫优惠券，电子优惠券虽然很厉害，但是也存在很强的开发成本与技术壁垒，传统优惠券虽然能力有限，但是使用门槛很低，成本更低。所以也不能片面说电子优惠券就是好，传统优惠券就是差，思考自己拥有的资源与需求，理性判断最合适的产品方案即可。 最后​ 本来只是想回顾一下优惠券的历史，结果一不小心就写了一篇5000字的文章，无论是消费者还是商家，理解优惠券的规则都可以帮助大家更好的理解这个世界发生的事情。 ​ 下一篇文章，我们将进入实战篇，谈谈营销工具 - 优惠券的产品设计逻辑。 ​ 参考资料2万字深度拆解可口可乐百年营销史：如何从冷启动到风靡全世界？ 我无比怀念肯德基和麦当劳的纸质优惠券 艾瑞咨询 日本3G市场","categories":[{"name":"产品","slug":"产品","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"}],"tags":[{"name":"营销工具","slug":"营销工具","permalink":"https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"},{"name":"优惠券","slug":"优惠券","permalink":"https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"}]},{"title":"从读《微信背后的产品观》到思考前端工程师的“35岁”","slug":"阅读/从读《微信背后的产品观》到思考前端工程师的“35岁”","date":"2023-08-09T16:00:00.000Z","updated":"2023-11-27T02:43:09.900Z","comments":true,"path":"2023/08/10/阅读/从读《微信背后的产品观》到思考前端工程师的“35岁”/","link":"","permalink":"https://bluedancers.github.io/2023/08/10/%E9%98%85%E8%AF%BB/%E4%BB%8E%E8%AF%BB%E3%80%8A%E5%BE%AE%E4%BF%A1%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E3%80%8B%E5%88%B0%E6%80%9D%E8%80%83%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E2%80%9C35%E5%B2%81%E2%80%9D/","excerpt":"","text":"​ 我是一名前端开发者，同时兼任pm职责，近半年在公司负责升级一直在开发与运营的一个B端的Saas商城系统； ​ 在对需求剖析、需求抽象、每个字段含义的推敲的时候，我越发对微信这样简洁、自然的产品产生兴趣与共鸣。 ​ 也会情不自禁的赞叹微信清晰明了、谨慎内敛的结构化产品思路。 ​ 虽然微信这么多年上线了如此多功能与特性，但是产品简洁而克制的灵魂从来没有改变，哪怕对于60岁的人来说，也几乎不存在用不好微信的情况。 ​ 而我做为微信的使用者，广义技术上的开发者，无论是产品还是技术维度，都让我越加佩服与引起共鸣(恶心的小程序开发除外)。 ​ 昨天终于行动了起来，把这本知名的《微信背后的产品观》找出来并读了起来，与其叫一本书，不如说是一个演讲的记录，很短，大约2小时就读完了，主要内容是2012年微信4.0发布时候，张小龙长达8个多小时的公开演讲的内容； ​ 不同于其他产品经理的书籍，他们会告诉你各种方法论、科学分析方法，张小龙截然相反的采用了一种极其浪漫的方式去看待产品，去理解所谓的用户需求，我认为这种产品思路的领先是微信这么多年在社交领域立于不败之地的根本。 ​ 虽然在最后，张小龙看似补刀似的说：我所说的，都是错的；但是这恰恰就是他的产品理念，所谓产品没有任何科学方法，完全来自于对人，对人类群体的理解，对自己的拷问与质疑。 ​ 我也斗胆推荐大家看看这本书，很快就能看完，人类之所以存在信息差，就是因为不知道，或许看完这本书，你会打开新的思路，某些问题也能豁然开朗。 ​ 借此机会，我也想与大家分享一下，这几年我作为一名前端开发者的迷茫与努力。 业务前端开发者的困境 我只是一名普通学历，普通的业务前端开发者，所以以下仅是我的个人感觉，不代表所有前端开发者。 ​ 目前在一个小型互联网公司的saas电商部门下，主要职责是前端开发组长，我们公司的主营业务不是saas电商，所以这几年算不上受到到很强的市场冲击，平时会管理几人的小团队，我18年毕业至今，一直在这家公司。 ​ 而我大学毕业之后一直从事前端开发方向，在我工作1-3年的阶段，我都保持着对技术的热情，主要是因为尝到了学习技术的甜头，那时候我坚定的认为下一个阶段是全栈，在工作之余我花费了大量的精力学习技术；但是后面我就发现了一个很现实的问题，公司需要大家更好分工协作，所以高级别的项目后端是绝对轮不到一个前端去开发开发；并不是说能力不行，而是人的精力有限，前后端都干，还要管团队，是忙不过来的。 ​ 在这样的环境下，关于全栈技术的学习，我也越发疑虑，逐渐走到了大多数业务前端开发者的临界点。 业务前端的35岁危机在普通人身上是存在的，我们的年纪、精力、外部压力都不允许你永远征战一线，并始终保持高竞争力。 业务前端的上限很低，大多数努力的前端开发者可以在3 - 5年内触摸到业务前端的上限，职位也就是前端组长。 技术纵深是很好的选择，但是受限于综合实力（英语、计算机基础、天分），普通人可以达到的纵深远比想象的要浅。 技术学会了，但是用不上，也会慢慢被遗忘；demo级别的应用无法让开发者对某一项技术有深刻理解。 在业务开发场景下的前端，永远是没有灵魂的大头兵，上限低就意味着待遇相对较低、可替代性相对较强。 代码写的越多，与人交流的机会越少，对于几十年的人生而言，这是一件很没安全的事情。 ​ 总结一下，就是因为兴趣而走的前端技术路径开始越来越窄，前路开始越来越看不清，时间推着我向前，这不禁让我低头沉思，下一步究竟要怎么走？ 说回产品 到目前为止我也依旧不确定前路怎么走，接下来的一些结论，只是我的一些探索。 ​ 在大学后期，我隐约感觉技术路线并非我所擅长的时候，我有目的的学习了微观经济学、企业管理、竞争战略相关的知识，从而间接接触到了互联网产品，也就是pm。 ​ 我很快就感受到了pm的魅力：创造，我恰好是一个喜欢新鲜事物的人，在技术上总喜欢优化、迭代、升级，亲手构建出优美并且有价值的产品极具满足感，而前端开发者与用户的距离比任何一个岗位都要近，甚至可以说：前端开发者决定了用户体验。 ​ 如果一个人同时具备前端开发 + 产品的能力是不是还不错？ 消除技术与产品的认知壁垒，后续我们做到了，在我们公司，产品和技术从来不吵架 如果有能力决定产品走向，开发者就可以是一名有灵魂的大头兵，甚至晋升军衔。 也就是说，我逐渐不再下探技术，而是走向用户。 ​ 走向用户，并不意味着开发者要放弃对技术的学习，技术很重要，技术能力依旧是核心竞争力，而是随着我对技术的理解逐渐深入，开始越发清晰的了解到，究竟什么样的能力是前端开发者最需要的，什么样的能力边际收益是最高的。 ​ 在我从事前端开发第2年至今，我一直都有在产品这方面作出努力与尝试。 ​ 关于这几年产品的结果，大概可以用这句话来形容： ​ 100个想法中，80个想法死在在调研与分析阶段，15个想法死在在demo阶段，最后落地5个想法，其中4个反响平平，只有1个还算成功。 ​ 虽然绝大部分都是失败，但是站在此刻回头来看，这几年的产品的学习将我的思维高度提升了很多，综合能力也提升了很多，因为很多想法初期是没有团队介入的，凡事都需要亲力亲为，需要思考需求、写最小demo、UI设计、沟通，而上线后，有需要又要为产品负责，就需要进行数据分析，线上数据的观察，等等….，这其实比写代码累多了。 ​ 这些进步不像程序的学习有一个可量化的指标，这样的软实力很多的是一种感觉，虽然依旧是时而迷茫，但是也偶尔会有一些收获。 ​ 虽然我做的产品决策越来越多，公司与同事给予的信任也越来越多，所以在产品上的舞台也是越来越大，而看了《微信背后的产品观》，里面的想法非常符合我对产品的理解，当然我的理解是相对浅显与张小龙没法比的，不过张小龙对产品的理念，以及他对需求的理解，这样一套浪漫的方法论，真的非常有魅力，这也是为什么，我看完最后决定写这篇文章。 跨越“技术”思维​ 这几年，我的老板经常会找我聊天，因为我和他提过对产品很有兴趣，在前两年，他反复和我提一句话技术为业务服务，我当时觉得我理解这句话了。 ​ 我想，这不是废话，写代码最终都是为了公司的项目，为了更好更快的完成公司需求，我要狠狠的学习技术。 ​ 之后来随着我写的代码越来越多，我对这句话逐渐有了新的理解。 ​ 之前过于执着于技术，总是站在写代码的角度去理解，而这句话的侧重点是业务，或者我们换个词交付。 ​ 并不是技术推动交付，而是在推动交付的因素中，技术是其中之一，我们可以衍生出很多类似的话；设计为业务服务、产品为业务服务…. ​ 所以技术的目的并非技术，而是交付价值。 ​ 人们总是不自知的放大自己在团队中的价值，这样只会蒙蔽大家的视野，走到更高处，对很多事物将会有不一样的理解。 低纬度的技术思维，走向高纬度的业务（交付）思维。 最后​ 其实我本来只是觉得读了还不错的一本书，不复盘、不留下点什么反思会达不到学习的目的，写着写着就想到了自己的职业，想到了这几年的经历； ​ 总结性的话不说太多，希望可以帮助到屏幕前你，我们共同成长，共同进步。","categories":[{"name":"书摘","slug":"书摘","permalink":"https://bluedancers.github.io/categories/%E4%B9%A6%E6%91%98/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"张小龙","slug":"张小龙","permalink":"https://bluedancers.github.io/tags/%E5%BC%A0%E5%B0%8F%E9%BE%99/"}]},{"title":"这是我写过的最简单的Vue3中后台动态路由 + 侧边栏渲染方案","slug":"项目解决方案/这是我写过的最简单的Vue3中后台动态路由 + 侧边栏渲染方案","date":"2023-06-14T16:00:00.000Z","updated":"2023-11-27T03:16:52.275Z","comments":true,"path":"2023/06/15/项目解决方案/这是我写过的最简单的Vue3中后台动态路由 + 侧边栏渲染方案/","link":"","permalink":"https://bluedancers.github.io/2023/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BF%99%E6%98%AF%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Vue3%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%20+%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 在3年前发布了一篇vue2后台管理系统动态路由方案，时至今日，vue2已经升级到了vue3，动态路由的实现方案也同步做出了一些升级迭代，帮助开发者们更高效的完成业务需求，然后摸鱼🐟。 ​ 本次逻辑的升级，主要聚焦于2点 更加简单的实现逻辑 更加便捷的路由配置 之前的动态路由方案 前端只存储基础的路由（登录、首页、404） 根据不同的登录角色，返回其对应的可访问路由树 从服务端获取路由树（JSON）并递归处理成vue-router可使用的数据结构，并通过addRouters拼接到基础路由树，完成动态路由 优点 相当安全，项目里面只有基础路由，业务路由全部来自接口 缺点 代码中只保存了基础路由，业务路由的全部字段需要前端开发人员手动录入到超级管理系统之中，维护业务路由非常繁琐。 客户端逻辑相对复杂，addRouters的逻辑必须在路由钩子beforeRouter中完成，这部分逻辑比较烧脑。 有没有一种办法，可以既保留动态路由的特性，也保证代码逻辑的简单性，同时将路由配置回归前端项目呢？ 转变解决思路​ 通过以上分析，我们首先可以明确一点，动态路由的配置数据还是需要放在前端项目中，而不是将路由的配置录入到系统中。所以，我们可以简化系统后台的权限配置，由之前的超多字段简化为两个字段 路由名称、路由标识，仅服务于为角色勾选路由，路由配置交还给前端项目。 ​ 路由的树形结构还是需要录入到系统中，因为我们还需要保留动态路由的核心逻辑，给（角色&#x2F;用户）勾选指定路由。 ​ Vue2版本，我们通过addRouters为项目路由树“做加法”实现动态路由。 ​ Vue3版本，我们则为项目路由树手动“做减法”实现动态路由。 做“减法”实现动态路由首先依旧将我们的全部路由分成2部分，基础路由数组，动态路由数组 基础路由：无论什么角色都可以访问的路由（登录后的公共页面，比如工作台，没有可以为空） 动态路由：拥有权限的角色才可进行访问的路由 123456789101112131415161718192021222324252627282930313233343536373839/** * 基础业务路由 */export const baseRouter: RouteRecordRaw[] = [ //.....]/** * 动态业务路由 */export const asyncRouter: RouteRecordRaw[] = [ //.....]const router = createRouter(&#123; routes: [ // 这一层的路由除了dashboard，其他都是业务无关的路由，比如登录 注册 404 500，不属于动态路由 &#123; path: &#x27;/login&#x27;, name: &#x27;login&#x27;, meta: &#123; title: &#x27;登录&#x27;, &#125;, component: () =&gt; import(&#x27;@/views/login/index.vue&#x27;), &#125;, &#123; path: &#x27;/&#x27;, redirect: &#x27;/dashboard&#x27;, name: &#x27;baseDashboard&#x27;, meta: &#123; title: &#x27;根路径&#x27;, &#125;, component: layout, children: [...baseRouter, ...asyncRouter], // 全部注册到vue-router中 &#125; // ... ],&#125;) 我们直接将全部路由都注册到Vue中，如果不存在鉴权，此时任意角色都可以访问所有页面。 为了实现动态路由的需求，我们只要解决两个问题 如何实现路由拦截，拦截不允许被访问的页面。 如何做减法，筛选出指定的权限树，用于侧边菜单栏的展示。 如何实现路由拦截在用户登录的时候，我们会调用服务端的**获取当前用户权限**接口，获取到当前用户的权限数据 无论后端给我们返回的什么样的接口，嵌套也好、一维数组也罢，我们都将其处理成一维数组 1[&quot;index&quot;, &quot;dashboard&quot;, &quot;root&quot;, &quot;goods&quot;, &quot;goodsList&quot;, &quot;goodsClass&quot;] 并将这样的一维数组，保存到我们全局状态库pinia中，我们假设变量名称为authList。 然后我们再增加路由钩子的逻辑，每次跳转之前，都判断next的页面name在authList中是否存在，如果不存在，则直接404，如果存在，则允许访问 123456789101112131415router.beforeEach((to, from, next) =&gt; &#123; const auth = useAuthStore() // ...... // 登录后逻辑 if (auth.isLogin) &#123; // 判断权限是否通过 if (auth.asyncRouter.includes(String(to.name))) &#123; next() &#125; else &#123; next(&#123; name: &#x27;404&#x27; &#125;) &#125; &#125; else &#123; // 未登录逻辑... &#125;&#125;) 经过beforeEach的逻辑之后，我们现在就已经实现了基本的鉴权，不允许访问的页面，都将404。 递归筛选出菜单树​ 接下来，我们考虑第二个问题，用户登录之后，自身权限获取完毕，用户进入到管理系统内部，右侧显示功能侧边栏，我们不能将不属于该用户的动态路由都显示出来，所以我们需要根据服务端返回的权限数据，实现项目中的动态路由asyncRouter的筛选。 ​ 因为我们路由层级理论上是无限的，所以这里使用递归进行实现比较合理。 实现思路如下 递归遍历asyncRouter路由树，如果路由的name在权限数组内，并且该菜单可显示，则继续递归children，如果没有children则不做处理 如果路由的name不在权限数组中，则将其splice，也就是做减法，并且循环下标后退一位，防止跳过下一个。 12345678910111213141516171819202122/** * 获取可访问路由树 * @param tree */export function loopRouter(tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]) &#123; for (let i = 0, len = tree.length; i &lt; len; i++) &#123; let item = tree[i] if (asyncRouter.includes(item.name!) &amp;&amp; item.meta!.showMenu) &#123; if (item.children) &#123; item.children = loopRouter(item.children!, asyncRouter) &#125; &#125; else &#123; tree.splice(i, 1) len = tree.length // 刷新循环长度 if (i &lt; tree.length) &#123; // 删除后,数组长度-1,数组的下一位前进了一位,所以一旦splice掉不存在的权限,便需要i--,否则会跳过下一位 i-- &#125; &#125; &#125; return tree&#125; 经过以上代码后，我们的路由树便会过滤掉那些不允许被访问的路由 接下来，我们便可以进行菜单的渲染工作了，前端基操我就不做过多赘述了，大家可以看看我精心为大家准备的源码案例。 到此为止，我们的动态路由就实现了，是不是非常简单~ 安全问题有经验的小伙伴会问，用户登录后，刷新页面再访问的时候，我们如何处理权限呢？ 在我看来这有2个方案 方案1（相对简单）：使用pinia的持久化插件pinia-plugin-persistedstate来持久化我们存储pinia的权限数据，无论用户如何刷新，我们的权限数据都一直有效，这样的实现非常简单，但是存在一定的安全隐患，就是心怀不轨的某些人，知道了不允许访问的菜单路由名称之后，可以通过手动修改当前页面的localStorage实现权限的突破。 方案2（更加安全）：在pinia中创建一个变量isRouterInit标识权限是否已经被初始化，如果没获取过权限数据，则为false，如果获取过则为true；每次beforeEach的时候，登录情况下都判断该值是否为false，如果为false，则请求当前角色的权限数据，并在请求完毕后，再进行相关路由拦截逻辑，并将变量isRouterInit改为true，表明权限已经被初始化。 ​ 以上2种方案都可以用，如果安全性要求不是特别高，建议方案1，如果对安全性、实时性要求比较高，则建议方案2。 菜单的排序问题​ 经过实操的小伙伴还会发现一个问题，在项目中的路由排序也许是个麻烦事。 ​ 可能角色A说：我要acb，角色b说：我要bac，但是我们路由表放在项目中，其排序是固定不变的，有什么办法可以实现项目左侧路由树按照后台返回的权限字段数据进行渲染呢？ ​ 其实这个问题很简单，我们针对递归后的动态路由的结果，加一个sort即可。 123456789/** * 获取可访问路由树 * @param tree */export function loopRouter(tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]) &#123; // ..... // 将菜单按照当前拥有权限asyncRouter的顺序排序 return tree.sort((a, b) =&gt; asyncRouter.indexOf(a.name) - asyncRouter.indexOf(b.name))&#125; 这样项目的右侧菜单树就会按照我们后端返回的顺序进行排序了。 不需要的路由可以删除吗？​ vue3提供了动态路由的相关API，其中有一个removeRoute，可以删除不需要的路由，那么，我们在根据登录角色动态删除剔除不需要在侧边栏显示的路由的时候，是否也同步将不需要的路由进行删除呢？ ​ 关于这个问题，我的建议是，不建议删除，首先我们的路由模块均为异步加载的，是否删除一定不会访问的路由，都不会影响项目的加载。而一旦真的删除了，用户在推出登录切换账号的时候，一定要重载当前页面，因为我们不知道用户下一次登录的角色是什么，会不会用到已经被删除的路由。 最后​ B端项目通过动态路由实现角色鉴权，已经是一个非常成熟的方案，无论是使用“加法方案”实现，还是使用“减法方案”，都是可行的，理论上都是对权限的一次递归筛选。 ​ 大家主要根据项目规模、要求合理选择最适合的方案，在安全、便捷、开发难度、稳定性，等多角度做好权衡利弊。","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"动态路由 - vue3","slug":"动态路由-vue3","permalink":"https://bluedancers.github.io/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-vue3/"}]},{"title":"Vue3 笛卡尔积算法构建SKU最佳实践！看完不会来打我","slug":"技术类文章/Vue3 笛卡尔积算法构建SKU最佳实践！看完不会来打我","date":"2023-06-02T16:00:00.000Z","updated":"2023-11-27T02:38:00.358Z","comments":true,"path":"2023/06/03/技术类文章/Vue3 笛卡尔积算法构建SKU最佳实践！看完不会来打我/","link":"","permalink":"https://bluedancers.github.io/2023/06/03/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BASKU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%81%E7%9C%8B%E5%AE%8C%E4%B8%8D%E4%BC%9A%E6%9D%A5%E6%89%93%E6%88%91/","excerpt":"","text":"前言​ 商城一直都是平台研发类的高频项目，也存在诸多含金量与难度非常大的功能点，比如购物车模块、支付模块、装修模块、商品模块、以及很多与业务相关的模块，主导此类复杂需求的开发与落地不仅可以升职加薪，也是面试中的展示肌肉的时刻， ​ 所以今天，我和大家分享一个在正式项目中沉淀出来的Vue3版发布商品 - 构建sku的思路以及具体实现方案；附带源码与案例，点赞收藏不迷路，接下来进入正文~ 源码：https://github.com/BlueDancers/vue3-sku-demo/blob/main/src/views/goods/add/index.vue 案例：https://bluedancers.github.io/vue3-sku-demo 什么是SKU​ 在开始正文之前，首先要做一次扫盲，那就是我们说的电商项目中的SKU，究竟是什么？ ​ SKU的全称是Stock Keeping Units，我们可以理解为商家用于管理商品库存和销售的一种方式。 ​ 每个 SKU 对应着一个若干属性的组合，例如一个商品存在颜色、尺寸、款式等属性。商家可以根据商品的不同属性设置不同的 SKU，并对每个 SKU 进行价格、库存若干信息的管理。 ​ 举个例子，假设商家有一件衬衫商品，有红色、蓝色两种颜色、S、M、L 三种尺码可选。那么该商品便存在 6 个 SKU ，分别为： 红色 S 号 红色 M 号 红色 L 号 蓝色 S 号 蓝色 M 号 蓝色 L 号 在这里我们就要明确一下概念了，颜色、尺码都是我们的商品属性中的销售属性，而生成的 红色 S 号 红色 M 号 等等 就是我们的SKU。 再让我们在看看某宝的SKU选择弹窗 ​ 这个商品的销售属性：尺码（6个） 颜色分类（6个），那么通过销售属性，最终将会生成6*6&#x3D;36个SKU，而用户选择任意尺码 + 颜色分类的搭配都可以匹配到具体的价格与库存等信息。 ​ 以上提到的功能点，就设计到电商后台的商品模块的SKU构建知识点，接下来让我们看看，如何使用Vue3构建SKU。 具体实现构建销售属性​ 通过上面的案例，我们得知了SKU并非凭空捏造出来的，而是由销售属性动态生成。 ​ 那么根据某宝的SKU信息，我们反向推导一下，他的销售属性的数据结构可能是这样 123456type skuAttrItemType = &#123; title: string // 销售属性名称 values: &#123; attributeValue: string // 属性名称 &#125;[]&#125; ​ 如果，不考虑SKU的图片，我们的每个销售属性的数据结构都这样，存在一个销售属性的名称，以及若干个属性值。 ​ 我们继续观察某宝，发现无论如何修改尺码，白色的图片都是同一张，不会随着尺码的变化而变化，因此我们可以推断出，sku的图片是由着销售属性进行设置的； ​ 另外还要注意一个细节，一个商品无论存在多少个销售属性，最终只能为其中一个销售属性设定图片，所以我们优化一下我们的销售属性数据结构，增加销售属性图片的字段。 12345678type skuAttrItemType = &#123; title: string // 销售属性名称 isAddImage: boolean // 是否上传图片（最多只能打开一个） values: &#123; attributeValue: string // 属性名称 thumbnailUrl?: string // 属性图片 &#125;[]&#125; ​ 于是，我们便可以得出我们案例的数据结构 1234567891011121314151617181920let skuAttrItemType = [ &#123; title: &#x27;尺码&#x27;, isAddImage: false, values: [ &#123; attributeValue: &#x27;S&#x27; &#125;, &#123; attributeValue: &#x27;M&#x27; &#125;, // .... ], &#125;, &#123; title: &#x27;颜色分类&#x27;, isAddImage: true, values: [ &#123; attributeValue: &#x27;白色&#x27;, thumbnailUrl: &#x27;...白.png&#x27; &#125;, &#123; attributeValue: &#x27;黑色&#x27;, thumbnailUrl: &#x27;...黑.png&#x27; &#125;, // .... ], &#125;,] ​ 这样的数据结构便满足了我们客户端渲染商品SKU，用户可以将不同的尺码与颜色分类进行搭配，但是我们目前仅能实现SKU的选择，还无法满足用户选择任意尺码 + 颜色分类的搭配后，立刻得知价格的场景。 这也是我们下一步需要解决的问题，就是基于销售属性构建商品SKU。 使用笛卡尔积算法实现商品SKU的构建基于以上销售属性，我们的目标是构建一个如下的结构 12345678910111213141516171819202122let sku = [ &#123; attributeValue: &#x27;S,白色&#x27;, thumbnailUrl: &#x27;...白.png&#x27;, // ... 价格 库存 等等信息 &#125;, attributeValue: &#x27;S,黑色&#x27;, thumbnailUrl: &#x27;...黑.png&#x27;, // ... 价格 库存 等等信息 &#125;, &#123; attributeValue: &#x27;M,白色&#x27;, thumbnailUrl: &#x27;...白.png&#x27;, // ... 价格 库存 等等信息 &#125;, &#123; attributeValue: &#x27;M,黑色&#x27;, thumbnailUrl: &#x27;...黑.png&#x27;, // ... 价格 库存 等等信息 &#125;,] SKU的生成是存在明确的运算规则的，销售属性的属性名称的数量的乘积等于SKU的数量。 比如我们上线的销售属性是 两个尺码 两个颜色分类，则生成的SKU数量2 * 2 &#x3D; 4个 假如我们存在三个尺码 三个颜色分类，则生成的SKU数量3 * 3 &#x3D; 9个 假如我们再多一个销售属性 两个尺码 三个颜色 四个风格，则生成的SKU数量为 2 * 3 * 4 &#x3D; 24个 ​ 我们程序如何实现以上逻辑呢？大部分小伙伴面对这样的诉求的第一反应应该都是递归，因为销售属性的数量是未知的，写死循环实现是不现实的，不过在SKU生成上，我们一般使用更加简单的笛卡尔积算法。 ​ 笛卡尔积：笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积，又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 。 接下来，我们就来实现这一部分的逻辑 sku的生成是实时的，销售属性的变化会引发sku的变化，所以我们需要监听销售属性的变化，这里我们通过watch进行实现 笛卡尔积本身不复杂，熟练了解reduce即可，如果有点忘记了，请去MDN复习一下~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type skuAttrItemType = &#123; title: string // 销售属性名称 isAddImage: boolean 是否上传图片（限制最多只能打开一个） values: &#123; attributeValue: string // 属性名称 thumbnailUrl?: string // 属性图片 &#125;[]&#125;// 监听销售属性的变化,并构建skuwatch( () =&gt; skuAttributes.value, (value) =&gt; &#123; if (value.length) &#123; generateSku(deepClone(value)) &#125; &#125;, &#123; deep: true &#125;)/** * 更新销售属性构建sku * @param skuAttribute */function generateSku(skuAttribute: skuAttrItemType[]) &#123; let attrValue: any[] = [] skuAttribute.map((item) =&gt; attrValue.push(item.values)) // 获取所有属性名称 =&gt; [[&#x27;S&#x27;,&#x27;M&#x27;], [&#x27;白&#x27;,&#x27;黑&#x27;]] // 开始构建sku let skus: any[] = [] // 笛卡尔积算法（注意，我们的reduce没有指定第二个参数，则第一次循环中，col是数组第一位，set是数组第二位） skus = attrValue.reduce((col: any[], set) =&gt; &#123; let res: any[] = [] // 对于每个属性值集合，依次与当前已有的结果集做笛卡尔积 col.forEach((c) =&gt; &#123; set.forEach((s) =&gt; &#123; // 将两个属性值合并为一个字符串，并存入结果集中 let t = c.attributeValue + &#x27;,&#x27; + s.attributeValue // 寻找销售属性指定的图片 res.push(&#123; attributeValue: t, thumbnailUrl: c.thumbnailUrl || s.thumbnailUrl || &#x27;&#x27; &#125;) &#125;) &#125;) // 将笛卡尔积后的结果集返回，作为下一轮的结果集 return res &#125;) // 将结果存储起来 stockKeepUnits.value = skus&#125; 经过以上的代码，我们变化销售属性，就会得出以下的结果 123456789101112131415161718let sku = [ &#123; attributeValue: &#x27;S,白&#x27;, thumbnailUrl: &#x27;...白.png&#x27;, &#125;, &#123; attributeValue: &#x27;S,黑&#x27;, thumbnailUrl: &#x27;...黑.png&#x27;, &#125;, &#123; attributeValue: &#x27;M,白&#x27;, thumbnailUrl: &#x27;...白.png&#x27;, &#125;, &#123; attributeValue: &#x27;M,黑&#x27;, thumbnailUrl: &#x27;...黑.png&#x27;, &#125;,] 这便实现了我们的sku算法，无论是多么复杂的销售属性，都可以通过该函数，输出符合预期的SKU。 这时候有同学要说了，哎，我SKU的价格，库存等等属性呢？ 这还不简单？赋值之前再循环一遍，增加字段即可。 123456789skus.map((e: skuType) =&gt; &#123; e.price = &#x27;&#x27; // 价格 e.marketPrice = &#x27;&#x27; // 市场价 e.stock = &#x27;&#x27; // 库存 e.specificationBarCode = &#x27;&#x27; // 销售规格 return e&#125;)// 将结果存储起来stockKeepUnits.value = skus 最终我们得到了这样的结果 12345678910111213141516171819202122232425262728293031323334let sku = [ &#123; attributeValue: &#x27;S,白&#x27;, thumbnailUrl: &#x27;...白.png&#x27;, price: &#x27;&#x27;, marketPrice: &#x27;&#x27;, stock: &#x27;&#x27;, specificationBarCode: &#x27;&#x27;, &#125;, &#123; attributeValue: &#x27;S,黑&#x27;, thumbnailUrl: &#x27;...黑.png&#x27;, price: &#x27;&#x27;, marketPrice: &#x27;&#x27;, stock: &#x27;&#x27;, specificationBarCode: &#x27;&#x27;, &#125;, &#123; attributeValue: &#x27;M,白&#x27;, thumbnailUrl: &#x27;...白.png&#x27;, price: &#x27;&#x27;, marketPrice: &#x27;&#x27;, stock: &#x27;&#x27;, specificationBarCode: &#x27;&#x27;, &#125;, &#123; attributeValue: &#x27;M,黑&#x27;, thumbnailUrl: &#x27;...黑.png&#x27;, price: &#x27;&#x27;, marketPrice: &#x27;&#x27;, stock: &#x27;&#x27;, specificationBarCode: &#x27;&#x27;, &#125;,] 数据准备妥当后，接下来我们就可以渲染表格了，这都是前端基操，我就不做过多赘述，有兴趣的朋友，可以看看源码以及我精心为大家准备的案例。 实现SKU数据缓存如果大家仔细想以上代码，会发现一个问题 ​ 假设，运营人员在发布商品的时候漏填了一个销售属性，尺码L，但是这时候运营已经填写好了SKU表格中的信息，如果这时候运营想增加字段，根据我们上面的代码，会触发skuAttributes.value的watch，进而运行generateSku，开始重新构建SKU，导致运营人员之前的数据全部被重置了。 ​ 而以上提到的场景是项目实际运营期间非常常见的场景，那么有没有办法，可以实现SKU的变动，不影响已经填写好的SKU呢。 ​ 实现起来其实也很简单，那就是，我们保存每一次生成的SKU的副本，然后在下一次SKU重新构建的时候，对比副本，再回填信息。 思路如下： 实时保存SKU的副本 SKU重新构建的时候对比副本 销售规格一致的SKU回填副本数据 123456789101112131415161718192021222324252627282930let afterSku: skuType[] = []// 监听sku本身的变化,并将当前sku进行备份watch( () =&gt; stockKeepUnits.value, (value) =&gt; &#123; afterSku = deepClone(value) &#125;, &#123; deep: true &#125;)/** * 更新销售属性构建sku * @param skuAttribute */function generateSku(skuAttribute: skuAttrItemType[]) &#123; // ..... // 增加,回显相关字段 skus.map((e: skuType) =&gt; &#123; // 寻找销售规格一致的副本数据 let old = afterSku.find((item) =&gt; item.attributeValue == e.attributeValue) e.id = old == null ? &#x27;&#x27; : old.id e.price = old == null ? &#x27;&#x27; : old.price e.marketPrice = old == null ? &#x27;&#x27; : old.marketPrice e.stock = old == null ? &#x27;&#x27; : old.stock e.specificationBarCode = old == null ? &#x27;&#x27; : old.specificationBarCode return e &#125;) stockKeepUnits.value = skus&#125; 当然也可以是其他回填规则，比如按照下标的方式回填，这就看具体业务的要求了，基于副本我们便完成了SKU的变动后数据的缓存功能。 最后我们vue3版本的商城项目的SKU核心实现到此就全部结束了，如果你想了解全部代码，请点击这里，如果你想测试案例，请点击这里 作为一名Vue3开发者，你可能对这个专栏感兴趣 Pinia 源码分析专栏 Vue3 硬核源码解析系列 写给前端nginx教程","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://bluedancers.github.io/tags/vue3/"},{"name":"sku","slug":"sku","permalink":"https://bluedancers.github.io/tags/sku/"}]},{"title":"Vue3硬核源码解析系列（7）watch源码解析.md","slug":"vue3源码解读/Vue3硬核源码解析系列（7）watch源码解析","date":"2023-05-17T16:00:00.000Z","updated":"2023-11-27T02:40:13.017Z","comments":true,"path":"2023/05/18/vue3源码解读/Vue3硬核源码解析系列（7）watch源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/05/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 原本打算本章讲讲computed，但是computed的源码相当复杂，使用文章的形式说清楚，难度真的很大，所以暂时跳过computed，先说说watch。 ​ watch即为监听的意思：监听响应式数据，每当状态发生变化，就会触发回调函数。 ​ 如果大家对之前的源码分析有所理解的话，我相信大家可以猜到watch实现原理，一定是初始化的时候进行依赖收集，依赖项发生变化的时候依赖触发。 ​ 如果能领悟到这一层，那么对vue3的核心实现你已经有所理解啦。 ​ 接下来就让我们走进watch的世界，让我们看看，vue3是如何实现他的吧。 首先还是放出watch的逻辑图，watch的逻辑相对简单，因为对于watch而言，响应式是其一部分逻辑。 带着问题看源码在我刚刚使用Vue3 watch的时候，经常出现以下让我无法解释的情况。 1234567891011121314151617// reactive的案例const user = reactive(&#123; name: &#x27;卖鱼强&#x27; &#125;)watch(user, (value) =&gt; console.log(&#x27;第一&#x27;, value)) // 有效watch(user.name, (value) =&gt; console.log(&#x27;第二&#x27;, value)) // 无效watch(() =&gt; user, (value) =&gt; console.log(&#x27;第三&#x27;, value))// 无效watch(() =&gt; user.name, (value) =&gt; console.log(&#x27;第四&#x27;, value))// 有效user.name = &#x27;狂飙强&#x27; // 修改reactive 期望触发watch// ref案例const user = ref(&#x27;卖鱼强&#x27;)watch(user, value =&gt; console.log(&#x27;第一个watch&#x27;, value)) // 有效watch(user.value, value =&gt; console.log(&#x27;第二个watch&#x27;, value)) // 无效watch(() =&gt; user, value =&gt; console.log(&#x27;第三次watch&#x27;, value)) // 无效watch(() =&gt; user.value, value =&gt; console.log(&#x27;第四次watch&#x27;, value)) // 有效user.value = &#x27;狂飙强&#x27; // 修改reactive 期望触发watch 以上案例，我相信大部分写vue的同学，都很难在第一时间准确判断其watch是否有效无效，接下来就让我们一起从源码中寻找答案。 正文watch的源码并不在reactivity中，而是在runtime-core中 关于这一点我会谈谈我的想法，讨论一下为什么不在reactivity中，而在runtime-core中。 watch初始化当我们使用watch的时候，其执行的具体源码位置为packages/runtime-core/src/apiWatch.ts line131 123456789101112export function watch&lt;T = any, Immediate extends Readonly&lt;boolean&gt; = false&gt;( source: T | WatchSource&lt;T&gt;, cb: any, options?: WatchOptions): WatchStopHandle &#123; return doWatch(source as any, cb, options)&#125;export interface WatchOptions &#123; immediate?: boolean deep?: boolean&#125; 通过以上代码，我们可以了解到，watch是存在三个参数的 source ：监听项 cb：watch的回调函数 options： 关于watch的设置，内部存在2个参数 immediate 首次是否运行 deep 是否深度监听 这些消息和我们通过Vue文档了解到的信息完全一致，最终我们会发现，其实际返回了一个doWatch函数，并将watch的三个参数传递了进去。 doWatch内部的逻辑就是watch实现的核心逻辑了，我们从三个阶段分析doWatch的代码。 第一阶段：处理source，监听项分析 第二阶段：构建响应式模块，完成依赖收集 第三阶段：明确依赖触发方式 第一阶段：处理source，监听项分析我们在使用watch的时候，第一个参数，也就是被监听项，是可以传入很多类型的，ref reactive function array，在doWatch函数中，我们可以看到，针对不同类型与属性的source，都做了个性化的依赖处理。 接下来就让我们看看，doWatch都是如何处理这些变量的吧。 ref 后续getter函数一旦执行，将会访问ref，触发 ref本身的依赖收集 12345if (isRef(source)) &#123; // 如果当前source的值是ref, 则处理为() =&gt; source.value // 这里注意const num = ref(1) num是ref，num.value并不是ref而是基础类型 getter = () =&gt; source.value&#125; reactive 后续getter函数一旦执行，将会访问reactive，触发 ReactiveEffect 完成依赖收集 123456if (isReactive(source)) &#123; // 如果是reactive则,直接处理成() =&gt; source getter = () =&gt; source // 同时将deep赋值为true 因为reactive为object，一般为多层嵌套，需要深度递归 deep = true&#125; Function 后续getter函数一旦执行，将会运行fn，访问函数返回值，如果fn返回的是ref 或者reactive 就会触发相应的依赖收集 123456if (isFunction(source)) &#123; // callWithErrorHandling函数比较复杂，这里就不做展示了 // 函数效果为：返回 () =&gt; fn() // 后续getter getter = () =&gt; callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)&#125; Array 后续getter函数一旦执行，将会访问getter中的所有的访问值，如果fn返回的是ref 或者reactive 就会触发相应的依赖收集 1234567891011121314151617181920if (isArray(source)) &#123; isMultiSource = true // 标识为多个监听项 // array类型的source，可能包含ref reactive Function 所以都需要进行处理 // 其中reactive比较复杂，需要通过traverse函数，递归触发所有依赖项，也可以说array类型的source，默认deep参数就是true getter = () =&gt; source.map(s =&gt; &#123; if (isRef(s)) &#123; return s.value // &#125; else if (isReactive(s)) &#123; return traverse(s) &#125; else if (isFunction(s)) &#123; return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER) &#125; &#125;)&#125;export function callWithErrorHandling(fn,instance,type,) &#123; return fn()&#125; 未知类型123export const NOOP = () =&gt; &#123;&#125;getter = NOOP // 如果watch的第一个参数不是以上类型，这起getter函数为空 以上就是watch针对所有类型的source的处理。 我们可以发现其实就做了一件事，就是将其包装为getter函数，getter函数一旦运行，便可以触发相关依赖收集。 完成第一阶段的分析，其实我们文章开头提出的问题已经有了明确答案，我们回过头来继续看看 12345678910const user = reactive(&#123; name: &#x27;卖鱼强&#x27; &#125;)watch(user, () =&gt; &#123;&#125;)// user是reactive，将会被处理为（）=&gt; user，同时deep参数默认设置为true，reactive中的所有依赖都将会触发依赖收集，watch有效watch(user.name, () =&gt; &#123;&#125;)// name是reactive内的基础对象，将会被识别为未知类型，所以watch无效watch(() =&gt; user, () =&gt; &#123;&#125;)// 函数返回，并未访问proxy的属性，无法完成依赖收集，所以watch无效watch(() =&gt; user.name, () =&gt; &#123;&#125;)// 函数返回 而user.name是proxy下的属性，将会触发依赖收集，所以watch有效 以上就是reactive + watch不同使用方式的效果解读。 有兴趣的小伙伴可以试试解读一下ref + watch的结果。 如果真的记不住，我们就记住下面的这句话：watch 监听对象本身，使用对象的形式；watch监听对象内部属性，使用函数形式。 第二阶段：构建响应式模块，完成依赖收集 这上小节，我们完成getter函数的构建，这一步我们需要进行依赖触发，与依赖收集，使watch的监听功能正式生效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253if (cb &amp;&amp; deep) &#123; // 如果deep为true, 则将getter函数再通过traverse进一步处理，使其可以被深度监听 // traverse的作用前面说过，目的就是递归触发对象所有属性的get。 const baseGetter = getter getter = () =&gt; traverse(baseGetter()) &#125;// 初始化oldValue，如果source是数组isMultiSource为true，否则为falselet oldValue = isMultiSource ? [] : &#123;&#125;// watch的核心实现，注意一下，此刻我们还没有执行// 内部逻辑非常复杂，我们这里简化处理// 简单来说就是每次watch的属性或者字段发生变化，都会触发该方法，可以触发的原因是我们getter函数完成了依赖收集的必要逻辑const job: SchedulerJob = () =&gt; &#123; const newValue = effect.run() // 获取被监听项的最新值 // 如果deep为true 或者新旧值不一致, 则会执行watch的cb，也就是我们需要触发的函数 if (deep || hasChange(newValue, oldValue)) &#123; cb(newValue, oldValue) &#125;&#125;let scheduler: EffectScheduler// flush：回调的刷新时机 // queuePreFlushCb queuePostRenderEffect 后续再说，我们先假设flush就是asyncif (flush === &#x27;sync&#x27;) &#123; scheduler = job&#125; else if (flush === &#x27;post&#x27;) &#123; scheduler = () =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)&#125; else &#123; // default: &#x27;pre&#x27; scheduler = () =&gt; queuePreFlushCb(job) // queuePreFlushCb 暂时先忽略&#125;// getter是第一步处理的，可以访问到响应式字段的函数// scheduler是watch监听字段发生变化，实际需要执行的回调函数，我们可以理解为scheduler = job = getterconst effect = new ReactiveEffect(getter, scheduler)if (cb) &#123; // 如果immediate为true,则代表默认watch初始化阶段自动执行一次 if (immediate) &#123; job() // job中的effect.run运行，完成依赖收集，建立其了变量与cb函数之间的联系。 // 同时也执行了cb函数，首次watchcb被执行 &#125; else &#123; // 如果immediate为false，则直接运行effect.run()，完成依赖收集，建立其了变量与cb函数之间的联系。 oldValue = effect.run() &#125;&#125;return () =&gt; &#123; // 返回了effect的stop函数，则意味着，watch api存在返回值，只需要执行一下返回值 就会结束掉watch的监听 effect.stop()&#125; ​ 到此为止，我们可以明确了解到，在Vue的初始化阶段，watch其内部通过ReactiveEffect，以及effect.run()的触发，完成了watch需要监听的变量与触发函数的绑定，ReactiveEffect逻辑在Vue3硬核源码解析系列（3） reactive + effect源码解析可以了解其具体实现。 ​ 也就是相当于说，watch内部通过手动访问source，触发source的get事件，source依赖一旦触发，就会开始依赖收集，就会收集到watch的第二个参数cb，经进而完成watch的依赖收集；只要source发生改变，一定会触发cb函数。 ​ 其实到这里watch的核心源码就已经结束了，依赖已经完成收集； ​ 当被监听变量或者属性发生变化的时候，cb函数一定会执行，但是watch的执行时机是非常有讲究的； ​ 所以接下来就要讲讲watch第三个参数的flush，该字段就是控制cb函数的执行时机。 第三阶段：依赖触发当我们watch监听的字段发生变化的时候，watch的第二个参数，cb会被触发，但是并不是监听字段发生变化的下一步就立刻触发。 这里我们回顾一下watch源码中变量scheduler的相关逻辑 12345678910111213if (flush === &#x27;sync&#x27;) &#123; scheduler = job&#125; else if (flush === &#x27;post&#x27;) &#123; scheduler = () =&gt; queuePostRenderEffect(job)&#125; else &#123; // default: &#x27;pre&#x27; scheduler = () =&gt; queuePreFlushCb(job)&#125; // 为了便于理解，暂时认为__FEATURE_SUSPENSE__为false，此处一定等于queuePostFlushCbexport const queuePostRenderEffect = __FEATURE_SUSPENSE__ ? queueEffectWithSuspense : queuePostFlushCb 我们可以看到，flush参数不同的时候scheduler的值也是不同的 如果我们指定了flush是sync，则source发生变化下一个同步任务就是执行watch的cb函数， 如果我们不进行指定，默认将是pre，则会触发queuePreFlushCb(job) 如果指定为post，则会触发queuePostFlushCb(job) 根据文档我们可以了解到当flush为pre的时候，watch第二个参数cb，将会在Vue组件更新之前被调用，post则会让cb函数在Vue组件更新之后被调用 接下来就让我们看看queuePreFlushCb与queuePostFlushCb内部是如何实现的吧！ queuePreFlushCb与queuePostFlushCb123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const resolvedPromise = Promise.resolve()let currentFlushPromise = nulllet isFlushPending = falseconst pendingPreFlushCbs: SchedulerJob[] = []let activePreFlushCbs: SchedulerJob[] | null = nulllet preFlushIndex = 0// cb传入到queueCb中export function queuePreFlushCb(cb: SchedulerJob) &#123; // 执行方法附带一些关于pre队列的全局变量 queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)&#125;// cb传入到queueCb中export function queuePostFlushCb(cb: SchedulerJobs) &#123; // 执行方法附带一些关于post队列的全局变量 queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)&#125;// 将cb加入到全局变量pendingPreFlushCbs或者pendingPostFlushCbs中，我们可以理解为缓存了cb函数，并执行了queueFlushfunction queueCb( cb: SchedulerJobs, activeQueue: SchedulerJob[] | null, pendingQueue: SchedulerJob[], index: number) &#123; pendingQueue.push(cb) queueFlush()&#125;// 该函数最终将缓存的cb函数访问到Promise的.then中，resolvedPromise已经是resolve状态，则意味着，将会在下一次微任务的时候触发flushJobsfunction queueFlush() &#123; if (!isFlushing &amp;&amp; !isFlushPending) &#123; isFlushPending = true currentFlushPromise = resolvedPromise.then(flushJobs) &#125;&#125;// 若干时间后watch被触发，然后一轮事件循环结束，开始触发flushJobsfunction flushJobs() &#123; isFlushPending = false flushPreFlushCbs() try &#123; for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) &#123; const job = queue[flushIndex] if (job &amp;&amp; job.active !== false) &#123; callWithErrorHandling(job, null, ErrorCodes.SCHEDULER) &#125; &#125; &#125; finally &#123; flushPostFlushCbs(seen) isFlushing = false &#125;&#125;// 依次触发之前存储的所有cb函数export function flushPreFlushCbs() &#123; if (pendingPreFlushCbs.length) &#123; let activePreFlushCbs = [...new Set(pendingPreFlushCbs)] pendingPreFlushCbs.length = 0 for (let i = 0; i &lt; activePreFlushCbs.length; i++) &#123; activePreFlushCbs[i]() &#125; &#125;&#125;// 依次触发之前存储的所有cb函数export function flushPostFlushCbs(seen?: CountMap) &#123; flushPreFlushCbs() if (pendingPostFlushCbs.length) &#123; const deduped = [...new Set(pendingPostFlushCbs)] pendingPostFlushCbs.length = 0 activePostFlushCbs = deduped for (postFlushIndex = 0; postFlushIndex &lt; activePostFlushCbs.length; postFlushIndex++) &#123; activePostFlushCbs[postFlushIndex]() &#125; activePostFlushCbs = null postFlushIndex = 0 &#125;&#125; 以上代码看起来似乎比较复杂，但是执行的逻辑其实非常简单，Vue3的更新队列存在三种分别是pre，queue，post，这三个队列按照顺序执行相应代码 执行pre队列中的代码 执行queue队列中的代码，（queue为组件update的相关逻辑） 执行post队列中的代码 这里对照vue3文档，我们可以发现，我们的分析是符合文档描述的。 因为涉及到vue3的更新队列，这并非watch关联的知识，为了方便源码阅读，可以假设watch的flush的参数为async，这样是最好理解的。 到此为止，我们的watch核心源码分析就全部完毕了。 关于ref的一些问题watch的源码为什么在runtime-core中？关于这一点我是这么理解的，watch不仅仅是一个响应式组件，他涉及到了组件的生命周期，更新渲染等等逻辑，放在runtime中更好与组件系统进行集成， 总结​ 通过以上源码分析我们可以发现，watch的响应式原理相对来说是比较简单的，完全依赖我们的之前说过的ReactiveEffect，所以如果小伙伴了解reactive的源码，相信看watch的源码的响应式部分是非常轻松的 ​ 相对于其他api，watch的响应式实现具备一下2个特点 watch的依赖收集是被动触发的 watch的依赖触发，实际上是调度器scheduler，然后通过不同的flush，达到控制执行顺序、规则的目的。 ​ watch的源码分析就到这里，我们下期再见吧~👋🏻","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"Vue3硬核源码解析系列（6） 100行代码 实现mini版ref","slug":"vue3源码解读/Vue3硬核源码解析系列（6） 100行代码 实现mini版ref","date":"2023-03-21T16:00:00.000Z","updated":"2023-11-27T02:39:55.068Z","comments":true,"path":"2023/03/22/vue3源码解读/Vue3硬核源码解析系列（6） 100行代码 实现mini版ref/","link":"","permalink":"https://bluedancers.github.io/2023/03/22/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/","excerpt":"","text":"专栏前言​ 在上一节，我们完成了vue3的ref核心源码解读，其实基础类型的ref的核心逻辑还是非常简单的，所以在我们的简易版源码环节，我们直接切入基础类型，复杂类型仅做支持，不做讲解。 注：单基础类型场景的ref源码，几乎可以说是整个vue3源码中最简单的一部分，所以这一节的学习难度是最小的 mini版vue3仓库地址，还请大家不要吝啬star，下次不迷路~ 仅保留最核心逻辑，极大减低阅读难度，80行代码实现vue3 ref，让我们直接进入源码实现环节！ 逻辑图（基础类型） 完整版ref逻辑图，请看 Vue3硬核源码解析系列（5） ref源码解析 具体逻辑 如同逻辑图所示，我们简易版源码的具体实现也从 初始化 依赖收集 依赖触发三个角度来进行实现 初始化ref的初始化非常简单，逻辑流程如下 判断传入对象是否已经是ref，如果是，这直接返回，如果不是，则继续运行代码 ref的本质就是一个Class RefImpl 初始化RefImpl的时候，将ref的参数保存到_value，同时将参数的原始值保存到_rawValue 通过get value，实现ref.value的访问 使用set value，实现ref.value &#x3D; xx的更新逻辑 确定实现逻辑的同时，我们也仿照vue3的源码结构开始输出吧~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 入口函数 */export function ref(value?: unknown) &#123; return createRef(value, false)&#125;function createRef(rawValue: unknown, shallow: boolean) &#123; // 判断是否已经是ref,如果是直接返回其本身 if (isRef(rawValue)) &#123; return rawValue &#125; // ref本质上就是RefImpl的实例 return new RefImpl(rawValue, shallow)&#125;class RefImpl&lt;T = any&gt; &#123; private _value: T // ref每次读取与返回的属性 private _rawValue: T // ref中value的原始属性 public dep: Dep | undefined // 当前ref相关effect public readonly __v_isRef: boolean = true // 标记__v_isRef为true,以后将无法在通过isRef()的判断 constructor(value: T, public readonly __v_isShallow: boolean) &#123; this._rawValue = value // 赋值原始值 // ref API中 __v_isShallow,一定为false （__v_isShallow 表示是否浅层代理） // value是基础类型,则toReactive返回原值，value是复杂类型,则toReactive会将其处理成为reactive(proxy)再返回,这就意味着,此时的value是一个proxy this._value = __v_isShallow ? value : toReactive(value) &#125; // 实现ref.value能力 get value() &#123; // 配合effect阶段保存的activeEffect,将依赖收集到this.dep中（依赖收集） trackRefValue(this) // 返回最新value return this._value &#125; // 实现ref.value = xx能力 set value(newVal) &#123; // 判断当前set的value是否存在变化, 有变化则进入if if (hasChange(newVal, this._rawValue)) &#123; // 保存最新的参数原始值，便于下次hasChange判断 this._rawValue = newVal // 如果value是基础类型, 则toReactive返回value本身，否则返回通过toReactive生成的proxy this._value = toReactive(newVal) // 触发get阶段收集在this.dep中的依赖（依赖触发） triggerRefValue(this) &#125; &#125;&#125; 依赖收集 ref &#x3D; Class RefImpl ​ 经过我们上一章的ref源码分析我们可以了解到，ref的依赖收集，并不是依赖WeakMap进行完成，而是其自行完成依赖收集，收集在自身class的dep中，逻辑大概是这样的 每次触发ref的get的时候，都会执行一次trackRefValue（trackRefValue的作用是完成依赖收集） 每次执行effect的时候，都会将effect本身保存到变量activeEffect中（具体请看Vue3硬核源码解析系列（3） reactive + effect源码解析） 如果RefImpl的dep不存在，则说明是第一次进行依赖收集，将通过createDep将RefImpl.dep赋值为Set 将activeEffect，也就是当前正在运行的effect，push到RefImpl的dep中，ref完成依赖收集 明确了逻辑之后，我们依旧结合vue3的源码结构，来完成ref依赖收集的代码输出。 12345678910111213141516171819202122232425262728get value() &#123; trackRefValue(this) return this._value&#125;/** * ref 依赖收集 */export function trackRefValue(ref: RefImpl) &#123; // 判断当前是否存在需要收集的依赖 if (activeEffect) &#123; // 判断RefImpl的实例中的dep是否被初始化过 if (!ref.dep) &#123; // 如果没有, 则赋值为Set ref.dep = createDep() &#125; // 将当前effect收集到当前RefImpl实例的dep中, 完成依赖收集 trackEffects(ref.dep) &#125;&#125;/** * * @param dep */export function trackEffects(dep: Dep) &#123; dep.add(activeEffect!)&#125; 依赖触发若干时间后，ref的value被更新，触发RefImpl的set value，在更新value的同时，也会执行其内部的triggerRefValue，开始依赖触发逻辑 获取到当前ref，也就是class RefImpl本身的dep 循环dep中存储的所有effect，并执行其fn，完成依赖触发。 12345678910111213141516171819202122232425262728/** * ref 依赖触发 */export function triggerRefValue(ref: RefImpl) &#123; // 当前当前RefImpl实例中是否存在收集的依赖 if (ref.dep) &#123; // 触发依赖 triggerEffects(ref.dep) &#125;&#125;/** * 处理所有待触发依赖 */export function triggerEffects(dep: Dep) &#123; // const effects = isArray(dep) ? dep : [...dep] const effects = [...dep] for (const effect of effects) &#123; triggerEffect(effect) &#125;&#125;/** * 触发执行依赖 */function triggerEffect(effect: ReactiveEffect) &#123; effect.run()&#125; 到此为止，我们的ref就具备响应式的能力了，是不是很简单~ 小结​ 这时候肯定有同学要说了，你这ref不保熟啊，仅支持基础类型，不支持复杂类型啊，这不是阉割版ref吗？ ​ 这里必须澄清一下，虽然简易版ref 100行代码不到，但是他是支持复杂类型的响应式的，因为复杂类型的响应式是依赖reactive进行完成的，不过reactive的源码解读，并不是本文的重点，所以，这里就跳过了，有兴趣的同学，请看这里Vue3硬核源码解析系列（3） reactive + effect源码解析，了解reactive的响应式实现，再看Vue3硬核源码解析系列（5）ref源码解析，了解复杂类型场景下的源码执行逻辑吧。 ​ 最后，建议大家clone源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，在简历上留下浓墨重彩的一笔~","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"chatGPT一些学习记录","slug":"日常/chatGPT一些学习记录","date":"2023-03-20T16:00:00.000Z","updated":"2023-03-22T03:17:16.552Z","comments":true,"path":"2023/03/21/日常/chatGPT一些学习记录/","link":"","permalink":"https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"最早​ 自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段文本做到深入的理解与分析，并生成高质量的语言表达。 ​ 那他究竟是什么原理呢？ ​ 从一段文本中，随机扣掉一部分字，然后模型不断学习此处到底应该填写什么，所谓学习与训练就是从大量的数据中学习理解复杂的上下文关系。 ​ 注：学习 无监督学习 训练 有监督学习 ​ bert的出现推动了自然语言处理领域的发展，在bert出现之前，我们都是基于规则与浅层神经网络（关键字理解）去解决，bert的出现使得深度学习在自然语言处理上得到了更加广泛的使用。 ​ 在bert出现之前，openid就出版了GPT1，GPT1也是基于Transformers进行实现，但是gpt没有走双向Transformers的方向，而是走类似单字接龙的方向，由长文单字接龙的自回归所生成，不过GPT1并没有出现bert的惊人效果，所以早期的GPT没啥热度。 GPT2 GPT3​ 基于bert的成就，大家都看到深度学习在语言模型上的可行性，于是大家都开始各种预训练模型，完形填空，判断题，改错题，GPT2、3也确实是这个思路，开始提升训练数据量，这个成果我们称之为开卷有益（无监督学习）。 ​ 让chatGPT对海量互联网文本做单字接龙，以扩充模型的词汇量、语言只是、世界的信息与知识。是chatGPT从哑巴鹦鹉变成了脑容量超大的懂王鹦鹉，这个和人类的学习其实很相似，小孩刚刚来到这个解释，就是不断的输入信息。 ​ 经过巨量的数据训练之后，我们下一步就需要情景学习（in-context learning），这两个阶段是NLP模型的基础工作流程，简单来说，就是让chatGPT对优质对话范例做单字接龙，以规范回答的对话模式和对话内容。是chatGPT变成懂规矩的博学鹦鹉，这里的场景标记几个就够了，机器一旦学会了规范，便可以应对此类所有问题。 关于强化学习（RL）​ 几年前，alpha go击败了柯洁，几乎说明了，经过强化学习，机器可以做到近乎人类极限的程度，但是这样的场景有一个前提，一个非常明确的奖惩机制，alpha go并不理解围棋规则，但是他可以接收到成功、失败的反馈，模型会根据反馈不断调整策略，已达到更多次成功的目的。 ​ 我们可以看到alpha go的强化学习规则书相对简单的，因为目标明确，而在NLP领域强化学习却很难实现。 ​ 因为NLP是语言，语言是没有固定的对错，这就意味着无法设定奖惩机制，除非人工来做反馈。 ​ openid还就这么干了，这被称之为 RLHF（Reinforcement Learning from Human Feedback） ​ openid公司找了40家外包公司，不断帮助gpt筛选什么是好的，什么是坏的，通过这种方式构建了一个奖励（reward）模型。 ​ 这样训练是为了让他学会举一反三的规律，开始出现类似人类的价值价值观与思考模式。 ​ 于是gpt通过这样奖励模型，开始感知到真实世界，开始了与真实世界的拟合。甚至可以说奖励模型就是gpt的母体，他对人类的理解不取决于世界，而是取决于模型。 ​ 这样引导学习的方式，在超大模型上出现惊人的效果，gpt在巨量的数据与规范 + 手动标注引导下，变成了看起来有心智的超级人工智能，甚至出现了理解、例子、思维链的能力。 ​ 这样的方式也是存在缺点的，比如缺点是可能混淆记忆，无法直接查看个更新所学，并且高度依赖学习材料 GPT对现今社会的可能影响​ chatGPT是里程碑的产品，就像流浪地球里面的行星发动机，刚开始大家都都不知道其潜力，经过验证后，地球上迅速出现了几万座行星发动机，并完成了最后的流浪地球，chatGPT这样大语言模型就像最开始几座行星发动机 ，最终也将会形成改变我们生活的推力 ​ 合理的使用大预言模型，就可以让一个普通人快速准确的触及各行各业的平均知识， 以及具体解法 ​ 所以我们可以畅想，未来我们也许不在需要学习如何打架，只需要对gpt发号施令，让机器去具体的做事即可 ​ 除了chatGPT本身具备对人类的能力输出，chatGPT具备我们人类不具备的一点，那就是他可以在语言中学会世界知识。 ​ 人脑是有限的，寿命是有限，个体死亡，一切都会消失，直到语言的发明，打通了过去与未来，知识以文字作为载体传承至今，一直以来我们通过纸质、或者其他物理形式进行存储，其效率是有限的，直到计算机的出现，我们开始用电子文档替代纸质， 信息传递的效率飞速提升，但是同时也带来了信息处理的巨大成本。 ​ 所以人工智能领域的自然语言技术应运而生（NLP），其目标就是让机器理解人类的语言，协助人类处理工作，这是人工智能领域非常重要的发展方向，虽然这些年发展缓慢，但是依旧被很多公司加以厚望，因为机器不需要作息，没有情绪，效率极高，可以为企业节省大量的成本。 与行业结合的可能性 搜索引擎，帮助用户更加精准的筛选信息 笔记工作结合，辅助阅读与写作 办公软件结合，辅助文字处理，数据分析，演示制作 教育培训结合，指定学习计划，寻找学习资料 开发工具结合，辅助编写业务代码，调试纠错 客服系统结合，全天候问答， 视频会议结合，会议记录，总结，谈话查找 审核机制结合，少选评论，统计舆论，给出提醒 行业顾问，提供法律，医疗，健身等等建议 社交媒体结合，帮助寻找兴趣相投的用户与话题 与视频音乐结合，个性化推荐视频、音乐、小说、动漫 游戏剧情结合，让NPC给玩家带来更加灵活的对话体验 GPT具备对文字行业巨大的改造潜力 学术界 创造知识 教育行业 传承知识 新闻行业 传播知识 ​ 还有对传统教育行业的巨大挑战，不是GPT可以给学生写作业，而是对现有的人才教育模式存在很大的冲击。 ​ 按照现在的教育模式（应试教育，传授既有知识）出来的学生，还能应对未来的5-10年的社会需求吗？ ​ 其实现在已经不太符合了，因为社会变化太快了，以前人们可以通过学习的知识终生受益，现在能满足毕业后5年其实都比较难了，因为知识过时的太快了，人们就需要不断学习新的知识。 ​ 正因如此，随着互联网时代的到来，终生学习的理念开始被人们推崇，同时教育模式也开始以【培养学习能力与创造能力】为主了，只有这样才能适应不断变化的时代。 试想一下你学习了20年，掌握了一些知识，但是GPT却可以瞬间替代你完成你的能力，怎么办？以后人人都有一个熟读人类既有知识的超级大脑，市场不会因为学校的禁用，而集体不使用。 ​ 任何事物都存在两面性，好的一面是，GPT将方便人来对既有知识进行集成，推进教育去培养高层次人才 GPT对网络安全的巨大挑战​ 因为GPT的第一阶段，需要大量录入信息，这其中的信息难免会存在一个坏的信息，亦或者军事机密等等信息，所以国家与国家之间很难愿意共享数据，这也意味着，在不就得将来每个有实力的国家都会自己研发大语言模型 ​ 同时在应用层面，大预言模型将会像口语、文字、电脑、互联网对社会进行再一次改造。 社会影响​ 只有会工具的人取代不会使用工具的人，没有工具取代人的说法，所以真正需要害怕的是，我们成为无法成为使用工具的人，时代的车轮势不可挡，抵触新工具就意味着落后，学20年干一辈子的时代已经逐渐远去，我们身处加速时期，必须学会终生学习 ​ GPT正在改变人类群体应用知识的方式与继承知识的方式，甚至未来可能会形成人机合作的科研，改变人类创造知识的方式，甚至步入下一个文明形态。 ​ 每个人的学习能力与理解能力，将是驾驭这项技术的瓶颈，也意味着是否可以充分发挥这一技术的优势， 名词解释bert（Bidirectional Encoder Representations from Transformers 双向编码变换器） ​ BERT 基于 Transformers 模型架构，使用双向编码器来训练深度双向表示，并在多项自然语言处理任务上实现了最先进的性能 浅层神经网络（Shallow Neural Network） ​ 浅层神经网络是一种神经网络，它只有一层或几层隐层，通常用于浅层特征学习和分类任务。与深层神经网络相比，浅层神经网络的参数量少，计算速度较快，但也可能会受到学习能力和表示能力的限制。 【UL】无监督学习（Unsupervised Learning） ​ 无监督学习是一种机器学习的范畴，其目的是在没有明确的标签或目标函数的情况下，从数据中发现隐藏的结构和规律。在无监督学习中，模型需要从数据中学习如何将数据分组、降维、聚类等。 【SL】有监督学习（Supervised Learning） ​ 有监督学习是一种机器学习的范畴，其目的是在有标签的训练数据上学习一个模型，使其能够预测新的数据。在有监督学习中，模型需要学习如何将输入映射到输出，并根据标签调整模型参数以提高预测性能。（特定的任务上进行微调，例如情感分析、文本分类、命名实体识别） 【RL】情景学习（Reinforcement Learning） ​ 情景学习是一种机器学习的范畴，其目的是通过试错来学习如何在特定的情景下做出正确的决策。在情景学习中，模型需要学习如何在不断尝试和反馈的过程中最大化累计奖励。 【NLP】自然语言处理技术（Natural Language Processing） ​ 自然语言处理技术是一种人工智能技术，旨在让计算机能够理解和生成自然语言。NLP 技术可以应用于文本分类、情感分析、机器翻译、问答系统等领域。 【LLM】大语言模型（Large Language Model） ​ 大语言模型是一种基于神经网络的自然语言处理模型，它可以处理大量的文本数据，并学习语言的语法和语义。目前的大语言模型通常使用预训练加微调的方式进行训练，并在各种自然语言处理任务中取得了很好的表现。 【MLLM】多模态大语言模型（Multi modal Large Language Model） ​ 多模态大语言模型是一种结合了自然语言处理和计算机视觉等多种模态的模型，旨在解决多模态数据的处理和理解问题。与传统的大语言模型不同，多模态大语言模型可以同时处理文字、图片、声音等不同类型的数据，并学习它们之间的交互和关联，从而提高自然语言处理和视觉任务的性能。 RLHF（Reinforcement Learning from Human Feedback 从人类反馈中强化学习） ​ 这是一种机器学习的方法，旨在通过与人类交互来提高强化学习算法的性能。在 RLHF 中，算法会在执行任务的过程中接收人类反馈，并将其作为一种奖励信号来调整自己的策略。与传统的强化学习不同，RLHF 可以在学习过程中快速地获得关于任务的准确信息，并且更容易被应用于实际场景中，如自动驾驶、机器人控制等。","categories":[{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/tags/chatGPT/"}]},{"title":"（3.1）vue3 手摸手实现mini版reactive.md","slug":"vue3源码解读/Vue3硬核源码解析系列（4） 200行代码 实现mini版reactive + effect","date":"2023-03-12T16:00:00.000Z","updated":"2023-11-27T02:39:41.220Z","comments":true,"path":"2023/03/13/vue3源码解读/Vue3硬核源码解析系列（4） 200行代码 实现mini版reactive + effect/","link":"","permalink":"https://bluedancers.github.io/2023/03/13/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/","excerpt":"","text":"专栏前言​ 在上一节，我们完成了vue3的reactive的核心源码解读，总的来说还是非常复杂，文章的表现能力有限，我想可能有很多同学无法完全理解其精髓，所以在本节，我将带领大家完成mini版本源码的输出。 ​ 仅保留最核心逻辑，极大减低阅读难度，200行代码实现reactive + effect，话不多说，我们直接开始！ 简易版vue3仓库地址，还请大家不要吝啬star，留个标记，下次迷路~ 逻辑图 逻辑流程reative初始化​ 将reactive处理为proxy，同时预先声明set get方法，赋值、取值均通过Reflect完成，get中存在track（依赖收集），set中存在trigger（依赖触发），完成reactive的初始化。 effect初始化（依赖收集） cb &#x3D; callback &#x3D; 回调函数 effect(() &#x3D;&gt; {}) &#x2F;&#x2F; () &#x3D;&gt; {} 就是cb ​ 初始化effect函数，通过一个类ReactiveEffect运行其cb，同时将当前cb存储到公共变量，cb中读取了reactive的属性，进而触发proxy的get，同时完成track（依赖收集），让reative收集到存储在公共变量中的effect的cb，至此完成依赖收集。 1重点：reactive - key - effect // 依赖收集完成后，将会形成这样的从上到下的可追溯关系 reactive改变（依赖触发）​ 若干时间后，reactive属性发生变化，触发reactive属性的赋值操作，进而触发proxy的set事件，同时完成trigger（依赖触发），根据指定的reative + key，找到特定effect运行，完成依赖触发，形成响应式。 1重点：reactive + key 找到指定effect，进而完成触发 具体逻辑proxy处理​ 经过真实的源码分析之后，我们都知道reactive实际上就是proxy，我们仿照源码的格式，将reactive经过proxy处理后返回就好了。 1234567891011121314151617181920212223// 缓存proxyconst reactiveMap = new WeakMap&lt;object, any&gt;()// 入口函数export function reactive(target: object) &#123; return createReactiveObject(target, mutableHandlers, reactiveMap)&#125;// 处理被代理对象function createReactiveObject( target: object, baseHandlers: ProxyHandler&lt;object&gt;, proxyMap: WeakMap&lt;object, any&gt;) &#123; // 如果已经被代理过,这直接返回结果 const existingProxy = proxyMap.get(target) if (existingProxy) &#123; return existingProxy &#125; const proxy = new Proxy(target, baseHandlers) proxyMap.set(target, proxy) return proxy&#125; get set函数编写​ 以上代码我们完成了变量的proxy处理，为了完成后续的响应式，我们需要预先声明好get set函数，我们依旧仿照源码格式，并只保留核心逻辑，get阶段返回结果，并触发（依赖收集）track，set阶段通过Reflect完成赋值，并触发（依赖触发）trigger 1234567891011121314151617181920212223242526272829export const mutableHandlers: ProxyHandler&lt;object&gt; = &#123; get, set,&#125;const get = createGetter()const set = createSetter()function createGetter() &#123; return function get(target: object, key: string, receiver: object) &#123; const res = Reflect.get(target, key, receiver) // 核心逻辑: 依赖收集 track(target, key) if (isObject(res)) &#123; return reactive(res) &#125; return res &#125;&#125;function createSetter() &#123; return function set(target: object, key: string, newValue: unknown, receiver: object) &#123; const res = Reflect.set(target, key, newValue, receiver) // 核心逻辑: 依赖触发 trigger(target, key, newValue) return res &#125;&#125; effect实现effect的核心的实现，就是在运行effect的时候保存当前的this，以便于后续流程中的依赖收集，所以其核心代码非常简单，保证一下2点即可。 运行effect本身 保存effect的fn到activeEffect即可 123456789101112131415161718export function effect&lt;T = any&gt;(fn: () =&gt; T) &#123; const _effect = new ReactiveEffect(fn) _effect.run()&#125;export let activeEffect: ReactiveEffect | undefinedexport class ReactiveEffect&lt;T = any&gt; &#123; constructor(public fn: () =&gt; T) &#123;&#125; run() &#123; try &#123; activeEffect = this return this.fn() &#125; finally &#123; activeEffect = undefined &#125; &#125;&#125; 依赖收集（track）按照时序，effect函数初始化阶段会执行，effect函数本身也会被保存到activeEffect中，同时触发effect中的reactive中的get事件，进而触发track，我们在track中完成 reactive- key - effect之间关系的构建，确保以后可以在set阶段找到指定的effet的fn即可。 1234567891011121314151617181920export function track(target: object, key: string) &#123; if (!activeEffect) &#123; return &#125; let depsMap = targetMap.get(target) if (!depsMap) &#123; depsMap = new Map() targetMap.set(target, depsMap) &#125; let dep = depsMap.get(key) if (!dep) &#123; dep = createDep() depsMap.set(key, dep) &#125; trackEffects(dep)&#125;function trackEffects(dep: Dep) &#123; dep.add(activeEffect!)&#125; 依赖触发（trigger）若干时间后，reative中的某个属性发生了变化，也就会发生set事件，这时候其实就很简单了，我们只需要通过reactive - key找到对应的effect的fn，然后执行即可。 这就形成了我们看到的“响应式”。 1234567891011121314151617181920212223export function trigger(target: object, key: string, newValue: unknown) &#123; let depsMap = targetMap.get(target) if (!depsMap) &#123; return &#125; const dep: Dep | undefined = depsMap.get(key) if (!dep) &#123; return &#125; triggerEffects(dep)&#125;function triggerEffects(dep: Dep) &#123; const effects = [...dep] for (const effect of effects) &#123; triggerEffect(effect) &#125;&#125;function triggerEffect(effect: ReactiveEffect) &#123; effect.fn()&#125; 最后​ 到此为止，我们简易版的reactive + effect的全部源码就完成了，虽然vue3的源码很复杂，但是我们抽丝剥茧，仅保留核心逻辑，大幅降低vue3源码阅读的难度，让绝大多数的前端开发者都可以读懂核心实现~ ​ 最后，建议大家clone源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，然后在简历上留下浓墨重彩的一笔~","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"（7）vue3 runtime-dom源码解析","slug":"vue3源码解读/（7）vue3 runtime-dom源码解析","date":"2023-02-17T16:00:00.000Z","updated":"2023-11-27T02:38:45.025Z","comments":true,"path":"2023/02/18/vue3源码解读/（7）vue3 runtime-dom源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%887%EF%BC%89vue3%20runtime-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"html叫做DOM节点数 vdom是正式dom的JavaScript数据结构的描述 在运行时runtime中，渲染器rerender会遍历整个虚拟dom树，并根据此结构构建正式dom树，这个过程我们称之为mount 当vnode发生变化的时候，，我们会对比旧的vnode与新的vnode，找出他们的区别，并应用于真实dom上，这个过程我们称之为patch。","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）","slug":"项目解决方案/webpack、vite在proxy中动态设置headers","date":"2023-02-16T16:00:00.000Z","updated":"2023-02-18T08:16:39.254Z","comments":true,"path":"2023/02/17/项目解决方案/webpack、vite在proxy中动态设置headers/","link":"","permalink":"https://bluedancers.github.io/2023/02/17/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/webpack%E3%80%81vite%E5%9C%A8proxy%E4%B8%AD%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEheaders/","excerpt":"","text":"通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）前言大家都知道，利用webpack、vite的proxy可以解决开发环境的跨域问题。 但是在真实开发场景下，我们可能不仅要面对跨域问题，还有可能面对动态header的情况。 让我们来看如下案例 案例强盛集团开发了一套多店铺的H5商城系统，此时小安 小龙 小虎，都想利用这个系统开一个线上商城，我们如何区分他们的店铺呢？ 聪明的同学肯定已经想到了答案，用二级域名进行区分 123小安 -&gt; xa.shop.com小龙 -&gt; xl.shop.com小虎 -&gt; xh.shop.com 接下来让我们把视角聚焦到强盛集团的技术部门。 面对这样的多店铺商城系统，开发环境肯定无法用ip直接访问了，因为ip无法识别具体是什么店铺。 这个问题其实也很好解决，修改本地host即可 123127.0.0.1 xa.shop.com127.0.0.1 xl.shop.com127.0.0.1 xh.shop.com 假设我们开发环境的端口是8082，我们想在开发环境访问小安的店铺，则通过xa.shop.com:8082进行访问。 ​ 直到某一天，安全部门发现了沙海集团的的scrf恶意攻击，决定限制该产品请求发起方的Origin Header与Referer Header，并且限制了必须是80端口。 这两个请求头的含义是标记来源域名，可以起到防止scrf攻击的目的。 ​ 此时前端开发就麻烦了，因为在开发环境，我们的Origin Header与Referer Header都是x.shop.com:8082，这会被服务端识别为不合法的请求来源，同时因为浏览器安全限制，前端是不具备直接修改referer头的能力， 除非将项目端口号改为80端口，但是这并不是一个好办法。 如果你是强盛集团的前端开发，你会怎么解决以上问题呢？ 后端高某强提供的思路​ 后端开发高某强这时候提供了一个想法，通过本地nginx代理8082端口就好了呀。 在开发机器本地启动一个nginx 通过nginx将x.shop.com指向127.0.0.1:8082 同时配合host的修改，实现开发环境去端口的诉求。 后续，我尝试了这个方案，确实是可以实现的，也在团队中推广并使用了一段时间； 但是长期使用下就暴露了一些问题 每次新增一个站点，都需要同时增加host、nginx中的配置，流程复杂。 并不是每个前端都了解nginx，初级开发非常容易出问题，增加团队内耗。 proxy解决方案Vite解决方案​ 直到某一天，我在vite的文档中突然发现一个细节，server.proxy的实现依赖node-http-proxy，而这个库具备设置请求头的能力 ​ 如果是这样，我是否可以在开发环境通过proxy代理请求接口，同时覆写Origin Header与Referer Header的方式来解决我们遇到的多域名+端口限制问题呢？进而在开发环境规避掉nginx。 ​ 通过vite的问题可以了解到参数configure可以编写http-proxy相关逻辑，再结合http-proxy文档，我们便可以完成相关代码。 1234567891011121314151617181920server: &#123; // ..... proxy: &#123; &#x27;/client&#x27;: &#123; target: &#x27;https://api.xxxx.com&#x27;, // 需要代理的地址 changeOrigin: true, secure: true, // 如果是https接口，需要配置这个参数 rewrite: (path) =&gt; path.replace(/^\\/client/, &#x27;&#x27;), configure: (proxy) =&gt; &#123; proxy.on(&#x27;proxyReq&#x27;, (proxyReq, req, res) =&gt; &#123; // req是当前真实请求的地址 开发环境为：a.shop.com:8082 let host = req.headers.host!.split(&#x27;:&#x27;)[0] // a.shop.com 动态获取当前请求地址，并去除端口 proxyReq.setHeader(&#x27;referer&#x27;, `http://$&#123;host&#125;`) proxyReq.setHeader(&#x27;origin&#x27;, `http://$&#123;host&#125;`) &#125;) &#125;, &#125;, &#125;, // .....&#125;, ​ 测试结果符合预期，web端请求被proxy代理，并在代理请求中完成了端口的去除，符合了服务端对Origin Header与Referer Header的要求。 Webpack解决方案​ vite测试成功后，我们便开始对webpack的vue2.x项目proxy动态headers进行评估；通过webpack4的文档，我们可以了解到webpack4的proxy是基于http-proxy-middleware 进行实现。 ​ 接下来我们也顺利在http-proxy-middleware文档中找到相关配置 我们基于webpack与http-proxy-middleware的文档，就可以很顺利的做产出了。 1234567891011121314151617devServer: &#123;// .... proxy: &#123; &#x27;/client&#x27;: &#123; target: &#x27;https://api.xxxx.com&#x27;, // 需要代理的地址 changeOrigin: true, //是否跨域 secure: true, // 如果是https接口，需要配置这个参数 pathRewrite: &#123; &#x27;^/client&#x27;: &#x27;&#x27; &#125;, onProxyReq: (proxyReq, req, res) =&gt; &#123; let host = req.headers.host.split(&#x27;:&#x27;)[0] proxyReq.setHeader(&#x27;referer&#x27;, `http://$&#123;host&#125;`) //添加请求头 proxyReq.setHeader(&#x27;origin&#x27;, `http://$&#123;host&#125;`) //添加请求头 &#125;, &#125;, &#125;, // .....&#125;, ​ 项目配置完成后，我们便可以在开发环境利用proxy的动态headers完成a.shop.com:8082正常访问线上端口了，只需要在本地配置host即可。 结语高某强了解到前端部门使用proxy + 动态headers方案后，连连称赞，表示请我去他家吃鱼。 如果你也遇到了类似的问题，快来试试proxy的解决方案吧~","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"关于proxy","slug":"关于proxy","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8Eproxy/"}]},{"title":"Vue3硬核源码解析系列（5）ref源码解析","slug":"vue3源码解读/Vue3硬核源码解析系列（5） ref源码解析","date":"2023-02-02T16:00:00.000Z","updated":"2023-11-27T02:39:46.861Z","comments":true,"path":"2023/02/03/vue3源码解读/Vue3硬核源码解析系列（5） ref源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%20ref%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 本文是Vue3硬核源码解析系列的第五篇文章，在之前文章中，我们了解到了reactive effect的源码实现原理，并抽丝剥茧输出了mini版本的reactive + effect，带领大家充分理解reactive的实现原理，同时我们也发现了reactive在使用上的一些局限性，比如无法代理基础类型。 ​ 正因为此，Vue3提供了另一个API ref，面对proxy无法代理基础类型数据的问题，ref又是如何实现其响应式的呢，本文将带领大家一起走进vue3源码世界，看看ref的实现原理 逻辑图因为ref既可以传入基础类型，也可以传入复杂类型，所以其实现逻辑要比reactive更加复杂，并且依赖reactive。 前置知识 如果关于class get set已经很了解，请跳过前置知识 为了降低大家理解ref源码的难度，我们在正式阅读源码之前，先学习一下JavaScript的 class以及修饰符get set相关知识点 12345678910111213class Obj &#123; _value = &#x27;张三&#x27; get value() &#123; console.log(&#x27;value的get行为触发&#x27;) return this._value &#125; set value(val) &#123; console.log(&#x27;value的set行为触发&#x27;, val) this._value = val &#125;&#125;let obj = new Obj() get： 被get修饰的方法，允许通过属性读取的方式，触发方法 set： 被set修饰的方法，允许通过属性赋值的方式，触发方法 当访问obj.value的时候，会执行被get修饰的value()，打印log，并得到返回值‘张三’ 当我们执行obj.value = ’李四‘，进行赋值的时候，将会执行被set修饰的**value()**方法，打印log，并完成变量_value的赋值 ​ 看到这里，大家是否有点似曾相识的感觉，访问与赋值触发get set，和proxy代理的对象的get set很相似，大家能理解到这一点就足够了。 ​ 因为ref可以代理简单类型，同时也可以代理复杂类型，并且这两种情况下的响应式实现逻辑是完全不同的。 ​ 所以接下来，我们从这两个角度分别解读ref的源码实现，以及其核心逻辑。 ​ 首先我们看相对简单的基础类型场景，从源码的角度去了解ref是如何实现响应式的。 基础类型场景案例12345678910let &#123; ref, effect &#125; = Vueconst name = ref(&#x27;卖鱼强&#x27;)effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = name.value&#125;)setTimeout(() =&gt; &#123; name.value = &#x27;狂飙强&#x27;&#125;, 2000) ​ 上述代码现象： 页面初始化的时候显示“卖鱼强” 2s之后，name发生改变，变成了“狂飙强”。 通过现象与我们之前分析reactive的经验，这个我们可以将ref的实现分为三大模块 初始化 读取（依赖收集） 赋值（依赖触发） 初始化packages/reactivity/src/ref.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export function ref(value?: unknown) &#123; // ref 实际上就是createRef return createRef(value, false)&#125;function createRef(rawValue: unknown, shallow: boolean) &#123; // 如果已经是ref，则直接返回 if (isRef(rawValue)) &#123; return rawValue &#125; // ref API 参数shallow 为 false 含义是 代理是否是浅层的,浅层则只会代理第一层数据 // ref 就是RefImpl的实例 return new RefImpl(rawValue, shallow)&#125;class RefImpl&lt;T&gt; &#123; private _value: T // 被代理对象 private _rawValue: T // 原始对象 public dep?: Dep = undefined // Dep是reative阶段声明的Set, 内部存放的是ReactiveEffect public readonly __v_isRef = true // 将RefImpl实例默认为true, 未来的isRef判断就一定为true constructor(value: T, public readonly __v_isShallow: boolean) &#123; // 寻找原始类型，如果是基础类型不会做任何处理 this._rawValue = toRaw(value) // 如果value是基础类型，toReactive内部不会做任何处理 this._value = toReactive(value) &#125; get value() &#123; return this._value &#125; set value(newVal) &#123; newVal = toRaw(newVal) // 判断新旧值是否一致，不一致进入if if (hasChanged(newVal, this._rawValue)) &#123; // 每次value的值发生修改的时候，都保存一下原始对象 this._rawValue = newVal // 如果value是基础类型 toReactive不会做任何处理 // 如果value是复杂类型，则重新进行proxy处理 this._value = toReactive(newVal) // 依赖触发，后面单独说 &#125; &#125;&#125; 通过源码分析，我们可以发现，ref的本质就是new RefImpl 我们ref传入的参数 原始对象被保存到_rawValue，同时将参数（“卖鱼强”）保存到-value中，便于后续的get set 读取调用name.value的时候，会触发RefImpl的**get value()**，方法内部返回最新的_value，完成读取。 12345get value() &#123; // trackRefValue(this) // 依赖收集，后面单独说 return this._value&#125; 赋值name.value发生赋值的时候，会触发RefImpl的**set value()**方法，方法内部进行_value的赋值，完成数据更新。 123456789set value(newVal) &#123; // 判断新旧值是否一致，不一致进入if if (hasChanged(newVal, this._rawValue)) &#123; // 如果value是基础类型 toReactive不会做任何处理 this._value = toReactive(newVal) // triggerRefValue(this)// 依赖触发，后面单独说 &#125;&#125; 到此为止，ref的基础逻辑就完成，我们已经具备给ref赋值、读取的能力。 但是还不具备响应式的能力，接下来就让我们看看，ref的响应式系统是如何实现的。 依赖收集（trackRefValue）​ 根据我们解读reactive的源码经验，我们可以猜到，ref一定是在get中完成依赖收集的，事实也是如此。 ​ 而第一次ref的get是何时触发的呢？ ​ 答案是初始化时期的effect，effect触发后，内部fn被保存到activeEffect中，并触发fn，fn访问了name.value，触发了ref的get行为，所以接下来我们前往RefImpl的get中，看看ref是如何完成依赖收集的。 12345678910111213141516171819get value() &#123; // 依赖收集函数 将当前RefImpl实例传入方法 trackRefValue(this) return this._value&#125;export function trackRefValue(ref) &#123; // shouldTrack一定为true，activeEffect在effect执行阶段保存了fn，所以一定存在 if (shouldTrack &amp;&amp; activeEffect) &#123; // createDep我们在reactive中见过，含义为创建一个Set // 所以这个实际函数是给RefImpl实例的dep赋值为Set，然后在传入trackEffects方法 trackEffects(ref.dep || (ref.dep = createDep())) &#125;&#125;export function trackEffects(dep: Dep,) &#123; // 将当前activeEffect，也就是effect的fn，保存到当前RefImpl实例的dep中，effect成功被ref依赖收集到实例的dep中 dep.add(activeEffect)&#125; 通过以上源码，我们可以发现，他们都公用了activeEffect部分的逻辑，但是ref收集依赖的方式与reactive是存在一些差别的 reactive的依赖收集通过WeakMap完成，实现属性、变量与effect fn的绑定关系 ref则通过自身实例内部的dep变量来保存所有相关的effect fn 依赖触发（triggerRefValue）若干时间后，name.value的值被修改，触发RefImpl的set value 1234567891011121314151617181920212223242526272829set value(newVal) &#123; // 判断传入值是否与原始值不一致 if (hasChanged(newVal, this._rawValue)) &#123; // 完成赋值 this._value = toReactive(newVal) // 依赖触发 triggerRefValue(this) &#125;&#125;export function triggerRefValue(ref: RefBase&lt;any&gt;) &#123; if (ref.dep) &#123; // dep为依赖收集阶段收集到的依赖，内部为effect的fn triggerEffects(ref.dep) &#125;&#125;export function triggerEffects(dep: Dep) &#123; const effects = isArray(dep) ? dep : [...dep] // 转为数组 for (const effect of effects) &#123; // 进入依赖触发函数 triggerEffect(effect) &#125;&#125;function triggerEffect(effect: ReactiveEffect) &#123; // 依次通过run触发被收集的effect的fn，至此完成依赖触发工作 effect.run()&#125; 依赖触发的逻辑就非常简单了，set value的同时，获取当前ref的dep，并遍历dep中的依赖，依次执行，完成依赖触发。 小结​ 到此为止，我们基础类型场景的ref源码解读就结束了，我们简单做一下总结， ​ 相比较于reactive，该场景下的逻辑要稍微简单一点，相关依赖（effect fn）被实例本身的dep管理，没有构建复杂的WeakMap对象。 ref与reactive的收集与触发的逻辑也不相同 ref实际上是一个class RefImpl的实例 数据响应并不是通过proxy实现，而是通过class 的get set修饰符实现 依赖收集、触发并不是通过WeakMap实现，而是通过RefImpl实例中的变量dep实现 复杂类型场景​ 大家都知道ref不仅可以实现基础类型的响应式，还可以实现复杂类型的响应式，我们可以说ref是reactive的超集，那ref是如何实现既支持基础类型也支持复杂类型的呢？ ​ 接下来就让我们看看复杂类型场景下的ref是如何完成响应式的吧。 案例12345678910111213let &#123; ref, effect &#125; = Vueconst obj = ref(&#123; name: &#x27;卖鱼强&#x27;&#125;)effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = obj.value.name&#125;)setTimeout(() =&gt; &#123; obj.value.name = &#x27;狂飙强&#x27;&#125;, 4000) Ref初始化首先依旧是进入ref函数中，开始new RefImpl，前面流程完全一致，所以直接我们进入RefImpl内部 12345678910111213141516171819class RefImpl&lt;T&gt; &#123; private _value: T // 被代理对象 private _rawValue: T public dep?: Dep = undefined // Dep是reative阶段声明的Set,内部存放的是ReactiveEffect public readonly __v_isRef = true // 将RefImpl的实例全部置为true,下次isRef判断就会为true constructor(value: T, public readonly __v_isShallow: boolean) &#123; this._rawValue = toRaw(value) // toRaw 获取原始数据 this._value = toReactive(value) // 跳转到toReactive函数中 并且最终会获取到一个proxy对象 &#125; get value() &#123;&#125; set value(newVal) &#123;&#125;&#125;export const toReactive = &lt;T extends unknown&gt;(value: T): T =&gt; isObject(value) ? reactive(value) : value // value为object，进入reactive(value)逻辑 最终返回一个proxy的对象 ​ 在constructor逻辑中，我们可以看到this._value &#x3D; toReactive(value)，而toReactive函数中，会首先识别value类型，如果不是object，原路返回，如果是object，将会被reactive函数处理，所以在该场景下，value将被reactive函数处理成proxy对象。 ​ 也就是说，此时ref内部的**_value实际上成了reactive**类型。 读取​ 初始化阶段，effect触发的时候，将会读取obj.value.name，，首先会访问量obj.value，触发ref的get方法。 ​ obj.value获取完成后，继续去获取obj.value.name，而name已经在初始化阶段，被toReactive处理成了proxy，所以接下来，会再触发reactive的get，来获取name ​ 也就是说，读取阶段，实际上触发了2次get，一次是ref的get value，一次是proxy的get，进而完成了变量的读取。 1234get value() &#123; // trackRefValue(this) // 依赖收集，后面单独说 return this._value // 获取到proxy类型的&#123;name: &#x27;张三&#x27;&#125;，进而再次触发proxy的get方法&#125; 赋值若干时间后，obj.value.name发生set行为，首先依旧会触发ref的get，获取obj.value，然后再触发reactive的set方法，完成name的赋值。 整个赋值过程，实际上分别触发了ref的get value，和proxy的set，进而完成变量的赋值 12//ref 本身的set在value为object，并且没有直接修改ref.value的情况下，不会被触发set value(newVal) &#123;&#125; 到此为止，我们了解了ref在处理复杂对象时候的读取与赋值的逻辑。 读取：先触发ref的get，再触发proxy的get 赋值：先触发ref的get，再触发proxy的set 依赖收集依赖收集是在get阶段进行完成，而通过上面的分析我们可以了解到，ref的get实际上其内部是两次get事件，所以我们分开来看。 ref的依赖收集（trackRefValue）effect初始化阶段执行的时候，会读取obj.value.name，首先会触发ref的get方法 12345get value() &#123; // 依赖收集函数 将当前ref本身传入方法 trackRefValue(this) return this._value&#125; ref的get方法触发了trackRefValue，会在当前ref的dep中收集到effect，此处逻辑与ref为基础类型的逻辑一致。 proxy的依赖收集（track）​ ref的的get完成后，紧接着触发了reactive的get，然后get内部通过WeakMap再次完成依赖收集（相关逻辑参考Vue3硬核源码解析系列（3） reactive + effect源码解析）。 ​ 我们会发现，在该阶段，我们内部实际上触发了2次依赖收集，effect fn被ref收集的同时，也被proxy收集了。 依赖触发因为ref内部是一个对象，所以赋值也存在多种方式，这依赖触发存在多种方式 对象属性触发依赖1obj.value.name = &#x27;狂飙强&#x27; 这种不会破坏RefImpl初始化阶段其内部构建的proxy，仅修改已有proxy内部变量的值。 首先触发的是obj.value的get行为（此时没有effet在执行，不会发生依赖收集）。然后ref的get函数返回proxy对象 &#123;name:&#39;卖鱼强&#39;&#125; ，紧接着触发proxy的set，并完成依赖触发（proxy的依赖触发请看这里Vue3硬核源码解析系列（3） reactive + effect源码解析）。 对象触发依赖123obj.value = &#123; name: &#x27;狂飙强&#x27;&#125; 第二种方式首先触发obj.value的set行为，同时替换掉ref的值，注意这会破坏RefImpl初始化构建的_value的proxy，进而导致WeakMap中已有的依赖关系断裂 然后执行triggerRefValue，触发，ref本身在get阶段收集了相关effect fn，。 effect fn被触发后，再次触发ref的get，proxy的get，并帮助proxy又重建了与effect fn之间的依赖关系。 这就是为什么存在依赖收集2次的原因。 到此为止，我们的ref核心源码分析就全部完毕了。 关于ref的一些问题Q：为啥一定要.value，不能干掉吗？ A：非常遗憾，value是去不掉的，因为ref依赖class get set 进行实现，在当前实现的场景下，可以简写为v，但是无法去除 Q：我是不是可以完全使用ref，不用reactive？ A：是的，可以完全使用ref，因为ref会根据你传入的类型，自动识别内部是否需要使用reactive，但是读过源码的同学知道ref在处理响应式系统中，存在重复收集依赖的场景，如果你有极致的性能要求，建议复杂类型依旧使用reactive完成，业务开发场景则无所谓。 如果还有其他问题，请评论区提问~ 总结​ 通过对ref源码的阅读，我们可以察觉到，如果仅仅聚焦基础类型的ref，其实底层实现还是比较简单的，所以建议有兴趣的同学渐进式的阅读源码，先完成基础类型场景的源码解读，再进行复杂类型的源码解读，这样事半功倍~ ​ 如果有任何问题，请评论区留言~ ​ 下一个阶段，我将手摸手带大家完成mini版本vue3 ref API，帮助大家深入理解ref~ ​","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue - 源码解读","slug":"Vue-源码解读","permalink":"https://bluedancers.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"Vue3硬核源码解析系列（7）有点难的computed源码解析","slug":"vue3源码解读/Vue3硬核源码解析系列（7）computed源码解析","date":"2023-02-02T16:00:00.000Z","updated":"2023-11-27T02:40:03.338Z","comments":true,"path":"2023/02/03/vue3源码解读/Vue3硬核源码解析系列（7）computed源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89computed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言写过vue的同学，写过computed的都知道，computed会在依赖属性发生变化的时候自动更新结果。 他有一个重要的特点：计算值是可缓存的，只有依赖项发生变化的时候，才会重新计算 而通过之前的文章，我们已经了解了reactive，ref的实现原理，相信大家已经对vue3响应式机制有所了解，今天我们就来了解一下computed是如何实现的。 注：computed的源码难度相当大，我会尽力描述清楚其实现原理，如有不足之处，还请见谅 案例123456789101112131415const obj = reactive(&#123; name: &#x27;张三&#x27;&#125;)const showName = computed(() =&gt; &#123; return &#x27;我叫&#x27; + obj.name&#125;)effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = showName.value&#125;)setTimeout(() =&gt; &#123; obj.name = &#x27;李四&#x27;&#125;, 2000) ​ 以上代码运行后，我们可以看到如下现象 页面显示：我叫张三 2s后，页面显示我叫李四 按照我们之前源码分析的思路，我们依旧从以下三个角度入口 初始化 读取（依赖收集） 赋值（依赖触发） 接下来就让我们走进computed的源码世界吧~ computed初始化1234567891011121314151617181920212223// 入口函数export function computed&lt;T&gt;(getterOrOptions) &#123; let getter; let setter; // 传入的是否是一个方法 const onlyGetter = isFunction(getterOrOptions) if (onlyGetter) &#123; // 如果是方法, 则直接赋值到getter, 同时屏蔽setter行为 getter = getterOrOptions // dev环境下 set函数给予提示 setter = __DEV__ ? () =&gt; &#123; console.warn(&#x27;Write operation failed: computed value is readonly&#x27;) &#125; : NOOP &#125; else &#123; // 如果不是方法,则认为是对象,将对象中的get set分别赋值到getter setter中 getter = getterOrOptions.get setter = getterOrOptions.set &#125; const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR) return cRef&#125; ​ 入口函数的逻辑还是非常简单的，如果传入的是一个匿名函数，这处理为getter，如果传入的是对象，这赋值getter setter，这部分逻辑符合我们对这个API的使用习惯，也解释了computed为何是这样的传参方式。 ​ 抹平两种传参方式的差异后，new ComputedRefImpl，并返回，所以computed &#x3D; new ComputedRefImpl ，我们接下来就进入该Class中看看吧。 12345678910111213141516171819202122232425262728293031// 计算属性的响应式也是通过class get set去实现的export class ComputedRefImpl&lt;T&gt; &#123; public dep?: Dep = undefined // 依赖收集处(effect) private _value!: T // 存储计算属性结果的值 public readonly effect: ReactiveEffect&lt;T&gt; // 存储依赖 public readonly __v_isRef = true // 所有的计算属性也会被识别为ref public _dirty = true // 判断是否需要重新计算 constructor( getter: ComputedGetter&lt;T&gt;, private readonly _setter: ComputedSetter&lt;T&gt;, isReadonly: boolean, // 是否只读,如果存在setter,则为false ) &#123; // 将计算属性的识别为effect，初始化一个ReactiveEffect // 初始化阶段仅仅声明 但是却没有触发 this.effect = new ReactiveEffect(getter, () =&gt; &#123; // 脏变量（_dirty）的本质就是判断什么时候去触发依赖 // 脏变量为false的时候才会触发 if (!this._dirty) &#123; this._dirty = true // 触发依赖 triggerRefValue(this) &#125; &#125;) this.effect.computed = this // 赋值ReactiveEffect中的computed为当前this &#125; get value() &#123;&#125; set value(newValue: T) &#123;&#125;&#125; ​ 在ComputedRefImpl初始化阶段，我们看到了非常熟悉的api，ReactiveEffect，在我们的前面的reactive，ref源码分析中，我们使用这个api来完成关键步骤依赖收集，不过这里有些区别，传入了第二个参数，一个匿名函数，目前还无法体现其作用，我们后面再说 ​ 总的来说，ComputedRefImpl初始化阶段，生成了一个ReactiveEffect并保存到当前类的effect变量中。 依赖收集按照我们实例代码，首次访问effect初次执行的时候，我们会触发showName.value的get，也就是说，会触发ComputedRefImpl的get。 123456789101112131415161718192021222324// 被读取的时候触发get value() &#123; // 依赖收集 trackRefValue(this) // 判断是否需要更新，如果需要则进入函数 if (this._dirty) &#123; // 如果更新过，这下一次就不需要更新了， this._dirty = false // effect的run执行，也就是执行computed的fn，将会得到一次计算属性的结果 this._value = this.effect.run()! &#125; // 返回computed的结果 return this._value&#125;export function trackRefValue(ref: RefBase&lt;any&gt;) &#123; // 首次computed内部的dep是不存在的，会通过createDep生成一个Set trackEffects(ref.dep || (ref.dep = createDep()))&#125;export function trackEffects(dep: Dep) &#123; // 将activeEffect，此时是effect的fn，收集到computed的dep中 dep.add(activeEffect!)&#125; ​ 当我们触发computed的get的时候，首先会触发trackRefValue，将当前activeEffect收集到ComputedRefImpl的dep中，这正是依赖收集，这里effect被收集到了computed的dep中，建立起了computed与其被依赖项（effect）的联系。 ​ 然后判断**_dirty是否为true，默认是true，所以进入判断中，首先将_dirty改为false，下一次则不会进入判断，直接返回computed**之前的结果，之后再执行computed初始化阶段声明的ReactiveEffect，也就是我们computed本身的effect。 ​ computed的effect.run一旦触发，全局activeEffect将会被替换为当前computed的 effect的fn ，并且触发computed依赖项obj.name的get，进而触发proxy的依赖收集，于是obj.name成功收集到了computed内部的effect，proxy与computed建立了联系，同时返回了最新的computed结果。 ​ computed的get行为触发的时候，我们发现computed收集了effect，reactive收集了computed，三者之间建立起了联系。 关于_dirty​ 现在我要个大家着重讲一下ComputedRefImpl中的这个参数，_dirty是实现计算属性缓存性的关键所在， 我们假设一下，没有缓存性的computed，是什么样的运行逻辑 计算属性依赖了变量abc，并返回abc的总和，每个获取计算属性的时候，我都需要计算一次abc的总和，即使abc这三个值没有发生任何变化，就是这样的 依赖触发2s后，我们触发了obj.name的set，所以首先触发obj.name的依赖触发，此时我们将可以通过WeakMap会找到之前收集到computed，我们直接进入依赖触发的逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;) &#123; const depsMap = targetMap.get(target) if (!depsMap) &#123; return &#125; let deps: (Dep | undefined)[] = [] deps.push(depsMap.get(key)) triggerEffects(deps[0]) // 找到了之前收集到的computed中的effect&#125;// 按照常理来说，我们找到指定依赖之后，就是触发依赖，但是计算属性有所不同，因为计算属性存在“调度器”// 还记得computed初始化阶段，new ReactiveEffect传递的第二个参数吗?// 该参数将会被保存到ReactiveEffect的scheduler(调度器)中// 所以此时的ReactiveEffect中，fn是computed的匿名函数，scheduler是computed初始化阶段new ReactiveEffect的第二个参数export function triggerEffects(dep: Dep | ReactiveEffect[]) &#123; const effects = isArray(dep) ? dep : [...dep] for (const effect of effects) &#123; triggerEffect(effect, debuggerEventExtraInfo) &#125;&#125;function triggerEffect(effect: ReactiveEffect) &#123; // 调度器的优先级大于run，所以此时会执行调度器逻辑 if (effect.scheduler) &#123; effect.scheduler() &#125; else &#123; effect.run() &#125;&#125;// 调度器代码this.effect = new ReactiveEffect(getter, () =&gt; &#123; // 还记得我们get之后将dirty改为false吗？ // 此时computed的依赖发生变化，将_dirty改为true，表示下次重新计算 if (!this._dirty) &#123; this._dirty = true // 触发当前computed中收集了相关effect（依赖触发） triggerRefValue(this) &#125;&#125;)export function triggerRefValue(ref: RefBase&lt;any&gt;, newVal?: any) &#123; // 公共依赖触发逻辑 triggerEffects(ref.dep)&#125;// computed的dep中收集的effect触发，再次触发computed的getget value() &#123; // 依赖项发生变化的时候activeEffect不存在，所以此处收集不到任何依赖 trackRefValue(this) // 刚才依赖项发生了变化，所以dirty为true，表示本次需要更新计算属性的结果 if (this._dirty) &#123; // 计算后dirty改为false 除非依赖项发生变化，否则将不会再重新计算。 this._dirty = false // 重新计算 computed的结果 this._value = this.effect.run()! &#125; return this._value&#125; ​ 计算属性的触发逻辑还是非常复杂的，首先proxy的set，触发computed的scheduler（调度器），scheduler通过computed的dep找到相关effect，effect的fn执行又会触发computed的get，并与首次完成computed的计算，同时缓存最新的computed的结果，进而再完成effect的全部逻辑。 代码执行流程依赖收集阶段 computed初始化阶段，通过ReactiveEffect进行初始化，并且生成scheduler（调度器） effect初始化，触发computed的get，将当前activeEffect（effect）收集到computed的dep中（computed将effect收集） 执行computed自身逻辑，刷新全局activeEffect 进而触发proxy的get事件触发，将当前activeEffect（computed）收集到WeakMap中（proxy将computed收集） proxy的返回值返回computed，完成computed的计算逻辑 获取到computed结果，完成effect 依赖触发阶段 触发proxy的set，set行为中触发依赖，触发之前保存的computed的调度器scheduler（proxy找到computed） 调度器scheduler触发，dirty改为true，同时触发computed中保存的依赖，其中都是相关effec的fn。（computed找到effect） effect触发，fn执行，触发computed的get行为 dirty为true，首次进行计算属性的重新计算（除非依赖项改变，否则下次不会重新计算），返回最新的computed结果， effect执行完成 回答一些问题computed如何实现高性能缓存的？​ 通过调度器scheduler + 脏值检查_dirty，实现依赖项不变化，不进行重新计算，依赖项变化后仅执行一次的逻辑，进而实现高性能缓存。 为什么访问computed需要.value​ 因为我们访问computed实际上是访问ComputedRefImpl这个Class的实例，他的内部通过get value返回被访问值，所以我们必须通过**.value**来访问 简述computed的实现原理？ vue的响应式api都可以从依赖收集 依赖触发2个角度出发阐述其原理实现 依赖收集阶段：computed通过首次get的完成相关effect的依赖收集，首次计算的时候proxy完成computed的依赖收集。 依赖触发阶段：computed的依赖项发生变化后，会通过proxy找到computed的调度器 scheduler，触发所有effect，effct中再出发computed的get，首次get将进行一次结果运算（后续不在运算，除非computed依赖项发生变化），effect触发完成 总结​ 到此为止，我们computed的核心源码就解读完毕了，虽然总体依旧可以从依赖收集和依赖触发两个角度去理解实现原理，但是新增加的scheduler（调度器）与**_dirty（脏值检查）**机制，让逻辑复杂了很多。 ​ 大家在理解computed源码的时候，一定要多走几遍流程，多捋几遍逻辑。","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"（3）vue3 reactive源码解析","slug":"vue3源码解读/Vue3硬核源码解析系列（3） reactive + effect源码解析","date":"2023-01-31T16:00:00.000Z","updated":"2023-11-27T02:39:34.784Z","comments":true,"path":"2023/02/01/vue3源码解读/Vue3硬核源码解析系列（3） reactive + effect源码解析/","link":"","permalink":"https://bluedancers.github.io/2023/02/01/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20reactive%20+%20effect%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"专栏前言​ 本文是vue3源码解析系列的第三篇文档，在前两篇文章中，我们了解了vue3源码的运行、调试，以及阅读前的一些前置知识点，从本节开始，我们就可以正式的开始vue3的源码阅读了。 ​ 我们首先阅读的模块是@vue&#x2F;reactivity 中的reactive以及相关api，effect的源代码。 在正文开始之前，我先将本节的简化版源码放出来，有兴趣的同学可以clone到本地，一边debug，一边阅读文章，这样效果更佳~ https://github.com/BlueDancers/vue3-mini/tree/reactive 前言reactive的含义如其名称，通过reactive创建的对象都是具备响应式的。即reactive对象的改变会造成副作用。 于是我们引出副作用API（effect），如果effect内部依赖了reactive，则reactive的改变会重新触发effect。 现在让我们走进案例与源码，看看究竟是如何实现响应式的。 案例123456789101112 let &#123; reactive, effect &#125; = Vue const obj = reactive(&#123; name: &#x27;卖鱼强&#x27;, &#125;) effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = obj.name &#125;)setTimeout(() =&gt; &#123; obj.name = &#x27;狂飙强&#x27;&#125;, 2000) 以上测试案例，我们涉及到了三个重要的阶段 reactive初始化 effect初始化 reactive发生修改 最后形成了effect的自动触发，我们就从以上三个角度去切入源码实现。 reactive初始化 为了方便阅读与理解，以下仅贴出核心源码 packages/reactivity/src/reactive.ts 1234567891011121314151617181920212223242526272829303132export function reactive(target) &#123; return createReactiveObject( target, // reactive里面的值 false, mutableHandlers, mutableCollectionHandlers, reactiveMap )&#125;function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) &#123; // 判断是否已经被代理过了，如果是，则获取缓存中的值，并直接返回 // 我们这里第一次指定，必然是不存在的，所以跳过这个 const existingProxy = proxyMap.get(target) if (existingProxy) &#123; return existingProxy &#125; // 对reactive中的变量进行代理，我们这里的target类型是obejct，targetType为common，所以接下来进入baseHandlers逻辑 // 而baseHandlers从reactive被当做参数传递过来的，实际执行的是mutableHandlers const proxy = new Proxy( target, baseHandlers ) proxyMap.set(target, proxy) return proxy&#125;// reactive中变量类型为object场景下，proxy的监听逻辑会走到这里export const mutableHandlers = &#123; get, set,&#125; ​ 通过源码 我们可以看得出来，使用reactive，内部实际执行的是createReactiveObject，函数就是新建了proxy，并最终返回。 ​ 不过要注意一点的是，经过reactive处理过的对象，都会以target为WeakMap键，proxy为值，进行一次缓存，这样同一个值再次进行reactive的时候就会读取缓存中的值。 ​ 接下来，让我们进入初始化阶段的mutableHandlers，也就是proxy中核心的get set函数，看看内部做了些什么。 初始化读取（get）当触发obj.name的读取行为的时候，就会触发代理对象的get函数 packages/reactivity/src/baseHandlers.ts 123456789101112131415const get = createGetter()function createGetter() &#123; return function get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver) // 读取被代理对象 // 核心逻辑(track)：依赖收集，后续单独看 // 如果当前值是reactive则递归proxy处理 if (isObject(res)) &#123; return reactive(res) &#125; return res &#125;&#125; get内部的逻辑很简单，通过Reflect完成被代理对象的读取操作。 如果被读取对象的属性是object则会再次进入reactive逻辑中进行proxy处理，确保嵌套对象的响应式。 也许有的人会说了proxy不是自身就实现了对象的拦截了吗？为什么我们还是要递归处理嵌套obj呢？ 这里我给大家解释一下，proxy确实会拦截到所有操作，但是他也只能拦截当前层级的。 如果没有递归处理， obj.name.abc &#x3D; 123的时候，只会触发obj.name的get事件，但是不会触发obj.name.abc的set事件。 初始化修改（set）当触发obj.name的修改行为，将会触发代理对象的set函数 packages/reactivity/src/baseHandlers.ts 123456789101112const set = createSetter()function createSetter(shallow = false) &#123; return function set(target, key, value, receiver) &#123; // 修改被代理数据，完成数据更新 const res = Reflect.set(target, key, value, receiver) // 核心逻辑(trigger)：依赖触发，后续单独看 return res // true &#125;&#125; 通过Reflect完成被代理对象值的更新，最后返回本次Reflect.set的结果，完成逻辑。 总体就是对proxy的简单利用，还是很简单的嘛 小结​ 以上代码是去除所有边界判断，以及响应式逻辑后，reactive的核心代码；我们可以发现，其实就是proxy + Reflect的基础使用。 ​ 目前数据已经具备响应式，但是数据变化后，引用数据的effect如何实现自动执行呢？接下来我们就去看看effect初始化的时候究竟做了什么。 effect初始化读取 - 依赖收集（track）​ 我们回到测试demo中，根据我们使用vue3的预期，在初始化完成后，effect会触发一次，若干时间后，setTimeout内set触发，依赖obj.name的 effect的函数还会被触发一次，这又是如何实现的呢？ ​ 这里我要提到Vue3中第一个非常非常非常重要的概念，依赖收集（track），整个reactivity都利用到了这个概念。 ​ 接下来，我们就要通过源码去了解，effect的初始化的时候，到底发生了什么，Vue3在此阶段是如何完成依赖收集的。 packages/reactivity/src/effect.ts 12345678910111213141516171819202122232425/** * 当前被执行的effect */export let activeEffect: ReactiveEffect | undefinedexport function effect(fn) &#123; const _effect = new ReactiveEffect(fn) // 首先执行new ReactiveEffect，所以我们跳转到ReactiveEffect中 _effect.run() // 并立刻执行了run方法，run方法内实际执行的就是effect内部函数&#125;export class ReactiveEffect &#123; parent: ReactiveEffect | undefined = undefined constructor( public fn: () =&gt; T, // 这里的fn就是effect内部的匿名函数 ) &#123;&#125; run() &#123; try &#123; activeEffect = this // 将effect对象，也就是new ReactiveEffect的结果，保存到activeEffect shouldTrack = true // 表示开始依赖收集 return this.fn() // 这里的fn，实际上就是effect内部的匿名函数 &#125; &#125;&#125; vue3的依赖收集几乎都是通过ReactiveEffect进行完成的，简单来说就是ReactiveEffect.run一旦运行后，就会将当前正在运行的匿名函数保存到内存中，以便于proxy get事件触发的时候，收集保存在内存中的匿名函数，进而完成依赖收集。 ​ effect方法内部，首先new ReactiveEffect 最终执行了一次fn，但是在执行之前，将activeEffect赋值为this，将自身保存到了公共变量activeEffect之中。 让我们来看看此时运行的fn是什么 123() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = obj.name&#125; ​ 匿名函数的内部读取了obj.name，触发了被代理对象obj的get方法. ​ 所以接下来我们回到get方法中，查看之前忽略的依赖收集逻辑。 packages/reactivity/src/baseHandlers.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function createGetter(isReadonly = false, shallow = false) &#123; return function get(target: Target, key: string | symbol, receiver: object) &#123; const res = Reflect.get(target, key, receiver) // 读取被代理对象 if (!isReadonly) &#123; // obj为可读代码 所以isReadony一定为false 进入if中 track(target, TrackOpTypes.GET, key) &#125; return res &#125;&#125;// 依赖收集function track(target, type, key) &#123; if (shouldTrack &amp;&amp; activeEffect) &#123; // 在effect中执行run方法的时候，我们确保了shouldTrack为true activeEffect 存在值，所以进入判断 let depsMap = targetMap.get(target) // targetMap是一个全局变量，实际上是一个new WeakMap 首次depsMap肯定是不存在的 if (!depsMap) &#123; // 这里的target为被代理对象，&#123;name: &#x27;张三&#x27;&#125;，该值做为key，Map作为value targetMap.set(target, (depsMap = new Map())) &#125; let dep = depsMap.get(key) // 当前key为name 首次也是不存在的 if (!dep) &#123; // depsMap是一个Map结构，key是name value是createDep()的返回值，我们进入createDep depsMap.set(key, (dep = createDep())) &#125; // 将dep作为参数传递到trackEffects中，此时的dep为Set trackEffects(dep, undefined) &#125;&#125;export const createDep = (effects?) =&gt; &#123; const dep = new Set(effects) // 实际上就是生成了Set结构（Set我们简单理解为元素不可重复的数组） dep.w = 0 dep.n = 0 return dep&#125;export function trackEffects( dep: Dep,) &#123; // 一系列边界判断，合法的情况下shouldTrack为true if (shouldTrack) &#123; dep.add(activeEffect!) // 将全局变量activeEffect（包含effect的匿名函数）加入到dep（Set）中 // 到这里 我们将响应式数据与effect函数建立起了联系 标志着我们完成了依赖收集 &#125;&#125; ​ effect内部的fn被触发，fn执行中触发了obj的get，get内部触发了依赖收集（track），track内部通过构建targetMap，来维护变量与effect之间的关系，进而实现所谓的依赖收集。 ​ 我们来梳理一下他的数据结构 WeakMap key：被代理对象（{name:’张三’}） value：Map对象 key：响应式对象的指定属性（name） value：指定对象的指定属性的使用函数（effect的匿名函数） 在WeakMap中，我们不仅仅收集了effect的匿名函数，还将effect与effect中具体读取的变量建立起了联系。 在未来的依赖触发逻辑中，weakMap将会发挥巨大作用。 到此为止，effect内的匿名函数执行完毕，同时我们也完成了重要的依赖收集。 修改 - 依赖触发（trigger）继续回到demo中，2s后，obj.name赋值为狂飙强，此时的现象是effect中的函数自动执行了，这又是如何实现的呢？ 此处首先一定是触发了代理对象obj.name的set，所以我们由此处开始分析。 packages/reactivity/src/baseHandlers.ts 123456789101112131415161718192021222324252627282930function createSetter(shallow = false) &#123; return function set(target, key, value, receiver): boolean &#123; const result = Reflect.set(target, key, value, receiver) // 完成被代理对象的赋值操作 trigger(target, TriggerOpTypes.SET, key, value, oldValue) return result &#125; export function trigger(target, type, key?, newValue?, oldValue?, oldTarget?) &#123; // 通过全局变量targetMap（weakMap）获取value // 在依赖收集阶段我们收集到了当前target，所以这时候 depsMap存在值 值为Map Map的key为name 值为Set Set内部是effect的fn const depsMap = targetMap.get(target) triggerEffects(depsMap.get(key))&#125; export function triggerEffects(dep, debuggerEventExtraInfo?) &#123; const effects = isArray(dep) ? dep : [...dep] // 将set处理为数组 for (const effect of effects) &#123; triggerEffect(effect, debuggerEventExtraInfo) &#125;&#125; function triggerEffect( effect: ReactiveEffect, // 每一个effect都是ReactiveEffect，内部的fn都是effect的fn) &#123; // 此时的activeEffect为undefined，一定进入if中 if (effect !== activeEffect || effect.allowRecurse) &#123; effect.run() // effect的run方法就是effect的fn，完成执行 &#125;&#125; 经过以上代码，我们可以了解到，obj.name的改变在触发了proxy的set方法的同时，也触发了依赖触发（trigger）。 trigger中，我们首先通过**{name: ‘狂飙强’}，找到了Map，再通过name找到Set，最终找到对应的effect的fn**，并进行匿名函数的执行，于是我们便看到了effect函数自动触发。 到此为止完成了整个响应式过程。 reactive源码总结我们简单总结一下，reactive中依赖收集与依赖触发的过程 通过proxy处理reactive包裹的对象，被返回proxy代理对象 effect初始化，生成了类ReactiveEffect，并执行了其run方法 run方法执行后，当前effect的fn函数本身被保存到了activeEffect(公共变量)，随后执行了effect的fn effect的fn触发，函数内使用到了obj.name，触发了代理对象的get get方法内部触发了依赖收集（track），配合保存到局部的activeEffect，最终通过WeakMap，建立了effect的fn与当前get的属性的联系，完成了依赖收集。 若干时间后，obj.name &#x3D; ‘狂飙强’，触发proxy的set，同时触发了依赖触发（trigger） trigger内部通过当前代理对象以及具体修改的属性，在依赖收集阶段保存的WeakMap中，找到所有需要触发的effect的fn。 触发effect的fn函数，完成响应式。 最后反映在我们眼前，就是obj.name改变的同时，所有使用到obj.name的effet都被自动触发其匿名函数，完成响应式。 关于vue3 reactive的面试题为什么Vue3的响应式使用WeakMap实现？​ 还记得我们前一篇文章谈到的WeakMap吗，一旦被代理对象被置为null，weakMap中该key将会被垃圾回收，达到性能最大化的目的 简述Vue3的响应式的核心实现逻辑？​ 通过proxy递归代理对象，然后在get中完成依赖收集，在set中完成依赖触发 Vue3的reactive为什么不能代理简单类型？​ reactive底层依赖proxy，但是proxy只能代理对象，无法代理基础类型。 为什么reactive解构会失去响应式？​ 这里要明确一点，只有解构出来的变量是基础类型的时候，才会失去响应式，失去响应式的主要原因是基础类型无法被proxy代理。 总结​ 到此为止，我们的vue3中的响应式模块的第一个API，reactive源码解读就完成了； ​ 总的来说逻辑还是比较复杂的，尽管我已经很努力的去反复修改与简化，但是还是能可以感觉到，有些东西很难用文字讲清楚。 ​ 也不知道是否可以帮助到正在阅读文章的你，如果你觉得还不错的话，还麻烦你动动小手点个赞，关注专栏，这是我输出优质文章最大的动力。 ​ 如果有小伙伴存在视频教程诉求的话，请评论区告诉我，我会评估出几期视频的必要性~ ​ 下一站，我们将前往ref。 ​","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"（2）Object.defineProperty vs proxy","slug":"vue3源码解读/Vue3硬核源码解析系列（2）Object.defineProperty VS proxy","date":"2023-01-29T16:00:00.000Z","updated":"2023-11-27T02:39:24.358Z","comments":true,"path":"2023/01/30/vue3源码解读/Vue3硬核源码解析系列（2）Object.defineProperty VS proxy/","link":"","permalink":"https://bluedancers.github.io/2023/01/30/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89Object.defineProperty%20VS%20proxy/","excerpt":"","text":"专栏前言本文是vue3源码解析系列的第二篇文章，这一章我们主要学习vue3源码中涉及到的一些核心api。 后续的源码解读是非常复杂的，所以相关基础知识一定要牢固哦~ 前言大部分使用过vue3的同学都知道，vue3的底层的响应式实现由Object.defineProperty更换成了Proxy。 为什么vue3要更换呢？proxy相对于前者又有何优势呢？ 接下来让我们通过案例去一探究竟吧！ ​ 当响应式不存在我们先看一个例子 12345678910let shoes = &#123; num: 3, price: 10,&#125;let total = shoes.num * shoes.priceconsole.log(total) // 30shoes.num = 5console.log(total) // 30 第二次打印依旧是30，虽然我们的num发生了变化，但是下一次获取total的值依旧是之前的值，因为total已经被运算过了。 那应该怎么做，才能实时的获取到当前最新的total呢？ 也很简单，我们每次获取之间，手动重新计算一次就好了。 1234567891011121314151617let shoes = &#123; num: 3, price: 10,&#125;let total = 0function effect() &#123; total = shoes.num * shoes.price&#125;effect() // 重新计算console.log(total) // 30shoes.num = 5effect() // 重新计算console.log(total) // 50 ​ 我们增加effect方法来手动触发依赖，这样我们实现了需求。 ​ 但是这样手动触发的方式，在真实业务中过于繁琐，难以维护，本质上依旧是命令式思维。 ​ 如何实现值的修改，后续逻辑的自动执行呢？ vue2的解决方案通过Object.defineProperty来对字段进行代理，通过set，get方法，完成逻辑的自动触发。 123456789101112131415161718192021let num = 3let shoes = &#123; num: num, price: 10,&#125;let total = 0function effect() &#123; console.log(&#x27;开始计算&#x27;, shoes) total = shoes.num * shoes.price&#125;// 被代理的值无法不可再get中使用了 因为会触发ett的死循环// 所以,必须增加一个变量来做被代理的值,所以我们监听shoes.num的get set内部实际修改和读取的都是numObject.defineProperty(shoes, &#x27;num&#x27;, &#123; set(newVal) &#123; num = newVal effect() &#125;, get() &#123; return num &#125;,&#125;) ​ 我们再以上代码，再次修改shoes.num，将触发代理中的set，进而触发effect，实现依赖的自动触发，vue2的底层也正是如此实现的，这样看起来我们的需求已经解决了，那为何vue3有放弃了Object.defineProperty呢？ ​ 接下来我们就要聊聊他的缺陷。 Object.defineProperty的缺陷该API确实满足了我们上面提到的案例，但是他在一些场景也存在很多问题。 比如大家一定都遇到过的问题 object中新增字段 没有响应性 array中指定下标的方式增加字段 没有响应性的 为什么会这样呢？vue的官方解释是 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。 尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。 那JavaScript到底限制了什么呢？ ​ object.defineProperty只能监听到指定对象的指定属性的get set，这些工作其实是vue初始化阶段完成，所以指定对象的指定元素发生变化的时候，我们可以监听到变化，vue中也确实是这么表现的； ​ 但是如果，我们在指定对象上面新增属性，object.defineProPerty是无法监听到的，无法监听则无法处理被新增的字段，自然字段就不具备响应式； ​ 在vue2中，如果想解决以上问题，需要使用Vue.$set进行手动增加响应式字段，解决无法监听到字段新增的问题。 vue3的解决方案vue3中改用了proxy，为什么响应式核心api做了修改，proxy是什么？我们先实现一个类似vue2的案例 123456789101112131415161718192021222324252627let shoes = &#123; num: 3, price: 10,&#125;let shoesProxy = new Proxy(shoes, &#123; // target 被代理对象 key 本次修改的对象中的键 newValue 修改后的值 receiver 代理对象 set(target, key, newValue, receiver) &#123; console.log(&#x27;触发了写入事件&#x27;) shoes[key] = newValue effect() return true &#125;, // target 被代理对象 key 本次读取的值 receiver 代理对象 get(tartget, key, receiver) &#123; console.log(&#x27;触发了获取事件&#x27;) return shoes[key] &#125;,&#125;)let total = 0function effect() &#123; console.log(&#x27;开始计算&#x27;, shoes) // 如果使用被代理对象本身shoes,这不会触发 // 如果使用代理对象shoesProxy,则这里会触发proxy的get事件 total = shoes.num * shoes.price&#125; 通过以上代码，我们可以看到一些差别 object.defineproperty 代理的并非对象本身，而是对象中的属性 只能监听到对象被代理的指定属性，无法监听到对象本身的修改 修改对象属性的时候，是对原对象进行修改的，原有属性，则需要第三方的值来充当代理对象 proxy proxy针对对象本身进行代理 代理对象属性的变化都可以被代理到 修改对象属性的时候，我们针对代理对象进行修改 无论是逻辑的可读性，还是API能力上，proxy都比object.defineProPerty要强很多，这也是vue3选择proxy的原因。 proxy的好兄弟Reflect​ 在vue3的源码中的**@vue&#x2F;reactivity中，我们会经常看到在proxy的set、get中存在Reflect的身影，但是从我们上面对proxy的使用来看，赋值 读取都实现了，为什么vue3中使用了Reflect**呢？ 首先我们了解一下Reflect是干嘛的 官方解释：Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。 似乎比较难理解，我们举个例子吧 123let obj = &#123; num:10 &#125;obj.num // 10Reflect.get(obj,&#x27;num&#x27;) // 10 这么来看，似乎这个api很普通啊，反而把简单的读取值写复杂了。 这时候我们就要提一下Reflect.get 的第三个参数了 1Reflect.get(target, propertyKey, receiver]) // receiver 如果target对象中指定了propertyKey，receiver则为getter调用时的this值。 这次我们知道了，第三个参数receiver具有强制修改this指向的能力，接下来我们来看一个场景 123456789101112131415let data = &#123; name: &#x27;张三&#x27;, age: &#x27;12岁&#x27;, get useinfo() &#123; return this.name + this.age &#125;,&#125;let dataProxy = new Proxy(data, &#123; get(target, key, receiver) &#123; console.log(&#x27;属性被读取&#x27;) return target[key] &#125;,&#125;)console.log(dataProxy.useinfo) 打印情况如下 12属性被读取张三12岁 ​ dataProxy.useinfo的get输出的值是正常的，但是get只被触发了一次，这是不正常的； ​ 因为useinfo里面还读取了被代理对象data的name、age，理想情况应当是get被触发三次。 ​ 为什么会出现这样的情况呢，这是因为调用userinfo的时候，this指向了data，实际执行的是data.userinfo，此时的this指向data，而不是dataProxy，此时get自然是监听不到name、age的get了。 ​ 这时候我们就用到了Reflect的第三个参数，来重置get set的this指向。 1234567let dataProxy = new Proxy(data, &#123; get(target, key, receiver) &#123; console.log(&#x27;属性被读取&#x27;) return Reflect.get(target, key, receiver) // this强制指向了receiver // return target[key] &#125;,&#125;) 打印情况如下 1234属性被读取属性被读取属性被读取张三12岁 现在打印就正常了，get被执行的3次，此时的this指向了dataProxy，Reflect很好的解决了以上的this指向问题。 ​ 通过以上案例，我们可以看到使用target[key]有些情况下是不符预期的，比如案例中的被代理对象this指向问题，而使用Reflect则可以更加稳定的解决这些问题，在vue3源码中也确实是这么用的。 补充章节（WeakMap）​ 通过以上文章，我们了解到了object.defineproperty相较于proxy的劣势，以及搭配proxy同时出现的Reflect的原因，这是vue3最核心的api。 ​ 但是仅仅知道理解proxy+reflect，还不太够，为了尽量轻松的阅读Vue3源码，我们还要学习一个原生API，那就是WeakMap。 WeakMap MDN中文文档地址 ​ weakMap和map一样都是key value格式，但是他们还是存在一些差别。 weakMap的key必须是对象，并且是弱引用关系 Map的key可以是任何值（基础类型+对象），但是key所引用的对象是强引用关系 ​ 通过查阅MDN我们可以发现，weakMap可以实现的功能，Map也是可以实现的，那为什么Vue3内部使用了WeakMap呢，问题就在引用关系上 强引用：不会因为引用被清除而失效 弱引用：会因为引用被清除而自动被垃圾回收 概念似乎还无法体现其实际作用，我们通过以下案例即可明白 12345678910111213// Maplet obj = &#123; name: &#x27;张三&#x27; &#125;let map = new Map()map.set(obj, &#x27;name&#x27;)obj = null // obj的引用类型被垃圾回收console.log(map) // map中key obj依旧存在// WeakMaplet obj = &#123; name: &#x27;张三&#x27; &#125;let map = new WeakMap()map.set(obj, &#x27;name&#x27;)obj = null // obj的引用类型被垃圾回收console.log(map) // weakMap中key为obj的键值对已经不存在 通过以上案例我们可以了解到 弱引用在对象与key共存场景存在优势，作为key的对象被销毁的同时，WeakMap中的key value也自动销毁了。 弱引用也解释了为什么weakMap的key不能是基础类型，因为基础类型存在栈内存中，不存在弱引用关系； 在vue3的依赖收集阶段，源码中用到了WeakMap，具体什么作用？我们下一节进行解答。 结语​ 通过本篇文章，我们认识到了object.defineproperty相较于proxy的劣势，以及搭配proxy同时出现的Reflect的原因，还有一个Map的原生的API，WeakMap的作用。 ​ 接下来我们就可以正式走进vue3源码的世界~","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"（1.1）搭建属于自己的vue3","slug":"vue3源码解读/Vue3硬核源码解析系列（1）准备工作","date":"2023-01-28T16:00:00.000Z","updated":"2023-11-27T02:39:16.228Z","comments":true,"path":"2023/01/29/vue3源码解读/Vue3硬核源码解析系列（1）准备工作/","link":"","permalink":"https://bluedancers.github.io/2023/01/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"前言​ 我们本次源码的目的是最终完成一个简化版的vue3，我们将他称为vue3-mini，本节我们就开始项目的搭建工作。 生成项目1npm init 引入ts1tsc -init tsconfig.json范本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; // 编辑器配置 &quot;compilerOptions&quot;: &#123; // 根目录 &quot;rootDir&quot;: &quot;.&quot;, // 严格模式标志 &quot;strict&quot;: true, // 指定类型脚本如何从给定的模块说明符查找文件。 &quot;moduleResolution&quot;: &quot;node&quot;, // https://www.typescriptlang.org/tsconfig#esModuleInterop &quot;esModuleInterop&quot;: true, // JS 语言版本 &quot;target&quot;: &quot;es5&quot;, // 允许未读取局部变量 &quot;noUnusedLocals&quot;: false, // 允许未读取的参数 &quot;noUnusedParameters&quot;: false, // 允许解析 json &quot;resolveJsonModule&quot;: true, // 支持语法迭代:https://www.typescriptlang.org/tsconfig#downlevelIteration &quot;downlevelIteration&quot;: true, // 允许使用隐式的 any 类型(这样有助于我们简化 ts 的复杂度，从而更加专注于逻辑本身 &quot;noImplicitAny&quot;: false, // 模块化 &quot;module&quot;: &quot;esnext&quot;, // 转换为 JavaScript 时从 TypeScript 文件中删除所有注释。 &quot;removeComments&quot;: false, // 禁用 sourceMap &quot;sourceMap&quot;: false, // https://www.typescriptlang.org/tsconfig#lib &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot; ], &quot;baseUrl&quot;: &quot;.&quot;, // 设置路径映射 // 设置后ts在打包过程中也会自动完成路径映射,需要其他地方再次设置 &quot;paths&quot;: &#123; &quot;@vue/*&quot;: [ &quot;packages/*/src&quot; ] &#125; &#125;, &quot;include&quot;: [ &quot;packages/*/src&quot; ],&#125; 引入代码格式化vscode下载插件prettier 创建文件.prettierrc.js 12345678910module.exports = &#123; singleQuote: true, // 单引号 trailingComma: &#x27;es5&#x27;, // 对象属性最后有 &quot;,&quot; semi: false, // 是否需要分号 printWidth: 110, // 一行最多120 jsxSingleQuote: true, // jsx使用单引号 tabWidth: 2, // 一个tab代表几个空格数，默认就是2 useTabs: false, // 不使用缩进符，而使用空格 jsxBracketSameLine: true,&#125; 创建文件.prettierignore 1234567# Ignore artifacts:distbuildcoveragecommontsconfig.jsonREADME.md 后续的代码格式化工具上选择prettier即可 我们这里不使用eslint，不做非常强制的代码校验 创建相关文件按照vue3源码中的结构进行创建，暂时只创建packages文件夹 引入打包工具全局安装rollup 1npm install --global rollup 项目创建rollup配置文件rollup.config.js output中的name暂时不生效 123456789101112131415161718192021222324252627282930313233import resolve from &#x27;@rollup/plugin-node-resolve&#x27;import commonjs from &#x27;@rollup/plugin-commonjs&#x27;import typescript from &#x27;@rollup/plugin-typescript&#x27;/** * 默认导出一个数组,数组中,每个对象都是独立导出项 */export default [ &#123; input: &#x27;packages/vue/src/index.ts&#x27;, output: [ // 导出iife的包(自动执行 适用于script标签) &#123; format: &#x27;iife&#x27;, sourcemap: true, file: &#x27;./packages/vue/dist/vue.js&#x27;, name: &#x27;Vue&#x27;, // 指定打包后的全局变量名（如果被打包代码，没有任何导出，将不存在导出名称） &#125;, ], // 插件 plugins: [ // 让rollup 支持打包ts代码,并可以指定ts代码打包过程中的相关配置 typescript(&#123; sourceMap: true, &#125;), // 与webpack不同的是,rollup并不知道如何寻找路径以外的依赖,比如node_module中的 // 帮助程序可以在项目依赖中找到对应文件 resolve(), // rollup默认仅支持es6的模块,但是还存在很多基于commonjs的npm模块,这就需要改插件来完成读取工作 commonjs(), ], &#125;,] package.json中增加打包命令 1&quot;build&quot;: &quot;rollup -c&quot; 执行打包命令 1npm run build 然后我们在packages/vue/src/index.ts编写测试代码 123import &#123; isArray &#125; from &#x27;@vue/shared&#x27; // ts部分我们配置了paths选项console.log(isArray([])) 不出意外的话，这里肯定是正常打包了，并且会生成sourceMap文件。 热更新package的script中增加一个命令 1&quot;dev&quot;: &quot;rollup -c -w&quot; 至此，基础的vue3框架环境我们就搭建完成了。","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"（1）vue3 源码解读前的准备工作","slug":"vue3源码解读/（1）vue3 源码解读前的准备工作","date":"2023-01-27T16:00:00.000Z","updated":"2023-11-27T02:38:37.875Z","comments":true,"path":"2023/01/28/vue3源码解读/（1）vue3 源码解读前的准备工作/","link":"","permalink":"https://bluedancers.github.io/2023/01/28/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%881%EF%BC%89vue3%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"前言​ 在22年下半年就有想阅读vue3源码的想法了，但是因为很多不可抗力原因，一直在不断拖延。 ​ 23年年初下定决心，一定要在半年内完成vue3的核心源码的解读，所有源码的阅读记录我都讲输出到本专栏中，目测可能有10片以上的文章，在输出中，我会尽力保证文字的简单易懂； ​ 话不多说，我们直接开始吧！ 下载vue3源码仓库地址：https://github.com/vuejs/core 本专栏版本为3.2.37，地址：https://github.com/vuejs/core/releases/tag/v3.2.37 克隆仓库地址 1git clone https://github.com/vuejs/core 打包与运行vue3源码vue3采用monorepo进行包管理，而monorepo由pnpm提供，所以需要一定要预先安装pnpm 1npm install -g pnpm pnpm安装完成后，开始安装vue3的依赖 1pnpm install 依赖安装完成后，开始vue3源码的打包工作，该步骤可能花费较长时间 1npm run build ​ 打包完成后，将会在packages/vue/dist，路径下生成打包后的vue3的代码，接下来我们去packages/vue/examples官方提供的案例中运行打包后代码，在目标html文件通过vscode启动live server，即可完成vue3示例的运行。 打包vue3源码可能遇到的问题Error: Command failed with exit code 128: git rev-parse HEAD运行build之后，出现以上错误，原因是因为build的过程中，会读取了当前git的commit id，如果当前目录下没有**.git**文件，相关逻辑就会出错，所以需要注释掉scripts/build.js中以下代码 12line34 const commit = execa.sync(&#x27;git&#x27;, [&#x27;rev-parse&#x27;, &#x27;HEAD&#x27;]).stdout.slice(0, 7)line97 `COMMIT:$&#123;commit&#125;` 跳过获取commitID相关逻辑代码，即可正确打包。 vue3示例中源码未支持SourceMap当我们完成上文的打包后，我们运行一个example，运行后就会发现一个问题，我们使用Vue3源码是打包后的代码，没有sourceMap，这样是无法调试源码的。 vue3源码内提供了打开sourceMap的能力，修改打包命令package.json中的line7，即可 1node scripts/build.js -s 为什么这个改动呢？我们还要从rollup.config.js入手 在rollup.config.js的line94 我们可以看到 1output.sourcemap = !!process.env.SOURCE_MAP // 反向取反，获取其对应的boolean类型的值 要开启sourcemap首先需要修改process.env.SOURCE_MAP，而这个值来源于scripts/build scripts/build.js中的line103 1sourceMap ? `SOURCE_MAP:true` : `` 而这里的sourceMap来源于命令行后缀 12const args = require(&#x27;minimist&#x27;)(process.argv.slice(2))const sourceMap = args.sourcemap || args.s 所以我们只需要在脚本命令后增加-s即可开启sourcemap。 至此为止，我们便可以在vue源码环境中进行阅读与调试了","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"（0）vue3源码解读前的准备工作","slug":"vue3源码解读/（0）vue3源码解读前的准备工作","date":"2023-01-25T16:00:00.000Z","updated":"2023-11-27T02:38:29.506Z","comments":true,"path":"2023/01/26/vue3源码解读/（0）vue3源码解读前的准备工作/","link":"","permalink":"https://bluedancers.github.io/2023/01/26/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%880%EF%BC%89vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"命令式VS声明式命令式​ 我们的前端代码中，大部分都是命令式思维，这种思维与我们现实是具备一定的一致性的，也就是说他不抽象，这也是为什么JavaScript是一门容易入门的语言。 ​ 比如我们想获取Dom1中的Dom2中的Dom3，并给其赋值“你好”，则我们的流程是 获取dom1 获取dom1中的dom2 获取dom2中的dom3 给dom3赋值你好 ​ 命令式编程相对于结果更加强调过程，非常好理解，但是命令式也有他的缺点，那就是一旦命令很长，代码也会非常难以维护。 ​ 声明式​ 而声明式则更多关注结果，究竟是什么样的过程，这并不是开发者需要关心。 ​ 我们依旧使用上面的例子，我们只需要在Dom3中进行&#123;&#123; msg &#125;&#125;声明，然后只关心何时更新其具体的值即可，msg是如何更新，这并不是开发者关心的问题，一般来说这些工作我们都是交给框架进行完成的。 如何评价？评价一个框架的好坏，我们一般从2个角度出发 性能 可维护性 命令式编程是JavaScript自带的编程方式，毫无疑问性能是最好多，声明式则需要我们内部进行一些运算，但是在可维护性的角度上来说，声明式的代码要更加简单、直观，项目越复杂，越能体现声明式的可维护性 总结一下 性能：命令式 &gt; 声明式（项目越大，差距越小） 可维护性：声明式 &gt; 命令式（项目越大，差距越大） 企业应用的开发与设计原则企业开发中，公司关注的无非就是以下2点 项目成本：就是开发周期的控制，如何更快更稳定的完成开发工作是首要目标 开发体验：开发体验式开发者的第一诉求（开发、维护难度），但是也符合公司诉求，因为好的开发体验可以加速开发进度 所以在企业纬度，可维护性是非常看重的一点，所以企业更加愿意使用声明式的开发方式 但是在性能的角度来说，命令式是一定高于声明式的，难道性能就不重要吗？ 框架的取舍 在可维护性的角度 声明式 &gt; 命令式 从性能的角度 命令式 &gt; 声明式 ​ 所以框架设计上就希望可以兼顾两者，既要声明式，又要尽可能的保持性能不会太差，在性能与可维护性的基础上寻找一个平衡点，这就是框架的核心目标。 声明式框架的实现要素​ 声明式框架需要提前在html中进行声明，这并不符合html的规范，所以我们的vue中的HTMl代码其实并非真实的代码，而是通过内部的编译后，形成一个真实运行的代码。 ​ 而这在内部实现上，存在2个步骤 1. 编译（compiler） 1. 运行（runtime） 编译时 将模板代码编译为一种浏览器可读格式 ​ 框架为了开发体验，经常会提供一些更加人性化的写法，这些人性化的写法便于人类阅读，但是不利于机器阅读，所以需要将我们编写的代码编译为机器便于阅读的代码，在vue中，compile函数用于编译template为render函数认识的代码。 ​ 运行时 将vnode转变为当前平台实际运行的代码 ​ 在运行时阶段有两个非常重要的函数h render，h函数用于生成虚拟dom，也就是vnode，render函数则负责解析与渲染vnode到特定的平台，如果是web平台，则渲染为dom。 vue为何采用编译时 + 运行时 编译时+运行时的代码实现中，我们规避了直接操作dom，而是引入了vnode的概念，让我们对html的逻辑变成了对js的逻辑，运行速度大大增加 使用编译时 + 运行时可以将每个流程更加彻底的解耦合，使更多语言可以被编译，可以被运行到更多平台。 为什么vue3对ts支持更加友好？首先vue3对ts支持友好并不是仅仅因为ts写的，这是一个片面的回答，vue3有用良好的类型校验与格式存在2种原因 大量编写type类型文件，让vue3+ts代码非常严谨 api设计的前期就考虑到了这一点，尽管DSL实现类型推到非常麻烦，但是vue团队还是实现了","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"vue3-配置环境","slug":"vue3源码解读/vue3-配置环境","date":"2023-01-18T16:00:00.000Z","updated":"2023-11-27T02:38:59.032Z","comments":true,"path":"2023/01/19/vue3源码解读/vue3-配置环境/","link":"","permalink":"https://bluedancers.github.io/2023/01/19/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/vue3-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言​ 使用vue3也有一年半的时间的，原本打算在22年的9月开始源码阅读的，一方面是作为一个前端人应当去了解技术原理，其二也是想通过源码解读来回答一些我心中对vue3的疑惑；但是后面因为公司业务相关事宜，实在是静不下心来完成源码学习的工作；转眼之间又来到了23年春节，赋闲在家，是一个难得的学习的机会，所以打算在2月中旬之前，完成vue3源码的学习与分析工作。那我们废话就不多说了，直接开始吧。 环境搭建vue2与vue3的对比 对Typescript支持不友好 大量的api都挂载在Vue的原型上，难以实现tree shaking 架构上对跨平台开发支持较差 composition-api 收到react hook的启发 对虚拟dom进行重写，对模板编译进行优化 monorepo介绍 一种将多个package包打包到一个仓库的技术 monorepo环境搭建","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"Vue - 源码解读","slug":"Vue-源码解读","permalink":"https://bluedancers.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"一个5年前端er的“前世今生”（前传）","slug":"日常/一个5年前端er的“前世今生”（前传）","date":"2023-01-10T16:00:00.000Z","updated":"2023-01-13T11:42:06.665Z","comments":true,"path":"2023/01/11/日常/一个5年前端er的“前世今生”（前传）/","link":"","permalink":"https://bluedancers.github.io/2023/01/11/%E6%97%A5%E5%B8%B8/%E4%B8%80%E4%B8%AA5%E5%B9%B4%E5%89%8D%E7%AB%AFer%E7%9A%84%E2%80%9C%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E2%80%9D%EF%BC%88%E5%89%8D%E4%BC%A0%EF%BC%89/","excerpt":"","text":"前言​ 我是一名18年下半年工作的一名前端开发，现在是一家规模不大的公司的前端组长 + C端产品经理，今年是我进入前端岗位的第五个年头，做C端产品经理的第一年；22年外部环境较差，技术岗位似乎也不再狂热，也看到了很多同学面对技术岗位的疑问，前端是否还值得学？，我适不适合学编程？，23年初亦是一个改天换日的节骨眼，借此机会，我也重新审视一下自己。希望我的经历可以为大家答疑解惑，为大家的职业选择提供一些参考。 ​ 篇幅较长，打算分两篇文章，前传写我是如何一步一步走向前端，以及学习开发的过程给我带来了怎样的改变。 ​ 对应的是16年9月到18年6月，也就是我进入大学之后，进入工作岗位之前的时间。 ​ 2016年​ 我是一名没参加过高考的同学，因为高三期间已经我确定了本科无望，决定在16年春天专科的自主招生中提前走，当时对专业的选择很清晰，因为一直以来特喜欢研究电子产品，对计算机很有兴趣的，所以专业方向很明确。为了求稳，最后选择了相对冷门的“物联网技术与应用”专业，这个专业其实和计算机技术与应用差不多，2016年3月20号考试，300分卷子，考了280分。 ​ 考试完成后，在家休息了10天，耐不住寂寞，就想出去挣钱，没想到意外开始了长达5个月的打工时光，那时候尚且未成年，9月还要上学，能找到一份有薪水的工作，且一个月有1600（对于当时的我来说，已然是一笔巨款），实属老天保佑，虽然是厂里面。这也是我人生中第一次进厂打工，那段日子，对我后来在大学中坚定学习信念产生的很大的影响，如果读者们兴趣的话，到时候再更新吧，我们回到主线故事。 ​ 转眼就到了16年9月，大学生活正式开始了，大一上学期简直就是一塌糊涂，学校教的第一门编程语言是C，可能天赋不够，第二节课就听不懂了，那一年基本玩过来的，其实内心已经很焦虑，但是又找不到方向。 ​ 面对C语言课程，我的表情大概是这样的。 ​ 后来到了16年冬天，学长给我看了一个表白主题的H5，依稀记得是用canvas实现的，代码那时候肯定是看不懂的，但是还是无师自通的发现了可以用记事本全局替换文字，发现这个秘密后，我打算给刚谈恋爱不久的同学一个惊喜（直男行为，请勿模仿），把里面的名字，替换成我和她的名字，项目里面很多文件，我估摸着用记事本一个一个替换至少花了三小时，后来被人家踹了。大一上学期就这样在学生会、游戏、恋爱，网吧中荒废。。 ​ 转眼到了17年春节，走亲访友下午回来后，一般都很闲，可能真的是太无聊了，竟然想学习一下之前的表白H5，学长告诉我，先学HTML+CSS，于是我就去了慕课网（imooc），学习了HTML+CSS的初级课程。不得不说，慕课网的课程做的很好，简单的同时，又充满了成就感，大约花了7天的时间，认认真真的把课程学完了，那时候还用本子做笔记，可惜本子现在找不到，要不然一定拍出来给大家看看。学习半个月后，我根据当时的全部知识，在2小时内使用Hbuilder临摹了百度的搜索首页，真的是成就感满满啊。 2017年​ 后来就到了大一的下学期，开始讲Java了，说实话，我也不清楚是老师问题，还是我的问题，我依旧上课听不懂。那时候已经不想荒废时间了，于是我上课就自己临摹网页，比如淘宝PC站点、网易新闻首页，看到啥就临摹啥。也算是认真学习了。还瞎折腾在阿里云上买了轻量级服务器和域名，配合wordpress，搭建个人博客；因为第一次接触阿里云，很多地方都无从下手，全靠自己摸索，一弄就是几个小时，急的我满头大汗，当然最终我还是部署成功了，回头来看，【折腾的过程】又何尝不是一种财富呢。 ​ 随着临摹的网页越来越多，html+css也愈发熟练，我开始进入JavaScript的神奇世界，那大概是17年5月。看的是网易云课堂的李炎恢老师的JavaScript教程；虽然课程有年头了，但是老师教的很不错。JavaScript难度比html大多了，最终还是坚持下来了，完成了第一遍学习，到了这个阶段，真的已经学入迷了，每天晚上我都和狗皮膏药一样跟着准备竞赛的室友找一间没人的办公室学习。 ​ 17年6月下旬，暑假前夕，在室友的引荐下，终于被竞赛老师注意到了，竞赛老师姓蔡，我们私下都叫他老蔡。 ​ 我对竞赛是充满期待的，同时也意识到了这是一次非常难得的机会，可惜谈话并不顺利，我和老师非常充分了的说明了我想参加比赛的决心，老师也和我聊了老半天。但是对于比赛这件事，却让我再学习学习，扔了几本书给我打发走了。我记得其中有一本《JavaScript设计模式》，完全看不懂。最后在大学图书馆重新找了本JavaScript入门数据。而进入竞赛组的学生都去北京培训了，我不止一次的表示也想去培训，但是老师委婉的表示，没有前端培训，你暑假自己学学吧，说起来还挺失落的。 ​ 比赛结束了我才知道，老师当时认定我不是正经人，其一是当时染了黄毛，其二是参加了学生会，其三是没有参加高考。 ​ 17年的暑假，只能回家啦。在之前的工厂继续打工，还好工厂里面可以接触到电脑，一边打工一边继续学习css、临摹网页，暑假就这样过去了，这次的工资后来成了我校内生意的启动资金，帮我赚到了半年的生活费，这个也有空再聊吧。 ​ 17年9月大二开始了，长期的学习已经让我铁了心想走前端路线了。自然不想把时间浪费在课程上了。我和老师请求能不能不上课，去没有人的教室自己学习，我们安卓老师比较好说话，说明情况后，老师让我和安卓竞赛组的学生一起学习，时至今日，依旧想说一声，感谢你，赵老师； ​ 大概就这样保持高强度学习到了9月底，机会终于来了，蔡老师的云计算竞赛组中，web + docker位置一直存在空缺，本届没有合适的学生，上一届同学已经功成名不想继续参加了，蔡老师最终还是给了我试一试的机会，10月7号，正式进入云计算竞赛组。 ​ 17年的10月初，进入实验室前夕，还朋友去南京玩了一圈，逛逛夫子庙、南京博物馆，与自由做一个告别。回来当晚就进入实验室。云计算竞赛组的规矩非常严格，作息时间：8:30 - 11:00&#x2F;14:00 - 18:00&#x2F;19:00 - 22:30，周一到周日全年无休，堪比互联网行业9107，但是对我来说这是得之不易的机会，因为兴趣，所以快乐。 ​ 进来之后，蔡老师就给我定了目标，一个月之内搞定web项目，起初还是有信心的，但看到这个所谓的web项目实际上是java的SSH项目时，我懵了。 ​ 整个项目web占比并不多，反而java开发量占比巨大，那个阶段我只会HTML CSS JavaScript（ES5），并且仅限静态页面的水平，web前端，HTTP，前后端交互完全不了解，更别说java了，相当于10级萌新直接挑战60级boss。初期异常困难，把ajax都写到java里面去了，还不知道为什么编译器报错，急的我天天都睡不着，好在整个10月学长一直对我进行指导，帮助我消化java部分，加上之前前端基础比较扎实，将绝大部分处理逻辑移到了前端侧后，11月初终于把ssh项目全部搞明白了，在实验室留了下来。 ​ 后面11月、12月都是日复一日的不断的学习，也进入了高速学习阶段，linux、docker、mysql、git，都是竞赛的一部分，肯定需要学习的。于此同时，私下也在继续深入前端领域，开始进入前端工程化的世界，学习Vue，之前一直写的都是原生或者jquery，编码思维上是面向过程的，刚开始接触Vue，很蒙圈，也很新奇，此外也逐渐进入了大前端领域，包括webpack scss typescript nodejs，还有github npm，琳琅满目的框架与工具，进一步的让我感受到了技术的魅力。 ​ 当然JavaScript不能放弃，那段时间把冴羽老师的JavaScript深入系列，专题系列认真看了一遍，当时只能看懂40%，但是依旧给了我莫大的帮助，对JavaScript的理解提升了一个档次，还有其他很多老师们的博客以及教学视频，非常感谢前辈们无私的奉献，有你们，技术世界会变得更好。 ​ 一转眼就放寒假了，我们竞赛组留在在学校，17年冬天很冷，鹅毛大雪，宿舍门口杯口粗的树干都压断了，为了增加学习时间。我也搬到实验室住了； ​ 这里我重点说一下，我们云计算实验室，听起来很高大上，其实上环境非常差，没有空调，到处都是机房的线，墙壁发黄并且起壳；是我们睡觉 + 吃饭 + 学习的地方，同时还是我们老师的办公室，而且还是顶楼，窗户也关不严，冬天风嗖嗖的，夏天墙壁被晒得发烫又像烤箱。不过我不在乎，燕雀亦有鸿鹄之志。我们在过年的前三天回家了，学校还发了坚果之类的慰问品，咱们学校还是很不错的。我家距离学校并不远，都在一个城市，但是这却是我时隔半年，第一次回家；临走前，学长给我丢了一本书《深入理解ES6》，让我过年在家继续学习。 ​ 动荡的2017年就这么过去了，年初还键盘都敲不利索的学习html css，而年底已经可以做一些独立开发，这一年经历了太多，从对未来的焦虑到对未来的兴奋，从荒废到废寝忘食的学习，，得到了竞赛老师的认可，进入了学习氛围浓厚的实验室，这是独一无二的一年。 2018年​ 18年春节，农历初五返回学校继续学习，在家的一个星期中也没歇着，加紧时间将《深入理解ES6》的全部内容看完，知识点很多，let、箭头函数、解构赋值、模板字符串、等等，受益匪浅，ES6是革命性的武器，后面我又断断续续学习 ES6 2年，足可见ES6的重要性，对了，深入ES6主要学习了《你不知道的JavaScript》，我们继续回到主线故事吧。 ​ 18年上半年只有一个旋律，职业技能大赛，18年3月中旬进行安徽区的省赛，前三名可以参与5月下旬深圳举办的国赛，蔡老师慎重思考后，决定暂时不让我上，让上一届的学长参加省赛。我可以理解，竞赛老师要为比赛结果负责，而我资历最浅，自然风险最高。最终兄弟们在安徽芜湖的芜湖职业技术学院拿到了省赛第一名，顺利进入国赛。 ​ 在比赛练习的间隙，我依旧保持了不断学习前端技术的习惯，具体学习方法是不断的看技术教程文章与视频、不断的写代码加深理解，那段时间经常看慕课网的付费Vue课程，老师们精彩的课程，在我理解现代前端上起到了很大的作用，另外就是技术胖老师的一些免费大前端课程，非常感谢老师们。同时也开始尝试写博客，进行输出，希望可以像帮助过我的前辈们一样，用我的能力帮助到更多前端人。 ​ 省赛之后，老师找我聊天，和我说会尽力为我争取国赛上场的资格，对与这件事，我很感动，因为校领导是不希望我上场的，我的学长能力更强，并且已经有一年参赛经验，能抗大旗，最后是蔡老师和校领导拍桌子，将一起责任担在自己肩上，才争取到了我国赛上场的机会，这些事情都是比赛结束之后才知道的，因为老师怕我比赛心理压力太大。其实蔡老师没理由这样，他的立场和校领导一样，只是蔡老师想尽自己所能，尽力为每一个追梦赤子带来回报，哪怕承受巨大的外界压力，真乃恩师也。 ​ 18年5月下旬，我们踏着初夏的晴日，带着8个月日日夜夜的努力，踏上了前往深圳的路程。到深圳的时候，已经是半夜2点，第二天8点无论是老师还是学生，依旧准时起床，做比赛前的最后冲刺，艰苦环境打不到意志坚定的人。 ​ 我们在深圳的宾馆练习到最后一刻；5月26号，正式开始比赛，我们早早的进入了比赛场地，对机器进行最后的调试。 ​ 真的进场了，到了最后一刻，其实也不紧张了，比赛时间2小时，因为我准备充分，我的题目都非常快速的完成了，拿到了可以拿的所有分数，团队中后期出现一些问题，但是最终都妥善解决了，没记错的话，最后存在小部分题目没有完成，但是这已经非常非常好了。 ​ 响铃，比赛结束，键盘敲击声逐渐停歇，人们开始根据引导逐步走出赛场，我的眼眶已经湿润，这一路太辛苦；从小我就爱玩，小学去游戏厅，中学去黑网吧，从来不好好学习，最后上了专科，其实不是不想学，只是因为一直断档，导致无法跟上学习节奏，随着年纪的增加，内心也越来越焦虑与自责，对未来充满迷茫，也愧对父母这么多年的养育之恩，但那一刻，我成了自己的英雄。 ​ 我们小组另外2个人因为没有拿到满分，似乎心情不太好，情绪没有渲染到位，我又把眼泪憋回去了，冷静下来后，仔细分析了一下，因为有一些题目没完成，内心还是比较担忧的，怕辜负了老师和大家这么久的努力。当天晚上成绩出来了，我们在全国88支队伍里面，排名第3，前10名国赛一等奖，我们成功了！。 ​ 成绩出来当晚，原本打算去看看深圳世界之窗，但是因为和校领导喝酒应酬，没去成，至今也没去成，回去的路上蔡老师和我们说了很多，包括强行让我上场和校领导的翻脸，以及这么多年搞比赛，做竞赛指导老师的艰辛；恩师难求，我们亦没有辜负蔡老师的期望。 ​ 第二天领奖仪式后，我们下午便启程返回合肥，学校专车过来拉横幅、送鲜花给我们拍照纪念，那种感觉还挺奇妙的。后来回到学校实验室后，也许真的是太开心了，紧绷的神经突然松开，似乎陷入到了一段甜蜜梦境，所以啊，那一段记忆怎么也回想不起来了。 最后​ 我偶尔会想，如果在另一个宇宙，我与蔡老师擦肩而过，是否还能走到前端这条路，会不会毕业就去工厂，亦或者毕业后花费几万元去培训，这些都是更加难走的路线。不过现在我有了答案，无论是何路线，都将走向现在技术岗位。 ​ 因为决定性的钥匙已经被我捏在手中，那就是兴趣。 ​ 这也是我想送给大家的答案，技术岗位似乎已经不像几年前那样火热，内卷非常严重，大厂开始裁员，互联网这么多年的发展似乎已经走到了尽头，不是这样的，可以独挡一面的开发，始终是稀缺的；但如果是奔着待遇来的，那么大概率拿不到高工资，并且职业上限很有限。只有兴趣，只有发自性的去做自己认定的事情，无论什么样的风雪都吹不灭的意志，才能带你突破重围，一定要不断思考自己，去探究本我，寻找自己的闪光点，然后不问结果的去做，直到最后一刻。如果历尽千辛万苦依旧失败，不必气馁，因为这一路的历练与坚持，会帮助你下一个的选择，如果成功了，将是人生的转折，就像《肖申克的救赎》中，Andy凭借超凡的信念与毅力，爬过长达500米的下水道，重获自由。 ​ 前传大概就到这里，后面还有坎坷的求职、专升本，那是一段与大学完全不同的经历，篇幅有限，下一篇我们再见吧！👋🏻","categories":[{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"阅读、游历和爱情","slug":"阅读/阅读、游历和爱情","date":"2023-01-09T16:00:00.000Z","updated":"2023-11-27T02:42:37.886Z","comments":true,"path":"2023/01/10/阅读/阅读、游历和爱情/","link":"","permalink":"https://bluedancers.github.io/2023/01/10/%E9%98%85%E8%AF%BB/%E9%98%85%E8%AF%BB%E3%80%81%E6%B8%B8%E5%8E%86%E5%92%8C%E7%88%B1%E6%83%85/","excerpt":"","text":"​ 这是梁永安老师的22年的初版的一本书，也是我第一次了解到老师，读了一部分，说实话，我觉得这本书写的还不错，虽然有些人会说，梁老师对某件事物的评价，都是套公式一样的废话，听了就像没听一样，说实话，我不这么认为，《阅读、游戏和爱情》这本书，有些文字确实存在看似“废话”的句子，但是人间的道理，不就是这么一回事吗，人类不就是需要在外力的引导下与自己和解吗？ ​ 读了三章，挺不错的，能看得出来，梁老师是一个热爱生活同时存在沉淀的人，他的文字具有让年轻人坐下来看看仅仅阅读的力量。 好了，废话就说这么多了，下面我会针对每个小节，写一些自己的想法，做一些积累与分享吧！ 自我​ 我们这一代，很多人是没有自我的，因为我们是中国第一代多元社会的经历者，我们大多数人带着传统思维来都这个多元的社会，一下子就陷入了一种迷茫，传统的思想不断受到挑战，甚至开始否定自我；在认识自我之前，我首先想说的是，要认识本我，很多人因为收到了家庭、社会、朋友的影响，开始分不清自我与本我，这可能会让一个人定位迷失，活在自己想象的世界里面，在寻找本我的过程中其实就是寻找自己在这个社会中的定位与坐标。 ​ 而我们现代社会因为历史阶段的复杂性，一方面我们没能脱离小农经济的影响，一方面我们需要像游牧民族那样快速适应，而中国社会本身有啥一个层叠社会，导致我们国家的价值观不是一元的，是有多重标准的，这都导致年轻去认识自我存在难度。 ​ 在这样的纷杂的大环境中，年轻人应该如何真正的认识自我呢，梁老师的答案是经历与突破，我们原生家庭带来的准则未必是符合现代的，倒是那些符合，那些又不符合呢？这个就需要当下的年轻人自己去经历，去沉淀，最后形成完整自我，完成对自身的突破。 ​ 有一句话是，世界上只有一种英雄主义，那就是看清了生活的真相后依然选择热爱他，其实这就是经历并且形成完整自我的结果，这个过程是艰难、挣扎、困惑的。 ​ 最后，想谈论一点，那就是坚定自己，其实在我这几年的经历里面，我也与都了很多对人格的冲击，从几十年来的固有观念的冲击，甚至对自身的准则产生怀疑，其实这是对自己认识不充分的体现，而现代生活又是如此多元化，坚定自己就显得极其珍贵，这里的坚定自己并不是顽固的坚持自己，而是接受世界，思考，批判，最后形成更加立体的自我。 工作​ 现代社会中，我们大部分人拥有了选择生活的机会，却又没有选择自己想要生活的权利，这有两方面的原因，一是固有观念的影响，二是社会本身的影响，我们现代社会是一个高度分工的社会，并且大家自由寻找的社会，其实这也是残酷的，因为岗位有好有坏，并且每隔10年也许就会发生变化，这样的环境充分的激发的大家的积极性，但是也加深了整个社会的焦虑； ​ 有些朋友可能还没有找到让自己满意的工作，其实越是这样的情况下，越是需要大家先去做，去深刻的体验，只有这样才能找到希望，找到自己的目标，如果一份工作你用尽全力依旧无法感受到自己的价值，那时候再带着这份工作带来的宝贵经验，再次出发，未必不是一件好事。 ​ 关于“摸鱼文化”，梁老师提出了很多很有价值的想法，一方面我们认同这种“亚文化”的出现，年轻人并非不努力，而是无可奈何，并且我们也没有形成让年轻人发泄的文化，最后形成了“躺平文化”，而这主要是两个因素的影响，一是层叠社会，二是我国的发展阶段，我们的父辈在改革开放的大环境下，是激发潜能，能人辈出的年代，他们在这边土地通过自己的打拼获得了回报，大家都看到了努力的价值，另外我国国情目前达到了非常关键的中等收入进入高等收入阶段，整个国家都在奋起前进，但是这样的环境中，我们年轻人是后来者，我们实际上是被裹挟在大环境的，我们从小直接自由主义的熏陶，但是通过了，却发现工作没有自由，所以这一切都是很合理的，年轻人陷入了迷茫，他们嘲笑自己躺平，实际上都是对生活的一种思考，这是积极向上的体现，我相信很多年轻人在挣扎与思考后都会发现，我能发挥自己的能力去让这个世界变得更好，去解决问题、探索答案，却不是仅仅抱怨问题。 ​ 肯定工作的价值，哪怕是阶段性的重复并且无聊的工作也未必就毫无价值，梁老师给了我们两个建议，第一是保持好奇，现代社会，前路是不可预测的，保持好奇才能更上脚步；第二是走出舒适圈，在新的领域寻找可能性，我们要去感受这个世界，人类，自然，情感，了解的多了，内心才能开阔，见识才能增长。 ​ 关于最后的斜杠青年，梁老师的观点我非常认同感，可以斜杠，但是不能太斜杠，太斜杠就不算斜杠了，那又如何找到值得斜杠的技能呢，梁老师的答案百分百真诚，百分百坚持的做一件事，如果我们没有到深入的程度，我们就无法值得一件事是否适合我们，哪怕最后结果不好，过程的宝贵经验也是非常重要的财富，帮助我们再次上路。 人格​ 人心是复杂的，好人与坏人也是界定不清晰的，现代社会的起点是文艺复兴，而文艺复兴最大的要点，就是释放人的本性亦或者说是欲望，人心这个社会是如此的多元化，也是如此的复杂，在这样大环境如何评价一个人格好与坏？这并没有答案，对于新鲜事物的好与坏的评价社会是存在一个缓慢的接纳过程的，就像“涂鸦文化”，早些年是一种反抗运动是坏的，但是几十年后，这成为了一种个性的表达，成了一种象征，我们无法用传统的人本主义去判断在这个“多元”社会发生的事情。 ​ 而发生在我们身边，对好人的界定依旧是复杂，书中提到了一个例子，我觉得非常经典，《挪威的森林》中，男主是放荡并且热爱自由的人，而女主却将男主当做唯一，这给男主造成了巨大的压力，以至于男主一直做出在女主看来很坏的事情，这是男主对自己自由的捍卫，对男主而言，这是好的，你看不同视角来看，就是不一样的，很难有一个道德标准去评价人的好与坏。 ​ 那倒是什么是好人呢？书中给了一个我很赞同的答案，身处迷茫的人，因为迷茫意味着思考，意味着自己探测，只有不断思考，接纳这个队员的社会，并去理解他，王阳明曾说：”知行合一，致良知“，做一个不断思考与接纳的好人。 躺平与幸福​ 躺平是不是坏事？其实这几年，躺平文化，确实是越来越被大众所熟知，我们已经进入了现代社会，自然不可用农业社会的道德标准去看待，农业社会中，日出而作日落而息，生活是规律性的，这自然是不允许躺平，而现代社会是细化分工的，是无规律的，年轻人具备了去躺平的条件，而躺平不是对生活的放弃，而是对迷茫生活的一种思考，对压力的一种宣泄方式，但是因为我们独有的内卷教育体系，我们无法像欧美国家那样，发展出摇滚，朋克文化，形成了我们独有的文化，就是躺平。 ​ 所以躺平不仅不是年轻人对生活的放弃，而是对现阶段社会的反抗与反思，在躺平中，人们开始思考我追求的究竟是什么，我如何过好我的一生，这都是一个人极其重要的组成部分，去认识到这个世界的高度，与自己的无知，去了解过去发生在这片土地的故事，然后再站起来，追求自己的幸福。 ​ 以上很多只是我有感而发，并非文中的想法，梁老师想告诉我们，远比我上面描述的要多的多，也更加体系化，总而言之，躺平不是不可取的，不是不被允许的，但是躺平之后要想想，好好体会一下，深入的思考一下，然后继续出发。 女性文化​ 这是一个很新鲜的话题，因为历史原因，女性在历史上是被压迫的存在，结婚后，就要离开原生家庭成为漂泊的人，成为别人的拥有物，这就需要女性对自己进行封闭，封建社会对女性的异化是非常严重的，也不断的压迫女性追求自由的权利，直到工业革命的出现，劳动力开始稀缺，女性得到走向前台的机会，并且在某些领域做的比男性更加好，从此女性获得了劳动回报“工资”，则意味着女人不再必须依赖男人才能活下去，拥有资本则拥有权利，但是女性文化的进步亦是曲折的，因为早期资本的介入，女性被按照男人的想法塑造出来，最后变成了追逐金钱的游戏，比如经济泡沫之前的日本，年轻女性被资本教育成了“如果没有拥有一个名牌包包就白活”。 ​ 女性文化真正的追求的是突破对自由的束缚，不仅是行为，更加是观念上的自由，不被封建思想左右，不被小农思维左右，去深度的思考突破不应存在的限制，这一点与追求完善的人格具有一定的相似性。 谈女性写作​ 女性写作最早最早起源与工业革命，因为工厂进入城市，大量贵族进入乡下，将一些古典贵族特有的习惯带入到乡绅，其中便有读书，女性开始了更大范围的阅读，这位后面女性的创作提供了基础。 ​ 女性的小说，相对与男性的宏达诗篇，冒险游记，其内容侧重点要更加细腻，以微观与心理描写为主，这也和女性的性格与生产环境存在一定的关系，而这些又深受工业革命背景下女性的喜爱； ​ 科学研究表示，女性的表达欲望是男性的三倍，并且更加注重情绪交换，但是这并不代表女性可以更加轻松的成为一名作家，写作是需要天分的，属于艺术范畴，我们一般认为这是一种突破常理的，虽然写作似乎很难，但是我们希望大家去尝试，也许这是自己被埋没的天赋，也许在这个多元世界受到新的启发后，就会产生一些第一五二的想法，去探索、探寻内心世界与思想的解放，其实这不论男女，都应该这样。 我们为何相爱相杀​ 我倒是觉得，这并不是坏事，工业革命之后，女性开始拥有人权，打破了几千年来的男尊女卑，女性得到了快速的进步，也开始兴起女性权利斗争运行，这在几百年前都是无法想象的事情，正是女性地位的上升，男女的差异才得以释放。 ​ 那么在现代社会，男女又应该如何相处呢，其实这一点我也经验尚欠，但是我赞成梁永安老师的想法，两个人在一起的价值就是一起创造独一无二的生活，相爱是存量的，而相杀的感情的增量，正是因为勇敢的相杀，彼此才能成长，而不是功利的去看待男女关系。 ​ 另外还要再多说一点，两个人再一起，不仅要向内走，更加要向外看，寻求更大的精神空间，现代社会是复杂的，多元的，我们现在的生活也非常向美国20世纪20年代，大量的年轻人成了无根的人，人的思想在不同环境中被影响与塑造，产生了很多选择，正是这些选择让人们活的很纠结，很累，这样的环境下，大家都想找一个可以帮助自己减负的人，婚姻就变成了解决问题的方式，但是在剩下的人生中，我们还会遇到比物质匮乏更加难的问题，精神的匮乏，人的异化，这都不是功利可以解决的。 ​ 最后，我想写单身并没有罪，我们90后身处传统意识与现代社会的交融点，是复杂的一代，一方面我们追求精神自由，一方面却无法摆脱传统思维，我亦是如此，观念上跨不过去，虚妄的恐惧统治了自己，希望后来者积极探索不一样的可能性。 谈爱情​ 读到这里，我基本确定了，梁老师这本书的基调，是以中国社会、世界文明的研究作为一切观点的基础，然后再延伸到各个方面，爱情、工作、关系。 ​ 未来的世界一定是更加开源，更加自由的社会，我们身处的时代要比国外更加复杂，我们短短几十年完成了工业化，同时存在农耕时代、工业时代、网络时代，我们身处自由之中，却被旧时紧固，这样的环境下，爱情就变成了一个非常复杂的命题，应该遵循传统，还是跟随内心，究竟是主动出击，还是听从安排，其实问题答案大家心里大部分都有数，现代社会重人权的，自然一切从自身出发，但是历史快速转变的背景下，又有几个可以做到突破镣铐呢。 ​ 爱一个人，万不可停留在臆想中，然后自以为找到了理想，一旦臆想逐渐破裂，就会形成巨大的悲剧，所以我们已经要走追求美好的勇气，也许要真正的看清自己看清您一半与拒绝一段感情的勇气。 ​ 最后，跟随本我，用实践去理解爱情，勇敢的去学习与接受这个世界，去打破固有观念的限制，保持学习，培养自己抓住一瞬间的能力。 ​ 谈孤独​ 人类需要孤独，因为孤独，人们才有审视自己的机会，因为孤独人们才有体会到感情的可贵，如果人人都在漂流，又如何去了解自己呢。 ​ 现今时代确实是一个纠结的时代，一方面是我们受到传统观念中一切寻求安稳与规律的影响，一方面我们接触这几十年改革开放，多元文化的快速进入，很多年轻人在安稳与自由之间举棋不定，因为自由伴随着困难与孤独，而安稳则无趣且不自由，这是两个完全不同的思想。 ​ 从古至今，所有有思想的人都是孤独的，因为他们具有超乎时代的能力，这对社会其实是一种反叛，自然探索者都是孤独的，而对于现代的年轻人来说，其实孤独并不是坏事，我们身处历史的转折点，需要很多的时间，去看清我们与历史、未来的关系，没有孤独则没有思考，没有思考在无法了解自己，无法审视自己，何谓自己的追求，在这个自由社会，我是否真正的自由了，这都需要我们静下心来，跳出现有框架，去俯瞰自己，一直活着浮华之中，只会让内在空空如也。 ​ 梁永安老师说，如果一个人完全忍受不了孤独那就出现大问题了，其实我不是很同意这个观点，其实这与很多因素有关，有些人的生长环境已经达到了自己的想象，甚至超越了，这就成了孤独最大的障碍，因为她当下没有理由去抛弃这一切，放弃现有的优待，去从零开始另一种生活无疑是困难的，这是一种生活态度，长远来看，也许懂得越少，活的越快乐呢，人活的成功，深度并不是唯一标准， ​ 但是请不要抗拒孤独，不要荒废孤独，孤独其实是奢侈的，可以放心自己的机会不常有，去静静的思考，去阅读，去感受自身独一无二的特性，思想的深度将会帮助你活的更加精彩。 谈读书​ 书籍是人类智慧的结晶，是独特的人类立足世界的基础，通过书籍，我们得到了和世界、时空对话的机会，年轻人们需要去多读书，去链接自己与世界，梁永安老师对读书有一些更加深层次的理解，就是寻找自己的生命之书，以及书籍具有改变命运的能力，历史中有很多非常伟大的人物，都与书籍有密不可分的关系，例如历史上的拿破仑，他一路增长欧亚大陆都带着《少年维特的烦恼》，这本书给予了拿破仑很大的精神支持，让人们在纷乱的世界中保持清醒。 ​ 另外梁老师谈到了一点我非常赞同，并且我去做了的事情，就是细读，我读书的速度一直都是慢于平均速度的，因为当我看一本书的时候，我会从，历史背景、作者背景、描述方式，等等多个角度去分析与欣赏一个作品，这让我每看一本书都受益匪浅。 ​ 第二个要谈的话题是，读书可以激发一个人的灵性，回想儿时，其实我一直都爱读书，作为独生子女一代，我的童年的独孤，是童话故事、拓展阅读，然后是作文范文，在之后是意林，但是因为客观因素，我接触到的书其实并不多；让我第一次感受到“读书”的魅力的书，是一本家喻户晓的书《活着》，我第一次意识到我们的世界并不是一层不变的，这个世界既有广度也有深度，于是书籍成了我重要的信息窗口，读书的同时让我沉浸在自己的反思中，获得更加有价值的提升，这是一件极其美妙的事情。 ​ 关于如何验证读书的作用，梁老师的观点是“写作”，除了这个观点之外，我还想说另一点，“交谈”能力，我近五年是认知提升，几乎都是读书带给我的，读书，让我的思想有了深度，让我有看到一件事更加底层的能力，以及对同龄人的观点输出能力，所以想验证读书的左右，除了写作，不妨也可以多试试深度交流，可以是你的群友、你的上级，甚至老板，而观点的碰撞，又会产生新的价值，这是非常宝贵的。 ​ 我们的时代，是适合读书的一代，我们的父辈被工业时代和尚不丰富的物质生活裹挟，并且大多存在兄弟姐妹，他们大部分没有反思自己，没有去读书的几乎，但是我们95后，是非常不同的一代，独生子女+现代社会，让我们每个人都是成了个体，社会关系逐渐变淡，我们有更多时间，和反思自己的机会，如何去反思？我认为读书是最好的选择，书籍让我们有了一场精神交流，去探究生活更加深层次的意义，读书会让我们收获良多。 谈生活​ 我们这一代年轻人其实是充满疑问的，因为我们是第一届无法循规蹈矩的一代，父母也好，父母的父母也好，他们都是一代继承一代，但是现在这个方法行不通了，我们的生活失去了最基本的框架，在现代社会，原本的价值观已经被打破，我们的生活出现了多样性，失去的同时，我们也获得了我们往上任何一代都不具备的选择权利，所以首当其冲的就是，了解我们可以拥有怎样的生活。 ​ 上上一代在温饱线挣扎，上一代被住房压住，而我们这一代，已经没有了以上烦恼，我们这一代一定是在文化上有更多的需求，按照梁老师的说话，我们应当打开想象，不要局限在一种日出而作日落而息的生活中，去外面把好的感觉带回来，我们年轻人还有很大的成长空间，多样的生活已经在我们眼前，但是我们还没有积极的去获取，我们的电影，书籍还有很大的市场，自由的文明与中华文明的结合，需要我们去努力场次独一无二的种子，希望大家在生活上可以跳开父辈的惯性生活，走出去看看，也走进自己的类型看看，用好我们独一无二的财富“自由”，一个好的人生，一定是具备深度的，即在岸上，也在水里。 谈社交​ 我们这一代的人的社交，是不同前人的，我们创造了属于我们的独特文化，例如“宅文化”“躺平文化”，我们引导如何看待现代的社交方式，我们需要谈两个关键因素，家庭 社会，家庭是我们最初的社交场，也会对我们的人生产生非常深远的影响，而我们这一代，大部分都是独生子女，并且父母多半是工业阶段，在家庭感情上投入甚少，所以我们90后其实大部分是孤独的一代；这样环境进入社会，自然也很难形成大规模的社交群体，每个人更加停留在自己的舒适圈中。 ​ 而到了社会的第二阶段，我们逐渐融入社会，按理说应该会有所突破，但是实际上也没有，因为我们这一代是规模化教育，每个的人经历大致相同，人与人之间很难产生灿烂的火花，于此同时，互联网短视频，游戏的不断发展，助长了断社交是趋势，没有社交，大家依旧可以过得更好，最后再说一个梁老师的观点，就是传统文化对我们的隐形影响，中国自古以来强调自给自足，关起门来过自己的日子，久而久之便失去了社交性，自然我们骨子里蒙蔽了交流的价值，进而形成了我们现代的“宅文化”。 ​ 梁老师是阅历丰富的人，他凭借敏锐的情感与经历，感受到了社交的价值，并且对中国先进社会的社交气氛有所反思，意识到了人想在这个社会生存下去，就需要与他人交流，通过整个市场将自己和他人连接起来，自有这样多方面才能全面发展，进而构成脱离小家小户的社会心态，我觉得，我们已经快做到了，我们有部分年轻人是有这样的趋势。 ​ 另外还要说一点，就是无效社交，如果老朋友见面就是吃吃喝喝玩玩，这样是无法形成内心深处的情感交流，这样的社交无法让两个人形成更加深层次的链接，我们便永远无法拉进彼此的距离，需要大家尽可能的去输出与输出，寻找精神上的共鸣。 ​ 社交是为了生活，从社会发展层面分析，我们的父辈，更多的投入到国家，公共事业之中，每个人都是国家的螺丝钉，个人的精神追求与国家深度绑定，虽然生活很艰苦，但是大部分人是具有一个相对可预见的未来的，但是我们这一代经历了改革开放后，私营企业承担了大部分就业，以前遍地都是的价值感，便需要我们自己去获取，所以现代大部分都是”自私”的，为自己而奋斗，其实这是很合理的事情，现在我们为资本打工，生活确实越来越好了，但是我们的精神也越发贫瘠，这不是社会可以解决的，需要自己我们去探索了，其实有价值的社交，就是探索的一种方式，所以不然让我们离开舒适区，对于土地，与风土人情，与朋友们进行一次更加深层次的交流吧。 谈修养​ 我们这一代年轻人是很有修养的，我们接受了以往任何一代都没有的通识教育，接受到了来自全球的人文精神的影响，但是我们这一代是挑战巨大的，因为我们不断面临各种异化，资本主义，家庭，在现今社会，道德修养就显得尤为重要，因为你的行为取决于你的修养，这是我们每一个年轻人都需要去深入思考与提升到地方，梁老师给出了他的建议。 热爱自然 热爱人类 热爱生命这些修养然后我们形成自己的道德标准， 热爱自然比较好理解，就是认识到人类与自然的关系，然后从本初出发的道德准则 热爱人类是指我们不可丧失人性，回到人类本身，而不是功利的去看待这个世界。 热爱生命是人类是很多人难以做到的，包括我自己，我的理解就是对生命要充满敬畏，对自己的人生负责，去思考，去勇敢的做出自己的选择，不进行外界因素的拖鞋，不辜负生命，给自己的定制一个有点难度的目标，去充实自己，也去释放自己的，人就这样语法具有深度，语法理解休养的价值 除了以上三点，我再说一下我的关键，就是深度阅读能力，在深度阅读的过程中，会逐渐形成属于自己的更加深厚的修养，将会潜移默化的让个人具备超乎同龄人的思想高度。 ​ 最后是尊重，尊重从何而来，如何评判是否应该被尊重，这些其实是源于个人的修养，这都是相辅相成的关系，坚持自己的价值与原则，判断不应来源外界的肯定与否定，而是源自你的内心。 谈美​ 什么是美？这其实是一个主观的认识，传统社会的人们认为男人雄壮是美，女人好生育是美，现代自然是另一个看法，还有其他国家呢，我们的审美进入现代社会后从实用化趋向于个人化，只是没有问题的，因为90后一代是开创性的一代，自然社会面的审美发生变化也是很合理的，但是这些都是表面的， ​ 所以我们不能从表面去评价什么美，这是片面且经不起推敲的，那对于你我来说，如何去评判何谓真正的美呢，我仔细的思考了梁老师的话，实践就是美，美即使真知；在纷乱复杂的社会中，只有实践才能理解美的含义，充满困惑依旧一往无前难道不是一种美？坚守底线不畏舆论也是一种美，这些都需要在实践中去理解。 ​ 除了审美 作者也谈了审丑，我理解的审丑，其实即使审视自己，只有我们把那些荒诞的事情摆在我们眼前的时候，我们哈哈大笑的之后，才会发现其实我们是在笑自己，这又何尝不是发现美的途径呢。 谈艺术​ 何谓艺术？艺术就是打破有限，打破固有，正是如此，所以艺术可以带给人精神的宽度。 ​ 我一直对这些虚无缥缈的因素很有兴趣，他有什么直接价值吗，甚至于所谓艺术接触的当时，我都无法理解，为何这是艺术？更多成分可能是不明觉厉。 ​ 作为前端开发工程师，我可以通过编程创造性的解决问题，作为一名产品经理，我亦想创造性的满足用户需求，我们身处世界最前沿，虽然前路一片朦胧，但是却充满机遇，我们也获得了创造的权利，如果我们不把艺术局限于文学、绘画、舞蹈领域，你我未尝不是行动艺术家。 ​ 我们上一辈的人，其实不理解艺术的价值，中国是一个务实的国家，我们强调传统意义上的价值，强调国有意志。所以我们中国可以产出如此多优秀的管理者，但是且很少做出革命性的事情，而现如今，我们之间意识到了艺术的价值，艺术充满了未知性，并且艺术无法用现在的价值标准去评判，古代大哲学家苏格拉底经常与当代哲学家一起探讨生存的意义，这些事情如果从那时的框架去思考是毫无意义的，但是却给后人带来了深远的影响，启发了一代又一代人，所以无用还是有用，我们再现有价值框架很难平淡，但是我们从历史来看，艺术给人类的发展做出了巨大的贡献。 ​ 我认为的年轻人学习艺术，我所说的艺术，不仅是是传统艺术，自由、创造对我而言就是艺术，其实就是打破固有观念，关注自身正式的想法，人活着不仅仅只是肉体上的吃吃喝喝，精神也是需要喂养的，父母给了我们肉体活下去的机会，而我们自己则需要给自己活下去的机会。 最后​ 起初吸引我的是引言中对生活的描写，只言片语中，我真切感受到了梁老师对生活的热爱与时代的沉淀，这是我们当代年轻人最缺乏的2点，前者的匮乏来源与快速转折的社会，后者则来源与经历与反思。阅读的过程中，我仿佛看到了梁老师坐在我的面前，时而温声细语，时而语重心长，谈论了很多与每个人都息息相关的点，我们不必将梁老师的话作为绝对正确的答案，我们需要聆听与反思，找到自己的答案。 ​ 通读全文，我认为最底层最重要是以下几点，自由 热爱 求知，这三把钥匙，帮助我们打开答案之门，我对梁老师口中的层叠社会概念受益匪浅，我作为一名95后，几乎一直活在现代社会，我本能性的认为这个世界是平面的，并且惯性的只向前看，而没想到，不知古，怎知今。 ​ 通过层叠社会的发展规律，我们可以在宏观层面解释现如今社会层面的很多现象，再向前一点还是文艺复兴、工业革命，这都是人类历史重要的节点，真正理解了历史，看世界的角度就会高出了很多，也能够解释很多以前的疑虑，受益匪浅，谁说作为一个合订本，内容上存在一切重复，但是作为一名初读者，可以反复理解案例也未必不是一件好事，总体是非常推荐大家阅读的，走进梁老师的理想世界。 2023-01-24完 ​","categories":[{"name":"书摘","slug":"书摘","permalink":"https://bluedancers.github.io/categories/%E4%B9%A6%E6%91%98/"}],"tags":[{"name":"阅读、游历和爱情","slug":"阅读、游历和爱情","permalink":"https://bluedancers.github.io/tags/%E9%98%85%E8%AF%BB%E3%80%81%E6%B8%B8%E5%8E%86%E5%92%8C%E7%88%B1%E6%83%85/"},{"name":"梁永安","slug":"梁永安","permalink":"https://bluedancers.github.io/tags/%E6%A2%81%E6%B0%B8%E5%AE%89/"}]},{"title":"更加优雅的web端上传文件","slug":"项目解决方案/更加优雅的web端上传文件","date":"2023-01-02T16:00:00.000Z","updated":"2023-01-11T10:10:19.010Z","comments":true,"path":"2023/01/03/项目解决方案/更加优雅的web端上传文件/","link":"","permalink":"https://bluedancers.github.io/2023/01/03/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%9B%B4%E5%8A%A0%E4%BC%98%E9%9B%85%E7%9A%84web%E7%AB%AF%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","excerpt":"","text":"前言​ 大家一起回想一下，我们在使用Element、Antd的时候，是如何实现图片、文件上传功能。 ​ antd就不截图了，使用方法差不多，相信写过相关代码的同学，都会感觉比较繁琐。 既要改html，还需要写JavaScript，开发效率低。 组件API复杂，很多时候，并不需要那么多功能，心智负担重。 等等 ​ 这时候，写过微信小程序的同学，心里肯定会想，小程序的上传图片API开发体验还可以，逻辑上也很直观，通过事件触发函数，函数内实现上传图片的逻辑，我们web端能否也能拥有类似的开发体验呢？ npm地址以下内容为实现思路以及关键代码，如果您仅仅想使用的话，请直接到npmjs 文档地址：https://github.com/vkcyan/choose-to-file#readme 1npm i choose-to-file 需求分析首先，web端使用文件上传功能，一般使用input标签进行实现 1&lt;input type =&quot;file&quot; onchange/&gt; 最后在onchangecallback中，获取本次的结果。 我们会发现，上传文件必须通过特定的标签才能触发。这么来看似乎与函数式相违背。 但这并不是死路一条，我们可以通过input.click()，自动指定点击事件，核心逻辑就是这样。 实现思路 创建input标签 触发&lt;input /&gt;的click事件 监听上传结果，并作为结果返回，同时对临时数据进行销毁。 具体实现实现不与具体框架做绑定，我们基于原生逻辑进行开发，天然兼容web端框架。 理想使用方式 12345678async function uploadImg() &#123; try &#123; let res = await chooseToFile() console.log(&#x27;file&#x27;， res) &#125; catch (err) &#123; console.log(err) &#125;&#125; 接下来开始实现chooseToFile，首先我们创建input标签 12let input = document.createElement(&#x27;input&#x27;)input.type = &#x27;file&#x27; 创建完成后，立刻执行自动点击事件 1input.click() 然后监听input的onchange callback，并通过Promise resolve进行返回。 12345input.onchange = (evt) =&gt; &#123; removeInput(input) // 删除dom let &#123; files &#125; = evt.target as HTMLInputElement return resolve(files)&#125; 至此，我们的核心逻辑就完成了，还是很简单的~ 一些问题初始化阶段调用无效，并且会弹出警告。1File chooser dialog can only be shown with a user activation. ​ 这是因为浏览器的安全限制，不允许用户在没有任何”激活行为“的情况下，JavaScript调用窗口，针对此问题官网有详细的说明user-activation。 ​ 也就是说这是不允许的，大家开发中要规避这种行为。 无取消上传callback​ 当用户点击文件进行上传的时候，我们可以通过onchange组件进行获取，但是如果用户关闭了上传文件弹窗，或者点击”取消“按钮，input并未提供响应的回调函数。 ​ 如果无法监听取消上传，逻辑将不知道何时销毁临时标签input，查阅了一些资料后，找到了解决方案。 ​ 无论用户是否上传，只要当前用户有操作，上传行为结束，都会重新聚焦到body本身，也就会触发全局的focus方法，如果用户上传了文件则在onchange callback中将fileCancle赋值为false； ​ 之后focus事件触发的时候则不会进入if内逻辑。 123456789101112let fileCancle = true // 是否未上传文件window.addEventListener( &#x27;focus&#x27;, () =&gt; &#123; setTimeout(() =&gt; &#123; if (fileCancle) &#123; removeInput(input) reject(&#x27;upload canceled&#x27;) &#125; &#125;, 500) &#125;) 最终效果 调用函数，打开文件管理器 用户上传文件：.then触发，收到上传的文件信息 用户取消上传：.catch触发，收到无文件上传错误 最后​ 功能的实现并不复杂，因为作者工作上vue用的较多，所以可以保证Vue是没问题，理论上React也是没问题的，欢迎大家体验，在使用中有任何问题，请评论区留言。 ​ 祝你开发愉快。","categories":[{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"羊了个羊，怎么突然爆火了？","slug":"NPDP产品经理/羊了个羊爆火，到底发生了什么？","date":"2022-09-18T16:00:00.000Z","updated":"2022-12-11T13:51:24.079Z","comments":true,"path":"2022/09/19/NPDP产品经理/羊了个羊爆火，到底发生了什么？/","link":"","permalink":"https://bluedancers.github.io/2022/09/19/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A%E7%88%86%E7%81%AB%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"中秋节后的几天内，每个互联网人都主动或被动地了解到了一个现象级小游戏羊了个羊 ，该小游戏在一个星期内火速出圈，高频制造热点话题，火速出现大量梗图，段子，可以说一举一动都引发巨大话题热点。 当我在各大平台看到这个关键字的时候，我的脑子里面只有一句话“发生了什么？”，直到9月15号铺天盖地的信息才让我意识到了他的火爆程度。 微信指数&#x2F;抖音指数 截止9月16号，其热度在微信与抖音都出现了指数级爆炸，同时在微博多次荣登热搜第一，以及多个热点话题，可能还有其他作者不知道的平台，微博 抖音 微信三个国民级app，已经包含了全国几乎所有的网民，这也为他后面的爆火埋下了伏笔，那他又是如何制造话题的呢？ 信息传播让我们坐上时间机器，回到中秋之前，羊了个羊刚刚上线的时间 9-9号 其官方账号在微博发布了一篇推文 在随后的时间里面，发布了老师vs学生 打击作弊 服务器崩掉 再次崩掉等等一连串的话题，而根据微博指数显示13号开始，热点趋势开始疯狂增加，这也就表明9号到13号是第一波启动用户。 除了微博外，也在抖音进行短视频宣传，可惜抖音趋势无法显示14号之前的数据，但是我们可以推测得出来，其热点也是爆炸增长的。 而这个过程中其宣传的切入点，过关率极低，不睡觉也要玩网友热评等等口碑宣传也起到了早期非常重要的推波助澜作用，让我们来深入分析一下吧。 价值冲突 在不知道游戏内容的情况下，如何吸引用户进入游戏？羊了个羊在做出符合Z时代用户游戏界面的同时，创造了额外的动机。狼人VS吸血鬼 五仁VS莲蓉 学生VS老师 省份VS省份，一旦出现了站队，游戏便不仅仅是游戏，还包含个人价值是否被认同，如果你喜欢吃五仁，看待五仁落于下风，便存在内在动机去参与游戏进行支持，如果你喜欢吃莲蓉，便会进入胜利者的自嗨状态参与游戏寻求碾压对手。 一只羊一旦进入羊群，他便不仅仅是一只羊，而是羊群的一份子，自然带上了集体荣誉的帽子，排名靠前，自豪 快乐，排名靠后 焦虑 失望 甚至自责，无论如何，这都增加了玩游戏的动机。 人类是天生的冒险家如果我告诉你，这一款消消乐游戏很好玩，音乐很魔性，你可能大概率会说我没兴趣，但是如果我告诉这个消消乐游戏，你第二关都过不去，是不是有试一试的冲动了？ 还记得羊了个羊的官方简介吗？ 小游戏以简单休闲出名，很多玩家被极低的通关率所刺激，好奇心促使起主动打开小程序本着试试看的心态进行游戏。教学关卡确实非常简单，甚至会给人一种，后面的关卡也会这么简单的错觉，同时经过教学关卡的无脑通关，玩家也更加确定自己可以成为那0.1%的人。 结果大家都知道了，第二关的难度极大，在将上层较多的消除后，便进入极难的阶段，而到达这一步玩家已经在不知不觉中付出的大量的时间成本 心智成本，便有了足够的动机去看广告，然后复活，再用完所有道具，然后再次失败。 而人类天生爱好挑战，也很难接受与心理预期的巨大差距，也梦想在圈子种脱颖而出，明明是很简单的三消游戏，我怎么就过不了？便产生了再试一局的心态，游戏结束会显示今日挑战了多少次，结果越玩越久，又投入了更大的时间成本 心智成本，便更加不愿意放弃，开始自己和自己较劲（是不是很像拼多多的邀请好友获得100元）。 情绪引导游戏会在很多关键的裂变阶段下足了心思。 羊了个羊的分享文案几乎都是激发玩家胜负欲的主题加上非常魔性的，符合Z时代风格的分享图，事实证明一种方案确实很管用，在不假思索的情况下，我会有很大的概率去点击，尤其是圈子内的分享，例如室友圈 班级圈 好友圈。 而游戏通过给予道具的形式引导玩家进行分享，大部分首次观看广告复活的玩家再次面对困难的时候，便有了足够的动机去分享给朋友，这样每个玩家便会产生三次分享。 在你道具用完，游戏失败的时候同样进行引导，可以说是精准了抓住了用户的心理 我们可以看到，除了外部话题营销的爆火之外，产品类的裂变也在玩家的私域圈子内形成最直接的近距离触达，进而引发了指数级别的爆炸。 小程序的“天然优势”小程序触达路径极短，app内打开，无需下载，即点即玩，登录流程短，借助平台能力即可实现一键登录，这些特性显著降低了使用门槛。 推广能力强，传播渠道多，抖音视频，公众号文章，微信视频，用户可能在多个场景下触发。 开发、上线成本低，没有类似版号的限制 也难怪国内各大app都做小程序生态，从商业的角度上，小程序的优点实在是太多。 一些tips登门槛效应也被称给得寸进尺效应，是指一个人一旦接受了他人一个微不足道的要求，为了避免认知上的不协调，或者想给对方前后一致的印象，就有可能接受更大的要求 回想羊了个羊的关卡设计中第一关极度简单，随便点点就过了，而来自固有观念的路径依赖，会让用户产生后面也会很简单的想法，结果第二关直接地狱难度，与用户的期望结果出现偏差，此时用户为了证明自己，便会走进死胡同。 还有用户首次获得道具需要进行分享，之后再想获取道具便需要看视频，相对于看视频必然分享更加低成本，当用户第二次在想获得道具需要他看广告的时候，因为玩家已经有了分享获取道具的动作，这时候再让用户看广告获取道具便不会让用户非常抗拒。 羊群效应经济学里面经常用“羊群”效应来描述经济个体从众跟风心理，同时从众心理也会也会导致盲从，进而陷入骗局或者遭受失败。 不可否认高难度折叠类三消游戏确实好玩，但是在我看到开发方是非常恶趣味的，完成第二关的就可以加入羊群，成为“领头羊”，如果某位幸运儿过了第二关，那一定会大肆宣传，满足自己的社交情绪，殊不知最大受益者正式游戏方本身，因为你的榜样，更多的人开始盲目跟风，攀比，争取加入盐羊群，于是便开始不断挑战高难度第二关。等到小羊们反应过来的时候，游戏方早已赚得盆满钵满，潇洒离去。 而游戏的爆火也顺带其“周边产业”的爆火， 上瘾模型分析我们使用经典的上瘾模型进行分析，看看羊了个羊是如何让用户成为”犟驴”的 触发 外部触发：微博 抖音多平台 微信分享文案 切入0.01%过关率 话题营销 好友分享 Z时代画风 内部触发：人类的好奇心 胜负欲 社交需要 行动 行动 &#x3D; 动机 + 行为 + 触发 动机：好奇心 胜负欲 社交需要 话题PK 三消游戏的趣味性 行动：年轻群体 + 三线用户具备时间充裕，追求快乐的属性 触发：小程序无需下载，打开即玩的特点极大地降低了触发难度 多变的酬赏 游戏内每次三消带来的正向反馈 游戏话题热度带来的大量奶头乐信息 投入 当前场次，今日已经挑战场次的时间、精力成本的投入 社交关系的投入 而投入最终也成为用户下一次触发的原因，亦或者不服输的驴脾气，亦或者身边的社交唤醒，形成了上瘾模型的闭环。 但是我们可以看到酬赏环节相对薄弱，如果用户一直无法过关，便最终失去兴趣，而话题营销保质期是有限的，并且其游戏内部实现已经被扒了个底朝天，负面消息充斥互联网平台，可以预见在15天内，其流量会跌回他原本的高度（猜测是最高点的10%-20%）。 目标人群作者是9月15号知晓的时候，已经是产品最火的时候了，我们可以发挥想象简单分析一下，作者经过反复的外部触发，才打开小程序，很明显高强度上班族不是他的目标客户，9号到13号的用户才算是他的第一批用户，而他的第一批用户是时间较多的大学生，工作强度不大的年轻人为主，这部分人时间多，并且喜爱追热点话题。 而开发商也精准了抓住了目标用户的特点，从传播切入点 分享切入点 游戏画风等多方面进行针对性开发与策划，保证准确挠到目标用户的痒点，从这个角度看，其实羊了个羊小游戏火起来是存在实力的，不是一个简单的demo产品，大家也不要把他的爆火完全归功于传播营销，产品能力也是其热度持续引爆的原因之一。 非常遗憾在巨量算数中都无法看到9-13号的用户数据，无法验证结论，只能看看14号之后的数据。 从巨量数据来看，越年轻的用户越频繁触发关键词，而31-40岁的用户虽然也非常多，但是TGI数值已经非常低，基本是符合我们推测的结论的。 潮起与潮落9月16号是热度的转折点，不夸张的说，三天内（14-16）号，全国几乎所有网民都听说了一个新名词“羊了个羊”，凭借魔性的画风以及超难的第二关而破圈，而热度也伴随争议随之而来，抄袭，游戏无解，骗人看广告还赚了几百万。 流量的双刃剑已经挥下，这些消息也火速在网上传播开来，也让很多人意识到，原来玩家自己才是“羊”，自然羊群效应带来的用户也火速消失，如果没有这些争议点，也许该游戏可以多保持几天热度，截至19号，微博数据已经下跌了80%-90%，抖音也出现了大幅度的下滑，微信因为社交关系的原因稍微平稳一点，但是可以预见，最多半个月，便会回归到正常的水平，而这几天开发商已经赚的盆满钵满，开始研究下一个热点小游戏。 而微信 抖音，也等到开发商们为其带来下一个热点。 最后我们大多数人从小大到接受的是非常正向的教育理念，相信正义一定打败邪恶，游戏一定是给人带来快乐，哪怕类似《茶杯头》《坐在罐子里面的男人》都仅仅是极大的游戏难度，很难，看似无解，但是本质上都是有解的，但是羊了个羊在实现上采用伪真随机的方式进行打乱，导致游戏无法保证一定有解，也就是说很多时候注定是玩不过去的，也就是说就算你是三消游戏的天才，你也要看广告，他这样的目的是利用玩家的不愿放弃沉没成本、渴望社交酬赏、赌徒心理诱导你看广告而已。 而这样畸形的游戏却能火起来值得我们深思。","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"产品分析","slug":"产品分析","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"}]},{"title":"vue3相对于vue2做了什么？","slug":"vue3源码解读/vue3相对于vue2做了什么？","date":"2022-09-17T16:00:00.000Z","updated":"2023-11-27T02:39:08.300Z","comments":true,"path":"2022/09/18/vue3源码解读/vue3相对于vue2做了什么？/","link":"","permalink":"https://bluedancers.github.io/2022/09/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"vue3.0更加注重模块上的拆分，在2.0版本中所有vue相关的逻辑都相互耦合在一起，就算仅仅使用vue的一小部分，也需要引入完成的vue，造成了空间的浪费，而vue3则在模块层面上进行拆分，通过tree-shaking实现按需导入，减少用户打包体积，同时每个项目单独管理，单独发布，更加具备稳定性 ​ 模块拆分成npm包，独立使用，独立发布 虽然底层出现大量改动，但是顶层设计理念没有发生改变，依旧是声明式架构。 Monorepo： 一个仓库下可以维护多个模块 方便版本管理，依赖管理，模块间引用。 搭建vue3仓库通过pnpm初始化项目1pnpm init 创建Monorepo仓库环境新建文件夹packages 新建文件pnpm-workspace.yaml 12packages: - &#x27;packages/*&#x27; // 含义为怕package目录下的每个文件都是一个单独的仓库 安装公共依赖 项目根目录执行 1pnpm install vue -w // w 为workspace-root的缩写，代表该包为全局依赖 幽灵依赖 ​ vue依赖了abc包，我们下载vue的时候abc包就被下载到项目，我们可以直接使用abc，但是vue可能在某一个版本就不再使用abc，这就会造成依赖丢失，这些依赖就被成为幽灵依赖 生成相关配置信息创建packages内部的package环境 通过 1pnpm tsc --init 生成ts默认配置文件 并且增加配置 1234&quot;baseUrl&quot;: &quot;.&quot;,&quot;paths&quot;: &#123; &quot;@vue/*&quot;: [&quot;packages/*/src&quot;] // 引入库关系映射&#125; 实现构建流程 编写每个组件的package.json 编写公共打包文件，可以打包packages中的所有库 编写esbuild打包代码","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]},{"title":"pinia源码分析【5】- 150行代码实现mini版pinia","slug":"pinia源码解读/pinia源码分析【5】- 150行代码实现mini版pinia","date":"2022-07-28T16:00:00.000Z","updated":"2022-12-11T13:51:24.081Z","comments":true,"path":"2022/07/29/pinia源码解读/pinia源码分析【5】- 150行代码实现mini版pinia/","link":"","permalink":"https://bluedancers.github.io/2022/07/29/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%905%E3%80%91-%20150%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0mini%E7%89%88pinia/","excerpt":"","text":"源码解析系列文章分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言 别人还在学习使用pinia，看过文章的你直接了解核心原理，无论是实际使用，还是面试都将更上一层楼~ ​ 前段时间完成了对pinia核心源码的解读，因为源码存在难度，也间接到了分析文章具有较高的阅读门槛，为了解决这一问题，可以让更多人参与到pinia的源码阅读中，所以今天给大家带来一个mini版pinia的核心实现，核心代码压缩到100行左右，极大了降低了源码阅读难度。 ​ mini版pinia实现了state，getters，action，$patch，$reset，$dispose；居家旅行面试常备~ ​ 同时为了降低阅读门槛，方便TypeScript不熟练的同学，本版本全部使用any，话不多说我们直接开始！ ​ mini版pinia开源地址：https://github.com/vkcyan/mini-pinia mini版逻辑流程图 简单版实现我们在代码结构上尽量与正式源码保持一致，仅仅做一些逻辑上的简化与压缩，保证核心实现的质量。 注册到vue 这里主要参照官方实现，如果不清楚effectScope，请看分析pinia源码之前必须知道的API，如果想深入了解createPinia，请看Pinia源码分析【2】- createPinia 1234567891011121314151617181920212223/** * 创建Pinia */export function createPinia() &#123; // 创建响应空间 const scope = effectScope(true); const state = scope.run&lt;Ref&lt;Record&lt;string, StateTree&gt;&gt;&gt;(() =&gt; ref&lt;Record&lt;string, StateTree&gt;&gt;(&#123;&#125;) )!; // markRaw使其不具备响应式 const pinia = markRaw(&#123; install(app: App) &#123; // 注入pinia app.provide(piniaSymbol, pinia); &#125;, use() &#123;&#125;, _s: new Map&lt;string, StoreGeneric&gt;(), // 保存处理后的store数据全部数据 state, // 保存可访问state _e: scope, // 相应空间 &#125;); return pinia;&#125; 实现defineStore实现一个基础功能的pinia，简单来说，我们只需要做最核心的两件事 将state转为ref，使其具有响应式 将getters处理为computed 如果需要实现$Action还需要对action中所有事件进行拦截处理（mini版不实现$Action） defineStore defineStore中的useStore主要做一些初始化判断，如果是store第一次被使用，则需要初始化，进入createOptionsStore，非第一次直接获取_s中已被处理好的缓存。 1234567891011121314151617181920212223242526272829303132/** * 创建store（仅支持单对象创建方式） * @param options * @returns */export function defineStore(options: &#123; id: string; state: any; getters: any; actions: any;&#125;) &#123; let &#123; id &#125; = options; // 实际运行函数 function useStore() &#123; const currentInstance = getCurrentInstance(); // 获取实例 let pinia: any; if (currentInstance) &#123; pinia = inject(piniaSymbol); // 获取install阶段的pinia &#125; if (!pinia) &#123; throw new Error(&quot;super-mini-pinia在mian中注册了吗?&quot;); &#125; if (!pinia._s.has(id)) &#123; // 第一次会不存在，单例模式 createOptionsStore(id, options, pinia); &#125; const store = pinia._s.get(id); // 获取当前store的全部数据 return store; &#125; useStore.$id = id; return useStore;&#125; createOptionsStore 使用ref处理state，使用computed处理getters，但是此处尚未运行，将setup函数作为参数传值到createSetupStore。 12345678910111213141516171819202122232425262728/** * 处理state getters * @param id * @param options * @param pinia */function createOptionsStore(id: string, options: any, pinia: any) &#123; const &#123; state, actions, getters &#125; = options; function setup() &#123; pinia.state.value[id] = state ? state() : &#123;&#125;; // pinia.state是Ref const localState = toRefs(pinia.state.value[id]); return Object.assign( localState, // 被ref处理后的state actions, // store的action Object.keys(getters || &#123;&#125;).reduce((computedGetters, name) =&gt; &#123; computedGetters[name] = markRaw( computed(() =&gt; &#123; const store = pinia._s.get(id)!; return getters![name].call(store, store); &#125;) ); return computedGetters; &#125;, &#123;&#125; as Record&lt;string, ComputedRef&gt;) // 将getters处理为computed ); &#125; let store = createSetupStore(id, setup, pinia); return store;&#125; createSetupStore ​ 声明当前store的方法，并且运行上一个函数组建的setup函数，其中包含state，getters，我们将其响应式存储到pinia._e中，便于后面对数据变化进行监听，以及统一管理。 ​ 最后将setup返回的对象与存放方法的partialStore对象进行assign，完成store的全部初始化逻辑，并将其加入_s，下次使用该store则直接取值，最后返回当前store。全部逻辑结束。 12345678910111213141516171819202122232425262728293031323334/** * 处理action以及配套API将其加入store * @param $id * @param setup * @param pinia */function createSetupStore($id: string, setup: any, pinia: any) &#123; // 所有pinia的methods let partialStore = &#123; _p: pinia, $id, $reset: () =&gt; console.log(&quot;reset&quot;), // 该版本不实现 $patch: () =&gt; console.log(&quot;patch&quot;), // 该版本不实现 $onAction: () =&gt; console.log(&quot;onAction&quot;), // 该版本不实现 $subscribe: () =&gt; console.log(&quot;subscribe&quot;), // 该版本不实现 $dispose: () =&gt; console.log(&quot;dispose&quot;), // 该版本不实现 &#125;; // 将effect数据存放如pinia._e、setupStore let scope!: EffectScope; const setupStore = pinia._e.run(() =&gt; &#123; scope = effectScope(); return scope.run(() =&gt; setup()); &#125;); // 合并methods与store const store: any = reactive( Object.assign(toRaw(&#123;&#125;), partialStore, setupStore) ); // 将其加入pinia pinia._s.set($id, store); return store;&#125; ​ 我们nimi版pinia的核心实现便完成了，真实的pinia源码中存在许多边际判断，为了方便阅读作者仅仅保留核心逻辑，剔除ts，简化分叉流程，极大的降低了了解pinia核心实现的门槛。 增加一些方法 $Action $subscribe因为涉及到订阅发布模块，所以代码量比较大，mini版就忽略了，对其原理有兴趣的请看pinia源码分析【4】- Pinia Methods $patch 将状态补丁应用于当前状态 123456function $patch(partialStateOrMutator: any) &#123; // mini版实现仅支持传入function if (typeof partialStateOrMutator === &quot;function&quot;) &#123; partialStateOrMutator(pinia.state.value[$id]); &#125;&#125; $reset 初始化state 123456store.$reset = function $reset() &#123; const newState = state ? state() : &#123;&#125;; // 通过闭包获取最初定义的state this.$patch(($state: any) =&gt; &#123; // 借用$patch完成state数据的替换 Object.assign($state, newState); &#125;);&#125;; $dispose 停止store的所有effect，并且删除其注册信息 1234function $dispose() &#123; scope.stop(); // effect作用于停止 pinia._s.delete($id); // 删除effectMap结构&#125; 测试使用我们首先将实现的函数导出出去 src\\super-mini-pinia\\index.ts 1234import &#123; createPinia &#125; from &quot;./createPinia&quot;;import &#123; defineStore &#125; from &quot;./store&quot;;export &#123; createPinia as myCreatePinia, defineStore &#125;; 在项目中的main.ts进行注册 123456import &#123; createApp &#125; from &quot;vue&quot;;import &#123; myCreatePinia &#125; from &quot;./super-mini-pinia/index&quot;;import App from &quot;./App-super-mini.vue&quot;;const app = createApp(App);app.use(myCreatePinia());app.mount(&quot;#app&quot;); 在页面增加一些测试代码 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;div&gt;state.num:&#123;&#123; useStore.num &#125;&#125;&lt;/div&gt; &lt;div&gt;getters.dnum:&#123;&#123; useStore.dnum &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;addNum&quot;&gt;增加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; watchEffect &#125; from &quot;vue&quot;;import &#123; useCounterStore &#125; from &quot;./super-mini-store/counter&quot;;const useStore = useCounterStore();watchEffect(() =&gt; &#123; console.log(useStore.num);&#125;);function addNum() &#123; useStore.addNum();&#125;&lt;/script&gt; 预期效果 action正常触发 num与dnum随着action的触发更新UI mini版pinia测试 ​ 到此为止，我们便完成了mini版pinia的开发，代码虽少，但是核心逻辑五脏俱全，看懂了mini版pinia便是了解了pinia最核心的实现逻辑。 ​ 我已将mini版pinia的开源到github，如果你对pinia核心实现有兴趣，欢迎fock、clone，有任何问题请评论区留言。 结语​ 到此为止pinia源码解读系列便全部结束了，总体来说难度不算太大，作者前前后后花费了半个月时间，从零开始搭建环境，逐步深入阅读，读懂pinia源码的也让作者vue3 reactivity核心响应机制，闭包，订阅发布有了更深入的理解，值得阅读；也欢迎大家一起阅读源码，交流讨论~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"pinia源码分析【3】- defineStore","slug":"pinia源码解读/pinia源码分析【3】- defineStore","date":"2022-07-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.080Z","comments":true,"path":"2022/07/18/pinia源码解读/pinia源码分析【3】- defineStore/","link":"","permalink":"https://bluedancers.github.io/2022/07/18/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%903%E3%80%91-%20defineStore/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言本系列文章参考源码pinia V2.0.14 源码分析记录：https://github.com/vkcyan/goto-pinia 在上一节，我们完成了createPinia相关逻辑的源码解读，了解了pinia注册到vue的阶段具体做了哪些工作，以及pinia核心对象的生成逻辑，本文我们就要一起解读pinia中最重要的方法defineStore的实现原理 关于store的初始化三种创建方法 源码中对defineStore的三种类型描述便解释了为何我们可以用以上三种方式创建。 在defineStore声明中，我们需要传入三种的参数。 id：定义store的唯一id，单独传参或者通过options.id进行传参 options：具体配置信息包含如果传参是对象，则可以传，state，getters，action，id，例如上图1 2 种声明方式；如果传参是Function，则自主声明变量方法，例如上图第三种声明方式 storeSetup：仅限第三种store的声明方式，传入函数 defineStore执行逻辑1234567891011121314151617181920212223242526export function defineStore( // TODO: add proper types from above idOrOptions: any, setup?: any, setupOptions?: any): StoreDefinition &#123; let id: string; let options: // .... // 对三种store创建形式进行兼容。 const isSetupStore = typeof setup === &quot;function&quot;; if (typeof idOrOptions === &quot;string&quot;) &#123; id = idOrOptions; options = isSetupStore ? setupOptions : setup; &#125; else &#123; options = idOrOptions; id = idOrOptions.id; &#125; function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric &#123; //.....下面单独分析 &#125; useStore.$id = id; // 将useStore执行结果返回，在该store在使用之前被返回函数不会执行。 // 所以defineStore早于在Vue种注册pinia也不会出现错误。 return useStore;&#125; ​ 通过对defineStore的源码大致分析可以得知，只有在store被执行的时候才会运行被返回的函数useStore，useStore才是核心store的创建逻辑，我们接下便要重点分析其实现原理。 useStore逻辑分析useStore之前的逻辑执行顺序我们在App.vue中使用我们创建的store 123&lt;script setup lang=&quot;ts&quot;&gt; const useCounter1 = useCounterStore1();&lt;/script&gt; 在main createPinia defineStore useStore初始化处增加日志 defineStore初始化 main.ts -&gt; createPinia -&gt; vue.use -&gt; install（注册逻辑） 执行useStore（页面逻辑） 代码执行与我们想象的一致，defineStore是一个函数，会在引用阶段执行，并返回未执行函数useStore，之后便是一连串的初始化，最后是页面中使用pinia而运行的useStore。 useStore准备工作 12345678910111213141516171819202122// useStore接受两个参数，一个是pinia的实例，另一个与热更新相关。function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric &#123; // 首先会通过getCurrentInstance获取当前组件实例，并处理参数pinia，组件实例可以被正常获取，接下来通过inject(piniaSymbol)获取pinia实例（在install阶段保存）。 const currentInstance = getCurrentInstance(); pinia = (__TEST__ &amp;&amp; activePinia &amp;&amp; activePinia._testing ? null : pinia) || (currentInstance &amp;&amp; inject(piniaSymbol)); // 设置当前活跃的pinia，如果存在多个pinia实例，方便后续逻辑获取当前pinia实例 if (pinia) setActivePinia(pinia); // 在dev环境并且全局变量activePinia获取不到当前pinia实例，则说明未全局注册，抛出错误 if (__DEV__ &amp;&amp; !activePinia) &#123; throw new Error( `[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\\n` + `\\tconst pinia = createPinia()\\n` + `\\tapp.use(pinia)\\n` + `This will fail in production.` ); &#125; // 获取最新pinia，并断言pinia一定存在（猜测这里主要为了断言，此时两个变量就是一个值） pinia = activePinia!; // ....&#125; 核心store创建 ​ 当我们第一次运行store的时候，才会进行相关逻辑的执行，通过单例模式创建，未来再次使用该store将会直接从pinia._s中获取已经被处理过的store并返回。 12345678910111213141516function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric &#123; // ..... // 如果是第一次使用创建store逻辑，后面则跳过 if (!pinia._s.has(id)) &#123; // 如果defineStore的时候第二个参数是函数则为true，否则为false if (isSetupStore) &#123; createSetupStore(id, setup, options, pinia); &#125; else &#123; createOptionsStore(id, options as any, pinia); &#125; &#125; // 从_s中获取当前id对应的store信息 const store: StoreGeneric = pinia._s.get(id)!; // 这里返回的值实际上就是我们实际获取到值 return store as any;&#125; useStore的大致逻辑比较简单，我们假设第一次使用，并且通过非Function进行传参，进入createOptionsStore函数。 createOptionsStoredefineStore的第二个参数使用非Function进行声明将会走入该逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function createOptionsStore&lt; Id extends string, S extends StateTree, G extends _GettersTree&lt;S&gt;, A extends _ActionsTree&gt;( id: Id, // storeid options: DefineStoreOptions&lt;Id, S, G, A&gt;, // state action getters pinia: Pinia, // 当前store实例 hot?: boolean): Store&lt;Id, S, G, A&gt; &#123; const &#123; state, actions, getters &#125; = options; // 获取state中是否已经存在该store实例 const initialState: StateTree | undefined = pinia.state.value[id]; console.log(&quot;initialState&quot;, initialState); let store: Store&lt;Id, S, G, A&gt;; function setup() &#123; if (!initialState &amp;&amp; (!__DEV__ || !hot)) &#123; if (isVue2) &#123; set(pinia.state.value, id, state ? state() : &#123;&#125;); &#125; else &#123; // 将数据存储到state中，因为state时通过ref进行创建 pinia.state.value[id] = state ? state() : &#123;&#125;; &#125; &#125; // 避免在 pinia.state.value 中创建状态 console.log(11, pinia.state.value[id]); console.log(22, toRefs(pinia.state.value[id])); const localState = __DEV__ &amp;&amp; hot ? // 使用 ref() 来解开状态 TODO 中的 refs：检查这是否仍然是必要的 toRefs(ref(state ? state() : &#123;&#125;).value) : toRefs(pinia.state.value[id]); // 经过toRefs的处理后，localState.xx.value 就等同于给state中的xx赋值 let aa = assign( localState, // state =&gt; Refs(state) actions, // Object.keys(getters || &#123;&#125;).reduce((computedGetters, name) =&gt; &#123; if (__DEV__ &amp;&amp; name in localState) &#123; // 如果getters名称与state中的名称相同，则抛出错误 console.warn( `[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with &quot;$&#123;name&#125;&quot; in store &quot;$&#123;id&#125;&quot;.` ); &#125; // markRow 防止对象被重复代理 computedGetters[name] = markRaw( // 使用计算属性处理getters的距离逻辑，并且通过call处理this指向问题 computed(() =&gt; &#123; setActivePinia(pinia); // 它是在之前创建的 const store = pinia._s.get(id)!; // allow cross using stores /* istanbul ignore next */ if (isVue2 &amp;&amp; !store._r) return; // @ts-expect-error // return getters![name].call(context, context) // TODO: avoid reading the getter while assigning with a global variable // 将store的this指向getters中实现getters中this的正常使用 return getters![name].call(store, store); &#125;) ); return computedGetters; &#125;, &#123;&#125; as Record&lt;string, ComputedRef&gt;) ); console.log(&quot;aa&quot;, aa); return aa; &#125; // 使用createSetupStore创建store store = createSetupStore(id, setup, options, pinia, hot, true); // 重写$store方法 store.$reset = function $reset() &#123; const newState = state ? state() : &#123;&#125;; // 我们使用补丁将所有更改分组到一个订阅中 this.$patch(($state) =&gt; &#123; assign($state, newState); &#125;); &#125;; return store as any;&#125; ​ createOptionsStore函数在获取defineStore声明的数据后，在其内部构建了setup函数，该函数将option形式的state与getters分别转化为ref与computed，这样就与setup形式声明的store保持一致。 ​ 这一块代码非常核心，初步解释了为何state具备响应式，为何getters具备computed的效果 ​ 最后不论是option方式创建还是setup的形式创建，最后都统一通过createSetupStore完成对store最后的处理 createSetupStore 无论是何种defineStore创建方式，最终都会走向createSetupStore，在这里进行最终store的生成以及相关methods的实现。 注：这一块代码实在是复杂，关于$reset $patch等API，我们放下一个系列文章 ​ 经过createOptionsStore的处理，已经将option形式的字段全部转化为setup形式进行返回，现在无论何种创建方式，执行此处的setup函数，都会得到同一个结果。 以上三种创建方式，内部运行setup函数都会得到如下结果 接下来，我们就需要对其数据进行处理，获取到所有变量与方法，并对action通过wrapAction进行处理，便于实现后续的订阅发布模式 methods$Action 12345678910111213141516171819202122232425262728293031const setupStore = pinia._e.run(() =&gt; &#123; scope = effectScope(); return scope.run(() =&gt; setup());&#125;)!;for (const key in setupStore) &#123; const prop = setupStore[key]; if ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123; // 如果当前props是ref并且不是计算属性与reative if (!isOptionsStore) &#123; // option结构已经在createOptionsStore将其加入pinia if (isVue2) &#123; set(pinia.state.value[$id], key, prop); &#125; else &#123; pinia.state.value[$id][key] = prop; &#125; &#125; &#125; else if (typeof prop === &quot;function&quot;) &#123; // 如果当前函数是fun // wrapAction 会将当前prop也就是函数增加调用错误与正常的回调函数 const actionValue = __DEV__ &amp;&amp; hot ? prop : wrapAction(key, prop); if (isVue2) &#123; set(setupStore, key, actionValue); &#125; else &#123; setupStore[key] = actionValue; &#125; // 将其函数同步到optionsForPlugin中 optionsForPlugin.actions[key] = prop; &#125;&#125; ​ 经过以上逻辑处理后，setupStore方式进行创建的store也会被添加到pinia.state中，而所有的function都会被wrapAction进行包装处理。 ​ 对state，action进行处理的同时，还需要对当前store可调用API进行处理，例如$reset，$patch 1234567891011121314151617181920212223242526const partialStore = &#123; _p:pinia, $id, $Action, $patch, $reset, $subscribe, $dispose&#125;const store: Store&lt;Id, S, G, A&gt; = reactive( assign( __DEV__ &amp;&amp; IS_CLIENT ? // devtools custom properties &#123; _customProperties: markRaw(new Set&lt;string&gt;()), _hmrPayload, &#125; : &#123;&#125;, partialStore // must be added later // setupStore )) as unknown as Store&lt;Id, S, G, A&gt;;// ...将变量 方法合并到store中assign(toRaw(store), setupStore); ​ 最终将相关methods与store内的数据进行合并，存储以当前store的id为key的Map中，createSetupStore的核心逻辑便全部结束了。 useStore后续逻辑我们再回到defineStore的逻辑中，获取到createSetupStore最后放入pinia._s中的当前store被处理后的对象。 12345// ....// 从_s中获取当前store的effect数据const store: StoreGeneric = pinia._s.get(id)!;// StoreGeneric cannot be casted towards Storereturn store as any; ​ 最后将通过createSetupStore处理后的数据进行返回，我们便得到了使用当前store中变量与方法以及各种方法的能力。 拓展：为什么访问defineStore创建的state不需要.value​ 通过以上源码分析可以得知，state的数据都会被处理为ref，那访问ref自然是需要.value，但是我们日常使用pinia似乎从来没有.value。 我们先看一个小例子 1234567let name = ref(&quot;张三&quot;);let age = ref(&quot;24&quot;);const info = reactive(&#123; name, age &#125;);console.log(info.name); // 张三console.log(info.age); // 24 ​ 简单来说就是reactive中嵌套ref的时候，修改reactive内的值不需要.value ​ 在官方文档（https://vuejs.org/api/reactivity-core.html#reactive）中，我们也能找到相关说明 注意：reactive嵌套ref的场景下，对象与数组格式存在差异，有兴趣可以了解一下 根据文档我们简单的翻阅了一下vuejs&#x2F;core&#x2F;…&#x2F;baseHandlers.ts的源码 源码地址：https://github.com/vuejs/core/blob/main/packages/reactivity/src/baseHandlers.ts line 131 - 134 createGetter() line 131 - 134 createSetter() 可以发现，逻辑实现与文档描述相符。 最后再看一下我们的pinia源码中createSetupStore函数中store声明的那一段函数，这便解释了为什么在使用pinia修改值、读取值的时候都不需要进行.value了。 12345678910111213const store: Store&lt;Id, S, G, A&gt; = reactive( assign( // ... partialStore ) ) as unknown as Store&lt;Id, S, G, A&gt;;// .....if (isVue2) &#123; // ...&#125; else &#123; assign(toRaw(store), setupStore); // 将defineStore的数据合并到reactive声明的store中&#125; 结语​ 虽然代码量比较大，但是核心逻辑就是将state处理为ref，将getters处理为computed，将action进行二次封装，提供若干方法，最后组合对象存储到Pinia中。 ​ 在这一章我们完成了最核心store创建流程的源码分析，但是通过partialStore增加的方法我们还没有一一了解。下一篇我们将会重点介绍store相关Methods的具体实现。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"pinia源码分析【4】- Pinia Methods","slug":"pinia源码解读/pinia源码分析【4】- Pinia Methods","date":"2022-07-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.081Z","comments":true,"path":"2022/07/18/pinia源码解读/pinia源码分析【4】- Pinia Methods/","link":"","permalink":"https://bluedancers.github.io/2022/07/18/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%904%E3%80%91-%20Pinia%20Methods/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言本系列文章参考源码pinia V2.0.14 源码分析仓库：https://github.com/vkcyan/goto-pinia ​ 上一章我们对store的核心流程完成了分析，从而了解了一个store从定义到被使用的实现逻辑，但是store相关的方法，我们还未进行分析，本章我们就重点分析分析store自带的Methods $onAction使用示例订阅当前store所有action操作，每当action被执行的时候，便会触发该方法 12345678910onMounted(() =&gt; &#123; useCounter1.$onAction((option) =&gt; &#123; let &#123; after, onError, args, name, store &#125; = option; &#125;); setInterval(() =&gt; &#123; useCounter1.counter++; // useCounter1.increment(); &#125;, 1000);&#125;); 源码分析订阅在$Action声明的地方，我们可以看到一段这样的函数 第一个参数传null，则不改变this指向，并且在后续的调用依旧是该this。 123const partialStore = &#123; $onAction: addSubscription.bind(null, actionSubscriptions), // action事件注册函数&#125; ​ 也就是说，当我们使用store.$Action的时候实际上触发的是addSubscription函数，并将我们$Action中的回调函数传入createSetupStore中的actionSubscriptions中，也就是订阅了我们的callback ​ 运行store.$Action后得到了addSubscription方法的返回值removeSubscription方法，让我们可以执行其返回值，达到取消订阅的目的。 1234567891011121314151617181920212223export function addSubscription&lt;T extends _Method&gt;( subscriptions: T[], // createSetupStore中的actionSubscriptions callback: T, // 我们传入的callback detached?: boolean, // 如果为true，则该$Action在页面销毁之后依旧有效 onCleanup: () =&gt; void = noop) &#123; // 使用$Action的时候就会触发本函数 subscriptions.push(callback) const removeSubscription = () =&gt; &#123; const idx = subscriptions.indexOf(callback) if (idx &gt; -1) &#123; subscriptions.splice(idx, 1) onCleanup() &#125; &#125; if (!detached &amp;&amp; getCurrentInstance()) &#123; // 如果detached参数不存在，则在当前页面卸载的时候，去除该订阅事件 onUnmounted(removeSubscription) &#125; return removeSubscription&#125; 触发订阅​ 在useStore中对action进行处理的逻辑中，存在这样的一段代码，这段代码中的hot在正常使用的业务场景下都是undefined，所以会走后面的逻辑。 1const actionValue = wrapAction(key, prop) // hot为undefined的情况下 ​ 所有的action在初始化阶段都会被wrapAction方法拦截，也就代表我们执行action的时候，实际上执行的是wrapAction函数，那就让我们就看看，在wrapAction中究竟发生了什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*** 包装一个action来处理订阅** @param name - store的名称* @param action - 需要被包装的action* @returns a wrapped action to handle subscriptions*/function wrapAction(name: string, action: _Method) &#123; return function (this: any) &#123; setActivePinia(pinia); // 获取当前action的参数 const args = Array.from(arguments); const afterCallbackList: Array&lt;(resolvedReturn: any) =&gt; any&gt; = []; const onErrorCallbackList: Array&lt;(error: unknown) =&gt; unknown&gt; = []; // 声明after方法 function after(callback: _ArrayType&lt;typeof afterCallbackList&gt;) &#123; // 将after的call放入list中 afterCallbackList.push(callback); &#125; // 声明error方法 function onError(callback: _ArrayType&lt;typeof onErrorCallbackList&gt;) &#123; onErrorCallbackList.push(callback); &#125; // @ts-expect-error // 触发actionSubscriptions中订阅的store.$Action的全部回调函数,并将参数传入 // 此时store.$Action的callback已经执行,但是after onError的回调函数尚未执行 triggerSubscriptions(actionSubscriptions, &#123; args, name, store, after, onError, &#125;); let ret: any; // ret为action的返回值 try &#123; ret = action.apply(this &amp;&amp; this.$id === $id ? this : store, args); // handle sync errors &#125; catch (error) &#123; // 如果action执行出错,则直接执行错误回调,终止函数 triggerSubscriptions(onErrorCallbackList, error); throw error; &#125; // 如果ret是promise,则当前结果未知，会通过上方的try catch，但是会在action结尾增加then catch进行结果捕捉 if (ret instanceof Promise) &#123; return ret .then((value) =&gt; &#123; triggerSubscriptions(afterCallbackList, value); return value; &#125;) .catch((error) =&gt; &#123; triggerSubscriptions(onErrorCallbackList, error); return Promise.reject(error); &#125;); &#125; // allow the afterCallback to override the return value // 如果try catch 通过，并且当前action不是Promise，则逻辑进行到此处，触发所有 触发真正的after函数，并将当前action的返回值传入其中，至此完成对action触发的监听。 triggerSubscriptions(afterCallbackList, ret); return ret; &#125;;&#125; ​ 之前在$Action中的回调函数在此处发挥了作用，每当一个action触发的都会遍历之前订阅的所有$Action的回调函数，其内部执行action方法，action执行正常在触发after的callback，执行异常则触发onError的callback。 小结 本质上来说$Action就是一个订阅发布模式。 $Action 订阅者 store.action 发布者 actionSubscriptions - 事件注册中心 triggerSubscriptions - 调度中心 ​ 通过订阅者（$Action）把对发布者（action）的订阅注册到事件注册中心（actionSubscriptions）中，当发布者（action）触发时，通知调度中心（triggerSubscriptions），调度中心（triggerSubscriptions）触发事件注册中心中的所有订阅。 $subscribe使用示例​ 订阅当前store中的state的变化，state发生任意更改都会触发其回调函数，他还会返回一个用来删除的回调函数 12345678910111213let abc = useCounter1.$subscribe( (option, state) =&gt; &#123; // 通过store.num = xxxx修改，type为direct // 通过store.$patch(&#123; num: &#x27;xxx&#x27; &#125;)修改，type为directpatchObject // 通过store.$patch((state) =&gt; num.name=&#x27;xxx&#x27;)修改，type为patchFunction // storeId为当前store的id // events 当前改动说明 let &#123; events, storeId, type &#125; = option; console.log(events, storeId, type, state); &#125;, &#123; detached: false &#125;); 源码分析当我们使用$subscribe并传入callback的时候，首先会将当前的callback加入注册中心中 123456const removeSubscription = addSubscription( subscriptions, // 事件注册中心 callback, // $subscribe传入的callback options.detached, // 页面卸载的时候是否取消监听 () =&gt; stopWatcher() // 执行stopWatcher实际上执行的是scope.run返回的watch，而执行watch的返回函数，也就是停止当前watch); ​ 前三个参数经过对$Action的分析后已经比较熟悉，这里我们重点说明一下第四个参数 ​ stopWatcher是当前store中的effectScope，我们将对当前state的watch放入scope中，以便于销毁store的时候统一处理。 12345678910111213141516171819const stopWatcher = scope.run(() =&gt; watch( () =&gt; pinia.state.value[$id] as UnwrapRef&lt;S&gt;, // 监听state的变化 (state) =&gt; &#123; // 在不使用$patch的情况下，则两个参数都为true，callback一定会执行 if (options.flush === &quot;sync&quot; ? isSyncListening : isListening) &#123; callback( &#123; storeId: $id, // type: MutationType.direct, events: debuggerEvents as DebuggerEvent, &#125;, state ); &#125; &#125;, assign(&#123;&#125;, $subscribeOptions, options) ) ) 小结 ​ $subscribe主要依赖vue3的watch进行实现，在subscriptions中注册callback，但是注册的callback不通过triggerSubscriptions进行触发，仅仅作为保存，watch的触发函数中通过闭包触发$subscribe中的callback，达到store中任意值发生变化的时候都执行callback的目的 ​ 在addSubscription的返回值removeSubscription中，不仅会在subscriptions(注册中心)删除订阅，同时也会执行() =&gt; stopWatcher()，停止watch监听。达到完全停止监听的目的。 $patch使用示例直接更新当前state，可以通过传入对象与callback两种方式进行state更新，允许传递嵌套值 123456// 对象useCounter1.$patch(&#123; counter: 2 &#125;);// functionuseCounter1.$patch((state) =&gt; &#123; state.counter = 2;&#125;); 源码分析​ $patch的主体逻辑不算很复杂，针对不同的参数类型进行分别处理，其中partialStateOrMutator是传入的方法，我们将当前store传入其中，通过其callback直接完成state的修改，而传入类型为object的时候，则通过mergeReactiveObjects进行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function $patch(stateMutation: (state: UnwrapRef&lt;S&gt;) =&gt; void): void; // Fun传参function $patch(partialState: _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt;): void; // 对象传参function $patch(partialStateOrMutator: | _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt; | ((state: UnwrapRef&lt;S&gt;) =&gt; void)): void &#123; let subscriptionMutation: SubscriptionCallbackMutation&lt;S&gt;; isListening = isSyncListening = false; // reset the debugger events since patches are sync /* istanbul ignore else */ if (__DEV__) &#123; debuggerEvents = []; &#125; // 如果参数是方法，走以下处理逻辑 if (typeof partialStateOrMutator === &quot;function&quot;) &#123; partialStateOrMutator(pinia.state.value[$id] as UnwrapRef&lt;S&gt;); subscriptionMutation = &#123; type: MutationType.patchFunction, storeId: $id, events: debuggerEvents as DebuggerEvent[], &#125;; &#125; else &#123; // 如果参数是对象，走以下处理逻辑 mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator); subscriptionMutation = &#123; type: MutationType.patchObject, payload: partialStateOrMutator, storeId: $id, events: debuggerEvents as DebuggerEvent[], &#125;; &#125; const myListenerId = (activeListener = Symbol()); nextTick().then(() =&gt; &#123; if (activeListener === myListenerId) &#123; isListening = true; &#125; &#125;); isSyncListening = true; // 在上方逻辑中，我们将isListening isSyncListening 重置为false，不会触发$subscribe中的callback，所以需要手动进行订阅发布 triggerSubscriptions( subscriptions, subscriptionMutation, pinia.state.value[$id] as UnwrapRef&lt;S&gt; );&#125; 12345678910111213141516171819202122232425262728// $patch传入参数为Object的处理逻辑function mergeReactiveObjects&lt;T extends StateTree&gt;( target: T, patchToApply: _DeepPartial&lt;T&gt;): T &#123; // no need to go through symbols because they cannot be serialized anyway for (const key in patchToApply) &#123; if (!patchToApply.hasOwnProperty(key)) continue; const subPatch = patchToApply[key]; const targetValue = target[key]; if ( isPlainObject(targetValue) &amp;&amp; isPlainObject(subPatch) &amp;&amp; target.hasOwnProperty(key) &amp;&amp; !isRef(subPatch) &amp;&amp; !isReactive(subPatch) ) &#123; // 如果被修改的值 修改前修改后都是object类型并且不是Function类型、并且不是ref 不是isReactive，则递归mergeReactiveObjects达到修改嵌套object的目的 target[key] = mergeReactiveObjects(targetValue, subPatch); &#125; else &#123; // @ts-expect-error: subPatch is a valid value // 如果是简单类型 则直接进行state的修改，这里的target为pinia.state.value[$id] // 按我们的示例来实际分析：pinia.state.value[$id].counter = 2 target[key] = subPatch; &#125; &#125; return target;&#125; ​ 完成对mergeReactiveObjects的分析后，$patch的核心逻辑就全部结束了，但是还有一点我们没完成，就是通过$patch修改的state，$subscribe是否可以监听到。 $patch触发$subscribe​ 在$patch执行的中，我们会修改当前store中的state，$subscribe中的watch在flush=&#39;sync&#39;的情况下可以立刻监听到，但是也无法执行callback，因为$patch函数最开始的地方将isListening，isSyncListening置为false ​ 在对值完成修改后，我们将isSyncListening置为true，并且手动订阅$subscribe的callback，达到通过$patch修改state也能被$subscribe监听到的目的。 小结​ $patch的源码相对来说比较简单，但是关于触发$subscribe的部分代码逻辑比较复杂，尤其是当$subscribe option设置中的flush为sync的时候，修改state立刻就会触发$subscribe的watch，虽然最终呈现出来的结果是一致的，但是内部对不同情况的兼容没有看起来那么简单。 $dispose调用该方法后将会注销当前store scope中存储当前store中的相关反应，当前state的watch，ref，等等effect都通过scope.run创建，就是为了方便统一处理，这里调用scope.stop()所有的effect便被全部注销了。 123456function $dispose() &#123; scope.stop(); subscriptions = []; // $subscribe注册中心 actionSubscriptions = []; // $Action的注册中心 pinia._s.delete($id); // 删除effectMap结构&#125; $reset调用该方法可以将当前state重置为初始化的状态 但是有点需要注意，如果defineStore通过setup类型声明，则无法调用该函数 1234567const $reset = __DEV__ ? () =&gt; &#123; throw new Error( `🍍: Store &quot;$&#123;$id&#125;&quot; is built using the setup syntax and does not implement $reset().` ); &#125; : noop; // noop为空函数 如果通过option类型进行声明，则会重写$reset方法 12345678store.$reset = function $reset() &#123; // state通过闭包机制获得最初state定义的状态 const newState = state ? state() : &#123;&#125;; // 通过$patch完成对state中数据的更新 this.$patch(($state) =&gt; &#123; assign($state, newState); &#125;);&#125;; 总结​ 至此，我们就完成了对pinia所有方法的源码解读，而pinia源码解读系列文章也将告一段落，我们从pinia的初始化到了解如何实现state，getters的响应式，最后完成对pinia metnods的全部解读，也算是完全了解了其核心实现，最后我们将会实现一个mini版的pinia，仅仅保留核心实现，降低阅读门槛，让大多数人可以轻松了解pinia的核心实现原理~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"Pinia源码分析【2】- createPinia","slug":"pinia源码解读/pinia源码分析【2】- createPinia","date":"2022-07-06T16:00:00.000Z","updated":"2022-12-11T13:51:24.080Z","comments":true,"path":"2022/07/07/pinia源码解读/pinia源码分析【2】- createPinia/","link":"","permalink":"https://bluedancers.github.io/2022/07/07/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%902%E3%80%91-%20createPinia/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言参考源码pinia V2.0.14 源码分析仓库：https://github.com/vkcyan/goto-pinia 上一篇文章我们主要介绍了如何搭建一个pinia源码阅读环境；本文主要介绍pinia在vue3初始化阶段相关逻辑，以及如何构建pinia对象。 正文根据官方文档，我们使用pinia首先需要是将它注册到vue中 12const pinia = createPinia();app.use(pinia); createPinia阶段究竟做了什么，他又是如何被注册到vue中呢？我们要从createPinia中寻找答案。 源码地址我们通过pinia\\src\\index.ts找到 1export &#123; createPinia &#125; from &#x27;./createPinia&#x27; // `pinia\\src\\createPinia.ts为源码文件` createPinia函数​ 在函数的最开头，我们就可以看到通过effectScope声明了一个ref，并赋值给了state，这里的effectScope是高级API，未来会单独介绍，有兴趣的同学可以看一下官方文档，我们将其简单理解为声明了一个ref并赋值给state。 1234567891011export function createPinia(): Pinia &#123; const scope = effectScope(true); const state = scope.run&lt;Ref&lt;Record&lt;string, StateTree&gt;&gt;&gt;(() =&gt; ref&lt;Record&lt;string, StateTree&gt;&gt;(&#123;&#125;) )!; // 简化理解 // const state = ref(&#123;&#125;) // ...&#125; ​ pinia通过markRaw进行包装，将其标记为不会转化为响应式，最终pinia对象被createPinia函数返回，执行vue.use(pinia)的时候便会执行pinia对象中的install函数。 12345678910111213141516171819202122232425262728293031323334export function createPinia(): Pinia &#123; // ... let _p: Pinia[&quot;_p&quot;] = []; // 所有需要安装的插件 let toBeInstalled: PiniaPlugin[] = []; // install之前保存的待安装插件 // 使用markRaw标记pinia使其不会被响应式 const pinia: Pinia = markRaw(&#123; // vue.use实际执行逻辑 install(app: App) &#123; setActivePinia(pinia); // 设置当前使用的 pinia if (!isVue2) &#123; // 如果是vue2，全局注册已经在PiniaVuePlugin完成，所以这段逻辑将跳过 pinia._a = app; // 保存app实例 app.provide(piniaSymbol, pinia); // 通过provide传递pinia实例，提供给后续使用 app.config.globalProperties.$pinia = pinia; // 设置全局属性 $pinia toBeInstalled.forEach((plugin) =&gt; _p.push(plugin)); // 处理未执行插件 toBeInstalled = []; &#125; &#125;, use(plugin) &#123; if (!this._a &amp;&amp; !isVue2) &#123; // 如果use阶段为初始化完成则暂存toBeInstalled中 toBeInstalled.push(plugin); &#125; else &#123; _p.push(plugin); &#125; return this; &#125;, _p, // 所有pinia的插件 _a: null, // app实例，在install的时候会被设置 _e: scope, // pinia的作用域对象，每个store都是单独的scope _s: new Map&lt;string, StoreGeneric&gt;(), // store缓存 key为pinia的id value为pinia的对外暴露数据 state, // pinia所有state的合集 key为pinia的id value为store下的所有state（所有可访问变量） &#125;); return pinia;&#125; 返回值的含义以及作用 ​ 初始化的逻辑相对比较简单，只需要了解effectScope markRaw便能完全读懂，install阶段组成的pinia对象被setActivePinia保存了下来，而这个对象贯穿pinia整个生命周期，每个字段的作用在后面的源码解读中都会有所体现。 关于Vue2​ 通过pinia官网，我们可以了解到pinia支持vue2，不过vue2环境需要在使用createPinia之前，预先安装插件PiniaVuePlugin，通过pinia的入口文件了解到PiniaVuePlugin的源码入口为pinia\\src\\vue2-plugin.ts ​ PiniaVuePlugin是vue2插件比较主流的实现方式，获取Vue实例，通过mixin实现数据共享。如果了解过vuex的源码，相信对以下代码会十分熟悉。 1234567891011121314151617181920212223242526272829303132333435363738394041export const PiniaVuePlugin: Plugin = function (_Vue) &#123; // Equivalent of // app.config.globalProperties.$pinia = pinia // pinia在vue2中的注册逻辑与vuex核心逻辑几乎一致， // 注入全局mixin的beforeCreate _Vue.mixin(&#123; beforeCreate() &#123; const options = this.$options; // 在根节点通过vue.use中注册了pinia if (options.pinia) &#123; const pinia = options.pinia as Pinia; // defineProperty版provided实现 if (!(this as any)._provided实现) &#123; const provideCache = &#123;&#125;; Object.defineProperty(this, &quot;_provided&quot;, &#123; get: () =&gt; provideCache, set: (v) =&gt; Object.assign(provideCache, v), &#125;); &#125; (this as any)._provided[piniaSymbol as any] = pinia; // 首次注册变量不存在，进行存储 if (!this.$pinia) &#123; this.$pinia = pinia; &#125; // 保存Vue实例 pinia._a = this as any; if (IS_CLIENT) &#123; setActivePinia(pinia); &#125; &#125; else if (!this.$pinia &amp;&amp; options.parent &amp;&amp; options.parent.$pinia) &#123; // 所有子组件/页面都继承上一层的pinia this.$pinia = options.parent.$pinia; &#125; &#125;, destroyed() &#123; delete this._pStores; &#125;, &#125;);&#125;; 关于devTool在createPinia中存在这样一段代码 123if (__DEV__ &amp;&amp; IS_CLIENT &amp;&amp; !__TEST__) &#123; pinia.use(devtoolsPlugin);&#125; 如果是开发环境，并且是浏览器环境，并且不是测试环境，就会向pinia注册devtoolsPlugin，也就是将pinia注册到浏览器插件Vue.js devtools中。 结语​ createPinia的源码解读就全部结束了，现在我们已经了解初始化的具体流程，以及生成的pinia对象中存在什么参数，这些参数在运行阶段都会发挥它应用的价值。 ​ 下一章我们将要解析创建以及使用pinia的相关源码，defindStore函数实现逻辑，在defindStore中我们将会了解到install阶段每个字段的实际用途，以及pinia的核心响应原理。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"Pinia源码分析【1】- 源码分析环境搭建","slug":"pinia源码解读/pinia源码分析【1】- 源码分析环境搭建","date":"2022-07-05T16:00:00.000Z","updated":"2022-12-11T13:51:24.079Z","comments":true,"path":"2022/07/06/pinia源码解读/pinia源码分析【1】- 源码分析环境搭建/","link":"","permalink":"https://bluedancers.github.io/2022/07/06/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/pinia%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%901%E3%80%91-%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言​ 经过vue3从beta版本走向默认版本，vue2.x更新最后一个版本Naruto，全局状态管理也从vuex慢慢走向更加易用更加契合vue3的pinia。 本系列文章将会带领大家从源码角度去理解下一代vue全局状态管理库 pinia 的实现原理。 参考源码pinia V2.0.14 源码分析仓库：https://github.com/vkcyan/goto-pinia 工欲善其事，必先利其器，我们应该如何去阅读pinia的源码呢？ 本文将手摸手教大家如何在vue3环境搭建pinia的源码阅读环境。 创建源码分析环境我们使用vue3开箱即用的CLI初始化一个项目，创建项目非常简单，不做过多赘述。 https://vuejs.org/guide/quick-start.html 1npm init vue@latest pinia源码入口分析先去pinia的官方仓库下载源码 源码地址：https://github.com/vuejs/pinia，我们将其clone到本地 1git clone https://github.com/vuejs/pinia.git 首先分析pinia仓库的打包文件，寻找源代码位置 源码地址​ 在pinia/packages/package.json中，我们找到了打包命令，打包命令中可以得知，打包文件为../../rollup.config.js ​ 在打包文件中，我们找到了被打包源码的入口文件，即为pinia/packages/pinia/src/index.ts 仓库依赖​ 在打包文件rollup.config.js中line121标注了依赖文件，不过我们通过CLI生成的项目中已经包含了以下依赖文件，所以这一步我们不需要额外操作。 环境变量​ 源码中存在大量环境变量注入代码，具体配置在rollup.config.js中line121；如果缺失环境变量声明，会导致源码无法正常运行。 ​ 所以在源码阅读环境，我们需要添加合适的环境变量，让源码正常运行起来。 环境适配将pinia/packages/pinia目录下的所有文件复制到我们之前通过CLI生成项目的/src中。 并根据我们通过源码入口分析获取的信息进行环境变量补全。 在vite.config.ts增加环境变量1234define: &#123; __DEV__: &quot;true&quot;, // 是否开发环境 __TEST__: &quot;false&quot;, // 是否测试环境&#125;, 全局环境变量报错​ 我们在vite的配置文件中向运行环境注入了pinia必要的环境变量，但是TypeScript并不认识相关全局变量，便会发出警告。 ​ 我们需要将源码中的pinia/packages/pinia/src/global.d.ts文件内的声明复制到项目中的env.d.ts即可。 123456789101112/// &lt;reference types=&quot;vite/client&quot; /&gt;// Global compile-time constantsdeclare var __DEV__: boolean;declare var __TEST__: boolean;declare var __FEATURE_PROD_DEVTOOLS__: boolean;declare var __BROWSER__: boolean;declare var __CI__: boolean;declare var __VUE_DEVTOOLS_TOAST__: ( message: string, type?: &quot;normal&quot; | &quot;error&quot; | &quot;warn&quot;) =&gt; void; 至此，我们解决了项目静态检查阶段中所有报错信息，接下来我们启动项目。 浏览器控制台报错’…ComputedRef’​ 启动项目后，在浏览器控制台收获了一个报错信息 我们找到报错代码type.ts进行分析 ​ 错误提示已经非常贴心，可以得知是tsconfig.json配置问题，我们根据报错信息修改配置 出现报错的原因是因为这里vue CLI生成的代码自带一份配置文件，此文件与pinia源码的tsconfig部分配置发生了冲突。 123456789101112131415161718&#123; &quot;extends&quot;: &quot;@vue/tsconfig/tsconfig.web.json&quot;, &quot;include&quot;: [&quot;env.d.ts&quot;, &quot;src/**/*&quot;, &quot;src/**/*.vue&quot;], &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;./src/*&quot;] &#125;, &quot;importsNotUsedAsValues&quot;: &quot;remove&quot;, // 默认被设置为error error情况下类型导入必须增加前缀type 以区分类型 改成remove即可 &quot;preserveValueImports&quot;: false // 对于类型，在同时启用了 &quot;preserveValueImports&quot; 和 &quot;isolatedModules&quot; 时，必须使用仅类型导入进行导入；改成false即可 &#125;, &quot;references&quot;: [ &#123; &quot;path&quot;: &quot;./tsconfig.config.json&quot; &#125; ]&#125; 源码分析环境测试在源码处增加打印，测试pinia源码是否正常运行。 log被正常打印，说明pinia源码已经被正常运行。 ​ 如果感觉搭建环境过于繁琐，又想阅读pinia源码，可以直接clone项目，https://github.com/vkcyan/goto-pinia，开箱即用~ 结语​ 至此，我们便完成了万里长征第一步；植入的源码文件被正常运行，我们便可以通过log debug的方式来进行逻辑观测，接下来我们将正式开始pinia核心实现的探索之旅~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"分析pinia源码之前必须知道的API","slug":"pinia源码解读/分析pinia源码之前必须知道的API","date":"2022-07-04T16:00:00.000Z","updated":"2022-12-11T13:51:24.082Z","comments":true,"path":"2022/07/05/pinia源码解读/分析pinia源码之前必须知道的API/","link":"","permalink":"https://bluedancers.github.io/2022/07/05/pinia%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%88%86%E6%9E%90pinia%E6%BA%90%E7%A0%81%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84API/","excerpt":"","text":"专栏导航分析pinia源码之前必须知道的API Pinia源码分析【1】- 源码分析环境搭建 Pinia源码分析【2】- createPinia pinia源码分析【3】- defineStore pinia源码分析【4】- Pinia Methods 前言​ 在pinia源码中有一些业务场景下不常用的vue3 api，如果没有预先了解将会给源码解读带来较大困难，建议先搞清楚相关API，阅读代码将会事半功倍~ effectScope​ 在createPinia中的遇到的第一行就是不认识的vue3 API，打开官网看了一下，最上方info中写道 effect作用域是一个高阶API，专为库作者服务。 ​ 他的作用是创建一片单独的effect空间，该空间内的effect将可以一起被处理，有点类似docker与k8s的关系，例如ref computed watchEffect 都是docker中的容器，而effectScope就是k8s，它可以统一管理effect集群。 类型： 123456function effectScope(detached?: boolean): EffectScopeinterface EffectScope &#123; run&lt;T&gt;(fn: () =&gt; T): T | undefined // 如果这个域不活跃则为 undefined stop(): void&#125; ​ 通过官网的类型可以看到，effectScope存在一个boolean类型的参数，但是在vue3文档中并未找到参数说明，而在RFC中找到了更加详细的文档。接下来为effectScope的相关API说明。 run 接受一个函数并返回该函数的返回值 1234567891011121314const scope = effectScope();const counter = ref(1);const setupStore = scope.run(() =&gt; &#123; const doubled = computed(() =&gt; counter.value * 2); watch(doubled, () =&gt; console.log(&#x27;doubled&#x27;,doubled.value)); watchEffect(() =&gt; console.log(&quot;count:&quot;, doubled.value)); return &#123; doubled, &#125;;&#125;);// 打印 &#x27;count 2&#x27; watchEffect触发console.log(setupStore!.counter.value); // 打印&#x27;1&#x27;,可以正常访问返回值setupStore!.counter.value = 2; // 打印 &#x27;doubled 4&#x27; &#x27;count: 4&#x27; counter修改触发watch与watchEffect stop 递归结束所有effect，包括后代effectScope 12345678910111213141516171819const setupStore = scope.run(() =&gt; &#123; const counter = ref(1); const doubled = computed(() =&gt; counter.value * 2); nestedScope = effectScope(true /* detached */); nestedScope.run(() =&gt; &#123; watch(counter, () =&gt; console.log(&quot;doubled&quot;, counter.value * 2)); watchEffect(() =&gt; console.log(&quot;count:&quot;, counter.value*2)); &#125;); return &#123; counter, doubled, &#125;;&#125;);scope.stop();setupStore!.counter.value = 2;// 打印 doubled 4 count: 4 // 因为nestedScope被指定为true，所以就算父级被销毁，nestedScope依旧存在反应。// 如果想结束nestedScope，需要手动进行销毁nestedScope.stop() detached表示是否在分离模式下创建，该参数默认为false；当为true的时候，父级被停止，子集也不会受影响。 12345678910111213141516171819202122232425const scope = effectScope();let nestedScope: any;const setupStore = scope.run(() =&gt; &#123; const counter = ref(1); const doubled = computed(() =&gt; counter.value * 2); nestedScope = effectScope(true /* detached */); nestedScope.run(() =&gt; &#123; watch(counter, () =&gt; console.log(&quot;doubled&quot;, counter.value * 2)); watchEffect(() =&gt; console.log(&quot;count:&quot;, counter.value * 2)); &#125;); return &#123; counter, doubled, &#125;;&#125;);scope.stop();setupStore!.counter.value = 2;// 打印 doubled 4 count: 4// 因为nestedScope被指定为true，所以就算父级被销毁，nestedScope依旧存在反应。// 如果想结束nestedScope，需要手动进行销毁nestedScope.stop()nestedScope.stop();setupStore!.counter.value = 3;// 不会出现任何打印 markRaw标记一个对象，使其永远不会转换为 proxy。返回对象本身。 123456const foo = markRaw(&#123;&#125;)console.log(isReactive(reactive(foo))) // false// 嵌套在其他响应式对象中时也可以使用const bar = reactive(&#123; foo &#125;)console.log(isReactive(bar.foo)) // false markRaw在pinia源码中非常常见，主要用于优化pinia的自身性能。 toRaw toRaw可以获取一个响应式对象的原始属性 1234567const foo = &#123;&#125;;const reactiveFoo = reactive(foo);console.log(&quot;toRaw&quot;, toRaw(reactiveFoo) === foo); // trueconst foo1 = &#123;&#125;;const refFoo1 = ref(foo1);console.log(&quot;toRaw&quot;, toRaw(refFoo1.value) === foo1); // true 在pinia源码中用于获取reactive的原始数据，并添加字段到其中 toRefs​ toRefs比较常见，简单来说：结果中的每个对象都指向原始属性；在实际开发中常用于reactive的解构。 ​ 在pinia的源码中，针对store中的state的处理用到了toRefs，不过它解构的是state（ref类型）对象，如果解构的是普通对象将不具备响应式。 结语​ 以上就是pinia源码中使用较多的vue3 api，还有些非常基础的例如ref reactive，就不做过多赘述了。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"}]},{"title":"关于我使用Hexo搭建个人博客这档子事","slug":"技术类文章/关于我使用Hexo搭建个人博客这档子事","date":"2022-06-29T16:00:00.000Z","updated":"2022-12-11T13:51:24.085Z","comments":true,"path":"2022/06/30/技术类文章/关于我使用Hexo搭建个人博客这档子事/","link":"","permalink":"https://bluedancers.github.io/2022/06/30/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/","excerpt":"","text":"前言​ 在我刚工作的那年，便搭建过一次Hexo静态站点到github Pages，那时候输出不多，几乎全都是技术类文章，于是我便把学习记录、文章都放在github仓库中，也会把精品文章发布到掘金；这样的情况下，自建博客没有被维护下去。 ​ 时间来到2022年，随着输出类型越来越多，自然便需要一个空间来存储所有的输出，调研了很多在线文档工具，比如语雀，飞书，Notion，都是非常不错的，不过我个人非常喜欢用Typora，也不太习惯其他文档工具，同时作者也是比较喜欢自由的人，思来想去还是自建博客吧，这便是再次搭建github Pages的原因。 ​ 博客搭建过程也花费了一些时间，遇到了若干小问题，希望后来人不要踩前人已经踩过的坑，这也是这篇文章的由来，希望借此可以帮到大家。 ​ 接下来就让我们正式开始吧。 适合人群 爱折腾、爱自由的开发者 需要一个美观的空间来存储各类文章的开发者 通过个人博客让面试加分的开发者 Hexo介绍​ Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的markdown文件，按照指定的主题解析成静态网页。 githubPages介绍​ GitHub Pages 是一种静态站点托管服务，它直接从 GitHub 上的存储库获取 HTML、CSS 和 JavaScript 文件，可选择通过构建过程运行文件，然后发布网站。您可以在GitHub Pages 示例集合中查看 GitHub Pages 站点示例。 ​ 通过上面的介绍我们便可以得到一个结论：githubPages + Hexo &#x3D; 个人博客，下面让我们正式开始搭建个人博客吧！ 环境要求 nodejs环境 安装git并 注册github账号，并已经将当前电脑的ssh秘钥添加到了Github（相当于告诉github，这台电脑有权操作你的github数据） 创建github Pages仓库 最后点击下方的 Create repository ，完成创建即可。 配置hexo搭建环境首先全局安装hexo 1npm install -g hexo-cli 然后创建存放站点资源的文件夹，在你认为合适的目录下执行 123hexo init 文件夹名称 // 建议username.github.iocd username.github.io // 刚才创建的文件夹npm install install完成后，在该文件夹下执行 1hexo s // hexo server的缩写 正常情况下会看到以下信息 然后我们访问http://localhost:4000/,便可以看到hexo生成的站点 能到这一步就算搭建成功了，接下来我们需要认识hexo生成文件中的配置，来个性化定制我们的个人站点 hexo文件说明_config.yml 一定要仔细看每一项配置哦，比如语言，博客简介，等等 非常重要的文件，配置网站的基本信息信息，比如名称 描述 分页 主题等信息。具体含义看这里 配置参数 themes​ 第三方网站主题存放目录，后面我们会用到 source​ 该文件夹是存放站点文章的地方，_post目录为文章存放处，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。 public​ 所有打包生产的文件都会被输出到public中，其中MD html文件将会被解析再存放在其中，其他文件会被拷贝进去。 将文章发布到Hexo中 可以将搬运到hexo，但是需要修改&#x2F;增加文章头部的配置信息，让hexo得以自动化归类 我们在_post中增加一个md文件，然后文章开头处写入以下信息，使用过wordPress的同学应该很熟悉，这是对当前文章的属性描述，具体配置可以看官方配置，之后便是填入文章内容，还记得我们通过hexo s启动的本地服务器吗，文章编写完成后，让我们去看看是是否存在变化。 不出意外的话应该可以看到我们刚才写的文章出现在网页中了,如果这里未显示可以尝试重启服务 在文章头部编写的categories，tags字段，hexo会按照关键字自动生成索引。 下一步我们便要将其发布到github Pages中，让所有人都可以访问到。 将hexo发布到githubPages​ 我们之前已经处理过了git本地环境与仓库，hexo的部署十分简单 安装快速部署脚本 该脚本会在你的目录下生成.deploy_git/执行更新命令的时候就会将该文件夹下的所有文件上传到指定的仓库中。 1npm install hexo-deployer-git --save 填写相关配置 12345deploy: type: git repo: https://github.com/username/username.github.io // 替换这里的username branch: master // 填写部署的GitHub分支，默认为gh-pages message: &#x27;&#x27; // 提交信息，存在默认值，可以不填写 部署到仓库 12hexo clean // 清除缓存文件 db.json与public/ (建议每次部署之前清除缓存)hexo d // deploy的缩写，读取yml中deploy的配置并部署 看到以上日志则说明部署成功 接下来我们前往仓库，就会发现仓库master分支中已经存在代码，再设置一下github Pages的分支，让博客资源文件可以被正常读取。 最后点击Action查看部署任务是否正常完成，正常情况下Action会在60s左右完成，部署完成后我们便可以访问线上站点了，https://username.github.io/ 只要可以看到我们的文章，便是部署成功了~（可能访问速度还有些慢，我们后面再优化） 这里肯定有好奇的小伙伴要问了，为什么你的样子和我部署的不一样？ 这就是下面要说的，自定义主题。 自定义主题​ 一个风格优美的博客可以为读者带来更好的体验，也是作者个性的一种表达，这也是自建博客的优势所在， hexo中存在大量官方提供 + 个人维护的Themes ​ 如果出现Hexo官网的Themes无法正常访问，可以在github中搜索hexo-theme，同样可以看到受欢迎的hexo主题，每个主题都会有使用文档，只需要仔细阅读文档并进行配置即可使用主题，感谢开源大佬们，别忘记给他们一个Star。 ​ 主题文件都存在在项目的themes文件夹中，并且需要将根目录的_config.yml的themes字段改为主题名称。 插件功能​ 自建博客的虽然不存在后端服务，但是借助第三方服务依旧可以实现交互能力，例如评论系统，统计系统，等等非常有趣的插件，常见的插件第三方主题的README中都会有相关介绍，本文就不做过多赘述了，建议大家看专门介绍相关内容的文章。 常见问题站点很慢​ github Pages访问很慢，绝大部分原因都是因为JS脚本加载阻塞问题，在不加任何异步属性的情况下，script的下载和执行都会阻塞dom的渲染。 ​ 例如项目依赖了jQuery，但是其CDN因为某些原因加载缓慢甚至超时失败，都会导致页面的长时间白屏，这会非常影响访问者的用户体验，以及作者的创作热情。 ​ 如果出现此类情况，我们就打开Chrome devTool查看NetWork中加载缓慢的脚本文件，然后复制其名称，在hexo源码中找到，再百度搜索国内的高速CDN替换掉即可。（注意不要修改打包后代码） 点击菜单404​ 有些第三方主题自带的一些菜单点击可能会出现白屏的情况，这是因为没有建立标签页 执行以下命令建立不存在的页面即可，新建的md具体内容还是需要参考使用的主题文档 1hexo new page books // 缓存问题​ 修改了一篇文章，但是打包到github Pages依旧没有被删除，类似这样的缓存问题怎么办？ ​ 我们只需要在每次push到github之前清除hexo生成的缓存文件即可 1hexo clean 部署报错执行hexo d，得到错误： 12345678910fatal: unable to access &#x27;https://github.com/username/username.github.io/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054FATAL &#123; err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (xxx\\username.github.io\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:390:28) at ChildProcess.cp.emit (xxx\\username.github.io\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123; code: 128 &#125;&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html ​ 网络问题，重试即可。 其他静态构建工具Vuepress​ Vue出品的静态站点生成工具，用来写文档非常不错，但是如果你对个性化要求较高，可能他不是很适合你。 jekyll​ 非常老牌的静态网站生成工具，使用Ruby语言进行开发，这就意味着使用jekyll需要安装Ruby环境，据说构建速度相对较慢，相对于Hexo未发现明显优势，喜欢的小伙伴可以试用一下。 Hugo​ 基于Go语言开发的静态网站构建工具，不过它并不需要Go环境，对于非前端开发者还是不错的选择，他号称是最快的构建框架；在搭建完hexo后才看到hugo，感觉有点意思，喜欢折腾的朋友可以试用一下，目前拥有59.8k的Star，是静态构建工具中最受欢迎的项目。 结语​ 搭建好github Pages并不是一件很困难的事情，但是保持输出习惯却是一件有难度的事情，通过这篇文章成功搭建起了个人博客，非常恭喜，你完成了万里长征非常重要的第一步，希望你可以坚持输出，从小的知识点开始做起，保持对可输出点的敏感嗅觉，并将其输出，逐渐搭建起自己的知识库，这对知识积累，将来跳槽也有很大的帮助。 ​ 如果一个正在被使用的技术方案当事人却无法教会别人，这便不算完全掌握，浅尝辄止是技术岗位的大忌。在输出的过程中，也是重新梳理的过程，在过程中会发现一些开发中未注意到潜在问题，逻辑漏洞，而为了完成输出，便会自我驱动解决遇到的问题； ​ 用输入驱动输出，用输出倒逼输入，将复杂的知识通过简单平实的话说出来，并教会别人，才是完全掌握，这也是输出的意义，这也是个人博客的意义。 ​","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://bluedancers.github.io/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://bluedancers.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"关于消费降级","slug":"随想/关于消费降级","date":"2022-06-27T16:00:00.000Z","updated":"2022-12-11T13:51:24.096Z","comments":true,"path":"2022/06/28/随想/关于消费降级/","link":"","permalink":"https://bluedancers.github.io/2022/06/28/%E9%9A%8F%E6%83%B3/%E5%85%B3%E4%BA%8E%E6%B6%88%E8%B4%B9%E9%99%8D%E7%BA%A7/","excerpt":"","text":"当我们买东西的时候，我们支付的不是钱。 我们支付的是我们生命中，去挣这笔钱所花掉的时间。 在我们创造的消费性社会，它还会持续不断的增长。 每当无法增长的时候，变成了悲剧。 我们为自己造了一座名叫【需求过剩】的大山。 你得不停的购买然后抛弃，在这个过程中，你却买不来生命，生命只会逝去。 浪费生命，失去自由是非常糟糕的 要懂得知足，不要给自己过重的负担，保持内心的幸福，否则你将一事无成。 出自《人类Human》（2015）","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://bluedancers.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"价值观","slug":"价值观","permalink":"https://bluedancers.github.io/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"}]},{"title":"移动端兼容性那些事儿","slug":"技术类文章/移动端兼容性那些事儿","date":"2022-06-23T16:00:00.000Z","updated":"2022-12-11T13:51:24.089Z","comments":true,"path":"2022/06/24/技术类文章/移动端兼容性那些事儿/","link":"","permalink":"https://bluedancers.github.io/2022/06/24/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/","excerpt":"","text":"低版本IOS系统Promise不存在finally事件​ 这是几年前生产环境发生的问题，通过错误监控看到了该错误，并且集中出现在ios10.0.x版本中，出现了，网上也有开发者遇到了IOS 10 Promise不存在问题，我们没遇到该情况，如果Promise对象不存在，则引入Promise的polyfill，如果仅仅是finally函数不存在则只需要手动补充即可 12345678910Promise.prototype.finally = function (callback: any) &#123; let P = this.constructor return this.then( (value) =&gt; P.resolve(callback()).then(() =&gt; value), (reason) =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) ) &#125; IOS时间戳兼容性问题​ 在ios无法解析使用-分割的时间字符串 123new Date(&#x27;2022-6-27 12:00:00&#x27;).getTime() // Android 正常获取 IOS NaNnew Date(&#x27;2022/6/27 12:00:00&#x27;).getTime() // 均正常new Date(1656302400000) // 均正常 ​ 在移动端开发中建议统一采用时间戳记录时间，具体格式交给时间处理函数即可。 移动端1px问题点击事件300ms延时问题​ 因为历史原因，移动浏览器会在touch和click事件之间增加300ms等待时间，来判断用户是否会进行双击手势来缩放页面，自然该特性也会影响到单击事件，后来在Chrome团队的推动下，该问题逐渐有了清晰的解决方案 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; // 窗口自动调整到设备宽度，并禁止用户缩放页面 ​ 随着响应式设计的逐步推进，开发者们已经根据设备本身的尺寸对站点进行了优化，也就逐渐淘汰了诸如双击缩放的约定。 移动端长按识别二维码无效​ 有些移动端开发者在使用类似uniapp这样的框架在开发H5应用中的，长按识别二维码的时候会出现不触发识别的情况，这是因为，长按识别图片信息仅仅在img标签生效，所以只需要使用原生img标签即可。 微信小程序按钮边框无法覆盖问题​ 非常常见的问题，button的边框无法被css中的border正常覆盖掉，那是因为自带的边框是通过伪类实现的 123button::after&#123; border: none;&#125; IOS input标签type为search时候右边有放大镜​ 在ios中input的type值为search的时候，会自带一个搜索icon，而安卓则没有此icon，为了保证一致性，我们需要删除ios自带的搜索icon 12input[type=&quot;search&quot;]&#123;-webkit-appearance:none;&#125; input::-webkit-search-cancel-button &#123;display: none;&#125; 公众号登录路由栈无法去除问题IOS系统微信公众号location跳转后，回退页面不刷新Vue2.x 报错Cannot read property ‘_wrapper’ of undefined​ 这个错误原则上也不算移动端错误了，但是这个报错信息确实会让人摸不着头脑，堆栈信息也无法明确看到具体报错位置，但是出现这个错误八成是因为@click事件在methods中未定义 vue2.x 排序key值问题如果JSON.stringify进行深拷贝时，一些引用类型的异常情况。replaceAll兼容问题uniappv3版本开发小程序 textarea事件绑定错乱","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"兼容性","slug":"兼容性","permalink":"https://bluedancers.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"JavaScript设计模式","slug":"设计模式/JavaScript设计模式","date":"2022-06-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.096Z","comments":true,"path":"2022/06/18/设计模式/JavaScript设计模式/","link":"","permalink":"https://bluedancers.github.io/2022/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JavaScript设计模式基础JavaScript是一门经典动态类型语言，对变量类型的宽容给实际编码带来了很大灵活性。由于无需进行类型检测，我们可能尝试调用对象的任何方法，而无需去考虑它原本是否被设计拥有该方法。 ​ 这一切都建立在鸭子类型的概念上，鸭子类型：如果它走起路来像鸭子，叫起来像鸭子，那他就是鸭子 ​ 利用鸭子类型，我们就不必借助类型的帮助，实现一个动态语言专有原则：面向接口编程，而不是面向实现变成，例如一个对象，具备length属性，那我们就可以将其视为数组，而不需要关心它的实际类型。 多态​ 同一个操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果 ​ 例如：小狗汪汪叫 小猫喵喵叫 他们都是动物，都会发生，但是各自发出的声音并不一样 ​ 其背后的思想是将“做什么”于“谁去做以及怎么样”分离开来，也就是将“不变的事物”于“变化的事物”分离开来。这给予了我们拓展程序的能力，程序看起来是可生长的，也是符合开放封闭原则的，相对于修改代码，增加代码显然优雅安全的多。 12345678910111213141516function sound(animal) &#123; animal.sound();&#125;var Dog = function () &#123;&#125;;Dog.prototype.sound = () =&gt; &#123; console.log(&quot;汪汪汪&quot;);&#125;;var Cat = function () &#123;&#125;;Cat.prototype.sound = () =&gt; &#123; console.log(&quot;喵喵喵&quot;);&#125;;new Dog().sound()new Cat().sound() 如果是强类型语言就需要借助继承来实现向上转型，从狗可以发出叫声转变为动物可以发出叫声，从而避免我们指定了发出声音对象是某一个类型，他就不可能被替换成为另一个类型。 ​ 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 封装封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节，设计细节以及隐藏对象的类型。 原型编程JavaScript本身就是基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型业务更加合适。 ​ 在JavaScript中不存在类的概念，对象也并非从类中创建出来，所有的JavaScript对象都是从某个对象上复制出来的。 ​ 原型编程存在一个重要特性，即当对象无法响应某个请求的时候，就会把该请求委托给自己的原型；这里更好的说法是把请求委托给它的构造器的原型 ​ 在JavaScript中，一个function并不一定仅仅是一个普通函数，也可以是一个函数构造器，当使用new运算符来调用函数的时候，此时函数就是一个构造器。使用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype，再进行一些其他额外操作的过程。 原型链查找对象的过程12345678var A = function () &#123;&#125;;A.prototype = &#123; name: &quot;sven&quot; &#125;;var B = function () &#123;&#125;;B.prototype = new A();var b = new B();console.log(b.name); 首先尝试遍历对象b中的所有属性，但是没有找到name这个属性 查找name属性的请求被委托到对象b的构造器原型，它被b._proto_记录并指向B.prototype，而B.prototype又直线new A()创建的对象 再该对象中依旧没有找到name属性，于是请求又被委托到这个对象的构造器的原型A.prototype 在A.prototype中找到了name属性，返回值 闭包闭包案例123456789101112var func = function () &#123; var a = 1; return function () &#123; a++; alert(a); &#125;;&#125;;var ff = func();ff();ff();ff(); ​ 局部变量在函数执行结束后将会被销毁，但是以上的例子中，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行func的时候，func返回了一个匿名函数的引用，它可以访问到func被调用时产生的环境，而局部变量所在的环境一直处于这个环境中。既然局部变量所处的环境还能被外界访问，这个局部变量就有了不被销毁的理由；在这样的闭包结构中，局部变量实现了生命的延续。 闭包与面向对象过程与数据的结合是形容面向对象中的对象时常用的表达 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据 通常用面向对象实现的功能，用闭包也能实现，反之亦然。 闭包版本 1234567891011121314var app = function () &#123; var value = 0; return &#123; call: function () &#123; value++; console.log(value); &#125;, &#125;;&#125;;var App = app();App.call(); // 1App.call(); // 2App.call(); // 3 对象版本1234567891011var app = &#123; value: 0, call: function () &#123; this.value++; console.log(this.value); &#125;,&#125;;app.call(); // 1app.call(); // 2app.call(); // 3 类版本12345678910111213var App = function () &#123; this.value = 0;&#125;;App.prototype.call = function () &#123; this.value++; console.log(this.value);&#125;;var app = new App();app.call(); // 1app.call(); // 2app.call(); // 3 高阶函数高阶函数是指最少满足下列条件之一的函数 函数可以作为参数被传递 函数可以作为返回值输出 ​ JavaScript语言的函数显然满足高阶函数，在实际开发中将函数作为参数进行传递，让函数的执行结果返回一个另一个函数都是非常普遍的情况，例如函数执行的callback函数。 ​ 通过高阶特性，我们可以实现AOP，也就是面向切面编程 1234567891011121314151617181920212223242526272829303132// 面向切面编程Function.prototype.before = function (beforeFn) &#123; console.log(&quot;before&quot;); var _self = this; return function () &#123; beforeFn.apply(this, arguments); // 执行before本身 return _self.apply(this, arguments); // 返回函数本身 &#125;;&#125;;Function.prototype.after = function (afterFn) &#123; console.log(&quot;after&quot;); var _self = this; return function () &#123; var ret = _self.apply(this, arguments); // 先执行before afterFn.apply(this, arguments); // 最后执行after return ret; &#125;;&#125;;var func = function () &#123; console.log(2);&#125;;func = func .before(function () &#123; console.log(1);&#125;) .after(function () &#123; console.log(3);&#125;);func(); 首先执行before，打印‘before’，然后执行after，打印‘after’ 执行func()，开始执行after，进入after闭包中，然后执行ret，进入before before中首先执行了自己beforeFn，打印‘1’，然后执行func本身，打印‘2’，并返回本身 ret执行结束，开始执行afterFn，打印‘3’，返回func本身 高阶应用 - 函数柯里化​ 柯里化又被称为部分求值，一个柯里化函数首先会接受一些参数，接收参数后不会立刻求职而是继续返回当前函数，之前传入的值在函数形成的闭包种被保存了起来。待函数真正需要求值的时候，之前传入的所有参数都会被一次性求值。 ​ 例如实现一个计算每个月花费多少钱的函数，但是在实现中，我们并不关心吗，每天花费了多少，只想知道月底花掉了多少，实际上只需要计算一次 12345678910111213141516171819202122232425262728function currying(fn) &#123; var args = []; return function () &#123; if (arguments.length == 0) &#123; var res = fn.apply(this, args); args = []; return res; &#125; else &#123; [].push.apply(args, arguments); return arguments.callee; // 当前正在执行的函数 &#125; &#125;;&#125;var cost = (function () &#123; var money = 0; return function () &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; money += arguments[i]; &#125; return money; &#125;;&#125;)();var cost = currying(cost);cost(100)(100)(100)(100);cost(100);console.log(cost()); 500cost(100);console.log(cost()); 600 单例模式​ 要实现一个单例模式并不复杂，无非是用一个变量来标志是否已经为某个类创建过对象，如果是，则下一次获取该类的实例，直接返回之前创建的对象。 vue2.x 中的vuex在页面与组件中进行挂载使用的就是单例模式 使用代理实现单例模式12345678910111213141516171819202122var createDiv = function (html) &#123; this.html = html; this.init();&#125;;createDiv.prototype.init = function () &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = this.html; document.body.appendChild(div);&#125;;var proxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new createDiv(html); &#125; return instance; &#125;;&#125;)();var a = new proxySingletonCreateDiv(&quot;one&quot;);var b = new proxySingletonCreateDiv(&quot;two&quot;);console.log(a === b); // true JavaScript的单例模式​ 单例模式的核心是确保只有一个实例，比提供全局访问。在JavaScript中很多都会通过全局变量进行实现，但是JavaScript的全局变量并不是非常好的特性，在中大型项目中会存在命名冲突问题，所以应当尽量使用命名空间。 惰性单例​ 在未使用之前，相关逻辑不会被创建，并且只有第一次使用的时候才会创建，同时我们别忘记了单一职责原则 ​ 在下面的代码中，我们将创建单例与具体单例逻辑进行分离，这两个方法独立变化而且互不影响，这样避免了下次出现其他元素，我们需要将整个单例函数都复制一遍的情况，而是只需要创建对应的创建函数即可。 123456789101112131415161718192021function getSingle(fn) &#123; let result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;;&#125;function createLoginLayer() &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是登录弹窗&quot;; div.style.display = &quot;none&quot;; document.body.appendChild(div); return div;&#125;var createSingLoginLayer = getSingle(createLoginLayer);document.getElementById(&quot;loginBtn&quot;).onclick = function () &#123; var loginLayer = createSingLoginLayer(); loginLayer.style.display = &quot;block&quot;;&#125;; 小结​ 单例模式是一种简单，但是非常实用的模式，特别是惰性单例技术，在合适的时候再去创建对象，并且只创建唯一一个，同时我们将创建对象与管理单例的职责分开到不同方法中，这样的模式更加体验单例模式的优势。 策略模式​ 策略模式：定义一系列的算法，把它们一个个的封装起来，并且使它们可以相互替换。 ​ 案例：某个公司年终奖方式为基础工资乘以效绩等级，S为基础工资的4倍，A为基础工资的3倍，我们实用策略模式进行实现 1234567891011121314151617181920212223242526272829303132var performatceS = function () &#123;&#125;; // 效绩为S 工资算法performatceS.prototype.calculate = function (salary) &#123; return salary * 4;&#125;;var performatceA = function () &#123;&#125;; // 效绩为A 工资算法performatceA.prototype.calculate = function (salary) &#123; return salary * 3;&#125;;var Bonus = function () &#123; this.salary = null; // 基础工资 this.strategy = null; // 具体算法&#125;;Bonus.prototype.setSalary = function (salary) &#123; this.salary = salary;&#125;;Bonus.prototype.setStrategy = function (strategy) &#123; this.strategy = strategy;&#125;;Bonus.prototype.getBonus = function () &#123; return this.strategy.calculate(this.salary);&#125;;var bonus1 = new Bonus();bonus1.setSalary(10000);bonus1.setStrategy(new performatceS());console.log(&quot;效绩为A&quot;, bonus1.getBonus()); // 40000bonus1.setStrategy(new performatceA());console.log(&quot;效绩为A&quot;, bonus1.getBonus()); // 30000 JavaScript中策略模式的体现以上是类的实现方法，在JavaScript中我们可以通过函数进行实现，代码将会简洁很多 123456789101112var srtategies = &#123;&#125;;srtategies.S = function (salary) &#123; return salary * 4;&#125;;srtategies.A = function (salary) &#123; return salary * 3;&#125;;var calclateBonus = function (level, salary) &#123; return srtategies[level](salary);&#125;;console.log(&quot;效绩为S&quot;, calclateBonus(&quot;S&quot;, 10000));console.log(&quot;效绩为A&quot;, calclateBonus(&quot;A&quot;, 10000)); 多态在策略模式中的体现​ 通过使用策略模式，我们可以消除程序中大量的ifelse语句，并将我们将具体逻辑与实际执行函数进行分离，执行函数没有计算能力，而是委托某个策略对象来完成奖金计算，这正是多态性的体现。 策略模式在表单校验的应用​ 在通过JavaScript表单校验的场景中,我们可以通过ifelse进行校验判断，但是这种方式不符合单一职责，开放封闭原则，我们可以通过策略模式来优化他，将通用的校验逻辑与具体校验条件进行解耦合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 校验逻辑/** * 如果同时设置了required与verify，将会忽略required * verify为自定义校验函数 可以理解为一旦写了verify,其他参数都不需要写了 * @param data 被校验对象 * @param validate 校验规则 * @param isOne 是否校验到错误就立刻返回 * @returns */function starValidate(data, validate, isOne) &#123; let errBack: any[] = [] for (const key in data) &#123; if (validate[key]) &#123; if (validate[key].verify) &#123; validate[key].verify(&#123; data: data[key], allData: data &#125;, (errMsg) =&gt; &#123; if (errMsg) &#123; errBack.push(errMsg) &#125; else &#123; errBack.push(validate[key].callback(data)) &#125; &#125;) &#125; else &#123; // 开启校验 if (validate[key].required) &#123; // 数据不存在 if (!data[key]) &#123; errBack.push(validate[key].callback(data)) &#125; &#125; &#125; &#125; if (isOne &amp;&amp; errBack.length != 0) &#123; break &#125; &#125; console.log(&#x27;处理结果&#x27;, errBack) if (errBack.length == 0) &#123; return Promise.resolve() &#125; else &#123; if (isOne) &#123; return Promise.reject(errBack[0]) &#125; else &#123; return Promise.reject(errBack) &#125; &#125;&#125;// 校验条件const validateRules = &#123; cashingInstructions: &#123; required: true, callback: () =&gt; (&#123; selector: &#x27;.open_prize&#x27;, message: &#x27;请输入字段cashingInstructions&#x27; &#125;), &#125;, lotteryDescription: &#123; verify: (&#123; data &#125;, err) =&gt; &#123; if (data == &#x27;[]&#x27;) &#123; err(&#123; selector: &#x27;.launch_total&#x27;, message: &#x27;请输入字段lotteryDescription&#x27;, &#125;) &#125; &#125;, &#125;,&#125;let data = &#123; cashingInstructions:&#x27;&#x27;, lotteryDescription:&#x27;[]&#x27;&#125;// 实现表单校验 starValidate(data, validateRules, true) 策略模式的优缺点优点 策略模式利用组合，委托和多态等技术与思想，可以有效避免多重条件选择语句 策略模式符合开放封闭原则，将具体逻辑单独封装，使其易于理解易于拓展 策略模式的策略函数可以再多项目之间复用，避免复制粘贴工作 缺点 相对于ifelse，策略模式的整体代码量会有所增加 调用者需要对策略细节可能了解，才能很好的使用该策略，这违反了最少知识原则，增加了使用成本 一等公民函数与策略模式​ 在函数作为一等公民的语言中，策略模式是隐形的具体策略的值就是函数变量。 ​ 在JavaScript这种将函数作为一等对象的语言中，策略模式已经融入到语言中，例如我们经常使用高阶函数来封装不同行为，并且将它传递到另一个函数中，当我们对这些函数发出“调用”的消息，不同的函数会返回不同的结果，函数对象的多态性来到更加简单。 代理模式​ 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个提升对象来控制对这个对象的访问，客户实际上访问的是替身对象。 小红想找心仪的对象让小明作为自己的媒人(代理人) 保护代理：张三找过来了，但是张三没车没房，小红便直接帮他拒绝 虚拟代理：介绍给小明是非常重要的事情，李四对小红有兴趣，给小明好处费，小明便在小红心情好的时候给其介绍（延迟到正常需要的时候再创建） 单一职责原则​ 对一个类&#x2F;函数&#x2F;对象而言，应该仅有一个引起它变化的原因，如果一个对象承担了多种职责，就意味着这个对象将变得巨大，引起它变化的原因将会有多种。面向对象估计设计将行为分布到细颗粒度的对象中，如果一个对象承担的职责过多，等于把这些职责耦合在一起，这种耦合会导致脆弱和低内聚的设计，当变化发生时，设计会遭到意外的破坏。 开放封闭原则​ 例如我们为了更好的性能将一些数据处理成为另外的数据格式，但是2年后上游帮助我们处理过了，我们不再需要额外处理，就不得不在改动原本函数中的代码 ​ 我们可以使用代理模式 达到不改动原对象的情况下，为其提供新的行为，他们各自变化，也不影响对象。 代理与本体接口的一致性​ 通常来说，代理对象对外提供的方法名称会与本体名称保持一致，这样可以在任何使用本体的地方替换成使用代理 代理模式-合并http请求​ 这是一个应用案例，文中的例子我在日常生活中也经历过，将每次点击都请求转变为收集2s类所有请求，并统一发送出去，发送请求时一个函数，何时发送，发送什么，时另一个函数，其中用到了节流函数来控制请求频率 代理模式 - 空间复杂度换取时间复杂度面对非常复杂的计算逻辑，我们可以保存每一次的计算结果，下一个再来同样的参数可以直接走缓存，不再需要计算，这样增加空间，但是缩小了时间。 代理模式示例12345678910111213141516171819202122232425262728293031323334353637var muit = function () &#123; var a = 1; for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i]; &#125; return a;&#125;;var plus = function () &#123; var a = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; a = a + arguments[i]; &#125; return a;&#125;;// 代理模式函数var ceateProxyFactory = function (fn) &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, &quot;,&quot;); if (args in cache) &#123; console.log(&quot;存在缓存&quot;, args,cache); return cache[args]; &#125; cache[args] = fn.apply(this, arguments); return cache[args]; &#125;;&#125;;var muitFun = ceateProxyFactory(muit);var plusFun = ceateProxyFactory(plus);console.log(muitFun(1, 2, 3, 4, 5)); // 120console.log(muitFun(1, 2, 3, 4, 5)); // 走缓存 120console.log(plusFun(1, 2, 3, 4, 5)); // 15console.log(plusFun(1, 2, 3, 4, 5)); // 走缓存 15 总结​ 总体来说代理模式相对简单并且常用，就算一名开发人员没听过这个名词也会写出比较优秀的代理模式代码，并且代理模式不需要预先考虑，需要用到的时候再编写代理函数也不迟。 迭代器模式内部迭代器​ 完全接手整个迭代过程，外部只需要初始调用即可，外界不需要关心迭代器的内部实现，但是这也是内部迭代器的缺点 ​ 例如JavaScript的map forEach 外部迭代器​ 外部迭代器必须显式的请求迭代下一个元素，外部迭代器增加了程序的复杂度，但是也增强了迭代器的灵活性。 12345678910111213var current = 0;var aa = function (obj) &#123; var next = function () &#123; current += 1; &#125;; var getItem = function () &#123; return obj[current]; &#125;; return &#123; next, getItem, &#125;;&#125;; ​ 再具体业务中，使用何种迭代器并无优劣，根据实际场景而定。 总结​ 大部分语言已经内置了迭代器，并且使用频率高、门槛低；迭代器是一种非常简单设计模式，简单到大部分人不认为他是一种迭代器。 发布-订阅模式​ 发布-订阅模式它订阅了一种一对多的依赖关系,当一个对象的状态发生改变的时，所有依赖于它的对象都将得到通知 案例​ 小明看重了某一个小区的热门户型，并且得到消息，后期还会开放一批，但是时间未知，于是小明找到售楼处，预留了自己的电话号码，让售楼处在开发房源的时候通知他，同理，小张、小王都预留了手机号码，于是售楼处就会在房源发布的时候通知预留电话的客户。 ​ 客户想知道房源开售消息，于是他订阅了售楼处，售楼处得到消息后，第一时间将消息发布给订阅者，这样具备显而易见的优点。 小明不需要天天给售楼处打电话，在合适的时间售楼处会通知购房者 购房者于售楼处不再有强耦合关系 发布-订阅模式的作用​ 以上场景于程序中的异步场景是非常相似的，例如我们订阅ajax的error事件，我们无需关心异步运行期间的内部状态，只需要订阅需要的事件发生点即可。 ​ 另外发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式的调用另一个对象的某个接口。 dom事件​ 我们使用dom绑定事件函数就是发布-订阅模式的实际应用，我们不知道用户会在什么时候点击点击，所以我们订阅了dom本身的click事件。 自定义发布-订阅事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546var salesOffices = &#123;&#125;;salesOffices.clientList = [];salesOffices.listen = function (key, fn) &#123; // 创建订阅关联关系 if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn);&#125;;salesOffices.trigger = function () &#123; // 获取订阅数组 var key = Array.prototype.shift.call(arguments); var fns = this.clientList[key]; // 不存在订阅数组则直接返回 if (!fns || fns.length === 0) &#123; return false; &#125; // 执行订阅数组 for (let i = 0; i &lt; fns.length; i++) &#123; let fn = fns[i]; fn.apply(this, arguments); &#125;&#125;;// 小明订阅salesOffices.listen(&quot;sq88&quot;, function (price) &#123; console.log(&quot;我是小明，88平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);salesOffices.listen(&quot;sq88&quot;, function (price) &#123; console.log(&quot;我是小强，88平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);// 小红订阅salesOffices.listen(&#x27;sq110&#x27;, function (price) &#123; console.log(&quot;我是小红，110平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);salesOffices.trigger(&quot;sq88&quot;, 20000000);salesOffices.trigger(&quot;sq110&quot;, 30000000);// 我是小明，88平方// 价格=20000000// 我是小强，88平方// 价格=20000000// 我是小红，110平方// 价格=30000000 取消订阅​ 取消订阅只需要将订阅数组中的指定订阅函数删除即可 123456789101112131415161718192021222324/** * key 订阅类型 * fn 订阅函数 */salesOffices.remove = function (key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; // 没有传入具体的回调地址，则取消所有订阅函数 if (fns) &#123; fns.length = 0; &#125; &#125; else &#123; for (let i = 0; i &lt; fns.length; i++) &#123; const fnItem = fns[i]; if (fnItem === fn) &#123; fns.splice(i, 1); // 删除订阅函数回调 break; &#125; &#125; &#125;&#125;; 关于网站登录的实际应用场景：用户登录完成后，我们需要刷新不相邻模块的数据，这种异步问题，我们一般通过回调函数的方式解决 123456login.succ(() =&gt; &#123; header.setAvatar(data.avatar) nav.setAvatar(data.avatar) message.refresh() // ....&#125;) ​ 这种编写方式将组件数据于信息产生了强耦合关系，如果在未来，我们又增加了一个模块，则需要再次修改改回调函数 ​ 而通过发布-订阅模式，我们就可以在不同模块中订阅用户信息状态的变化，当登录成功的时候，登录模块发布消息到订阅他的模块中，至于各个模块做了什么，登录模块并不关心。 123login.listen(&#x27;loginSucc&#x27;,() =&gt; &#123; // 登录成功，用户数据获取完毕&#125;) 全局模式下的发布-订阅模式​ 全局状态下的发布-订阅可以在两个毫不相关的模块之间进行使用，这样就能保持模块的封装性 ​ 但是这里也需要留意一个问题，如果模块之间又太多的全局发布-订阅模式，就会造成消息流向混乱问题，这会导致维护上出现一些问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var Event = (function () &#123; var clientList = &#123;&#125;; var listen; var trigger; var remove; listen = function (key, fn) &#123; // 创建订阅关联关系 if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function () &#123; // 获取订阅数组 var key = Array.prototype.shift.call(arguments); var fns = clientList[key]; // 不存在订阅数组则直接返回 if (!fns || fns.length === 0) &#123; return false; &#125; // 执行订阅数组 for (let i = 0; i &lt; fns.length; i++) &#123; let fn = fns[i]; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; // 没有传入具体的回调地址，则取消所有订阅函数 if (fns) &#123; fns.length = 0; &#125; &#125; else &#123; for (let i = 0; i &lt; fns.length; i++) &#123; const fnItem = fns[i]; if (fnItem === fn) &#123; fns.splice(i, 1); // 删除订阅函数回调 break; &#125; &#125; &#125; &#125;; return &#123; listen, trigger, remove, &#125;;&#125;)();var xm = function (price) &#123; console.log(&quot;小明价格&quot;, price);&#125;;Event.listen(&quot;sq88&quot;, xm); // 订阅Event.listen(&quot;sq110&quot;, xm); // 订阅Event.remove(&quot;sq88&quot;, xm); // 取消订阅Event.trigger(&quot;sq88&quot;, 220000); // 发布Event.trigger(&quot;sq110&quot;, 2020000); // 发布 JavaScript实现发布-订阅模式的便利性推模型​ 事情发生的时候，发布者会一次性将所有改变的状态与数据都推送给订阅者 拉模型​ 事情发生的时候，发布者只会告诉所有订阅者，需要订阅者手动去拉去 ​ 而在JavaScript中，因为语言特性的存在，是我们可以非常方便的将所有参数通过arguments传入订阅者，所以我们使用推模型来完成消息的订阅与发布。 总结优点 对象之间的解耦合，可以帮助我们写出更好的应对异步编程的场景。 通过订阅-发布模式可以实现以此为特性的解决方案，例如MVVM。 缺点 创建订阅-发布模式需要消耗一定的时间与内存。 订阅的消息会一直留存在内存中，产生了无意义的消耗。 过度使用订阅-发布会导致程序难以追踪与维护。 ​ 命令模式​ 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者与请求接收者能够消除彼此之间的耦合关系 ​ 命令模式还需要支持撤销、排队等等操作 命令模式的例子-菜单程序（面向对象）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var btn1 = document.getElementById(&quot;btn1&quot;);var btn2 = document.getElementById(&quot;btn2&quot;);var btn3 = document.getElementById(&quot;btn3&quot;);var setCommand = function (btn, commm) &#123; btn.onclick = function () &#123; commm.execute(); &#125;;&#125;;var MenuBar = &#123; refresh: function () &#123; console.log(&quot;刷新菜单目录&quot;); &#125;,&#125;;var SubMenu = &#123; add: function () &#123; console.log(&quot;增加子菜单&quot;); &#125;, del: function () &#123; console.log(&quot;删除子菜单&quot;); &#125;,&#125;;var RefreshMenuBarCommand = function (receiver) &#123; this.receiver = receiver;&#125;;RefreshMenuBarCommand.prototype.execute = function () &#123; this.receiver.refresh();&#125;;var AddSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;AddSubMenuCommand.prototype.execute = function () &#123; this.receiver.add();&#125;;var DelSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;DelSubMenuCommand.prototype.execute = function () &#123; this.receiver.del();&#125;;var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);var addSubMenuCommand = new AddSubMenuCommand(SubMenu);var delSubMenuCommand = new DelSubMenuCommand(SubMenu);setCommand(btn1, refreshMenuBarCommand); // 将div与方法做好绑定关系,同时约定一个触发指令点击btn1触发refresh内部预留的execute方法setCommand(btn2, addSubMenuCommand);setCommand(btn3, delSubMenuCommand); 命令模式的例子-菜单程序（面向函数）123456var bindClick = function (btn, func) &#123; btn.onclick = func;&#125;;bindClick(btn1, MenuBar.refresh);bindClick(btn2, SubMenu.add);bindClick(btn3, SubMenu.del); 命令模式的由来，其实就是回调（callback）函数的一个面向对象的替代品 而再JavaScript这样函数作为一等公平的语言中，命令模式早已经融入到语言之中，函数本身就可以被四处传递，即时我们依旧需要请求“接收者”，那也未必使用面向对象的方式，闭包同样可以完成同样的功能。 命令模式的例子-菜单程序（闭包）1234567891011121314var setCommand = function (btn, func) &#123; btn.onclick = function () &#123; func(); &#125;;&#125;;var RefreshMenuBarCommand = function (receiver) &#123; return function () &#123; receiver.refresh(); &#125;;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(btn1, refreshMenuBarCommand); 命令模式 - 回放123456789101112131415161718192021222324252627282930313233343536373839var Ryu = &#123; attack: function () &#123; console.log(&quot;攻击&quot;); &#125;, defense: function () &#123; console.log(&quot;防御&quot;); &#125;, jump: function () &#123; console.log(&quot;跳跃&quot;); &#125;, crouch: function () &#123; console.log(&quot;蹲下&quot;); &#125;,&#125;;var makeCommand = function (receiver, state) &#123; return function () &#123; receiver[state](); &#125;;&#125;;var commandStack = []; // 保存命令堆栈document.onkeypress = function (ev) &#123; var commands = &#123; 119: &quot;jump&quot;, // w 115: &quot;crouch&quot;, // s 97: &quot;defense&quot;, // a 100: &quot;attack&quot;, // d &#125;; if (commands[ev.keyCode]) &#123; var command = makeCommand(Ryu, commands[ev.keyCode]); command(); // 执行命令 commandStack.push(command); // 保存到堆栈 &#125;&#125;;document.getElementById(&quot;replay&quot;).onclick = function () &#123; var command; while ((command = commandStack.shift())) &#123; command(); &#125;&#125;; 宏命令​ 宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。 ​ 在创建命令模式的时候，增加一个add方法来增加命令，并保存到任务对略，最后调用execute方法依次执行即可 总结​ 命令模式在JavaScript中因为高阶函数的存在，让其不太显眼，本质上他是将具体调用与调用的具体逻辑进行分离，具体逻辑就是命令的体现。 组合模式​ 组合模式需要通过对象的多态性进行体现，是的用户对单个对象和组合对象的使用具有一致性 示例​ 这里定义了一个通用函数execute来作为组合模式的桥梁，完成对象树的构建。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;button id=&quot;button&quot;&gt;按我&lt;/button&gt;&lt;script&gt; var MacroCommand = function () &#123; return &#123; commandsList: [], add: function (command) &#123; this.commandsList.push(command); &#125;, execute: function () &#123; for (let i = 0; i &lt; this.commandsList.length; i++) &#123; this.commandsList[i].execute(); &#125; &#125;, &#125;; &#125;;var openAcCommand = &#123; execute: function () &#123; console.log(&quot;打开空调&quot;); &#125;,&#125;;var openTvCommand = &#123; execute: function () &#123; console.log(&quot;打开电视&quot;); &#125;,&#125;;var openSoundCommand = &#123; execute: function () &#123; console.log(&quot;打开音响&quot;); &#125;,&#125;;var macroCommand1 = MacroCommand();macroCommand1.add(openTvCommand);macroCommand1.add(openSoundCommand);var closeDoorCommand = &#123; execute: function () &#123; console.log(&quot;关门&quot;); &#125;,&#125;;var openPcCommand = &#123; execute: function () &#123; console.log(&quot;打开电脑&quot;); &#125;,&#125;;var openQQCommand = &#123; execute: function () &#123; console.log(&quot;登录QQ&quot;); &#125;,&#125;;var macroCommand2 = MacroCommand();macroCommand2.add(closeDoorCommand);macroCommand2.add(openPcCommand);macroCommand2.add(openQQCommand);var macroCommand = MacroCommand();macroCommand.add(openAcCommand); // 如果是基本对象,就是直接触发到其本身的execute方法macroCommand.add(macroCommand1); // 如果是复杂对象,则触发到下一级的execute,然后以深度优点遍历直到最底部的基本对象macroCommand.add(macroCommand2);var setCommand = (function (command) &#123; document.getElementById(&quot;button&quot;).onclick = function () &#123; command.execute(); &#125;;&#125;)(macroCommand);&lt;/script&gt; ​ 组合模式最大的优点在于可以一致地对待组合对象与基本对象。客户不需要关心当前处理的是谁，只要它是一个命令，并且有execute方法，这个命令就可以被执行。 ​ 得益于JavaScript是动态类型语言，对象的多态性与生俱来，不会存在编辑器检查，所以我们实现组合模式并不需要编写抽象类，只需要保证组合对象与叶对象拥有相同的方法即可，并且用鸭子类型的思想进行接口检查 组合模式-扫描文件夹​ 我们通过组合模式，可以做到更新树的结构，但是却不需要改变原有代码，这符合开放封闭原则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Folder = function (nameParams) &#123; let name = nameParams; let files = []; function add(file) &#123; files.push(file); &#125; function scan() &#123; console.log(&quot;开始扫描文件夹&quot;, name); for (let i = 0; i &lt; files.length; i++) &#123; files[i].scan(); &#125; &#125; return &#123; add, scan, &#125;;&#125;;var File = function (nameParams) &#123; let name = nameParams; function add() &#123; throw new Error(&quot;文件中不能增加文件夹&quot;); &#125; function scan() &#123; console.log(&quot;开始扫描文件&quot;, name); &#125; return &#123; add, scan, &#125;;&#125;;var folder = new Folder(&quot;学习资料&quot;);var folder1 = new Folder(&quot;JavaScript&quot;);var folder2 = new Folder(&quot;jQuery&quot;);var file1 = new File(&quot;JavaScript设计模式与开发实践&quot;);var file2 = new File(&quot;精通jQuery&quot;);var file3 = new File(&quot;重构与模式&quot;);folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3);var folder3 = new Folder(&quot;Nodejs&quot;);var file4 = new File(&quot;深入浅出Node.js&quot;);folder3.add(file4);var file5 = new File(&quot;JavaScript语言精髓与编程实战&quot;);folder.add(folder3);folder.add(file5);folder.scan(); 一些需要注意的地方 组合模式不是父子关系 对一组叶对象的操作必须具有一致性，只有用一致的方式对待列表中的每一个叶对象，才适合使用组合模式 如果存在一个叶子元素存在多个父级，可能就需要管理映射关系，避免子元素多次被执行 总结​ 组合模式可以让我们把相同的操作应用在组合对象和单个对象上。 组合模式的美国和对象看起来都和其他对象差不多，他们的区别只能在运行中才能显现出来，这会使代码难以理解 组合模式会大量创建变量，会让系统负担不起 模板方法模式​ 模板方法是一种只需要继承就可以实现的非常简单的模式（多态性） 模板方法由2部分组成，第一部分是抽象父类，第二部分是具体的实现子类 在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留到子类中进行实现，这很好的体现了泛化的思想。 ​ 在模板方法中，子类实现中的相同部分被上移到父类中，而将不同的部分留给子类实现，子类可以复写其具体实现。 咖啡与茶1234567891011121314151617181920212223242526272829303132333435363738394041var Beverage = function () &#123;&#125;;Beverage.prototype.boilWater = function () &#123; console.log(&quot;把水煮沸&quot;);&#125;;Beverage.prototype.brew = function () &#123;&#125;;Beverage.prototype.pourInCup = function () &#123;&#125;;Beverage.prototype.addCondiments = function () &#123;&#125;;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;;var Coffee = function () &#123;&#125;;Coffee.prototype = new Beverage();Coffee.prototype.brew = function () &#123; console.log(&quot;沸水冲泡咖啡&quot;);&#125;;Coffee.prototype.pourInCup = function () &#123; console.log(&quot;把咖啡倒进杯子&quot;);&#125;;Coffee.prototype.addCondiments = function () &#123; console.log(&quot;加糖和牛奶&quot;);&#125;;var Coffee = new Coffee();Coffee.init();var Tea = function () &#123;&#125;;Tea.prototype = new Beverage();Tea.prototype.brew = function () &#123; console.log(&quot;沸水冲泡咖啡&quot;);&#125;;Tea.prototype.pourInCup = function () &#123; console.log(&quot;把咖啡倒进杯子&quot;);&#125;;Tea.prototype.addCondiments = function () &#123; console.log(&quot;加糖和牛奶&quot;);&#125;;var Tea = new Tea();Tea.init(); ​ 在以上例子中Beverage.prototype.init就是所谓的模板方法，因为该帆帆中封装了子类的算法框架。 抽象类模板方法模式是一种严格依赖抽象类的设计模式。 抽象帆帆被声明在抽象类中，抽象方法并没有具体的实现过程，是一些哑巴方法 如果每个子类中都有一些同样的具体实现方法，那么这些方法也可以选择放在抽象类中，这样可以节省代码以达到复用的效果，这些方法被叫做具体方法。 钩子方法​ 模板方法是固定不变的，但是在某些场景下却又要求他变化，有什么办法可以让子类不受这个约束呢？ ​ 我们可以使用钩子方法来实现，放置一个钩子在特定的逻辑。例如以上的例子中咖啡有些人不希望加调料 12345678910111213141516171819// ...Beverage.prototype.custonmerWantsCondiments = function () &#123; return true; // 默认需要调料&#125;;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); if (this.custonmerWantsCondiments()) &#123; this.addCondiments(); &#125;&#125;;// ...Coffee.prototype.custonmerWantsCondiments = function()&#123; return window.confirm(&#x27;请问需要调料吗？&#x27;)&#125;var Coffee = new Coffee();Coffee.init(); 好莱坞原则​ 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历投递过去之后，只能回家等电话，有些等不及的就会打电话过去问，而好莱坞每次都会回答：“不太来找我，有消息我会通知你” ​ 在设计中，这种模式被称为好莱坞原则，在程序中，高层组件决定什么时候以何种方式使用这些底层组件 ​ 这种模式在模板方法模式中很常见，在发布订阅模式，回调函数都非常适用，就像出租车司机告诉你别问我还有多远到，到了我会告诉你。 小结​ 模板方法是一种典型的通过封装变化提高系统拓展性的设计模式。我们把部分抽象逻辑抽象到父类的模板方法，而子类的方法具体怎么实现是可变的，于是我们把这部分变化的逻辑封装到子类中。 享元模式案例​ 假设有一个服装工厂，目前里面50个男士样式，50个女士样式，他们都需要模特穿上拍宣传片，正常情况下就需要分别50个模特来拍照，程序实现逻辑为 123456789101112131415var Model = function (sex, underwear) &#123; this.sex = sex; this.underwear = underwear;&#125;;Model.prototype.takePhoto = function () &#123; console.log(`$&#123;this.sex&#125;:$&#123;this.underwear&#125;`);&#125;;for (let i = 0; i &lt; 50; i++) &#123; var maleModel = new Model(&quot;male&quot;, `underwear$&#123;i&#125;`); maleModel.takePhoto();&#125;for (let i = 0; i &lt; 50; i++) &#123; var femaleModel = new Model(&quot;female&quot;, `underwear$&#123;i&#125;`); femaleModel.takePhoto();&#125; ​ 现在分别50种内衣，一共有100个对象，后面如果越来越多，10000个，可能就会导致程序崩溃。其实我们仔细想想就会发现，我们不需要一套内衣都搭一个模特，只需要一个男模特，一个女模特就够了，我们根据这样的思路再次改写代码 123456789101112131415var Model = function (sex) &#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function (underwear) &#123; console.log(`$&#123;this.sex&#125;:$&#123;underwear&#125;`);&#125;;var maleModel = new Model(&quot;male&quot;);var femaleModel = new Model(&quot;female&quot;);for (let i = 0; i &lt; 50; i++) &#123; maleModel.takePhoto(`underwear$&#123;i&#125;`);&#125;for (let i = 0; i &lt; 50; i++) &#123; femaleModel.takePhoto(`underwear$&#123;i&#125;`);&#125; ​ 改造之后，我们只需要两个对象就实现了相同的功能，并且开销是固定的2个，就算10000间衣服也不会出现问题 外部状态与内部状态 享元模式的目标是尽量减少共享对象的数量，是优先使用时间换取空间的优化模式 上传文件的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var id = 0;window.startUpload = function (uploadType, files) &#123; for (let i = 0; i &lt; files.length; i++) &#123; let file = files[i]; var uploadObj = new Upload(uploadType, file.fileName, file.fileSize); // 实例化传入变量 uploadObj.init(id++); // init中创建dom &#125;&#125;;var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null;&#125;;Upload.prototype.init = function (id) &#123; var that = this; this.id = id; this.dom = document.createElement(&quot;div&quot;); this.dom.id = id; this.dom.innerHTML = `&lt;span&gt;文件名称：$&#123;this.fileName&#125; 文件大小：$&#123;this.fileSize&#125; 上传方式:$&#123;this.uploadType&#125;&lt;/span&gt;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;`; this.dom.querySelector(&quot;.delFile&quot;).onclick = function () &#123; that.delFile(); &#125;; document.body.appendChild(this.dom);&#125;;Upload.prototype.delFile = function () &#123; if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm(&quot;确定删除文件吗？&quot; + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;;startUpload(&quot;plugin&quot;, [ &#123; fileName: &quot;1.txt&quot;, fileSize: 1000, &#125;, &#123; fileName: &quot;2.txt&quot;, fileSize: 2000, &#125;,]);startUpload(&quot;flash&quot;, [ &#123; fileName: &quot;5.txt&quot;, fileSize: 6000, &#125;, &#123; fileName: &quot;6.txt&quot;, fileSize: 7000, &#125;,]); ​ 在以上例子中，我们上传多少文件就需要创建多少个对象，接下来我们用享元模式重构以上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; &#125;; Upload.prototype.delFile = function (id) &#123; let carry = uploadManager.setExternalState(id); return carry.dom.parentNode.removeChild(carry.dom); &#125;; var UploadFactoy = (function () &#123; var createFlyWeghtObjs = &#123;&#125;; return &#123; create: function (uploadType) &#123; if (createFlyWeghtObjs[uploadType]) &#123; return createFlyWeghtObjs[uploadType]; &#125; createFlyWeghtObjs[uploadType] = new Upload(uploadType); return createFlyWeghtObjs[uploadType]; &#125;, &#125;; &#125;)(); var uploadManager = (function () &#123; var uploadDataBase = &#123;&#125;; return &#123; add: function (id, uploadType, fileName, fileSize) &#123; var flyWeight = UploadFactoy.create(uploadType); var dom = document.createElement(&quot;div&quot;); dom.innerHTML = `&lt;span&gt;文件名称：$&#123;fileName&#125; 文件大小：$&#123;fileSize&#125; 上传方式:$&#123;uploadType&#125;&lt;/span&gt;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;`; dom.querySelector(&quot;.delFile&quot;).onclick = function () &#123; flyWeight.delFile(id); &#125;; document.body.appendChild(dom); uploadDataBase[id] = &#123; fileName, fileSize, dom, &#125;; console.log(uploadDataBase); return flyWeight; &#125;, setExternalState: function (id) &#123; return uploadDataBase[id]; &#125;, &#125;; &#125;)(); var id = 0; window.startUpload = function (uploadType, files) &#123; for (let i = 0; i &lt; files.length; i++) &#123; let file = files[i]; uploadManager.add(++id, uploadType, file.fileName, file.fileSize); &#125; &#125;; startUpload(&quot;plugin&quot;, [ &#123; fileName: &quot;1.txt&quot;, fileSize: 1000, &#125;, &#123; fileName: &quot;2.txt&quot;, fileSize: 2000, &#125;, ]); startUpload(&quot;flash&quot;, [ &#123; fileName: &quot;5.txt&quot;, fileSize: 6000, &#125;, &#123; fileName: &quot;6.txt&quot;, fileSize: 7000, &#125;, ]); ​ 通过享元模式创建后，实例化的对象因为工厂模式的存在只创建了2个。 享元模式的适用性 一个程序中使用了大量相似的对象，并且这些对象大多数状态是可以成为外部状态的 可以使用共享对象取代大量对象，将外部状态剥离出去 对象池​ 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不会再去new，还是从对象池中进行获取，如果对象池不存在可用对象，则创建一个新对象，当获取处的对象完成了他的职责之后，再次进入池子等待下次获取 地图标点demo​ 进入地图软件后，首先搜索A地点，存在2个坐标点，通过工厂函数便创建了2个，而后搜索了B地点，存在6个坐标，便会利用之前空闲的2个，再新增加4个坐标点 ​ 对象池的模式与享元模式类，知识没有状态分离的过程。 12345678910111213141516171819var objectPoolFactory = function (createObjFun) &#123; var objectPool = []; return &#123; create: function () &#123; // 创建对象 if (objectPool.length === 0) &#123; // 如果对象池中没有对象，就创建一个新的对象 return createObjFun.apply(this, arguments); &#125; else &#123; // 如果对象池中有对象，就从对象池中取出一个对象 return objectPool.shift(); &#125; &#125;, recover: function (obj) &#123; // 回收对象 objectPool.push(obj); &#125;, &#125;;&#125;; 总结​ 享元模式主要为解决性能问题，在一个存在大量相似对象的系统中，享元模式可以很好的解决大量对象带来的性能问题。 职责链模式​ 使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 ​ 职责链优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系 使用指责链完成订单生成demo 支付过定金的不受库存限制，直接可下单 下了定金的订单但是却没有支付的正常购买 未支付定金的正常购买 12345678910111213141516171819202122var order500 = function (orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log(&quot;500定金预付，得到100元优惠券&quot;); &#125; else &#123; order200(orderType, pay, stock); &#125;&#125;;var order200 = function (orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log(&quot;200定金预付，得到50元优惠券&quot;); &#125; else &#123; order(orderType, pay, stock); &#125;&#125;;var orderNormal = function (orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log(&quot;普通购买，无优惠券&quot;); &#125; else &#123; console.log(&quot;手机库存不足&quot;); &#125;&#125;;order500(1, true, 10); ​ 我们按照职责链进行实现，但是链条的耦合问题非常严重，加入后面出现其他折扣，便需要改写原本已经写好的代码，这违反看开放封闭原则。我们继续优化 123456789101112131415161718192021222324252627282930313233343536373839404142var order500 = function (orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log(&quot;500定金预付，得到100元优惠券&quot;); &#125; else &#123; return &quot;nextSuccessor&quot;; &#125;&#125;;var order200 = function (orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log(&quot;200定金预付，得到50元优惠券&quot;); &#125; else &#123; return &quot;nextSuccessor&quot;; &#125;&#125;;var orderNormal = function (orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log(&quot;普通购买，无优惠券&quot;); &#125; else &#123; console.log(&quot;手机库存不足&quot;); &#125;&#125;;var Chain = function (fn) &#123; this.fn = fn; this.successor = null;&#125;;Chain.prototype.setNextSuccessor = function (successor) &#123; this.successor = successor;&#125;;Chain.prototype.passRequest = function (orderType, pay, stock) &#123; var ret = this.fn(orderType, pay, stock); if (ret === &quot;nextSuccessor&quot;) &#123; this.successor.passRequest(orderType, pay, stock); &#125; return ret;&#125;;var chianOrder500 = new Chain(order500);var chianOrder200 = new Chain(order200);var chianOrderNormal = new Chain(orderNormal);chianOrder500.setNextSuccessor(chianOrder200);chianOrder200.setNextSuccessor(chianOrderNormal);chianOrder500.passRequest(1, true, 10); ​ 现在我们将职责链的耦合关系维护交给Chain进行维护如果后期还会增加其他预约类型，只需要编写相关逻辑代码与部分职责链代码即可 异步职责链1234567891011121314151617181920Chain.prototype.next = function () &#123; return this.successor.passRequest(arguments);&#125;;var fn1 = new Chain(function () &#123; console.log(1); return &quot;nextSuccessor&quot;;&#125;);var fn2 = new Chain(function () &#123; console.log(2); var self = this; setTimeout(() =&gt; &#123; self.next(); &#125;, 1000);&#125;);var fn3 = new Chain(function () &#123; console.log(3);&#125;);fn1.setNextSuccessor(fn2);fn2.setNextSuccessor(fn3);fn1.passRequest(); ​ 我们增加一个next方法来执行下一个职责链的回调函数，进而实现异步效果 职责链模式的优点 解耦了请求发送者与若干接收者之间的复杂关系，并不需要链中谁可以处理，只需要传递给第一个人即可 职责链上的各个节点互不影响 职责链可以灵活拆分重组 职责链可以手动指定起点，而不是必须从第一个开始传递 职责链模式的缺点 不能保证请求一定会被职责链处理到，可能不存在任何结果，需要额外加一个保底判断。 职责链模式会让程序多很多对象，并且可能大部分阶段不会起到作用，它的作用仅仅是让请求传递下去，过长的职责链会造成了一部分的性能损耗，但是这个问题ifelse也存在。 使用AOP思路实现职责链 AOP为面向切面编程，例如装饰器，可以做到在代码执行的前后插入代码切片，并且并修改源代码 123456789101112131415161718192021222324252627282930Function.prototype.after = function (fn) &#123; var self = this; return function () &#123; var ret = self.apply(this, arguments); // 调用者结果 if (ret === &quot;nextSuccessor&quot;) &#123; let res = fn.apply(this, arguments); // 执行下一个函数 console.log(&quot;函数结果&quot;, res); if (res != &quot;nextSuccessor&quot;) &#123; return res; &#125; &#125; return ret; &#125;;&#125;;var getActiveUploadObj = function () &#123; return &quot;nextSuccessor&quot;; // 创建Ie上传组件(假设一定失败)&#125;;var getFlashObj = function () &#123; return &quot;nextSuccessor&quot;; // 创建flash对象(假设一定失败)&#125;;var getFormObj = function () &#123; return &quot;hahahah&quot;; // 创建表单对象(假设一定成功)&#125;;var getUploadObj = getActiveUploadObj.after(getFlashObj).after(getFormObj);console.log(&quot;getUploadObj&quot;, getUploadObj()); 小结个人感觉指责链有链表的感觉，在原型链，事件冒泡上都有所体现，在日常开发中倒不算很常见，类似订单demo可能更加偏向于使用ifelse + 封装来组织代码，同样可以实现职责链的效果。 中介者模式中介者模式的作用就是接触对象与对象之间的紧耦合关系。增加一个中介者后，所有的相关对象都通过中介者对象进行通信；而不是相互引用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/categories/JavaScript/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://bluedancers.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"随选朗读 - 给长辈更好的手机使用体验","slug":"随想/随选朗读 - 赋予长辈手机使用能力","date":"2022-06-11T16:00:00.000Z","updated":"2023-11-27T01:52:21.471Z","comments":true,"path":"2022/06/12/随想/随选朗读 - 赋予长辈手机使用能力/","link":"","permalink":"https://bluedancers.github.io/2022/06/12/%E9%9A%8F%E6%83%B3/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB%20-%20%E8%B5%8B%E4%BA%88%E9%95%BF%E8%BE%88%E6%89%8B%E6%9C%BA%E4%BD%BF%E7%94%A8%E8%83%BD%E5%8A%9B/","excerpt":"","text":"时代背景​ 在历史上的1952年5月24日是一个特殊的日子，在那一天正式开始大规模扫盲运动。新中国成立之初，全国5.5亿人口，80%都是文盲，农村的文盲率达到了95%以上，让我们把时间拉回2022年的今天，今天我想描述的是90后的父母一代，大约是1960-1975诞生于华夏文明的人，根据官方调查90后父母一代的文盲率大约为40%。 ​ 90后父母一代是疲惫的，他们大多从农村出来，为城市建设添砖加瓦，拿着微薄的薪水，做着繁重的工作，赶上了房价翻了一番又一番，他们的压力从来不会出现在主流媒体中，他们也大多数已经年过半百，身体机能开始衰退，视力开始下降，在互联网时代与90、00后赚个满怀的时候，他们只能踉踉跄跄的跟紧时代的步伐，他们是社会上看不见的大多数。而随着岁月的流失，亦或者时代的影响，存在很大一部分人因为视力问题，或者文盲，失去了使用手机的能力。 随选朗读 ​ 大部分年轻人可能并不知道这个名词，因为我们正值身体的最佳状态，本身便不存在工具来创造无障碍的场景，我们来了解一下“随选难度”的官方定义吧。 ​ “随选难度”可帮助障碍用户在无法使用视觉获取信息、阅读困难等情况下通过读取屏幕的无障碍接口来获取用户想要阅读的界面的文本信息，然后再调用语音库将之朗读出来。简而言之，用户在开启该功能后，可将他想获取的文本信息转化为音频被接收。 目标人群 低视力、老花眼人群 低文化水平、文盲人群 场景性障碍人群 ​ 随着岁数的增加，亦或者长期疲劳用眼，老花眼必然会出现在人类的生命轨迹之中，面对这样的情况，一般需要配一个老花镜，在阅读较小较密集文字的时候带上眼镜才能看清文字，正常生活并不需要长时间戴眼镜，而有了随选朗读功能后，查看手机咨询只需要滑动文字区域，即可让手机完成其识别与阅读，规避用眼场景，这将大幅度改善中老年人的手机使用体验。 ​ 90后的父母一代，文盲比例已经相对较少，但是在华夏大地庞大的人口基数下，也算是5%也是非常大的人口体量，因为不认识字，他们使用手机困难重重，但是又不得不使用智能手机，例如在进出都需要扫码的疫情时代，遍地移动支付的互联网时代，如果没有家人或者朋友的反复教学，他们可能永远都无法正常使用智能手机，甚至家人微信聊天都只能发送语音，而随选朗读则给予了文盲人群识别文字的能力，遇到不认识的字，滑动一下就会读出来，这给予了文盲用户独立使用智能手机的能力，作为晚辈也减小了压力。 ​ 最后是场景性障碍人群，例如开车中，做饭中暂时无法看长时间看屏幕的场景，不过从现实来看此类场景需求不大，因为长文可以等会看，一小段文本则很快就看完了，此处便不再赘述。 如何使用小米手机设置 - 更多设置 - 无障碍 - 视觉 - 随选朗读 开启后点击小喇叭就会出现一个红色按钮，即可选中你想被阅读的区域，松手即可开始朗读，朗读完毕后自动关闭，如果想下次使用，可以再次点击小喇叭，不同手机入口显示方式不同，有些是显示小人形状。 华为手机设置 - 辅助功能 - 无障碍 - 随选朗读 - 开启 iphone设置 - 辅助功能 - 朗读内容 - 朗读屏幕 - 语音控制器 - 打开显示控制器 其他手机​ 身边手机有限，就算一个品牌的手机不同版本设置路径也存在一定区别，不过可以放心无障碍功能所有手机都有，因为这是android，ios系统原生功能，一般都在其他设置&#x2F;无障碍菜单中。 没有随选朗读​ 我把周围同事的手机大致都研究了一遍，发现如果是20年之前的手机，大部分是没有“随选朗读”功能的，无障碍套件由安卓系统提供，低版本系统存在没有随选朗读的现象，手机没有自带没有关系，可以第三方下载，我在百度网盘放了一个，android无障碍套件v12.1，有需要的朋友请自取。 结语​ 看到这里，不知道你是否想到了长辈们，为了看手机上的微信消息而着急寻找眼镜的匆忙场景，是否想到了长辈们因为看不懂文字而无法正常使用手机的窘境，而通过简单设置，就可以赋予有困难的长辈们更好使用智能手机的能力，机器无情，人间有情，沉舟侧畔千帆过，病树前头万木春，记得多回头看看驻留在原地的那群可爱的人。","categories":[{"name":"玩机技巧","slug":"玩机技巧","permalink":"https://bluedancers.github.io/categories/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"无障碍","slug":"无障碍","permalink":"https://bluedancers.github.io/tags/%E6%97%A0%E9%9A%9C%E7%A2%8D/"},{"name":"随选朗读","slug":"随选朗读","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB/"}]},{"title":"三辆自行车","slug":"随想/三辆自行车","date":"2022-06-09T16:00:00.000Z","updated":"2022-12-12T07:34:54.509Z","comments":true,"path":"2022/06/10/随想/三辆自行车/","link":"","permalink":"https://bluedancers.github.io/2022/06/10/%E9%9A%8F%E6%83%B3/%E4%B8%89%E8%BE%86%E8%87%AA%E8%A1%8C%E8%BD%A6/","excerpt":"","text":"​ 初中的时候，我特别想要一个自行车，大概觉得骑车很酷吧，或者是幼年的虚荣心作祟，那时候家里条件还很差，三口之家租住在一个没有空调的老旧矮楼的二楼第一间，大约12平方的四方四正的小屋，大家可以想象一下电视剧蜗居的样子吧，父母自然不同意卖一辆自行车，上学的路程只有2公里，这点距离还要骑自行车，在爸妈眼里是不可理喻的，可终究是拗不过我，在那个夏天的夜晚，爸带我到一个破破烂烂的修车铺，那是一辆蓝色有点破旧的小轮自行车，依稀记得车头是一个T形的，黑漆上零星的白点，刹车线已经泛黄仿佛蒙上了茶油的滤镜，这似乎在告诉我它的年纪，我爸对此很满意，大约150吧，带着我带着它一起回家了，我相信爸妈是开心的，因为终于不用听这小子天天嚷嚷了，我也就是这么迷迷糊糊的有了一台自行车。 ​ 好景不长，这辆蓝色小轮车骑起来轴承里面会发出宛如鞭炮一样哒哒哒的，这让一个刚刚满12岁的小孩内心倍感自卑，因为我害怕因为这个声音招来马路上嘲笑的目光，以至于放学路上同学都骑走了，我才会开始骑车，我又开始不断嚷嚷自行车的问题，我妈耳根子软，心里虽然气愤儿子不懂事，但是依旧妥协了，没多久换了一辆新的凤凰牌自行车，蓝色小车被我爸骑电瓶车带回了老家，给了在村里的表姐，因为离镇上很远，她非常需要一辆车，而我终于如愿以偿的得到了一辆崭新的真正的自行车，那是一辆的银灰色自行车，车架在阳光下发射着宛如银河的色彩，黑色的车头一尘不染的深邃，仿佛在告诉全世界，他的诞生，也终于没有了哒哒哒的骑行背景音乐；而这属于我的第一辆新自行车的命运却是如此的凄惨，在我还没来得及和他好好人认识的时候，便戛然而止，是的，没多久他就被偷了；记得那天早上我骑着它到补习班，补习班对面是人流量很大的商业街，我用买车赠送的那把蓝色细锁火速锁好车便跑进补习班，等到中午补习结束回到停车点的时候，我傻眼了，同学一个个离开，而我在那片不大的地方反复寻找，恨不得把地下的砖都扒开，我可能找了半小时，最后我浑浑噩噩的走回家，那段路挺远，大概4个路口，回到家已经12点多了，我妈没有打我，但是我害怕极了，后续发生了什么也记不清了，也许是因为选择性忘记，最后，补习班和老师还赔了200块。 ​ 车丢了，但是习惯已经养成了，自然还是要买自行车，人总是贪婪的，得到了谷子就想得到糖，得到了糖就想得到肉，十三岁的我自然也不例外，这次我斗胆提议要一辆变速山地自行车，每次放学我都会偷偷观察同桌的捷安特，那卡卡的变速声音不断挠动我心中的痒，夜里做梦都想拥有一辆这样的自行车，去享受大家羡慕的目光；变速自行车比较贵，是普通自行车的2-3倍，爸妈自然非常不愿意，毕竟赚钱真的很不容易，那时候依旧在12平小屋中，夏天的下午会被太阳从侧面暴晒，晚上睡觉都能感受到从墙体深处散发的热浪，实在无法忍受，才加装了空调；耐不住我的软磨硬泡，耐不住这是他的儿子，最后还是给我买了，就在我丢掉凤凰牌自行车的商业街对面，我获得了我人生中第三辆自行车 ​ 那是一辆黑红相见的变速山地自行车，品牌名为“巨凤”，不是名牌所以也比较便宜，不过我依旧很喜欢，他看起来是那么具有运动感，如此的个性鲜明，花费了500多，这对我们家庭来说已经是一笔巨款，我带着它回家了，我至今都记得，在回家的路上有一段上坡，我将变速调节到比较省力的轮档，我向往常一样踩着踏板，但是这却是一种未曾有过的体验，如此的轻巧，如此安稳，第二天早上5点多我便醒来，迫不及待的我想骑上的我新车去学校，那时已经是晚秋，我踏着淡淡曙光，仿佛骑行在云端之上，到学校的时候，天都未亮，对于那一刻的我来说，我的虚荣心大概已经得到了满足。在后来的日子里，我经常骑着它去偏远的谭冲湖，去几公里外的古梗公园，去杂草丛生的老肥西火车站，没有理由，随便定一个目标的骑行，在我那平淡如水的初中时光，我和“巨凤”游览了肥西大大小小很多角落。在天气还不算燥热的初夏，在平坦又人际罕见的单排公路，路旁的山丘跑向我的身后，柏油路前方看不见尽头，河水流淌声不断微弱，我不断加速，尽情的享受与风的交流。 ​ 在我初中阶段中，我对自行车是如此的执着，我认为我热爱自行车，但是我错了；在买“巨凤”的第二年，我初三了，中考勉勉强强的考上了高中，但是分数线只够去比较远的地方，我与我的“巨凤”便失联了，我再次见到的他的时候，它已经落满了灰尘，斜靠在墙角，嶙峋的轮胎上满是龟裂，前轮已经完全漏气，夕阳下，他就像一匹消瘦的老马，我路过很多次都没注意到他，直到在大学入学前夕，我对家恋恋不舍的时候，我终于注意到了它，我已经不记得当时面对它的表情，是我抛弃了它，就像随着岁月不断被丢弃的东西们一样。 ​ 前往古梗公园的路依旧平整，谭冲湖的河水依旧川流不息，到现在也依旧会时常回想起与它们们在路上的时光，只是再也找不回记忆中的微风拂面的感觉。 ​ ​","categories":[{"name":"随想集","slug":"随想集","permalink":"https://bluedancers.github.io/categories/%E9%9A%8F%E6%83%B3%E9%9B%86/"}],"tags":[{"name":"童年","slug":"童年","permalink":"https://bluedancers.github.io/tags/%E7%AB%A5%E5%B9%B4/"},{"name":"随想","slug":"随想","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0","slug":"技术类文章/【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0","date":"2022-05-24T16:00:00.000Z","updated":"2022-12-11T13:51:24.084Z","comments":true,"path":"2022/05/25/技术类文章/【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0/","link":"","permalink":"https://bluedancers.github.io/2022/05/25/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E3%80%905000%E5%AD%97%E9%95%BF%E6%96%87%E3%80%91%EF%BC%88%E5%BC%80%E6%BA%90%EF%BC%89%20%E4%BD%8E%E4%BB%A3%E7%A0%81H5%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%20-%20%E6%98%93%E5%8A%A8v3.0/","excerpt":"","text":"前言​ 作者在2020年的时候开源了易动第一个版本（开源）从0打造H5可视化搭建系统 - 易动（vue+ts+egg），这两年在公司针对装修技术方案做了大量的实践，使用过draggable方案 iframe装修方案 绝对定位方案，对其在技术，产品层面都存在更深入的理解，今天给大家带来新一代企业级H5装修方案易动v3.0 开源地址 拖拽生成h5页面，支持页面全局设置，组件，自定义URL，插件市场，公共npm组件库 基于最新vue技术栈， 易动v3.0 已上线，欢迎体验~~ YD 管理端 YD_Client 客户端 开源不易，给个Star吧~ 技术栈管理端：vue3 + vite + pinia + vueuse + TypeScript 客户端：vue3 + vite + TypeScript 集成组件库（ydh5-ui）：基于Vue3 + TypeScript进行开发 服务端：serverLess 项目架构​ 在正文开始之前先为大家介绍一下项目架构，我们从底层到上层依次介绍 ​ 易动3使用腾讯云serverless作为后端服务，serverless在易动系统中提供组件schema的数据存储服务，为什么使用serverless下文在说明。 ​ 易动3将客户端、管理端的公共装修组件进行了统一封装发布成为npm包，解决了以往存在的一个组件需要写、改两遍代码的核心问题。 ​ 易动管理端是项目的最核心系统，除了核心的保存，修改之外，以及一系列提供装修效率的功能，例如组件市场、辅助线、复制、粘贴、撤销、放撤销，这个低代码装修系统的上限于下限皆由此项目决定。 ​ 易动客户端功能比较单纯，主要是根据约定好的js Schema结合集成组件库进行数据渲染于逻辑触发。 使用方向​ 这几年关于低代码领域开始不断有大厂入场，这也变相的说明了该领域巨大的提效需求，愿望是美好的，但是现实是骨感的，低代码无法做到全盘通吃，只能聚焦某个领域，易动v3.0也是这样的，他无法处理存在大量逻辑的页面，所以易动v3.0选择专注于营销单页，在营销单页领域他可以发挥自己的优势。 ​ 除了基础的按钮、图片组件外，业务组件可以做很多场景化组件，例如banner，商品专区，甚至从接口获取数据的组件都可以通过js Schema的约定进行实现 ​ 而营销单页的需求络绎不绝，这样的工作就像在工厂“打螺丝”，大部分前端开发者并不愿意做这件事情，并且工作流程比较繁琐，可能因为业务原因频繁改动，大致工作流程如下 ​ ​ 一个再简单的单页都需要走一样的固定流程，并且一旦某个环节出现了问题就需要回滚好几步，在这儿个过程中开发者也需要跟着回滚，遍出现了频繁改样式，重复机械行为。 ​ 如果有了低代码平台 流程可以变成这样 ​ 这样的架构中权责变的更加清晰，开发者从“螺丝钉”变成了技术解决方案开发者 ​ 而业务的决定权也掌握在专人手中；大家各司其职，技术根据实际需求不断优化技术解决方案，运营使用低代码平台的搭建能力 物料能力也能提高运营的效率。 H5装修常见方案​ 据作者了解，目前市面上所有的低代码平台几乎都是基于Schema进行实现的，这种方案的核心原理比较简单 ​ 基于这样的Schema结构，便衍生出来了多种实现方案，在这里简单描述一下我在实际工作中都使用过方案以及他们的优缺点； 绝对定位方案​ 简介：所有的装修组件都是再后台直接拖拽放置，没有组件群组的概念，可以任意放置你的组件到任何地方。 ​ 优点：灵活 ​ 缺点：无法流式布局，需要维护公共组件库，操作门槛较高，需要通过技术能力填补，例如吸附辅助线。 流式布局方案​ 简介：装修组件遵循流式布局，从上到下从左到右进行排序，就像搭积木一件，这种方案仅限移动端 ​ 优点：操作简单 ​ 缺点：组件不够灵活，因为只能上下移动，想做到非常规布局比较麻烦，需要维护公共组件库 iframe方案​ 简介：将客户端通过iframe内嵌到装修管理端中，再通过postMessage进行项目间通信，客户端识别环境开启装修模式与后台进行实时通信 ​ 优点：不需要维护公共组件库 ，只需要维护客户端代码 ​ 缺点：客户端与管理端代码耦合严重 装修操作部分代码需要写在客户端中 流式布局 + 绝对定位方案​ 简介：为绝对定位组件增加一个流式布局的父级容器，让装修数据具备二级结构， ​ 优点：灵活 具备可生成代码的规范结构 ​ 缺点：操作麻烦，存在一定学习成本 ，需要维护公共组件库，相对其他方案多了一层结构，难度相对更加大 易动3选择的方案​ 在公司生产环境项目中，凭借易动v1.0的经验，我使用了流式布局方案，最初效果还是非常不错的，那时候没想到将公共组件发布到npm，两端项目公用组件的方案，后期组件改动频繁，出现了极大的维护问题，这迫使我寻找其他出路。 ​ 为了解决流式布局中一套组件，两套代码问题，在生产环境项目中实验性的使用管理端 + 客户端耦合的iframe方案，满足了公司的需求只需要维护一套代码，并且可以将Schema抽象出来应用到单页中，实现活动页装修，iframe装修方案在公司也是沿用至今，帮助公司搭建了200+的页面。 ​ 再后来，我准备重启易动项目，开发易动v2.0，我们在易动v2.0中实验性的尝试了流式布局 + 绝对定位方案，在开发之前普遍觉得这是一个天才的主意，同时具备流式布局与绝对定位方案的优点，而且易动v2.0开发技术中还存在类似易企秀的多页的需求，大概经过2个月的代码编写，最终发现还是我们的想法过于理想化，首先操作上就存在比较高的门槛，技术难度也很大，而且因为Schema结构复杂，后期代码难度也是几何级别的提升，最终我们PASS了这个方案。 ​ 在后面一段时间我一直在思考一个问题，也就是低代码的边界性，他应该做什么，他可以做什么，我们如何通过低代码来创造产品价值，在不断的思考中我也逐渐明确了开发方向，不再去想他还能做什么，而是在开发之前就确定一个目标，易动3.0将会在营销领域发挥它的作用，所有的功能都围绕这个核心目标 ​ 基于这样的目标，易动v3.0再出发，依旧采用绝对定位方案，因为绝对定位方案符合需求，难度最小，具备拓展性，后期维护性更强。 ​ 方案确定好了，接下来将会介绍一些核心的实现思路。 核心实现思路Schema的编写​ schema的结构将会决定你的装修系统的上限，一个良好的设计结构将会为后面的开发降低很大的难度，我们需要定义好页面的结构与组件的结构。 ​ 而在代码中增加组件，或者增加组件类的数据，例如在轮播图组件中增加一项轮播图，都需要通过函数return的方式进行对象创建，以免出现多个组件使用的数据为一个数据源。 在项目中增加一个组件，只需要将组件Schema push到模板变量中即可 代码位置：https://github.com/vkcyan/YD/blob/main/src/modules/component/index.ts 123456789101112131415161718192021222324252627282930/** * 组件信息列表 * @param name 组件名称 * @param tempLen 本次层级 * @returns */function baseComList(name: string, tempLen) &#123; const list: baseComponent[] = [ &#123; id: guid(), name: &#x27;y-img&#x27;, showTitle: `图片$&#123;tempLen&#125;`, // 显示组件名称 show: true, cssModule: &#123; ...absolute(tempLen), ...borderData(), ...compSize(100, 60), &#x27;background-color&#x27;: &#x27;#ffffff00&#x27;, &#125;, // 样式 staticData: &#123; imglUrl:&#x27;xxxx.png&#x27;, ...linkData(), &#125;, // 行为 function: &#123;&#125;, // 方法 animation: [], // 动画 &#125;, // ..... ] return list.find((e) =&gt; e.name == name)&#125; ​ 例如增加一个图片组件，我们只需要将参数’y-img’，传入函数，即可得到一个图片组件的Schema，这样我们便具备搭建页面Schema树的能力。 实现拖拽 实现良好的拖拽是一件非常有难度的事情，它不仅仅是简单元素的移动，而是通过技术的手段降低装修的操作门槛。 元素位移​ 在易动v3.0中，弃用了以往采用的监听鼠标单次移动距离实现方案，因为这会导致快速移动后出现坐标不准确的情况，改成获取相对父级绝对坐标。 ​ 全局鼠标监听使用vueuse的useMouseInElementAPI，帮助我们获取每次的相对位置，鼠标按下同时保存元素下标，再通过watchEffect全局监听useMouseInElement的变化，拿着鼠标按下阶段保存的下标去寻找需要位移的元素，不断更新其Schema中的cssModule字段中的top与left值，进而实现元素移动。 元素缩放 ​ 我们为元素增加 上 下 左 右 左上 左下 右上 右下，八个操作点，是元素支持任意缩放功能，再点击任意缩放点的时候，我们都会保存一个标识，来确定当前点击的点是什么，然后在 全局监听鼠标移动的watchEffect中执行对应缩放逻辑，来不断更新选中的元素的 top left width height的组合值，进而实现元素缩放功能。 元素多选 ​ 支持元素位移与缩放其实已经完成了装修的最核心功能，已经可以完成简单的页面搭建了，但是仅凭位移与缩放操作起来不方便，这时候就需要开发多选功能，我们把之前保存的单个选中下标改成一个选中数组。 ​ 这里说明一下为什么保存数组下标，而不是组件的唯一id，这是一个时间复杂度的问题，如果保存组件唯一id，更新组件数据就需要通过循环再找到下标，进而通过下标更新数据，这时候时间复杂度为On，而直接保存数组下标，在通过下标直接更新数据，时间复杂度为O1。 ​ 回到正题，我们开发一个选中框组件，在拖动选中框的时候判断是否包含了组件，不断更新当前选中框多选的元素，进而实现多选删除，多选拖动，等等多选功能。 ​ 目前多选框计算逻辑还比较单一，仅支持从左上向右下拖动，后续有时间会继续完善。 辅助线 ​ 辅助线是低代码系统必备功能，这将会极大的降低使用门槛，实现辅助线相对来说也是非常复杂的，假如页面有4个组件，我们点击了任意一个的时候，就需要去保存其他3个组件的 top top + height/2 top + height left left + width/2 left+width，并且将其数组保存成为字典结构，也就是ES6的Set，相对数组实现可以将时间复杂度从On2降低到On，有效避免了卡顿的情况，在被选中元素不断拖动的时候，我们会不断对比当前变化坐标与之前保存的3个组件的坐标，一旦对比到了一致，就会将其值push到存储变量，并在页面上显示，表明已经对齐。 辅助线吸附​ 先声明一下，辅助线吸附作者的实现还存在瑕疵，目前还在寻找更好的方案，也希望有大佬可以指点一二，目前吸附还存在一点操作上的不流畅情况，所以这部分我便不多赘述。找到最佳解决方案再更新。 时间旅行 pinia的subscribes存在差异，并且events在生产环境无法获取，导致现在线上无法相关使用 ​ 所谓时间旅行就是可以进行撤销 反撤销操作操作，，具体原理感兴趣可以看看vuex版本的实现，本质原理都是一样的，基于vuex实现 撤销 与 反撤销 的plugins，采用数组 + 单指针进行实现。 more​ 移动端如何读取schema，使其还原装修效果；如何实现二次编辑组件的保存到创建市场；还有很多拖拽细节的实现；章节有限，这里不再一一赘述，有兴趣可以加入微信群在一起聊聊。 基础组件or业务组件 基础组件：按钮 图片 输入框 文字 模块（html自带的标签元素） 业务组件：富文本 轮播图 若干营销组件（由开发人员定制化产出的标签元素） ​ 在早期开发低代码，无代码产品的时候，我将绝对定位方案与基础组件绑定，业务组件与流式布局绑定，随着对低代码的深入理解，我在这里必须纠正之前的偏见，正确的观点应该是：基础组件 + 绝对定位方案更加和谐、业务组件 + 流式布局方案更加和谐。 ​ 随着将装修组件发布成为npm包，他们的隔阂已经几乎不存在，全部视为公共组件，公共npm组件包中将会抹平平台差异，任何可以描绘的组件可以看作为静态结构组件都可以被低&#x2F;无代码平台使用。 关于低代码​ 这几年关于低代码讨论也非常多，最近一直看到大厂开源的低代码工具，例如腾讯的tmagic-editor，阿里的LowCodeEngine，还有5月28号掘金直播低代码的探索与实践，其背后是前沿开发者们对效率的思考，是从局部效率转变到全局效率思想的转变。 ​ 在技术条件有限的情况下，低代码产品的广度与深度只能选择其一，我们自然希望低代码可以做的事情越多越好，生成页面，生成代码，直接编写事件，支持单页，支持多页，支持无限嵌套dom，达到降低门槛，提效降成本的作用，甚至解放劳动力，创造更大的社会价值，但是如果没有足够的技术基础，做的功能越多，就死的越惨。所以如果你也发现存在类似需求，切勿在产品设计期间不断加功能，要专注细分领域，只有这样，低代码项目才有发光发热的机会，有了经验之后再决定做什么也不迟。 ​ 从发现需求到明确定位有很长的路要走，低代码产品从可用到好用还有很长的路要走。 其他问题为什么易动v3.0选择绝对定位方案​ 易动v3.0考虑到营销页面的多样化，他并不是理想化的流式布局，而是多样化的，甚至你意想不到的UI实现方式，这也是易动v3.0使用绝对定位方案实现的一个重要原因，后续作者也会不断加强可用性，进一步降低搭建门槛。贯彻技术为业务服务，而不是业务为技术服务的理念。 为什么使用serverless​ 做出这个决定处于两点考虑 大部分公司不会使用node作为服务端框架，接入会重写服务端。 本人是前端工程师，node 以及服务端周边服务不算精通，低代码的项目核心也不在服务端，serverless满足了作者的需求，后续我会提供表结构，以及关联关系。 因为腾讯云serverless已经开始收费了，后续可能会换成fastify进行服务端编写，主要看作者是否有时间，也非常欢迎有志之士为开源做出贡献。 关于PC端​ 易动3的实现方案是绝对定位方案，这让实现pc端装修的可能性，但是个人感觉这部分需求比较小，B端的客户都是ToC，所以并没有做相关功能开发，但是理论上可以实现的。 后续还会做什么 目前易动v3.0 并不是完整状态，因为作者比较忙碌，很多功能依旧在开发中，大家也可以提出需求，如果存在价值，作者会加入后面的工作计划。 数据分析能力：页面的曝光情况是客户非常关心的指标，这也是易动v3.0非常关注的功能 模板市场功能：物料市场也是低代码平台非常重要的功能，配合组件市场，实现团队资源最大化利用，降低搭建门槛 丰富业务组件：根据客户需求开发其满足业务场景的组件，达到一次开发，多次使用的效果 增强装修能力：组件旋转，多选组件辅助对齐，搭建页面快捷操作，进一步降低大家门槛 最后​ 这个开源项目将会一直做下去，未来可能也会尝试做收费版本，毕竟为爱发电还是过于理想化了，如果你也是同道中人或者有这样的潜在需求，可以加入微信群，一起交流学习，共同进步~ 讨论群","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"},{"name":"低代码","slug":"低代码","permalink":"https://bluedancers.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"h5装修","slug":"h5装修","permalink":"https://bluedancers.github.io/tags/h5%E8%A3%85%E4%BF%AE/"},{"name":"Vue3","slug":"Vue3","permalink":"https://bluedancers.github.io/tags/Vue3/"}]},{"title":"关于免登录的一些实践与思考","slug":"项目解决方案/针对免登录的一些实践与思考","date":"2022-05-23T16:00:00.000Z","updated":"2022-12-11T13:51:24.095Z","comments":true,"path":"2022/05/24/项目解决方案/针对免登录的一些实践与思考/","link":"","permalink":"https://bluedancers.github.io/2022/05/24/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E9%92%88%E5%AF%B9%E5%85%8D%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"前言​ 听用户说，但是不要照着做。 ​ 这句话来自苏杰的《人人都是经理》这本书；在产品维度我们遵循这样的原则，其实在程序维度，也需要遵循这样的原则，如果没有意识到这一点我们也许会深陷泥潭。 案例：免登录到商品详情页面聊一个我们之前遇到的问题，场景是这样的 用户在第三方平台登录，用户登录后点击商品会免登录到我们商城 跳转过来后，我们商城需要完成免登录操作，服务端同时给用户发放优惠券，在这个过程中必须保证通过免登录进入后同步调用登录 发券 获取商品详情接口顺序。 ​ 场景就是这么简单，似乎并不是太难的问题，于是我们将我方的商品详情URL给对方，对方在URL后面拼接token，web端拿到token之后将token给后台，完成登录 发券 获取详情逻辑，流程图如下 ​ 按照我们上面的思路似乎没啥问题，无非就是用Promise控制代码顺序，但是在逻辑达到一定复杂程度后，这个问题就会变的非常棘手。 问题：非业务逻辑与业务逻辑的耦合​ 本质上来说，从第三方平台免登陆到我们商城中，并不属于购买商品逻辑，那就不应该将其逻辑写在商品详情页中 ​ 况且这必须同步，用户没有完成我们这边的登录逻辑之前，我们不能发起商品详情接口，因为我们的商品详情数据包括用户最新的优惠券信息，如果异步，就会出现用户第一次进入是没有券的情况；这样的规则就导致我们需要对商品详情页面的业务逻辑进行改动。 ​ 在这样的不安中，我们修改了商品详情页面的生命周期逻辑，一旦检测到需要免登录就会先执行登录再执行商品详情的获取。 ​ 后续又多次出现了其他平台免登录到商品详情页面，并且流程都不太一样，最终导致了我们的商品详情页生命周期代码凌乱不堪，异步流程难以维护，甚至会出现逻辑相互冲突的情况。 问题2：封装问题​ 最后我们商城对接的免登录越来越多，慢慢的我们便在逻辑层面进行了封装，但是依旧还是要动具体页面生命周期代码，而有些页面比如首页就存在很多第三方平台登录进来的，在生命周期代码中就出现大量的来源判断用来调用我们封装好的免登录逻辑，并且有些第三方还是具备时效性的，虽然我们在技术层面已经尽力，但是开发起来依旧很别扭，尤其是对于频繁需要维护的模块。 解决方案​ 再后面遇到这样一件事情，存在一个第三方商城免登录到我们的任意页面，听到需求的时候，我内心有点凌乱，因为我们目前免登录逻辑都是一对一的针对单个页面 ​ 最开始我们聊了能否在nginx中进行统一拦截，后面觉得性能很差，也有种走进死胡同的感觉，后台后端同事提出一个方案，这是一个技术上微不足道，但是却非常好的解决这个问题的方案。 ​ 我们将免登录的封装维度从单个逻辑的角度，提升为在对方跳转到我们目标页面中间的一层拦截 举个例子 ​ 原本 www.abc.com/goods/index?token=xxxxx，我们在具体页面中处理 ​ 最新 www.abc.com/autoLogin?sc=xxx&amp;redirectUrl=www.abc.com/goods/index&amp;token=xxxxx 如果redirectUrl存在参数一定要将该参数encodeURIComponent处理以下，以免参数解析异常 这样做有三个优点也有一个缺点 优点一：非业务逻辑与业务逻辑的耦合的问题，将免登录代码与业务代码完美的隔离开了，不论有多少，多个性化的免登录场景，都不会影响被跳转页面的逻辑 优点二：不再需要逻辑封装，直接将与服务端交互的代码写在该页面即可，因为他已经与业务逻辑解耦合了 优点三：可以形成对接规范，降低开发对接门槛，以及出现问题的可能性。 缺点一：对于用户来说需要多跳转一层页面，有可能需要多等待20-100ms。这一点就要看取舍了，我们是单页应用，站内跳转很快，从线上效果来看对用户影响很小，几乎忽略不计。 总结​ 回头看优化后的实现方案，其实技术难度非小，如果把需求说明白了，这是一个大学生都能写好的需求，这样一个毫无技术难度的方案，在项目中却完成让人非常头疼的部分非业务逻辑与业务逻辑的解耦合。 ​ 虽然作为一名开发人员，我们的本质工作就是实现需求，但是实现需求并不代表别人怎么说你就怎么做，而是根据需求加以自己的思考，在非开发角度提供自己宝贵的建议，也许，换一种思路，一个非常复杂的需求就会变得如此简单。 ​ 现在让我们回到文章开头的那句话，听用户说，但是不要照着做，是不是有点感悟了。","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"关于C端","slug":"关于C端","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8EC%E7%AB%AF/"}]},{"title":"上瘾模型如何应用到产品","slug":"NPDP产品经理/上瘾模型如何应用到产品","date":"2022-05-22T16:00:00.000Z","updated":"2024-03-25T08:01:07.960Z","comments":true,"path":"2022/05/23/NPDP产品经理/上瘾模型如何应用到产品/","link":"","permalink":"https://bluedancers.github.io/2022/05/23/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E4%B8%8A%E7%98%BE%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E5%88%B0%E4%BA%A7%E5%93%81/","excerpt":"","text":"前言​ 为什么有些产品有抓住我们的注意力，而其他产品却不能？是什么让我们出于习惯而建立与产品的联系？是否有一种潜在模式能够通过技术将用户紧紧吸引，欲罢不能。 ​ 这是《上瘾》的引言，我相信看到上面这些话的时候，你的脑海中一定出现了让你上瘾的产品，比如抖音，这样现象级的产品是如何被设计出来的呢？《上瘾》通过大量实验案例，社会调研，总结并抽象了用户上瘾的产品设计原则。最后提炼出一个通用模型，掌握这样的通用模型，你就会得到一个产品设计框架。 当你从0到1设计产品的时候，或者分析市面上的产品，你就可以将上瘾模型应用到你的产品。 上瘾模型是什么触发 行动 多变的奖励 投入 触发 内部触发​ 内部触发是用户与产品建立的感情链接，不需要被打广告，不需要被通知，我主动去使用，就好像短视频APP，没有给我钱，也没有被推广，但是我们每天都高频使用，内部触发是给予用户情感的满足，让产品融入到了生活，是用户内心真实情感的触发，获得快乐、认同与安慰，具体类型会在行动中说明 下班后无聊，打开短视频APP 自拍几张照片，发布到社交平台 ​ 这就是发生在我们身边的日常，我们选择某个产品是因为它能够为我们带来快乐或者解决烦恼，这就是为什么说要洞察用户的用户需求，而内部触发就是研究用户需求，而且是最深处的情感需求 ​ 所以常说做产品是发现用户需求，要去思考，我们的产品能够为用户解决什么问题，这自然是需要深入了解用户的痛苦与挣扎，然后设计出给予用户安慰的产品。 外部触发指用户在非主动情况下接收的信息，有清晰的动作指令进行行动召唤 付费型触发：电梯广告 APP中推广 回馈型触发：某某软件因为做的好，被APP Store上了推荐位 人际型触发：小明觉得某个软件特别有意思，推荐给小红 自主型触发：小明毕业了需要找工作，下载了一个BOOS直聘 ​ 一般会采用简单重复或者“经典+创新”的方式来完成外部触发，效果更加好，例如蜜雪冰城 还有很多老歌+新词的电梯广告 行动 ​ 用户完成触发后，就会来到产品中，让用户开始使用产品就是行动，而长时间高频率的行动才能养成用户习惯 用户行为模型公式：行动 &#x3D; 动机 * 能力 *触发 ​ 如果一个用户想完成一个行动，这三者是缺一不可的。例如，周末你打算找你朋友开黑王者荣耀，但是朋友突然有事，你放弃了周末打王者 动机：渴望快乐 能力：有手机 有网络 有时间 触发：和朋友一起玩做王者荣耀 然后因为朋友突然放弃了，缺少触发条件，放弃 亦或者网络太差，缺少能力，放弃 亦或者由于某种突发紧急事件，没心情去体会游戏里面的快乐，缺少动机，放弃 动机能够驱使用户采取行动的核心动机无非就是以下三种 - 追求快乐，逃避痛苦 - 追求希望，逃避恐惧 - 追求认同，逃避排斥 ​ 补充：相对与失去快乐，人们更加害怕痛苦，就像捡到100块钱，你会很快乐，但是你丢失一百块钱，你会非常痛苦，这远比捡到100块情绪更加激烈，这在产品中常常表现为厌恶损失心理 能力能力是行动的门槛，福格教授提出六要素 - 时间：完成这件事情需要的时间 - 金钱：从事这件事情需要的经济投入 - 体力：完成这件事所消耗的体力 - 脑力：完成这件事所消耗的脑力 - 社会偏差：他人对这项活动的接受度 - 非常规性：该活动与常规活动的匹配程度或矛盾程度 ​ 一个行动需要的能力越少，用户就越轻松使用你的产品，所以我们反复强调降低用户使用门槛，从而减少因为能力问题而造成的流失 多变的奖励 ​ 用户通过触发进入产品，并做出了行动，但是如果用户在你的产品中没有得到物质或者精神的奖励，用户自然会离你而去 猎物奖励​ 猎物奖励就是获取自己想要的资源，刷抖音，寻找带来满足的视频，刷知乎，发现自己感兴趣的问题与回答，这就像原始人类追逐猎物一样，抓住他会充满获得感的 社交奖励​ 社交奖励即为被认同，被赞美，被尊重，人类是情感动物，对社交奖励非常上瘾，会陶醉到社交带来的快乐中，这是及其有效的奖励方式，所以社交类产品经久不衰的原因，他的本质是获得一种社会认同 自我奖励​ 自我奖励主要为使用产品时候的成就感，满足感，控制感。比如你喜欢收集手办，没人让你收集，收集了也没钱，但是让自己快乐了，同时找到了志同道合的朋友，我把我的手办发布到社区，被点赞，被评论这就很快乐，还有例如蚂蚁森林浇水，这都会带来内心的满足，从而实现自我价值 多变性​ 灵长动物大都喜欢新奇的东西，一件事情，如果已经经历过很多次，再次经历将会失去兴趣，你的大脑不会获取快乐，因为你已经可以预感到下一步的行动，预感到你将会得到什么，大数据精准推荐、千人千面都是为了满足用户喜欢新奇的心理 ​ 如果某一次刷新知乎，推荐的都是你看过的或者不感兴趣的问答，那你自然不会上瘾，反之，如果你总是给用户带来新奇感，用户必定会进行更多的行动，来获取更多奖励，所以多变性是奖励的核心概念 ​ 最后补充一点，除了让用户经常获得奖励之外，让用户在第一次接触你的东西就有一个好印象也是关键点，例如首次打开小红书，QQ，他的登录背景视频是美好切令人向往的，让你感受到产品倡导的价值，如果恰好这也是你向往的，这个产品毫无疑问会吸引了你的注意力，你将会继续使用他 投入 ​ 想象一个简单的场景，小明经过朋友推荐下载了王者荣耀，玩了1年时间，在游戏中达到了王者段位，期间在王者荣耀中购买了大量付费皮肤，同时认识了游戏好友；这时候出来了另一个竞品，不比王者荣耀逊色 ​ 但是该竞品想吸引小明，难度是极大的，因为小明已经在王者荣耀中投入太多，时间，皮肤，游戏好友，对局资料，绝活英雄，这都会让小明无法脱离。 ​ 投入是上瘾模型闭环的最后一步，当用户通过触发，采取了行动，并获得了奖励，这时候如果能让用户进一步进行投入，那么这个产品在用户心中的地址将会达到顶峰 内容​ 在微信上添加好友，添加群，这都是内容，随着使用的时间越长，你就会越离不开微信，让你换掉微信，那真的比登天还难 数据资料​ 以作者为例子，作为一名前端开发者，我的开源代码都存放在GitHub，随着我工作年限越长，我越舍不得离开GitHub，我的大量资料都在github中，对我而言，他有很高的价值 关注者​ 小红是一位大厂产品经理，通过长期在知乎发表高质量文章获得了20w关注，随着人数的变多，小红将会越来越离不开知乎，微博，小红书 B站社区都是这样，关注者对于当事人来说是不可忽视的隐形价值 信誉​ 小明觉得咸鱼不错，经常在咸鱼上售卖一些东西，你已经售卖一些东西，在未来会越来越关注你的信用情况，你就会花更多的经历去经营他 技能​ 以我自己举例子，学习编程的时候，使用的是vscode（编程开发软件），至今我已经使用了5年，已经对他产生了依赖，通过他学会了编辑技能，投入了很大的时间成本，学习成本，尽管竞品某些细节更好，但者依旧很难让我行动起来去换掉vscode 总结​ 至此我们走完了上瘾模型，我们回顾一下，首先通过外部或者内部触发来让用户进入行动阶段，在行动中给予用户多变的奖励，最后让用户不断投入，时间，金钱，内容，或者资料，也可以为用户到来价值 信誉 关注这，经过这样的闭环后，用户将会越来越依赖你的产品 ​ 似乎这个模型很棒，是一个值得思考的方法论，但是一个有价值的产品是一切的前提，如果产品没有挠到用户痒点，或者本身就是伪需求，那上瘾模型也无济于事，他不是救命稻草，而是锦上添花，让你的产品变的更加好。 ​ 屏幕前的你此时此刻是否脑海中已经想到了很多，或者是对产品的理解，或者是对你正在进行中的项目产生了新的想法；后续内容提供了基于上瘾模型的产品设计模板，通过这样的模板可以分析别人的项目，也可以构建你准备开发或者正在进行中的项目 将上瘾模型应用到产品中以内部触发为起点​ 如果一款产品无法让用户内部触发，这就意味着用户感知不到其价值，产品的本质是满足客户需求，帮助用户解决问题；在这阶段我们需要研究、定位我们的客户群体，提炼特性，描述用户画像，通过丰田5Why法，深入了解用户的核心诉求，保证内部触发的合理性 设计多变的奖励​ 一款产品可以为用户带来什么？这是极其重要的问题，我们通过内部触发确定我们的用户群体，下一步就需要思考给予用户什么奖励，猎物奖励更好，还是社交奖励更好，同时要在奖励环节中贯彻多变性原则，这里再次强调：多变性是奖励的关键 注：如何给用户第一次良好的体验，让用户感知到价值，引导其内部触发，这也是关键的一环，其中越是生命周期短的产品，首次的啊哈时刻（一个用户对产品感知最强的点）必须要越早出现 用户可以投入什么​ 用户可以在你的产品中生产什么样的内容，数据资料，还是关注者，找准类型，同时要研究用户心理，找到用户可能想投入的实际，再引导用户去完成 利用外部触发推广​ 上瘾模型一旦形成，便需要源源不断的用户进入其中，这里可以根据自身的产品类型来选择外部触发方式，例如自身有钱，可以付费完成触发，或者通过社群进行人际型触发，具体触发方式需要根据产品特性来决定 重复测试迭代优化​ 当用户进行上瘾模型，并产生依赖之后，我们就需要不断检查每个环节是否符合预期，是否存在短板，根据实际数据进行测试，并进行优化迭代，不断完善上瘾模型 对抽奖助手小程序的上瘾模型分析 参考资料参考文章：http://www.woshipm.com/pd/5386132.html 参考书籍：上瘾：让用户养成使用习惯的四大产品逻辑 尼尔·埃亚尔 瑞安·胡佛","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"产品日常","slug":"产品日常","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E6%97%A5%E5%B8%B8/"}]},{"title":"Vue + webpack项目的移动端适配","slug":"技术类文章/vue项目使用vw进行移动端适配","date":"2022-05-19T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2022/05/20/技术类文章/vue项目使用vw进行移动端适配/","link":"","permalink":"https://bluedancers.github.io/2022/05/20/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8vw%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","excerpt":"","text":"2022-5-20更新技术栈：vue3 + webpack5 安装插件1npm i postcss-px-to-viewport -D 增加配置新建配置文件postcss.config.js 1234567891011121314151617181920212223module.exports = () =&gt; &#123; return &#123; plugins: &#123; autoprefixer: &#123;&#125;, &quot;postcss-px-to-viewport&quot;: &#123; unitToConvert: &quot;px&quot;, // 需要转换的单位，默认为&quot;px&quot; viewportWidth: 750, // 设计稿的视口宽度 unitPrecision: 5, // 单位转换后保留的精度 propList: [&quot;*&quot;], // 能转化为vw的属性列表 viewportUnit: &quot;vw&quot;, // 希望使用的视口单位 fontViewportUnit: &quot;vw&quot;, // 字体使用的视口单位 selectorBlackList: [&quot;.ignore&quot;, &quot;.hairlines&quot;, &quot;.ig-&quot;], // 需要忽略的CSS选择器 minPixelValue: 1, // 最小的转换数值，如果为1的话，只有大于1的值会被转换 mediaQuery: false, // 媒体查询里的单位是否需要转换单位 replace: true, // 是否直接更换属性值，而不添加备用属性 include: undefined, // 如果设置了include，那将只有匹配到的文件才会被转换，例如只转换 &#x27;src/mobile&#x27; 下的文件 (include: /\\/src\\/mobile\\//) landscape: false, // 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape) landscapeUnit: &quot;vw&quot;, // 横屏时使用的单位 landscapeWidth: 568, // 横屏时使用的视口宽度 &#125;, &#125;, &#125;;&#125;; end以下配置已经过时，请看最新内容 需要安装一下的插件 1npm install postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano cssnano-preset-advanced postcss-import postcss-url --S postcss.config.js配置 123456789101112131415161718192021222324252627module.exports = &#123; plugins: &#123; &#x27;postcss-import&#x27;: &#123;&#125;, &#x27;postcss-url&#x27;: &#123;&#125;, &#x27;postcss-aspect-ratio-mini&#x27;: &#123;&#125;, &#x27;postcss-write-svg&#x27;: &#123; utf8: false &#125;, &#x27;postcss-cssnext&#x27;: &#123;&#125;, &#x27;postcss-px-to-viewport&#x27;: &#123; viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: &#x27;vw&#x27;, // 指定需要转换成的视窗单位，建议使用vw selectorBlackList: [&#x27;.ignore&#x27;, &#x27;.hairlines&#x27;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 0, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换`px` &#125;, &#x27;postcss-viewport-units&#x27;: &#123; filterRule: rule =&gt; rule.nodes.findIndex(i =&gt; i.prop === &#x27;content&#x27;) === -1 &#125;, cssnano: &#123; preset: &#x27;advanced&#x27;, autoprefixer: false, &#x27;postcss-zindex&#x27;: false &#125; &#125;&#125;; 这里注意假如生成的项目里面没有.postcssrc.js 说明写在package.json里面,记得把package里面的部分配置删除 12345&quot;postcss&quot;: &#123; &quot;plugins&quot;: &#123; &quot;autoprefixer&quot;: &#123;&#125; &#125; &#125;, 最后在index.html里面进行引入viewport-units-buggyfill解决兼容问题 123456&lt;script src=&quot;//g.alicdn.com/fdilab/lib3rd/viewport-units-buggyfill/0.6.2/??viewport-units-buggyfill.hacks.min.js,viewport-units-buggyfill.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; window.viewportUnitsBuggyfill.init(&#123; hacks: window.viewportUnitsBuggyfillHacks &#125;); &#125; &lt;/script&gt; 注意如果遇到图片无法正常显示 1.img图片不显示： 全局引入 123img &#123; content: normal !important;&#125; 2.与第三方UI库兼容问题： 使用postcss-px-to-viewport-opt，然后使用exclude配置项，具体参考 Vue+ts下的移动端vw适配（第三方库css问题）","categories":[{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://bluedancers.github.io/tags/vue3/"},{"name":"webpack5","slug":"webpack5","permalink":"https://bluedancers.github.io/tags/webpack5/"},{"name":"响应式","slug":"响应式","permalink":"https://bluedancers.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"vw","slug":"vw","permalink":"https://bluedancers.github.io/tags/vw/"}]},{"title":"NPDP产品经理国际资格认证","slug":"NPDP产品经理/NPDP产品经理介绍","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.076Z","comments":true,"path":"2022/03/18/NPDP产品经理/NPDP产品经理介绍/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"产品经理与项目经理对比 内容 产品经理 项目经理 职责 发现并定义范围 执行并交付范围 范围 对产品整个生命周期负责 阶段性对项目负责 角色 母亲，定义目标，发布计划，然后在生命周期的各个阶段继续培育产品 像家庭教师，一直待在产品旁边，帮助产品成长，让他最后成为产品满意的样子 主题知识组合管理 新产品开发战略 新产品流程 产品生命周期管理 文化，组织与团队 工具与效绩度量 市场研究 知识点分布新产品流程 20% 新产品开发 20% 组合管理 10% 产品生命周期管理 10% 市场研究 10% 工具与绩效度量 20%","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"工具与绩效度量","slug":"NPDP产品经理/工具与绩效度量","date":"2022-03-17T16:00:00.000Z","updated":"2022-12-11T13:51:24.077Z","comments":true,"path":"2022/03/18/NPDP产品经理/工具与绩效度量/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%BB%A9%E6%95%88%E5%BA%A6%E9%87%8F/","excerpt":"","text":"9种创意工具 名称 内容 SCAMPER 特别是在生产改进现有产品，产生新的产品的想法上很有帮助，SCAMPER是一些行为东西的首字母缩略词。又叫奔驰法 奔奔法S：替代 C： 合并 A：改造 M：调整 P：改变用途 E：去除 R：逆向操作 头脑风暴 在群体决策中，由于群体成员心理相互作用影响，易屈于权威或大多数人意见，形成“群体思维”。群体思维削弱了 思维导图 在各种信息或创意之间建立思维链接的图形化技术。首先，讲一个关键字或者短语写在一页纸的中间，然后，从这一中心点触发，将其与不同方向的新创意连接，从而建立起网络式思维关系","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"文化、组织与团队","slug":"NPDP产品经理/文化、组织与团队","date":"2022-03-17T16:00:00.000Z","updated":"2024-03-25T08:00:46.663Z","comments":true,"path":"2022/03/18/NPDP产品经理/文化、组织与团队/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E6%96%87%E5%8C%96%E3%80%81%E7%BB%84%E7%BB%87%E4%B8%8E%E5%9B%A2%E9%98%9F/","excerpt":"","text":"文化定义​ 组织中人们共同拥有接受的信念、核心价值观、行为准则、思维方式、假设与期望 示例 反应组织的价值观，彰显与习惯、仪式、典礼、故事、英雄榜样 指出如何完成工作 表达生存力，即为了活下去我们应当做些什么 文化是否正确取决于组织本身​ 一个组织中运作良好的文化可能对于另一个组织是完全错误的 成功的创新文化具备的共同特点 清晰的方向和目标 鼓励尝试 个人绩效与组织绩效密切相关 契合创新文化是招聘标准之一 鼓励内部和外部的有效沟通 鼓励建设性冲突 让工作尽可能愉悦有回报 氛围定义​ 是员工可直接或者间接感知到的工作环境特点的集合，对员工的行为有重大的影响 示例 领导人水平、沟通、责任、信任、公平的认可与回报、机会，员工参与 新产品开发中的管理者角色战略纬度 管理内容 角色与职责分配 使命愿景、价值观 整体的企业愿景、使命价值观是由公司高管以及关键职能部门的负责人一起指定，在董事会层面通过 业务战略 通常由某个特定的业务单元的执行团队指定（有歧义） 职能战略 职能部门负责人以及高管团队定制 产品战略 高级产品经理（高级产品副总裁，首席产品官等）指定 创新战略 跨职能团队的高级经理定制，由一位董事会成员领导 流程纬度 角色 管理内容 流程拥护人process champion 负责推动组织内正式商业流程的日常工作，对流程进行调整、创新和持续改进 类似考委会，负责定制和改进考试规则 流程主管process owner 对新产品开发流程的战略性结果，包括生产能力、输出质量和组织类的参与度负责的执行经理，敏捷中由PO和敏捷教练来负责 类似巡场老师，负责监督规则的执行效果 流程经理process manager 确保流程中的创意和项目按时有序进行的运营经理。有时被成为业务流程经理或者工艺经理 类似监考老师，负责规则的按时有序执行 项目经理project manager 采用组织认可的流程，负责管理特定的产品开发项目 类似班主任，组织学生按规则试试考试项目 组织与团队 职责 说明 建立文化氛围 组织的文化和氛围由最高层管理者领导，并受其影响 推动积极氛围 是职能经理和各个团队或项目经理的职责 团队开发 整体团队开发的责任由高级产品开发经理承担，包括：团队成员的选拔，高绩效团队的建立，气氛的保持 产品管理者的关键职责落实产品开发战略，跨职能合作。 职位 职责 首席产品官 先CEO回报，定制整体的产品战略，监控、管理好产品的营销与开发 高级副总裁 领导大型产品经理团队，与工程、销售、制造、营销职能的主要领导紧密配合工作，确保开发中的产品是正确的，且有助于实现公司目标 产品群经理 为负责某个产品群的产品团队提供指导，负责执行高级管理者指定的战略，领导跨职能团队 产品经理 对具体的产品和产品类别负责 产品经理 VS 项目经理 产品经理 项目经理 发现与定义范围（要做什么，做成什么样） 范围的执行与交付（执行并交付产品） 对产品整个生命周期负责 阶段性的对项目负责 团队领导者的角色和职责-高级管理者新产品开发中高级管理者角色为战略负责 定制企业级和事业群级战略的终极责任在于高级管理者 而包括产品研发战略在内的职能型战略定制的责任人在于职能部门负责人 高级管理者角色倡导者：项目倡导者并非团队的一员，可能是市场部或者是研发部的总经理，他们对项目充满了热情，有感染力，并且愿意为推进项目承担风险，能够帮助团队获得资源，帮助团队承担风险 发起者：提供项目所需的资源，总资源需求承诺以及优化配置，评估绩效，提供激励奖励，关口评审，运营规划等 引导者：帮助团队尽量减少官僚主义，突破繁文缛节的限制和其他组织壁垒，从而提高生产力 高级管理者任务方向引领者： 奖励公司战略 确保为新产品所做的一切努力是一致的 产品线缔造者 为理解目前及未来的产品线确立框架 定义产品类型 组合管理 确定项目设置 匹配项目容量、生产力 高级管理者总结 跨职能团队和矩阵结构组织结构类型​ 矩阵结构式一种组织结构，其中的汇报关系按网格或者矩阵奖励，而不按照传统的层级结构，换言之，一个员工具有双重的回报关系，通常是指职能经理和产品经理（项目经理）汇报 矩阵结构 团队类型 项目经理 上下级 团队成员 团队能力 适合的产品任务类型 职能型团队 无 有 分散 最弱 改进的，轻微的（支持型项目） 轻量级团队 有无实权 无 兼职 弱 派生的扩张产品线（衍生型项目） 重量型团队 有有实权 无（交叉） 临时专职 强 新领域，不确定，复杂的（平台型项目） 自主型团队 创业团队领导 有 专职 最强 全新的，长周期，高风险（突破性项目）","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"新产品开发战略","slug":"NPDP产品经理/新产品开发战略","date":"2022-03-17T16:00:00.000Z","updated":"2024-03-25T08:00:23.243Z","comments":true,"path":"2022/03/18/NPDP产品经理/新产品开发战略/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E6%96%B0%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E6%88%98%E7%95%A5/","excerpt":"","text":"战略定义：能够引向未来的一种方法与战略，例如，某个目标的实现路径或某个问题的解决方法 商业环境下的战略定义： 战略能够定义与传播一个组织的独特定位，说明应当如何调整组织的资源、技能与能力以获取竞争优势（波特，2008） 给予行业定位、机遇和资源，企业为实现长远目标而定制的计划（科特勒 2012） 经营战略的设计步骤 战略制定与执行责任人​ 整体的企业愿景和使命通常由公司高管团队以及关键职能部门（财务、营销、制造等）的负责人一起正式制定，这些内容在董事会层面得到了正式通过 业务战略：通常由某个特定的业务单元的执行团队进行制定 职能战略：通常由职能部门负责人及高管管理团队（财务，营销）进行制定 产品战略：通常由高级产品经理（如高级产品管理副总裁）进行制定 创新战略：同工厂由跨职能部门的高级经理制定，由一位董事会成员领导，他可能是创新副总裁，首席技术官或首席执行官 使命 愿景 价值观使命定义： 公司信念、哲学、目的、经营原则或者企业信仰的声明 目的：阐述企业为什么存在(Why)。为了凝聚公司能量与资源 案例： 发布创意 克服困难(3M公司使命) 愿景定义： 透过预见与洞察的现象，透过实际上的限制，借此想象出企业对于未来发展的可能性 目的：阐述企业要往哪里(Where) 案例： 设计各式精良，优异的家居用品，并且价格低到让许多人都买得起(IKEA宜家家居愿景) 价值观 参与的成员为了完成任务需要遵守的行为准则 一个人或者公司带来某种程度的情感来遵守一个原则 目的： 阐述企业的行为准则与价值观(How) 案例： 诚信正直 承诺 创新 客户伙伴关系(TSMC公司价值观) 四种创新战略框架波特战略框架波特将公司优势最终划分成为2个部分：成本优势与差异化 通过运营这些优势或宽或窄的范围，定义了三种通用战略 成本领先战略 差异化战略 细分市场战略 战略名称 特点 优势 劣势 例子 成本领先战略 吸引价格敏感性客户提升市场份额规模生产降低成本优化供应链 在价格竞争激烈市场中有保持竞争的方法 利润低降低成本影响质量导致客户流失 世界工厂，中国制造 差异化战略 聚焦较宽产品基础交付优质产品建立忠诚客户关系获取市场份额更关注产品品质和性能 利于建立客户忠诚度可以获得更高的利润率 必须持续创新，开发新产品吸引客户性能不好可能导致市场份额的大幅度下滑 星巴克苹果 细分市场战略 也称”聚焦战略”适用于狭小市场对市场有深入认识与独特见解 聚焦营销和新产品开发工作具备很高的竞争壁垒增加产品开发投入提高利润率 依赖单一狭小市场风险大新技术冲击 医美行业月子中心 迈尔斯.斯诺战略框架基于企业对于变更响应的研究，提供有用框架去描述产品开发战略方法 类型 动作 方式 探索者Prospector 首先上市寻求增长敢于冒险 开发和应用新技术借助快速上市，占领市场份额 分析者Analyzer 快速跟随产品通常更好 经常跟随探索型公司，开发模仿产品被称为”快速跟随者”新产品开发成本低 防御者Defender 在稳定市场中维护其市场份额 风险厌恶型，聚焦于狭窄的，稳定的市场与产品类别通常不具备技术进攻能力 反应者Eeactor 只有在遭遇威胁时才会有所反应 没有清晰的战略目标没有明确的技术开发计划和市场进入计划 持续式创新 VS 颠覆式创新持续式创新 不创造新的市场与新价值主张，致力于把现有产品做的更加好 从审美，功能，特性或成本角度关注产品变更和改进的渐进过程 颠覆式创新 克莱顿.克里斯坦森首次提出颠覆式创新的概念(1997) 有助于创建新市场与新的价值网络(价值主张) 初期关注小众有影响力的目标市场，该市场产品具有重要的新特性或功能，但是因为开发成熟度不够充分，还无法与现在已被广泛接受的产品竞争 初期在目标市场的影响力加上产品改进将会扩大市场，导致现有产品最终退出市场 促成和创造颠覆式影响的通常是一个商业模式，而非是一项技术 颠覆式创新不会一夜之间实现，而是逐渐发生的 皮萨诺战略框架 - 创新画布在技术与商业模式创新的两个方面有效分配精力和资源 其他战略库珀的战略 库珀是门径管理流程的奠基人，库珀的战略从技术和市场的角度来讨论 差异化战略： 与波特的差异化战略类似，提供高价格，高质量的产品，满足客户需求 高成本战略： 研发成本高，较少关注市场和客户需求 技术推动战略： 最新技术，高度创新想法，较少关注用户需求 保守战略： 低风险，有限研发投入，非差异化产品 非博弈战略： 与迈尔斯.斯诺的反应者战略类似 平台战略平台战略被定为为一系列子系统及其接口，由此可以建一个通用架构，继而高效的开发，制造出其延伸产品 优势： 快速，连续的推出一系列产品 鼓励从长期视角定制产品战略 能大幅度提升运营效率 公司与市场能清晰理解产品平台的底层要素 能带来巨大的差异化，使自身产品与竞争产品得以区分开来 技术战略技术战略是一份有关技术维护和技术发展的计划，这些技术能够支持组织的未来发展，有助于组织战略目标的实现 技术战略与经营战略和创新战略相连 技术预测方法 头脑风暴法 专家小组法 德尔菲法 (专家 匿名 多轮 趋向一致) SWOT法 专利分析法 趋势分析法 技术S曲线基本上显示了大多数技术的生命周期阶段 引入期 成长期 成熟期 知识产权战略知识产权： 智力制造出来东西，比如发明、文学、艺术、设计、符号、名称、商业用户图像的所有权；同其他产权一样可以出售，授权，交换或者被拥有者放弃；知识产权被法律保护，例如专利、版权和商标可以让所有人从他们的创造中获取荣誉和金钱回报。 知识产权的类型专利：在一定时间阶段生效的，由政府授权或许可的权利，特别指禁止他人制造，使用或者销售一个发明的所有权力 版权：一定年限内，给予原创者独家的，指定的法律权利，可以印刷，发行，制作 商标：代表公司、产品的经由法定注册或许可的符号，单词或者词组 植物品种权： 给予独家权力生产和销售某种可繁殖的植物 商业机密：和企业相关的保密信息 营销战略从业务目标到营销计划，其中包含业务目标、营销战略、公司组合、营销计划 市场营销组合4P产品Product：外观 功能 特色 质量 包装 支持 质保 品牌 促销Promotion：主题&#x2F;信息 社交媒体 公关 销售团体 商品展会 纸质媒体 定价Price：目录价格 折扣 捆绑销售 信用条款 渗透定价（低价占领市场） 撇脂定价（高价回收成本） 地点Place：渠道 库存 物流 实体分销 如何定价 无论何时何地，对产品经理而言必须明确点：总利润比市场份额、效率更加重要 维持低成本是产品的事情，维持高售价是运营的事情 降价是最昂贵的运营策略，而提价的效果未必会有想象中的糟糕 如何应对竞争对手的价格变化​ 某一家酒企的一款酒经过多年经营，在市场上占有率一度达到20%，后来竞争对手也出了类似的产品，比他要低1美元，这时候酒企应该进行价格竞争吗？显然这会导致自己总利润降低，这时候决策者决定，将这款酒提价1美元，同时出这款酒的不同包装的产品，可以理解为青春版，其价格更加低廉，以此与对手竞争，一方面提高了前者酒的地位，一方面拉低了对手的品牌力，使销售量增加，利润量增加 如何“忽悠”用户付费在一定得到3w 80%的几率得到4w，20%的概念得到0元面前，大部分用户会选择前者 在一定失去3w 80%的几率失去4w，20%的概念失去0元面前，大部分用户会选择后者 结论：人性在面对失去与风险的时候更加害怕失去 策略：不要告诉用户买了产品会得到什么，而是告诉用户不购买会失去什么 场景：儿童兴趣班 阅读到一半的付费阅读 营销理念的历史演变 4P - 4C - 4R 4P 产品导向 4C 顾客导向 4R 顾客忠诚度导向 产品（product） 顾客需求（Consumer） 关系（Relation） 促销（promotion） 便利性（Convenience） 反应（Respond） 价格（price） 沟通（Communication） 回报（Return） 分销（place） 成本（Cost） 关联（Relevancy） 产品三环靶核心利益：产品核心价值（不是有形物理属性） 有形性能：赋予产品外观和功能的物理和美学设计特征 附加性能： 产品提供的额外性能可以是免费的 产品描述FAB每个产品或者品牌都具备的三个要素 产品的F-A-B结构（总结每个产品的卖点，特点，优势和利益） 特点（Feature）：对产品本身的技术性解释，通常包含产品专业化词语 优势（Advantage）：由于产品本身的特性所导致的产品表现 利益（benefit）：与消费者的感受密切相关，由产品带给消费者的价值 基于感觉上的体验，往往是针对个人而言，相对的，类比的，定性的 采用FAB表述产品卖点示例 名称 特点（F） 优势（A） 利益（B） 海飞丝 富含最新丝源蛋白 头屑去无踪 秀发更出众 潘婷 含丰富的维他命原B5 能由发根渗透到发烧，补充养分 使他浦发健康，亮泽 飘柔 含丝质润发素 洗发洗护一次完成 令头发柔顺飘逸 为产品卖点塑造画面感（场景） 产品卖点 普通文案 有画面感的文案 耳机音质好 声声震撼，激发梦想 犹如置身音乐会现场 笔记本噪音低 创想极致，精心由我 闭上眼睛，感受不到电脑开机 工资辛苦，不如旅行 乐享生活，畅意人生 你写PPT时，阿拉斯加的鳕鱼正跃出水面 波士顿矩阵分析 商业画布主要内容与要点 亚马逊商业画布 能力战略能力来源能力要求 技术 营销 研发 内部来源 保持现有能力 获取新能力 重新培训，重新开发现有能力 外部来源 兼并或收购 合资企业 开放式创新 咨询 封闭式创新 VS 开放式创新 封闭式创新的基本原则 开放式创新的基本原则 本行业里最聪明的员工为我们工作 并非所有的聪明人都给我们工作，我们需要和企业内外部的聪明人合作 为了从研发中会哦你，我们必须自己进行发明创造，开发产品并推向市场 外部研发工作可以穿在巨大价值，而要分享其中的一部分，则必须进行内部研发 如果我们自己进行研究，就能最先把产品推向市场 我们不是非要自己进行研究才能从中受益 最先将创新商业化的企业将成为赢家 建立一个更好的商业模式要比贸然冲进市场好很多 如果我们创造出商业中最多最好的创意，我们必将胜利 如果我们能充分利用企业内外部的创意，我们必将胜利 我们必须控制知识产权，这样竞争对手就无从我们的创意中获利 我们应当通过让他人使用我们的知识产权而从中获利，同时应当购买他人的知识产权只要它能提升我们的商业模式 保持市场竞争优势的办法 如果在一个相对封闭的行业，应当着重发展内生优势，提升自身能力但产业融合与跨界合作兴起时，生态优势的重要性会特别明显 定位观​ 认为决定竞争优势的因素有两个，一是行业盈利能力，二是企业在行业中的地位。因此企业的盈利能力取决于其竞争战略选择，而竞争战略的选择则是：选择有吸引力、高潜在利润的行业并建立自己的优势竞争地位 资源能力观​ 认为企业在竞争优势产生与企业内部运作（组织过程，包括协调&#x2F;整合、学习&#x2F;重构与转变）、流程和当前所处位置，具有路径依赖性 生态优势观​ 认为在新技术应用层出不穷、产业环境日趋动荡、消费者对一体化解决方案的期望越来越高的背景下，产业边界逐渐模糊，跨界合作与价值共创成为潮流，他不仅仅关注自身的价值链还要重新定义和优化价值网上面的活动，管理好未拥有的资源 互联网思维“孤独九剑”剑谱 互联网+​ “互联网+”就是“互联网+各个传统行业”，但这并不是简单的两者相加，而是利用信息通信技术以及互联网平台，让互联网与传统行业进行深度融合，创造新的发证生态 ​ “互联网+”行动加护将重点促进云计算、物联网、大数据为代表的新一代信息技术与现代制造业、生产性服务业等的融合创新，发展壮大新兴业态，打造新的产品增长点，为大众创业、万众创新提供环境，为企业智能化提供支撑，增强新的经济发展动力，促进国民经济提质增效升级 互联网+ 开展的前提用户中心不充分 行业通点多，低效环节多，用户体验不好的行业 充分竞争市场，行政垄断少，市场化长度比较高的地方 数据驱动不充分 产品或者服务可虚拟化、数据化的行业 价值环节可数据化的地方，将面临数据化改造 生态协作不充分 利用信息不对称，靠中介型的商业模式盈利的地方，会被改变","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"新产品流程","slug":"NPDP产品经理/新产品流程","date":"2022-03-17T16:00:00.000Z","updated":"2024-03-25T07:58:13.434Z","comments":true,"path":"2022/03/18/NPDP产品经理/新产品流程/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E6%96%B0%E4%BA%A7%E5%93%81%E6%B5%81%E7%A8%8B/","excerpt":"","text":"思维导图管控产品失败（降低不确定性）的方法不确定性、累计成本与开发阶段的关系 标准的决策框架 产品开发流程基本阶段 探索（Exploration） 筛选（Screening） 商业评估（Business Evaluation） 开发（Development） 测试（Testing） 商业化（Commercialization） 常见产品开发流程 门径管理流程（Stage - Gate@） 集成产品开发（IPD） 精益开发（Lean） 敏捷开发（Agil） 设计思维（Design Thinking） 模糊前端FFE​ 模糊前段（Fuzzy front end，FFE）：产品开发项目的前端是一个早期极端的起点，在进入正式的产品开发流程前，组织在该阶段识别机会，形成概念。 ​ 该阶段包括创意生成阶段，初始概念发展阶段和高级业务阶段。 ​ 是项目中定义最不确定的一个阶段 ​ 注：创意阶段可能有5个，概念开发阶段经过淘汰与融合变成了2个，最后立项分析，确定要做的项目 门径管理流程 阶段-关口概念什么是阶段产品开发流程中的一个确认区域，包括： 活动：项目负责人及团队成员依照项目计划必须完成的工作 综合分析：通过跨职能部门及团队成员依照项目计划必须完成的工作 可交付成果：是综合分析结果的呈现，这是团队必须完成的并在关口时所以提交的内容 什么是关卡基本上，他是产品开发流程中的一个确认节点，在该阶段时需要做出有关项目未来的关键决策。包括 可交付成果：关口评审点的输入内容（阶段中的可交付成果）。它是前阶段行为的结果，是实现确定的，在每个关口都有一个可交付成功的标准清单 标准：判断项目是继续还是停止以及优先级决策的标准，这些标准通过以分数呈现，包括财务和定向标准 输出：关口评审结果。关口必须有明确的输出包括一个决策（继续或者停止）以及下一个阶段的路径 阶段 - 关口（Stage - Gate）新产品开发过程 根据需要，可灵活裁剪与添加 分为六个阶段，由来自公司内部不同职能领域的人员一起完成： 发现（Discovery）：寻找新机会和新产品创意 筛选（Scoping）：也叫观察，初步评选市场机会、技术需求以及能力的可获得性 立项分析（Business Case）：也叫构建产品框架，建立在筛选阶段之上的一个关键阶段，包括更为深入的技术，市场和商业可行性分析 开发（Development）：产品设计，原生制造，生产设计，制造准备和上市规划 测试与修正（Testing and Validation）：也翻译成测试与确认，测试产品以及商业化计划的所有方面，以修正所有假设和结论，和证实对产品的预期和总结 上市（Launch）：也翻译为投放市场，产品的完整商业化，包括规模制造以及商业化上市 阶段：一个确定区域，包括 活动，综合分析，可交付成果 关卡：一个确定阶段，必须又明确的输出包括一个决策（继续或者停止等）以及下一阶段的路径。包括：可交付成果，标准，输出 瀑布模型 要求：了解要设计产品需要什么功能、目的、用户需求 设计：确定完成项目所需的软件与硬件，之后被转化为物理设计 实施：根据项目要求和设计规范编写实际代码 验证：确保产品符合顾客的期望 维护：通过客户确定产品设计中的不足或错误，进行修正 集成产品开发IPD integrated Product Development，PID 前身 - 并行工程含义​ 在产品的设计与制造流程中，跨职能团队采用并行模式进行工作，而不是各个功能的顺序依次开发，从而促使团队全面考虑产品生命周期中从概念到实施的全部元素，包括质量、成本、维护等方面 主要特征 并行交叉：并行工程强调产品设计与工艺过程设计、生产准备、采购等活动交叉进行 按部件并行交叉，将一个产品分成若干部分，使其各部件能并行进行交叉开发 各个组件的设计、采购、生产等各种互动尽可能的交叉并行 尽早开始工作，目的就是争取时间 具体做法​ 在产品开发的初期，组织多种可协同工作的项目组，使得有关人员从一开始就获得有关项目的最新消息，积极研究涉及本部门的工作任务，并将需求提供给设计人员，使得许多问题在开发早期就得到了解决从而保证设计质量，减少返工与浪费 发展 - 集成产品开发IPD含义​ 系统综合地应用不同职能体系的成果和理念，有效、高效的开发新产品，满足客户需求的方式 IPD管理的精髓 IPD基于并行工程发展而来 IPD首先是一个商业流程，关注商业结果，将产品开发作为一项投资进行审慎管理 IPD采用跨职能团队，加强部门合作，形成合力，共同承担 IPD流程分为不同的阶段，通过在决策评审点的决策实现集成组合管理团队（IPMT）和产品开发团队（PDT）互动，资源受控分配与投入，既满足项目进展的需求，又避免了投资失控的风险 IPD是灵活的，发展的，持续改进设计的，在不断吸纳业界实践和解决业务问题的过程与时俱进 IPD流程是基于市场的开发，关注市场需求和竞争分析，鼓励创新基于着二者之上 集成产品开发系统分级 精益产品开发定义（Lean Product Development）：创建在丰田首创的精益方法（TPS）的基础之上。目的是：从流程中去掉浪费 精益开发的原则（提升生产效率） 确定客户定义的价值 尽最大努力探索不同的解决方案 创造顺畅的产品开发流程 尊重颜色的标准，以减少变异 首席工程师全程参与 跨职能整合 学习不断改进 准求卓越与不断学习的文化 团队整个组织 消除浪费 + 强化学习 + 慎重政策 + 尽快交付 + 授权团队 + 品质为先 + 全局优化 + 消除浪费 &#x3D; 精益产品 潜在的浪费来源包括 混乱的工作环境 缺乏可用的资源 缺乏明确的优先级顺序 不同职能之间的沟通存在障碍 糟糕的产品需求定义 缺乏对可制造性的早期考虑 过度设计 太多无效会议 太多的电子邮件 直接效益 显著提升生产效能 准时制准时制生产方式（Just In Time简称JIT），又称作无库存生产方式（stockless production），零库存（zero inventories），单件流（one - piece flow）或者超市市场生产方式（supermarket production） JIT的基本理念：只在需要的时候、按需要的量，生产所需的产品，故又被称为准时生产、适时生产方式。 JIT的目标：彻底消除无效劳动和浪费。具体要达到以下目标 废品量最低 2. 库存量最低 3. 准备时间最短 4. 生产提前期最短 5. 减少零件搬运，搬运量低 6. 机器损坏低 7. 事故降低 单件流批量生产虽然是降低成本的生产方法，但是容易出现堆积浪费，周转麻烦，容错率低的问题 单件流则有目的的降低周转问题，并且减少堆积浪费，同时增加容错率 5WHY法（刨根问底法） 安灯法操作：产线异常，按下按钮 - 产线报警 - 领班支持 收益： 一线员工既要动手，也要动脑 鼓励员工持续成长，获得成就感 公司流程优化，持续改善 现场现物亲临现场 - 细致观察，分析&#x2F;评估 - 找出原因 构建学习型组织 超越短期利益，着眼长期利益 致力提升员工，合作伙伴能力 继任领导延续公司文化基因 丰田模式的核心精神是通过支持和鼓励员工持续改善工作流程 让他们不断成长与进步，进而获得工作成就感和主人翁意识 精益产品开发过程的核心概念 精益产品开发的优劣势优势 流程的聚焦点在于信息的顺畅流动,而非严厉管控 通过事件驱动方法简化合作，优化设计 重视对进度、成本、消极和质量方面的风险的积极管控 适用于各种规模的项目 用于记录学习和进展、判定优先级和解决问题的工具是简单的，可视化的 劣势 参与人员必须是相当敬业并且经验丰富的 需要改变组织的结构和文化 需要强有力的供应商管理 组织有意愿且有能力接受项目目标的和方向上的变化 敏捷开发传统方法VS敏捷方法 传统的写作方式 敏捷的写作方式 确定主题 与读者互动 整理大纲、搭建框架 确定主题 书写内容 与读者互动。收集反馈 设计、排版、校对 试写第一张 出版 与读者互动，收集反馈 与读者见面 试写第二章 筹集反馈 … 设计、排班、校对 出版 传统VS敏捷之客户互动对比 确定性项目VS不确定性项目 生命周期类型 增量型：楼盘 定下来不会变 但是要不断交付 敏捷性：互联网项目 不断在变化 预测型：铁路建造 变化极小，有规律的项目 迭代型：研发疫苗 不断变化，但是只需要交付一次 Stacy斯泰西图 敏捷宣言 敏捷宣言 价值观 个体以及互动 胜于 流程和工具 以人为本 可工作的软件 胜过 完整的文档 以价值为导向 客户合作 胜过 合同谈判 合作共赢 响应变化 胜过 遵循原则 拥抱变化 敏捷开发十二大原则 通过尽早和持续地交付有价值的软件来满足客户 欢迎对需求提出变更，敏捷过程要善于利用需求变更，帮助客户获得竞争优势 经常交付可用软件，并周期越短越好 业务人员与开发人员必须通力合作 要善于激励项目人员，基于他们所需的环境和支持，并相信他们能完成任务 团队内部和各个团队之间，最有效的沟通方式是面对面沟通 可工作的软件是衡量进度的首要指标 敏捷过程体长可持续的开发。项目方、开发人员和用户应该能够保持稳定恒久的进展速度 对技术的精益求精以及对设计的不断完善将提高敏捷性 尽量做到简洁，尽最大可能减少不必要工作，这是一门艺术 最佳的架构、需求和设计出自于自组织团队 团队要定期回顾和反思如何能够做到更有效，并相应地调整团队的行为 敏捷Scrum框架 敏捷实践SCRUM的333555 三个支柱 三个角色 三个工件 透明性（Transparency） 产品负责人（Product Owner） 产品待办事项列表（Product Backlog） 检查（Inspection） 敏捷教练（Scrum Master） 冲刺待办事项列表（Sprint Backlog） 适应（Adaptation） 项目团队（Scrum Team） 可交付产品增量（Increment） 五个事件 五大价值观 冲刺 承诺（Commitment） - 愿意对目标做出承诺 冲刺规划会议 专注（Focus） - 全身心都用到你承诺的工作上去 每日站会 开放（Openness） - 团队内所有信息对所有人开发 迭代评审会议 尊重（Respect） - 每个人都有他独特的价值与经验 迭代回顾会议 勇气（Courage） - 勇于承诺，履行承诺，敢于说不 敏捷实践 - 3个角色 产品负责人 敏捷教练 敏捷团队 确定产品的功能和标准维护产品待办事项列表指定软件的交付内容代表客户利益拥有最终解释权平衡有竞争关系的利益相关者 团队和产品主管之间的协调者，消除他们之间的障碍工作职责不是管理团队激发团队的创造力，给团队授权提升团队生产率改进工程工具的实践确保团队取得进展的信息实时更新与同步服务团队、教导团队、保护团队 5到9个人多职能部门人员组成冲刺阶段，团队通过自组织的方式实现冲刺目标实现目标的帆帆上有选择自主权责任属于整个开发团队一起成功，一起失败一起调整，一起改进 敏捷实践 - 用户故事作为 学员 我想 看直播课 以便于 和老师互动 作为老师 我想 提前排课表 以便于 合理安排事件 作为xx 我想 xx 以便于xxxxx 用户说出自己的问题而不是给出具体解决方案 敏捷实践 - 产品代办列表​ 待办事项是所有工作的有序列表，他以故事形式呈现给团队。价值大的排在上面。他是产品需求变更的唯一来源 ​ 他是一个持续完善的清单，根据产品和开发环境的变化而演进。 ​ 产品负责人Product Owner负责待办事项列表的内容，可用性和优先级 几种开发流程的对比瀑布模型 VS 敏捷流程 瀑布模型 敏捷流程 瀑布使用阶段 敏捷使用迭代 瀑布使用不提供高低频率的互动（开发阶段低频率，业务测试阶段高频率） 有频繁的业务互动 瀑布模式一个项目经理 敏捷流程是scrum master 瀑布不能迭代 敏捷能迭代 敏捷与精益敏捷开发：敏捷设计的初衷是再短时间内执行任务，与客户进行频繁互动，并能够对变化做出迅速相应，比较常用于软件开发 精益开发：精益旨在减少浪费，提高运营效率，特别适用于制造过程中常见的重复性任务 门径管理 VS 敏捷 特征 门径管理 敏捷 模型类型 宏观技术 微观计划，项目管理 范围 创意到结束，端点到端点 只有开发与测试阶段 组织广度 跨职能 - 技术、市场、生产 技术 结束点 上市成为新产品 已开发或测试的软件 决策模型 投资模型：设计高级管理层治理的继续或停止模型 主要是战术性的：下一个冲刺需要的动作 集成产品开发与其他流程对比 集成产品开发提供一种将产品开发中的功能，角色和行为集成起来的框架。 定义为系统地、综合的应用不同职能体系的成功和理念，有效、高效地开发新产品，满足客户需求的方式 集成产品开发模型的一个重要功能是“学习与持续改进”，模型表明专注于产品开发过程和技术的组织如何发展以知识为基础的学习型组织 各流程模型是潜在互补的，而不是相互排斥的，应以持续学习和改进为重点，将每个模型中的元素融合为一个真正适合于产品开发的模型 特点 门径管理模型 宏观规划、决策基础 敏捷模型 微观技术和灵活性 精益生产 减少浪费 集成产品开发 学习型组织，对新产品开发的综合集成 开发流程的治理治理：用于指导项目、程序和项目组合管理中的活动框架、功能和流程。治理是采取高层级和战略性的视角，而不是陷入过程和项目细节 治理 管理 职能 监督、控制、整合和决策 技术、组织、领导和控制 关注点 结果和目标 方法和技术 层面 宏观（战略、决策角度） 中观和微观（战术、执行角度） 负责人 董事会 管理层 作用 为管理提供框架、功能和过程授予管理者经营权并加以监督 再治理提供的框架和监督中形式经营权，实现经营目标 总结所有流程模型均遵从一下共同原则 关注战略一致性 基于知识进行决策 降低产品失败的风险 剪掉将利益相关者的输入信息融入设计决策 应用跨职能团队 是一个结构化框架，要被整个项目所理解和应用 门径管理流程 集成产品开发 精益开发 敏捷开发 是否对整个新产品开发流程进行管理 是 是 是 否 是否专注于跨职能团队的使用 是 是 是 是 能加快上市速度吗 是 是 是 是 最适用什么类型的产品行业 硬件、实物 多产品 制造 软件 软件类 如何降低产品失败的风险 关口 决策点 消除浪费 快速迭代 是线性还是迭代 线性 线性 线性+迭代 迭代+线性","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"组合管理","slug":"NPDP产品经理/组合管理","date":"2022-03-17T16:00:00.000Z","updated":"2024-03-25T07:56:58.642Z","comments":true,"path":"2022/03/18/NPDP产品经理/组合管理/","link":"","permalink":"https://bluedancers.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/%E7%BB%84%E5%90%88%E7%AE%A1%E7%90%86/","excerpt":"","text":"组合管理大纲 产品组合产品组织：一个组织正在投资的并将其做出战略性权衡取舍的一系列项目或产品 产品组合管理：以组合形式被管理的一系列程序、项目和&#x2F;或操作的集合。一个组合的构成元素未必是相互依赖的，甚至未必是相关的，但他们被集合成一个组合，以此为单位接受管理，以实现战略目标。 在产品开发和产品管理中，企业可以通过两种途径实现新产品成功 正确的完成项目（项目管理） 完成正确的项目（组合管理） 管理组合的五大高层次目标价值最大化​ 进行资源配置将组合价值最大化（独立项目商业价值的综合）（非财务评估与财务评估） 战略协同​ 确保整体组合战略与经营战略及创新战略始终保持一致（自下而上，自下而上，结合法） 项目平衡​ 根据预定设定的标准如长期或短期、高风险或低风险、特定产品或市场分类等，保持正确的项目之间的平衡 管道平衡​ 确保资源及焦点不会过度分散，避免组合囊括的项目过多，导致被过度分流（资源配置） 财务稳健​ 确保产品组合所选项目能够实现新产品创新战略中所设定的财务目标（财务可行性） 产品规划定义​ 运营严格、规范的方法对市场走势及客户的要求及需求进行分析，创建合理的市场细分规则，对要投资和取得领先地位的细分市场进行选择和优先级排序，从而设计确保市场营销取得成功需要执行的活动，定制可盈利，可执行的业务计划和驱动产品平台、新产品包的开发 老板决定 集体决定 成立规划部门 跨部门团队运行 优点 决策迅速 体现集体意志，形成共识 保证资源，提升专业能力 提升规划质量 缺点 随意、混乱 方法不严谨，责任容易分散 存在局限性，影响规划执行 对管理要求高，决策可能较慢 适用情况 公司创业阶段 公司规模不大，产品较少 公司规模较大，产品较多 公司多产品线，众多产品 组合管理流程 组合中的项目类型 类型 特点 团队（一般而言） 突破型项目Breakthrouth 有时被称为激进的或颠覆式的努力通过技术将新产品带进市场与公司现行的项目大不相同，有高风险 自主团队 平台型项目LpatForm 开发出一系列子系统及其接口，由此创建一个通用架构，继而高效的卡覅和生产一系列衍生产品为发现衍生产品、项目提供平台风险比产品改进或增量提升要高，但比开发突破性产品低 重量级团队 衍生项目Derivative 从其他现有产品或平台中衍生出来可以填补有产品线的空白，提供更具有成本竞争力的制造能力基于组织的核心技术提升性能和引入新特效风险较低 轻量级团队 支持项目Support 对现有产品渐进式改革提高现有产品的制造效率低风险 职能团队 产品组合与战略的关系自上而下法 开发过程中首先考虑愿景与战略 确定整个项目组合中可获得的资源平衡，根据重要战略可能对新产品的贡献，确定业务单元和产品种类的顺序 “战略水桶方法”规定了不同业务单元或产生种类理想的投入比例 在路径上，项目按优先级排序 自下而上法 始于单个项目，经评估筛选，形成项目组合 战略标准依据评估每个项目的选择标准而定 不同与自上而下法，单个的产品组合即是结果不对业务部门和产品类型进行特别考虑（不是很懂） 该法保证项目与战略是保持一致的，但可能无法对特定的项目类型头图理想比例的成本 自上而下和自下而上的结合法 具备两种方法的优点 确定能根据业务部门或产品类型的投入，进行战略优先级的排序 所有潜在的项目都要根据战略标准和每个项目的预估投入进行排序 通过战略预算分配项目时，要综合考虑独立的目标优先顺序和预算投入，并与业务部门或产品类型优先顺序保持一致 从上而下的确定计划，从下而上确定执行 产品机会评估新产品技术评估常用方法气泡图、选项标价、评分方法、项目排序、战略水桶、折现现金单、检查清单、投资回收期 一般分为财务方法与非财务方法 非财务性评估非财务评估方法或评分依据是主观判断。确定要采用的标准包括： 战略一致 产品优势 风险高低程度 法律法规影响 上市时间 市场吸引 利用核心竞争力的能力 技术可行性 通过&#x2F;失败评估示例 财务性评估建立对每个产品机会进行潜在财务评估的基础上 决定新产品在财务上是否可行 决定项目的优先级 具体可用的财务评估方法有： 净现值（Net Persent Value，NPV） 投资回收期（Payback Period） 内部回报率（Internal Rate of Return，IRR） 投入产出比、投资回报率（Return on Invesment， Rol） 以上每种方法都需要 销售潜力及回报的相对值 制造和营销成本的相对值 资金投入预估（对新厂房、设备等进行的投资） 财务可行性研究 - 净现值分析净现值NPV，表示期望项目未来收益折算到此刻的值的总和 财务可行性研究 - 投资回报期投资回报率（Payback period）：指多长时间能够收回在产品上的自由投入 静态投资回收期：不考虑资金的时间成本计算投资回收期 动态投资回收期：考虑资金的时间成本计算投资回收期 投资回收率 &#x3D; 1&#x2F;投资回收期 * 100%（假设3.2年成本收回，则投资回收率为30%左右） 投资回报率（ROI） &#x3D; 运营期年均收益&#x2F;投资总额 * 100%（投资收益率）（假设运营了5年，平均每年收益100，投资总额500，则投资回报率为20%） 内部收益率 &#x3D; 净现值等于0的折现率 什么是平衡组合目的：达到良好的风险与回报平衡，加入一些新产品机会 新产品机会所属的业务单元、产品类别、目标市场，或者产品特征，都可以作为新产品机会的分类标准。 例如： 突破性项目、衍生项目、平台型项目、支持性项目 研发成本、商业化成本 潜在的回报和利益 风险水平 - 开发阶段或商业化阶段 技术难度 - 开发或维护 上市时间 - 从决定开发到获得商业汇报时间 设施设备上的资金投入 知识产权的价值创造潜力 气泡图组合分析用气泡图（Bubble Diagram）来展示产品组合是否有效 通常，用气泡图来表示处于二维坐标图中的项目 X轴和Y轴表示具体的利益标准，如风险和回报 气泡表示单个项目，是根据项目在X轴和Y轴的排序所绘 气泡的大小表示第三个标准，如所需投入资金数额或资源份额 资源配置新产品开发成功率受限因素 同时项目太多 项目计划糟糕，执行任务能力差 产品开发项目与其他业务有优先级之争 上市延期，按照完成难度极大 产品资源竞争，流程不合理，缺乏辅助支持 任务优先级不断变化，资源配置随之改变 管理者陷入困境，无法施救项目 资源配置方法 基于项目资源的需求 基于新业务的目标 将资源配置作为一个业务流程","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"}]},{"title":"Vue3 + jsx开发指南","slug":"技术类文章/Vue3 使用jsx开发指南","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.086Z","comments":true,"path":"2022/03/15/技术类文章/Vue3 使用jsx开发指南/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E4%BD%BF%E7%94%A8jsx%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"","text":"​ 在2021年，vue3发布了正式版本，并且经过一年的维护已经越来越稳定，我们在公司项目中也小范围的上线了vue3的项目，总体还是很不错的 ​ 但是setup语法需要return比较麻烦，还有.value问题，尝试过setup语法糖，依旧觉得setup语法的api记忆负担比较重 ​ 所以下半年逐渐拾起了jsx的语法，并在开源项目中使用，总体感觉还是相当不错的，前人栽树后人乘凉，本文对jsx for vue的常见问题进行说明 jsx学习成本更低，这么多年jsx没有大改动； 无记忆负担，同时足够灵活，如果你是vue开发者，同时对setup语法并不是太合得来， vue3 + jsx也是非常不错的选择~ 前置知识​ 在vue3中使用jsx需要安装@vitejs&#x2F;plugin-vue-jsx（webpack版本的不了解，有需要者执行搜索），根据文档配置一下就行了，官方提供了文档供参考，提供了相关示例jsx-next,有react基础的同学可以先看官方文档，在开发过程中出现问题再看本文 指令v-modelJSX for vue是支持v-model语法的，这一点比react的setState,体验感确实要好 1234567891011// 正常写法&lt;input v-model=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;value&#125; /&gt; // jsx// 指定值写法&lt;input v-model:modelValue=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;]&#125; /&gt; // jsx // 修饰符写法&lt;input v-model:modelValue.trim=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;,[&#x27;trim&#x27;]]&#125; /&gt; // jsx v-show这个api与在vue中的表现形式一致 12&lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt; // vue&lt;div v-show=&#123;isShow&#125;&gt;&lt;/div&gt; // jsx v-bind1234567891011121314// vue&lt;a-modal :width=&quot;&#x27;400px&#x27;&quot; :title=&quot;&#x27;设置组件名称&#x27;&quot; &gt; // ....&lt;/a-modal&gt;// jsx&lt;a-modal width=&#123;&quot;400px&quot;&#125; title=&#123;&quot;设置组件名称&quot;&#125; &gt; // ....&lt;/a-modal&gt; v-if在jsx for vue中没有这个api，我们需要用jsx风格来实现v-if的效果 可以简单理解为jsx直接将if搬到html中 12&lt;div v-if=&quot;isShow&quot;&gt; ... &lt;/div&gt; // vue&#123;isShow &amp;&amp; &lt;div&gt; ... &lt;/div&gt;&#125; // jsx 事件事件语法jsx for vue，所有的事件都按照react风格来 所有事件有on开头 所有事件名称首字母大写 例如：@click &#x3D;&gt; onClick @change &#x3D;&gt; onChange @drop &#x3D;&gt; onDrop 事件修饰符这里没有找到权威的资料，有小伙伴知道也请告知一下，目前建议大家通过原生JavaScript来实现vue事件修饰符的效果 .stop ： 阻止事件冒泡，在JSX中使用event.stopPropagation()来代替 .prevent：阻止默认行为，在JSX中使用event.preventDefault() 来代替 APIref与reactivevue3的template会自动解析ref的.value,在jsx中ref的.value是不会被自动解析的 1234//声明变量 let type = ref(1)&lt;p&gt;&#123;&#123; type &#125;&#125;&lt;/p&gt; // vue&lt;p&gt;&#123;type.value&#125;&lt;/p&gt; // jsx props在jsx for vue中，props的语法使用的就是setup的语法，实际表现形式完全一致 1234567891011export default defineComponent(&#123; props: [&#x27;title&#x27;], setup(props) &#123; onMounted(() =&gt; &#123; console.log(props.title); &#125;) return () =&gt; ( &lt;div&gt;&#123;props.title&#125;&lt;/div&gt; ) &#125;&#125;) emit同样与vue3的setup语法保持一致，注意子父方法需要符合react规范 123emit(&#x27;changeVisible&#x27;, false) // 子组件 &lt;xxx onChangeVisible=&#123;(params) =&gt; xxxFun(params)&#125;&gt;&lt;/xxx&gt; // 父组件 solt如何写插槽这里以antd for vue的Popover 气泡卡片，为例子 Vue3语法123456&lt;a-popover title=&quot;Title&quot;&gt; &lt;template #content&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/template&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; jsx for vue语法123456789&lt;a-popover title=&quot;Title&quot; content=&#123; &lt;&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/&gt; &#125;&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; 基础模板12345678910111213import &#123; defineComponent, onMounted, ref &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; // props: [&#x27;xx&#x27;], setup(props,&#123; emit &#125;) &#123; onMounted(() =&gt; &#123; // ... &#125;) return () =&gt; ( &lt;div&gt;&lt;/div&gt; ) &#125;&#125;) 结语 国内这方面资料比较少，查问题的时候注意vue版本，以及jsx的使用（render方式本文不适用） 如果代码里面存在问题，如果是ui框架，建议直接看react版本的代码，例如antdv的jsx版本直接看antd的实例代码 直接看jsx语法的项目代码，H5-YD.v2 不接受杠精，例如写jsx为啥不去用使用react 如果在学习过程中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"Vite配置alias（设置别名）","slug":"技术类文章/vite配置alias","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2022/03/15/技术类文章/vite配置alias/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/vite%E9%85%8D%E7%BD%AEalias/","excerpt":"","text":"Vite配置alias需要两步进行（TS项目） 1、修改vite.config.ts（让程序支持） 2、修改tsconfig.json（让编辑器支持） 修改vite配置12345678910111213141516171819import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;function _resolve(dir: string) &#123; return path.resolve(__dirname, dir)&#125;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], // 配置项目别名 resolve: &#123; alias: &#123; &#x27;@&#x27;: _resolve(&#x27;src&#x27;), &#125;, &#125;,&#125;) 修改tsconfig.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;noImplicitAny&quot;: false, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true, &quot;importHelpers&quot;: true, // 不让同样的辅助函数重复的出现在多个文件中 &quot;allowSyntheticDefaultImports&quot;: true, // 允许对不包含默认导出的模块使用默认导入。 &quot;baseUrl&quot;: &quot;.&quot;, // 非相对模块的导入可以相对于baseUrl或通过下文会讲到的路径映射来进行解析 &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot; ], &quot;paths&quot;: &#123; // 配置导出路径（这里根据自己项目执行修改） &quot;@/stores*&quot;: [ &quot;./src/stores*&quot; ], &quot;@/components*&quot;: [ &quot;./src/components*&quot; ], &quot;@/modules*&quot;: [ &quot;./src/modules*&quot; ], &quot;@/utils*&quot;: [ &quot;./src/utils*&quot; ], &#125;, &quot;types&quot;: [ &quot;element-plus/global&quot; ] &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot;, ], &quot;include&quot;: [ &quot;src/*&quot;, &quot;src/**/*.vue&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.jsx&quot;, &quot;src/**/*.ts&quot;, &quot;src/**/*.js&quot; ]&#125; 结语 修改后请重启编辑器 本文验证与2022年1月10号，mac，win双平台均有效，如果以上配置无效了，请查看相关api的改动 如果帮助你解决了问题，动动小手点个赞吧！:)","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"Vue3.x 预渲染 Unable to prerender all routes错误排查","slug":"技术类文章/vue3.x 预渲染 Unable to prerender all routes错误排查","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2022/03/15/技术类文章/vue3.x 预渲染 Unable to prerender all routes错误排查/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/vue3.x%20%E9%A2%84%E6%B8%B2%E6%9F%93%20Unable%20to%20prerender%20all%20routes%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/","excerpt":"","text":"前言​ BOOS最近对前几年做的公司官网不太满意，觉得没有有效体现公司的优势，表明随着公司这几年的努力发展，我们将会接触到更大规模的合作伙伴，自然要展示更好的企业形象，所以官网重做。 需求分析 没有交互的静态页面，但是存在大量动画 需要支持良好的SEO ​ 最早期的官网是vue2.x + webpack3.x + vue-cli-plugin-prerender-spa进行实现的，效果挺不错，很快各大搜索引擎就收录了我们的网站，所以这次我们打算沿用此方案，不过使用最新技术栈； 为什么不用vite​ 查阅vite的生态后，未找到类似prerender-spa的plugin，没办法支持预渲染，所以vite就被淘汰了。 为什么不用unxtjs​ 我们的官网不具备大量的接口交互，用Nnxtjs多少有点杀鸡用牛刀了，并且还需要使用pm2部署代码，付出于收获不成正比，被淘汰。 最终方案​ 我们部门是vue技术栈，团队不考虑react，通过以上排除法，只能使用vue3.x + webpack5.x + prerender-spa进行业务实现了。 技术实现基础模板我们使用最新的vue-cli进行项目搭建，选择vue3版本，最近的cli默认就是webpack5 安装预渲染插件1npm i prerender-spa-plugin -D 增加配置123456789101112131415161718const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)const path = require(&#x27;path&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, &#x27;dist&#x27;), routes: [&#x27;/xxx&#x27;], &#125;) ) &#125; &#125;,&#125;) 打包测试1npm run build 然后就出现一个错误 1[prerender-spa-plugin] Unable to prerender all routes! 让我们一起抽丝剥茧，看看报错的具体原因。 错误排查因为报错提示很模糊，我们打开他的源码，在源码line144发生错误的地方增加log，了解具体报错。 再次执行npm run build，得到真正的错误。 1Building for production...error TypeError: compilerFS.mkdirp is not a function ​ 我们继续最终源码发现 compilerFS 由webpack进行提供，我们带着错误前往webpack官网查询错误，于是就找到了Filesystems，因为这个插件已经好几年没有更新，而我们当前使用的是webpack5，出现了API变更的情况。 ​ 于此同时，根据错误提示，我们也在该库的issues中找到了历史讨论。 在讨论中，找到了两种解决方案 修改node_modules源码，使其兼容webpack5 1234567891011// From https://github.com/ahmadnassri/mkdirp-promise/blob/master/lib/index.js const mkdirp = function (dir, opts) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;\\ndir&#x27;, dir, opts, &#x27;\\n&#x27;); try &#123; compilerFS.mkdirp(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; catch(e) &#123; compilerFS.mkdir(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; &#125;) &#125; 使用已经被修改的库，感谢这位大哥 1npm i @dreysolano/prerender-spa-plugin 我们使用第二种方案，重新修改vue.config.js 12- const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)+ const PrerenderSPAPlugin = require(&#x27;@dreysolano/prerender-spa-plugin&#x27;) 然后再次打包测试 打包成功，通过启动本地服务器curl命令测试得知，SEO功能正常，未发现问题。 总结​ 使用prerender-spa-plugin打包出现报错[prerender-spa-plugin] Unable to prerender all routes!，更换库为**@dreysolano&#x2F;prerender-spa-plugin**，即可解决问题。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"写给前端新人的nginx教程","slug":"技术类文章/前端工程师的nginx教程","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.088Z","comments":true,"path":"2022/03/15/技术类文章/前端工程师的nginx教程/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84nginx%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言​ 我相信大部分前端新手是接触不到部署相关的工作的，一般都是将代码包交给后端，或者通过CI，FTP完成代码的更新，至于代码如何部署，如何从域名到前端代码包，很多前端仔没有实际操作过，自然是不知道的，这篇文章就是要帮助未接触过部署的人学会在服务器上线部署一个前端项目，在这个主线中带大家慢慢的熟悉nginx ​ 记得在2017年暑假，那时候大二还没开学，当时我只会写一点简单代码，linux和运维完全没接触过，一冲动在阿里云购买了一个服务器，外加一个域名，好像还是xiaowuasy.top,现在已经不能访问了；那时候单纯的兴趣使然，想搭建一个网站，因为实力不足，也不知道求助别人，前前后后折腾了一个月，最终竟然成功在服务器上面部署了wordpress服务，后面域名备案也成功了； ​ 这段经历是曲折的，依稀记得在盛夏的傍晚，我坐在慢慢暗下来的客厅，头上还残留着因为紧张流下的细汗，眼睛因为专注而干涩，面对不太看得懂的文档，一遍一遍尝试；我自然不希望大家在这上面浪费时间，这也是写这篇文章的初衷 前置知识 一个云服务器，阿里云，腾讯云，xx云都行，首次购买或者学生认证都是有很大的优惠（本文以阿里云为例子） 了解linux基础命令，也就是对各种文件的增删改查 本教程基于CentOS 7.5系统，如果是图形化界面，或者其他系统，命令可能不完全一致，但是流程都是一致的，建议看对应教程 如果linux基础命令不会。下面的也不用看了，立刻去学 搭建环境连接服务器通过远程工具（CRT，Xshell）或者自带的远程连接进入自己的服务器，连接方式选择公网ip 安装nginx CentOS自带yum命令，这个命令很关键，自行了解 执行命令 1yum install nginx // 终于遇到需要确认的，直接确认即可 安装完成后,主机中便有了nginx服务，相关命令如下，启动完成后 1nginx 启动完成后，浏览器访问公网IP,就可以访问到nginx的默认主页 到这一步就算是nginx部署成功了 nginx相关文件路径12/etc/nginx/ // 配置文件/usr/share/nginx/ // 默认前端代码存放处 ​ 默认配置在/etc/nginx/nginx.conf,nginx根据默认配置，监听80端口，80端口指定了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html这个文件夹，于是你访问公网ip -&gt; 公网ip:80 -&gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html,于是”Welcome to CentOS“便呈现在你的面前 ​ 如果你希望不显示默认的页面，而是显示你自己写的项目，直接替换/etc/nginx/nginx.conf中的root,字段为自己程序包的路径 在6666端口上搭建一个站点​ 我们的代码除了部署在默认80端口上面，还可以其他端口上，例如8888，7777，等等 ​ 接下来我们就在一个自定义的端口上面部署一个站点 ​ 这里我们需要注意nginx.conf中的一行配置 含义：在&#x2F;etc&#x2F;nginx&#x2F;conf.d下面所有nginx的配置文件都会自动生效 根据配置文件的提示我们到目标文件夹下面，建立test.conf，名字无所谓，配置文件里面是通配符匹配的 并通过vi 写入内容 123456server &#123; listen 7777; server_name _; root /usr/share/nginx/test;&#125; 再去文件夹/usr/share/nginx/test下建立一个index.html 123mkdir test cd testvi index.html 将一下内容放入index.html种 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是7777端口&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后重启nginx 1nginx -s reload 访问我们部署的项目ip:7777 然后你会发现访问不了，最终访问超时(&#x3D;&#x3D;)，这是因为服务器限制了可访问端口，此时需要到云管理后台设置安全组 在阿里云后台增加安全组规则 之后就可以正常访问了！ 至此，便完成了第一个nginx项目的部署 部署一个vue项目​ 通过上面的例子，我们已经可以完成一个自定义站点的部署了，那么真实项目呢，例如将一个vue项目部署到3006端口 首先编写xxx.conf 1234567891011121314151617181920server &#123; listen 3006; server_name _; # 开启gzip相关配置 gzip on; gzip_static on; gzip_min_length 2k; gzip_buffers 4 8k; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/x-icon application/javascript; gzip_comp_level 9; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 站点代码路径 root /usr/share/nginx/client; # 单页应用必须设置（刷新404问题） location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 将打包之后的代码，通过FTP上传代码到目标文件夹/usr/share/nginx/client（注意文件夹名称） ftp 重启nginx nginx -s reload 这边完成了一个站点的部署！是不是很简单 绑定域名​ 直接拿ip+端口给别人访问是不太好的，大家都给自己站点绑定上一个好记忆的域名，那么nginx如何绑定域名呢？ 购买一个域名https://wanwang.aliyun.com/domain/，备案域名，这个流程很麻烦，需要10-30天 备案完成后，域名就可以使用了 我们需要去修改我们的nginx配置，将server_name的值修改为需要绑定的域名即可； 1234server &#123; listen 3006; server_name xxx.com;// .... 增加https支持 申请一个https证书，数字证书管理，以阿里云为例子，国内云厂商都有 将证书放在服务器中你可以记得住的文件夹里面 修改nginx配置 12345678910111213141516171819202122232425server &#123; // # 将当前域名的http自动打到https listen 80; server_name xxx.com; rewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123; listen 443 ssl http2; server_name xxx.com; ssl_certificate xxxx/yy.pem; # 证书 ssl_certificate_key xxxx/yy.key; # 证书秘钥 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; root /usr/share/nginx/client; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 结语​ 虽然部署一个站点，仅仅是用到nginx，但是涉及到的知识点还是很多的 ​ 如果遇到了错误，一定要仔细检查报错信息，问题百度百度基本都能得到答案，如果实在搞不定，直接重做云服务器系统，重头再来；遇到问题并把它解决了，便成了你的技能 ​ 一个有经验的开发人员部署一个站点，可能半小时就弄完了，想要熟练的话，一定要多练习多实践，从0到1部署一个项目还是一件很酷的事情！ 如果搭建中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"浏览器读取xls并生成二维码下载到本地","slug":"技术类文章/浏览器读取xls生成二维码并下载","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.088Z","comments":true,"path":"2022/03/15/技术类文章/浏览器读取xls生成二维码并下载/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96xls%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"需求一次普通的技术需求会议 ​ 项目经理首先发言 我们技术这边需要将xls表格中的几千条数据变成二维码，并且中间镶嵌logo，图片底部放置编号，由于xls表格数据私密，不能通过第三方完成 ​ 平常这个事情都是后端处理的，前端就是来摸鱼的，但是这次一反常态，后端脸黑了，带样式搞不来，脚一蹬，直接装死 ​ 项目经理用期盼的眼神看着我，顿时我紧张了起来，眼神飘忽，我已经好多年没搞过node了啊！！会议室都沉默了，在项目经理不断精神攻击下，后端装死的情况下，看来注定要大前端来拯救世界了，毕竟JavaScript万能语言，俺来试试吧！ 实现方案​ 以上情节纯属虚构，但是需求确实是这样的，虽然好几年没碰过node，好歹年轻记性好，用过的基本都还记得，调研实现方案上没出现太多问题，有如下方案 puppeteer地址：https://github.com/puppeteer/puppeteer ​ 使用基于node环境的puppeteer，进行二维码绘制，图片绘制，是JavaScript开发者面对此类需求的主流选择 node-canvas地址：https://github.com/Automattic/node-canvas ​ 同样是在服务端完成渲染，但是这个库依赖node-gyp，如果不安装python2，那安装过程懂得都懂，不过这也是很不错的方案 浏览器​ 通过浏览器canvas绘制，然后下载下来，会有刷刷刷下载图片的炫酷效果 很明显有刷刷刷下载图片炫酷效果的方案更好，所以就选择你了 浏览器方案！ 问题分解确定了技术方案，就要考虑具体实现了 JavaScript读取execl文件，并处理成理想格式 将读取到的execl中的网址字段生成一张二维码 将二维码写入canvas，在其中间加上logo，并在底部加一行文字 将canva转化为DataURL，下载它 不断递归生成，直到xls数据全部处理完毕 理论存在，实践开始！ 具体实现启动一个本地服务器首先我们通过VScode Live Server 启动一个本地服务器 这里有好奇宝宝要问了，为啥第一步是这？ 答：因为浏览器是访问不了电脑的文件系统的，所以只能通过启动一个本地服务器的方案，来读取我们的资源文件 创建html，引入资源库分析需要用到的第三方开源库 解析xls https://github.com/sheetjs/sheetjs 生成QRcode https://github.com/soldair/node-qrcode 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生成二维码&lt;/title&gt; &lt;script src=&quot;./qrcode.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./xlsx.full.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 用于生成载体 最终生成的图片大小，按自己的需求来 --&gt; &lt;canvas width=&quot;260&quot; height=&quot;310&quot; id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; const ctx = initCanvas(); // 获取ctx实例 // 初始化画布 function initCanvas() &#123; const canvas = document.getElementById(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); return ctx; &#125; &lt;/script&gt;&lt;/html&gt; 解析xls文件1234567891011121314151617181920212223242526272829303132333435363738readWorkbookFromRemoteFile().then((res) =&gt; &#123; // res 为实际解析代码 [&#123;key:&#x27;xxxx&#x27;,value:&#x27;xxxx&#x27;&#125;,....]&#125;);// 读取xls信息，并处理function readWorkbookFromRemoteFile() &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;http://127.0.0.1:5500/xls.xls&quot;, true); xhr.responseType = &quot;arraybuffer&quot;; xhr.onload = (e) =&gt; &#123; if (xhr.status == 200) &#123; var data = new Uint8Array(xhr.response); var workbook = XLSX.read(data, &#123; type: &quot;array&quot; &#125;); // 获取实际表格长度（去除表头） let carryLen = 0; for (const key in workbook.Sheets[&quot;Sheet&quot;]) &#123; const ele = workbook.Sheets[&quot;Sheet&quot;][key]; if (key.includes(&quot;A&quot;)) &#123; carryLen++; &#125; &#125; // 解析数据 let xls = []; for (let i = 2; i &lt;= carryLen; i++) &#123; let data = workbook.Sheets[&quot;Sheet&quot;]; xls.push(&#123; key: data[&quot;A&quot; + i].w, value: data[&quot;B&quot; + i].w, &#125;); &#125; resolve(xls); &#125; &#125;; xhr.send(); &#125;);&#125; 看到这里肯定也有细心的好奇宝宝问，为啥循环体中的i为2呢? 答案：因为表格中的A1，B1为表格的第一行，而第一行是表头，要去除 将链接生成为二维码12345678910111213141516171819new Promise((resolve, reject) =&gt; &#123; // 生成二维码 QRCode.toDataURL( &#x27;xxxxxxx&#x27;, &#123; width: 260, height: 260, margin: 3, &#125;, (error, url) =&gt; &#123; if (error) console.error(error); const code = new Image(); code.src = url; code.onload = () =&gt; &#123; ctx.drawImage(code, 0, 0); resolve(code); &#125;; &#125; ); 写入中间logo12345678return new Promise((resolve, reject) =&gt; &#123; const code = new Image(); code.src = &quot;http://127.0.0.1:5500/logo.jpeg&quot;; code.onload = () =&gt; &#123; ctx.drawImage(code, 260 / 2 - 20, 260 / 2 - 20, 40, 40); resolve(); &#125;;&#125;); 写入底部文字123456// 写入编号ctx.font = &quot;24px Arial&quot;;ctx.fillStyle = &quot;#000&quot;;ctx.textAlign = &quot;center&quot;;ctx.textBaseline = &quot;middle&quot;;ctx.fillText(xls[index].value, 130, 270); canvas转化为图片，并下载到本地1234567// 用于预览let url = document.getElementById(&quot;canvas&quot;).toDataURL(&quot;image/png&quot;);var a = document.createElement(&quot;a&quot;); // 生成一个a元素var event = new MouseEvent(&quot;click&quot;); // 创建一个单击事件a.download = xls[index].value; // 将a的download属性设置为我们想要下载的图片名称，若name不存在则使用‘下载图片名称’作为默认名称a.href = url; // 将生成的URL设置为a.href属性a.dispatchEvent(event); // 触发a的单击事件 第一张图片，完成生成 递归调用我们修改发起逻辑代码，逻辑尾部增加递归调用就好啦 12345678910111213141516171819202122232425262728readWorkbookFromRemoteFile().then((res) =&gt; &#123; createImg(res, 0); // 递归生成&#125;);// ......// 实际生成逻辑function createImg(xls, index) &#123; new Promise((resolve, reject) =&gt; &#123; // 生成二维码 &#125;) .then((res) =&gt; &#123; // 生成中间logo &#125;) .then(() =&gt; &#123; // 写入编号 &#125;) .then(() =&gt; &#123; // 下载图片 &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; if (xls.length &gt; index + 1) &#123; ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); // 初始化画布 createImg(xls, index + 1); &#125; &#125;, 20); // 爱惜机器，加个延时，也可以去掉延时，体会机器的极致速度 &#125;);&#125; 最终效果 至此，终于实现了刷刷刷下载图片炫酷效果，此时可以脑部一段很快的rap，如果华佗再世，崇洋可以医治，外邦来学汉字…………… 最终生成的文件 最终代码地址 一定要针对该项目启动一个本地服务器，否则资源无法访问 web-Output-QRcode 结语​ 首先纠正一点，JavaScript开发者针对生成二维码类似的任务，首选肯定是puppeteer，使用浏览器绕个弯这种实现方案，多少带点科研味道，长期项目自然是不推荐的 ​ 带着学习的态度去完成需求，并且不断优化代码、总结问题，将遇到的未知知识点学会，（比如创建a链接，自动触发点击事件），这才是本文的目的。 ​ 感谢阅读，觉得还不错就点个赞吧~ ​ QQ交流群：530496237 大佬解答疑惑~（内有微信群二维码） ​","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"三个案例带你理解Event Loop流程","slug":"技术类文章/聊一聊宏任务与微任务以及EventLoop","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.089Z","comments":true,"path":"2022/03/15/技术类文章/聊一聊宏任务与微任务以及EventLoop/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E8%81%8A%E4%B8%80%E8%81%8A%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEventLoop/","excerpt":"","text":"为什么 JavaScript 需要 Event Loop JavaScript 在创建之初就确认了一点，JavaScript 是一门单线程语言，因为 JavaScript 主要提供用户互动以及操作 DOM，假定存在两个线程，同时对一个 Dom 进行操作，那究竟以谁为准呢，为了避免这种复杂性，JavaScript 确认了单线程这个核心概念 在单线程中，除了 JavaScript 本身的逻辑之外，还存在一些 IO 操作，例如从服务端获取数据，在单线程中就需要等待结果的返回才能继续下面的逻辑，这时候机器是挂起状态，为了避免这个低效问题，这里就引入了同步任务与异步任务的概念，依旧是是单线程，但是有些任务不等待其运行结果 于是同步任务都在函数执行栈（Stack）上执行，所有的异步任务，在有了运行结果之后，就会将其放入任务队列（callback queue），如果 Stack 中任务执行完毕，就会再去检查任务队列是否存在待执行的回调任务，将其任务放入 Stack，再执行，这里就会不断循环此操作 Stack 执行 - Stack 执行完毕 - 检查任务队列 - 将任务加入 Stack - Stack 执行，这样重复的过程就需要 Event Loop 来持续不断的循环检查任务队列，确保异步任务被准时加入到 Stack 相关名词介绍函数执行栈（Stask）：遵循后进先出原则，同步函数执行栈 webAPIs：异步任务的发起者，事件是首先进入 stack，例如 click，change，再将 callback 加入任务队列 回调队列（callback queue）：也可以被称为任务队列，回调函数到达了执行时机就会进入任务队列，他们将会被 Event Loop 持续打入函数执行栈 事件循环解析我们用 Event Loop 来解释一个简单的 demo 1234567consoleo.log(&quot;1&quot;);setTimeout(() =&gt; &#123; console.log(&quot;2&quot;);&#125;, 5000);console.log(&quot;3&quot;); 我相信大部分人都知道，这里打印的顺序为 1 3 2，下面我们用事件循环的流程来说明为什么是这个结果 注： cb 为 callback console.log(&#39;hi&#39;)，进栈 执行 出栈，打印 1 setTimeout进栈 执行 cb 加入异步队列 自身出栈 console.log(&#39;end&#39;)，进栈 执行 出栈 打印 3 5s 后，cb 加入任务队列，event Loop 检查当前执行栈是否存在函数，检查发现不存在，将 cb 加入函数执行栈 cb进栈 执行 出栈 打印 2 我们通过 event Loop 的角度进行解析，就能很轻易的解释为什么代码执行顺序是 1 3 2，这是非常简单的场景，接下来我们会分析一些更加有难度的代码 关于宏任务与微任务 通过上面的介绍，我相信大部分人都事件循环有一个基础的认知的，但是与以上我们通过简单的示例，演示了异步代码在事件循环中的运行流程，并没有涉及宏任务与微任务，这两货是什么呢，为什么要在这里出现？ 首先，宏任务（macrotask），微任务（microtask）都是异步任务 宏任务：setTimeout setInterval setImmediate I/O 键盘事件 网络事件 UI rendering 微任务：pormise MutationObserver process.nextTick 他们在执行层面上存在一定差异 例子 1123456789101112131415console.log(&quot;script start&quot;);setTimeout(function () &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);Promise.resolve() .then(function () &#123; console.log(&quot;promise1&quot;); &#125;) .then(function () &#123; console.log(&quot;promise2&quot;); &#125;);console.log(&quot;script end&quot;); 结果为 script start script end promise1 promise2 setTimeout pormise 与 setTimeout 虽然都是异步任务，但是上图的代码你会发现，promise 仿佛插队了，这便是宏任务与微任务在任务队列最大的不同之处 event Loop 在事件循环中,首先解析 script，将宏任务加入宏任务队列，将微任务加入微任务队列，栈空了之后，执行当前微任务，第一轮事件循环结束 在第二轮事件循环中，首先执行宏任务 callback 中的第一个，执行完毕，栈空了之后，再执行当前微任务，后面同理 例子 212345678910111213141516171819202122232425console.log(&quot;a&quot;);setTimeout(() =&gt; &#123; console.log(&quot;b&quot;); setTimeout(() =&gt; &#123; console.log(&quot;g&quot;); &#125;, 0); new Promise((resolve) =&gt; &#123; resolve(); &#125;).then(() =&gt; &#123; console.log(&quot;h&quot;); &#125;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&quot;c&quot;); resolve();&#125;) .then(function () &#123; console.log(&quot;d&quot;); &#125;) .then(function () &#123; console.log(&quot;e&quot;); &#125;);console.log(&quot;f&quot;); 大家可以先别看答案，自己先尝试将答案推算出来 第一轮事件循环console.log(&quot;a&quot;);进入栈 执行 出栈 打印 a setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 console.log(&quot;c&quot;);进入栈 执行 出栈 打印 c new Promise.then 进入微任务队列 console.log(&quot;f&quot;);进入栈 执行 出栈 打印 f new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;d&quot;)进入栈 执行 出栈 打印 d console.log(&quot;e&quot;)进入栈 执行 出栈 打印 e –微任务执行完毕 第一轮事件循环完毕– 结果为 a c f d e 第二轮事件循环第一轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;b&quot;) 进入栈 执行 出栈 打印 b setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 new Promise.then 进入微任务队列 new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;h&quot;)进入栈 执行 出栈 打印 h –微任务执行完毕 第二轮事件循环完毕– 结果为 b h 第三轮事件循环第二轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;g&quot;);进入栈 执行 出栈 打印 g —宏任务完毕，开始执行微任务— –微任务队列为空 第三轮事件循环完毕– 结果为 g 结果a c f d e b h g 宏&#x2F;微任务的结论通过上面三个例子，我们可以得出以下结论 函数执行栈中如果还存在函数，则等待其结束，才会继续事件循环 Event Loop 先执行同步任务，再微任务，下一轮循环，宏任务加入队列，执行，所以说先微任务，再宏任务是合理的 单次 Event Loop 中，只会执行一次宏任务，但是微任务可以一次执行多个 推荐文章做一些动图，学习一下 EventLoop 通过动图看 Event Loop 更加便于理解 总结 JavaScript 单线程语言的特性注定其需要异步队列，让网页交互体验上更加友好，对于开发来说，需要尽量了解其特性 首先我们需要了解事件循环机制，搞懂代码执行栈 异步队列的概念，再后面搞懂宏任务与微任务，读懂异步队列的运行机制，这样基本上就可以解决大部分 Event Loop 问题，了解宏任务 微任务 将会对代码执行顺序有更加底层的理解，这样就可以解决","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"JS数据结构与算法","slug":"算法与数据结构/JS数据结构与算法","date":"2022-03-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.091Z","comments":true,"path":"2022/03/15/算法与数据结构/JS数据结构与算法/","link":"","permalink":"https://bluedancers.github.io/2022/03/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"数据结构为算法提供服务，算法围绕数据结构操作 时间复杂度 一个函数用大O表示，比如O(1)，O(n)，O(logN)… 定性描述该算法的运行时间 O(1)12let a = 1a += 1 每次执行改逻辑的时候，之后执行一次，复杂度不会随着时间的变化而变化 O(n)123for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; for循环里面的代码执行n次 O(1) + O(n) &#x3D; O(n)123456let a = 1a += 1for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; 两个时间复杂度先后排列就需要相加，相加的情况下低的的忽略不计，取更高的时间复杂度 O(n) * O(n) &#x3D; O(n ^ 2)12345for (let i = 0; i &lt; n; i += 1) &#123; for (let j = 0; j &lt; n; j += 1) &#123; console.log(i, j) &#125;&#125; 两个时间复杂度嵌套排列，时间复杂度就需要相乘 O(logN)$$对数函数：如果ax&#x3D;N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x&#x3D;loga$$ 12345let i = 1while(i &lt; n) &#123; console.log(i) i *= 2&#125; 这里的logN以2为底数，目的是就是求2的多少次方为N， 上面的代码while循环每次*2，实际上就是求2的多少次方为N，所以时间复杂度就是O(logN) 空间复杂度 一个函数用O表示，比如O(1)，O(n)，O(n^2) 算法在运行过程中临时占用存储空间的大小的量度 O(1)12let i = 0i += 1 声明了变量i，单个变量所占用的内存为1，所以空间复杂度为O(1) O(n)1234let list = []for (let i = 0; i &lt; n; i += 1) &#123; list.push(i)&#125; 声明了变量list，通过循环我们增加了n个值，相当于占用了n个内存单元，所以这段代码的空间复杂度为O(n) O(n^2)1234567const matrix = []for (let i = 0; i &lt; n; i += 1) &#123; matrix.push([]) for (let j = 0; j &lt; n; j += 1) &#123; matrix[i].push(j) &#125;&#125; O(n^2)实际上就是一个矩阵，矩阵的本质就是一个二维数据，存储了n的二次方的变量 小知识调试工具栏每个图标的作用 第一个箭头：程序运行到下一个断点，没有断点，程序执行完毕 第二个图标：一行一行执行代码 第三个图标：当前处如果调用了fun，点击此图标就会进入函数里面 第四个图标：点击跳出当前函数 第五个图标：重启调试 第六个图标：停止调试","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"基于PromiseA+，从零实现Promise","slug":"技术类文章/promise的源码解读","date":"2021-12-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.090Z","comments":true,"path":"2021/12/15/技术类文章/promise的源码解读/","link":"","permalink":"https://bluedancers.github.io/2021/12/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/promise%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"ECMAScript6中promise是划时代的API，他的出现解决了一直困扰前端开发者的异步问题，从此面对异步回调，我们有了更好的武器 前言​ 面对天天都能见面的promise，不知道你是否有以下的一些问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 为什么resolve之后才会执行then或者catch？ 为什么可以链式.then，并且还都会按同步进行？ 为什么执行promise.resolve()，后面的函数就支持promise了？ promise.all是如何实现的？ 是否被面试题中的promise题目迷惑的头晕目眩？ 让我们了解Promise的实现原理，所有问题答案自然浮出水面~ ​ promise在潜移默化之间帮助我们简化了复杂的异步代码，降低逻辑难度，说promise是划时代的异步解决方案也不为过，他很好的提现了开放封闭原则，解决耦合性过高的问题 ​ 说一个小知识，es6发布之前类似prmise的异步方案已经存在，在jquery的ajax中已经应用了类似的技术方案的jQuery.deferred()，感兴趣的同学可以去了解一下 123$.ajax(&quot;test.html&quot;).done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;).fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 简化版Primise 基础版本的实现虽然简单，但是解释了很多问题 建议将代码复制到本地，通过断点的方式查看代码的执行流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const PEDDING = &#x27;pending&#x27; // 等待状态const FULFILLED = &#x27;fulfilled&#x27; // 成功状态const REJECTED = &#x27;rejected&#x27; // 失败状态class APromise &#123; constructor(executor) &#123; this.status = PEDDING // 初始化状态 this.value = undefined // 成功的数据 this.reason = undefined // 失败的原因 this.onFulfilledCallbacks = [] // 保存成功状态的回调队列 this.onRejectCallbacks = [] // 保存失败状态的回调队列 const resolve = (data) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = FULFILLED this.value = data &#125; this.onFulfilledCallbacks.map((e) =&gt; e()) &#125; const reject = (err) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = REJECTED this.reason = err &#125; this.onRejectCallbacks.map((e) =&gt; e()) &#125; try &#123; executor(resolve, reject) &#125; catch (error) &#123; rejected(error) &#125; &#125; then(onFulfilled, onRejected) &#123; if (this.status == FULFILLED) &#123; onFulfilled(this.value) &#125; if (this.status == REJECTED) &#123; onRejected(this.reason) &#125; if (this.status == PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(this.value) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; &#125;&#125;new APromise((resolve, reject) =&gt; &#123; console.log(&#x27;开始回调&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;执行回调&#x27;) resolve(11111) &#125;, 1000)&#125;).then( (value) =&gt; &#123; console.log(&#x27;成功回调&#x27;, value) &#125;, (err) =&gt; &#123; console.log(&#x27;失败回调&#x27;, err) &#125;) 代码运行流程 初始化APromise，开始执行class中的constructor 在constructor中初始化当前promise的一些状态值以及resolve，reject函数 最后将resolve函数与reject函数以参数的形式给promise的回调函数，同时执行函数，打印开始回调 运行setTimeout，并且开始解析then函数 如果是成功，或者失败状态，直接执行回调，如果是pedding状态，则存储成功与失败回调函数 1s之后，setTimeout执行完毕，resolve执行触发constructor中的resolve resolve函数中执行之前初始化.then时候存储的回调函数，打印 成功回调，11111或者失败回调 逻辑流程图 基础版本的实现，不支持链式调用，不支持then穿透，不支持catch，只实现了最基础的逻辑 我们在这里解答一下前言中提出的问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 答：new的时候执行Promise中的constructor，声明了resolve与reject，并且在执行Promise回调函数的时候将参数传入到函数中 为什么resolve之后才会执行then或者catch？ 答：因为在初始化阶段，pedding状态下，我们存储了当前Promise的成功与失败回调，当执行resolve的时候，当前Promise的状态发生变化，开始执行之前存储的回调函数，如果不是padding，则立即执行回调函数 后面的问题我们暂时还无法解释，但是随着我们进一步的实现，答案都会浮出水面 正式版（链式回调，then值穿透，.catch 等）链式回调​ 我们一般写promise都会写多个.then，在多个.then中我们将异步代码变成同步代码块，但是我们基础版本的promise中无法显示链式调用，因为执行.then之后函数没有任何返回值，自然不会存在.then方法，在这个思路上，我们对promise的.then解析过程进行改写,尝试让其支持链式调用 每次.then中都需要返回一个promise来触发下一个.then 对then回调函数的各种情况需要进行判断，例如。then中返回的是一个string还是返回了一个promise，如果是则需要增加链式回调触发父级的resolve then函数执行需要通过settimeout进行包裹，让其加入宏任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * then可能返回的是普通值,也可能返回一个promise，这里的写法参照PromiseA+标准进行完成 * 逻辑较为复杂，可以先看静态变量代码逻辑，再看针对promise的处理逻辑 * @param &#123;*&#125; promise 当前promise * @param &#123;*&#125; x 当前返回值 * @param &#123;*&#125; resolve 成功回调 * @param &#123;*&#125; reject 失败回调 */const resolvePromise = (promise, x, resolve, reject) =&gt; &#123; if (promise === x) &#123; return reject(new TypeError(&#x27;检测到promise的循环调用&#x27;)) // &#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27; &#125; let called = false if ((typeof x === &#x27;object&#x27; &amp;&amp; x !== null) || typeof x === &#x27;function&#x27;) &#123; try &#123; const then = x.then if (typeof then === &#x27;function&#x27;) &#123; then.call( x, (y) =&gt; &#123; if (called) return called = true resolvePromise(promise, y, resolve, reject) &#125;, (r) =&gt; &#123; if (called) return called = true reject(r) &#125; ) &#125; else &#123; resolve(x) &#125; &#125; catch (err) &#123; if (called) return called = true reject(err) &#125; &#125; else &#123; resolve(x) &#125;&#125;then(onFulfilled, onRejected) &#123; let apromise = new APromise((resolve, reject) =&gt; &#123; if (this.status === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) &#125; &#125;) return apromise&#125; 经过上面的内部promise处理，函数的运行逻辑发生了很大的变化 我们直观看到的逻辑是 ​ 实际的运行逻辑是每次.then中都会再次创建一个Promise，以便于下次进行调用，并且对.then的回调函数进行处理，区分.then中返回了Promise对象还是普通对象，这样的思路实现了.then链式调用 当then中存在return promise的情况，逻辑会发生一些变化，这些主要体现在resolvePromise函数中 then值穿透首先查看一种场景 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then() .then() .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) ​ 这里我们就会发现，then的回调函数都不存在，自然无法将resolve的值传递到最下面的.then中，所以这里我们需要对这种情况做一些处理 123456789then(onFulfilled, onRejected) &#123; // 值穿透问题 如果then是空的话,就手动的将上一个resolve的值带入到下一个then中 onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : (data) =&gt; data onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err &#125; let apromise = new APromise((resolve, reject) =&gt; &#123; // .... &#125;) return apromise&#125; 当我们对then值中的回调函数进行处理后，实际运行的函数变成 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then((data) =&gt; data) .then((data) =&gt; data) .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) 这样便实现了then穿透问题 .catch目前我们错误回调在.then的第二个参数中，并不支持.catch的写法，我们可以在原型链上面增加catch方法 catch其实也是对.then方法的封装，只不过不存在成功回调，只有失败回调 123APromise.prototype.catch = function (errCallback) &#123; return this.then(null, errCallback)&#125; .finally 由于finally无法预知promise的最终状态，所以finally的回调函数中不接受任何参数，他仅用于无论最终结果都要执行的情况 需要注意的一点是如果finally中存在Promise，这需要等待promise执行完毕 123456789101112APromise.prototype.finally = function (callBack) &#123; return this.then( (data) =&gt; &#123; return APromise.resolve(callBack()).then(() =&gt; data) &#125;, (err) =&gt; &#123; return APromise.reject(callBack()).then(() =&gt; &#123; throw err &#125;) &#125; )&#125; 关于finally的小知识123Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 此时传递下去的是undefinedPromise.resolve(2).finally(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 传递下去的是 2，finally本身未接收参数，但是将上次的回调数据放入到了下次的回调 Promise.resolve() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回成功回调 12345APromise.resolve = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; resolve(data) &#125;)&#125; Promise.reject() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回失败回调 12345APromise.reject = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; reject(data) &#125;)&#125; Promise.race() 当调用race方法的时候，必须传入一个数组，数组中可以存在不同类型以及函数类型，在初始化过程中会再次创建一个promise，当数组中的某个promise对象最先执行的时候，触发自身的.then在回调函数中触发了race本身的resolve，后面执行完毕之后，因为race的状态已经发生了变化，自然无法再执行 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 同时执行多个promise,但是最返回最先返回的结果 * @param &#123;*&#125; promiseList * @returns */APromise.race = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须传递数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; promiseList.forEach((item) =&gt; &#123; if (item &amp;&amp; typeof item.then == &#x27;function&#x27;) &#123; item.then(resolve, reject) &#125; else &#123; resolve(item) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;ok2&#x27;) &#125;, 2000)&#125;)APromise.race([1, p1, p2]).then( (data) =&gt; &#123; console.log(&#x27;success1&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error1&#x27;, err) &#125;) Promise.all() all的实现逻辑非常简单，all的时候创建一个promise，内部记录当前传入的列表状态成功的单个数据，当所有的then数据都成功，调用自己的resolve，当有一个失败的时候，调用自己的reject 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 同时执行多个promise,会等待每次promise的结果,最后一起返回,有一个失败,这都不会返回 * @param &#123;&#125; promiseList * @returns */APromise.all = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resulteArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (key, val) =&gt; &#123; resulteArr[key] = val if (++currentIndex == len) &#123; resolve(resulteArr) &#125; &#125; for (let i = 0; i &lt; len; i++) &#123; const val = promiseList[i] if (val &amp;&amp; typeof val.then === &#x27;function&#x27;) &#123; val.then((data) =&gt; &#123; getResult(i, data) &#125;, reject) &#125; else &#123; getResult(i, val) &#125; &#125; &#125;)&#125;let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;); &#125;, 1000);&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;); &#125;, 2000);&#125;)Promise.all([1,2,3,p1,p2]).then(data =&gt; &#123; console.log(&#x27;success&#x27;, data);&#125;, err =&gt; &#123; console.log(&#x27;error&#x27;, err);&#125;) Promise.any() 实现方法与all非常相似，是all完全相反的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * any与all完全相反,只要有个一个成功就会返回成功,全部失败才会返回失败 * @param &#123;*&#125; promiseList * @returns */APromise.any = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, err) =&gt; &#123; resultArr[index] = err if (++currentIndex == len) &#123; reject(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then(resolve, (err) =&gt; &#123; getResult(index, err) &#125;) &#125; else &#123; resolve(res) &#125; &#125;) &#125;)&#125;let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.any([p3, p4]).then( (data) =&gt; &#123; console.log(&#x27;success&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error&#x27;, err) &#125;) Promise.allSettled() allSettled是ES2020加入的工具方法，一句话总结：他是永远都不会失败处理的promise.all 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 保存所有的成功与失败 * @param &#123;*&#125; promiseList * @returns */APromise.allSettled = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, data, status) =&gt; &#123; if (status == FULFILLED) &#123; resultArr.push(&#123; status: status, value: data, &#125;) &#125; if (status == REJECTED) &#123; resultArr.push(&#123; status: status, reason: data, &#125;) &#125; if (++currentIndex == len) &#123; resolve(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then( (data) =&gt; &#123; getResult(index, data, FULFILLED) &#125;, (err) =&gt; &#123; getResult(index, err, REJECTED) &#125; ) &#125; else &#123; getResult(index, res, FULFILLED) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;) &#125;, 2000)&#125;)let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.allSettled([1, 2, 3, p1, p2, p3, p4]).then((res) =&gt; &#123; console.log(&#x27;success&#x27;, res)&#125;) 测试函数首先需要安装测试脚本 npm install -g promises-aplus-tests 测试命令 promises-aplus-tests xxxx.js 测试文件末尾需要加入如下代码 不存在错误则为符合promiseA+标准 12345678910APromise.defer = APromise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new APromise((resolve, reject) =&gt; &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd&#125;module.exports = APromise 源码地址github-promise 可以通过chrome DevTool或者Vscode Debug的方式，加上断点，查看代码运行流程，便于理解promise运行逻辑 参考链接重学Promise，基于A+规范实现它，感谢掘金@关er的promise解读文章，大大降低了深入promise的门槛 PromiseA+规范 MDN-Promise 45道Promise面试题","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"简易版Reactivity源码解析","slug":"技术类文章/简易版Reactivity源码解析","date":"2021-11-30T16:00:00.000Z","updated":"2022-12-11T13:51:24.090Z","comments":true,"path":"2021/12/01/技术类文章/简易版Reactivity源码解析/","link":"","permalink":"https://bluedancers.github.io/2021/12/01/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E7%AE%80%E6%98%93%E7%89%88Reactivity%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 首先感谢__mxin同学的简易版本，没有这个简化版本，我大概率也没办法沉下心来将代码读下去，再次表示感谢，通读下来简化之后的逻辑清晰，只需要对几个JavaScript原生API进行了解，走完代码流程，便了解了核心流程 代码地址：传送门 前置知识Proxy Reflect WeakMap 核心流程图​ 尝试绘制了一遍代码流程图，主要流程就是初始化时候对reactive，computed，effect的依赖收集，以及在触发set事件的时候，对收集到的依赖的触发 reactive123456789const object = &#123; r: 0, g: 0, b: 0, o: &#123; a: 1, &#125;, &#125; const proxy = reactive(object) ​ reactive是一个赋予对象响应式特征的方法，传入的数据会被proxy代理，变量一旦被代理，就将会被加入reactiveMap，以后都会触发reactiveMap内的proxy 12345678910111213141516171819202122232425262728/** * 定义响应式对象，返回proxy代理对象 * @param &#123;*&#125; object */function reactive(object) &#123;// 判断是否已经代理，已经存在直接取自 if (reactiveMap.has(object)) return reactiveMap.get(object) // 第一次进行处理，进行proxy代理 const proxy = new Proxy(object, &#123; // 处理器对象，定义捕获器 get(target, key) &#123; console.log(&#x27;get方法&#x27;, target, key) // 针对effect，computed依赖进行处理 track(target, key) // 如果当前代理的值为object类型，将会对当前的值再次进行proxy,否则直接获取数据 return typeof target[key] === &#x27;object&#x27; ? reactive(target[key]) : Reflect.get(...arguments) &#125;, set(target, key) &#123; console.log(&#x27;设置的值&#x27;, ...arguments) // 在set事件中对原本的数据进行修改 Reflect.set(...arguments) // trigger(target, key) &#125;, &#125;) reactiveMap.set(object, proxy) return proxy&#125; 完成代理的数据 effect effect会在依赖的经过reactive处理后的对象发生变化的时候，自动执行一次回调函数，通常称它为副作用函数 effect的实现是Reactivity最核心的部分，也是比较难理解的部分，依赖WeakMap进行实现，如果不了解WeakMap，务必先去看一下文档 1234567const computedObj = computed(() =&gt; &#123; return proxy.r * 2&#125;)effect(() =&gt; &#123; console.log(`proxy.o.a: $&#123;proxy.o.a&#125;`)&#125;) 初始化的过程中触发effect，将函数fn放入effectStack，同时执行effect中的函数，一旦执行，必定会触发经过reactive代理的get函数，进行数据获取 123456789101112131415161718192021222324252627282930313233343536373839404142const effectStack = [] // 收集副作用函数/** * 副作用函数 */function effect(fn) &#123; try &#123; // 将需要执行的effect入栈 effectStack.push(fn) // **** 执行该effect，进入proxy的get拦截 **** return fn() &#125; finally &#123; // 依赖收集完毕及所有get流程走完，当前effect出栈 effectStack.pop() &#125;&#125;// ......// get方法触发了track方法get(target, key) &#123; // .... track(target, key) // ....&#125;/** * 依赖收集 */function track(target, key) &#123; // 初始化依赖Map let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; // 第二层依赖使用Set存放key对应的effect let dep = depsMap.get(key) if (!dep) &#123; targetMap.get(target).set(key, (dep = new Set())) &#125; // 取当前栈中的effect存入第二层依赖中 const activeEffect = effectStack[effectStack.length - 1] activeEffect &amp;&amp; dep.add(activeEffect) // 最后触发effect函数的finally，将处理完毕的effect进行弹出，完成依赖收集&#125; 初始化完成后，effect全部完成处理，我们可以看一下targetMap的数据 我们可以看到，变量a与effect中的函数关联在了一起，经过track处理后，effect内部用到的变量都与effect建立了某种关联，至此我们就完成了依赖收集 computedReactivity计算属性的实现是依赖effect进行实现，仅仅是增加了一个value函数进行包裹 12345678910/** * 计算属性 */function computed(fn) &#123; return &#123; get value() &#123; return effect(fn) &#125;, &#125;&#125; 变量发生变化数据发生变化的时候，例如我们将proxy.o.a&#x3D;1,他是如何完成响应式，以及effect的触发的呢？ 首先一定是触发proxy的set函数 123456789101112131415161718192021222324set(target, key) // 修改代理的值 Reflect.set(...arguments) // 等同于arguments[0][arguments[1]] = arguments[2] // 触发依赖收集器 trigger(target, key)&#125;, /** * 依赖收集触发器 */function trigger(target, key) &#123; // target: &#123;a:1&#125; key: a // 获取当前修改的值 const depMap = targetMap.get(target) // 开始执行effect方法 if (depMap) &#123; // 如果存在，开始寻找Map的value，在通过key找到对应的回调函数 const effects = depMap.get(key) effects &amp;&amp; effects.forEach((run) =&gt; &#123; // 执行收集的effect函数 run() &#125;) &#125;&#125; 至此完成数据的响应式，effect的函数触发完成 关键概念reactive 创建响应式对象 effect 副作用函数，存储匿名函数，同时调用自身收集依赖，最后弹出匿名函数 computed 计算属性，其原理是对effect的包装 track 收集依赖，绑定变量与使用该变量的effect trigger 触发依赖，根据变量触发对应的effect 总结​ 这个文章是一个代码记录贴，希望大家看到可以静下心来看看__mxin同学的文章，或者传送门代码，了解了基础的原理后再去看@vue&#x2F;Reactivity的代码，将会事半功倍； ​ 日积月累，将知识变成你的财富吧","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"React17学习记录","slug":"技术类文章/react17学习","date":"2021-10-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.087Z","comments":true,"path":"2021/10/15/技术类文章/react17学习/","link":"","permalink":"https://bluedancers.github.io/2021/10/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/react17%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"为什么学习React17​ 公司使用的是vue技术栈，并且因为历史原因，以及外部因素，可能不会使用react来做生产环境的项目，最近vue3走上正轨，大家都需要抛弃vue2.x的编码思想，在vue3中，hook思想开始越发明显，所以学习react17也是想借此加深对hook的理解，同时取长补短，综合vue与react的优点，在实际的开发中更好的完成开发任务 useState的疑问​ 关于react的useState有一个疑问，useState里面是一个对象，我想要修改对象里面的某一个字段，每次都需要...state,把之前的数据预先填入，这做法感觉有点傻 自定义hookhook是在特定换下调用自己的代码 实现自定义hook必须使用关键字use开头，这是ESLint的规则 自定义hook一般用于需要持续监听的值，而针对纯工具函数则不需要进行处理 实现一个hook风格的防抖函数1234567891011121314151617181920212223242526const [param, setParam] = useState(&#x27;ha ha&#x27;);const debounceParam = useDebounce(param, 2000);useEffect(() =&gt; &#123; console.log(&#x27;log log&#x27;)&#125;, [debounceParam]);/** * 去抖函数 * @param value 监听的值 * @param delay 防抖时间 * @returns 变化后变量 */export function useDebounce(value, delay) &#123; // 声明一个保存防抖结果的字段 const [debounceValue, setDebounceValue] = useState(value); useEffect(() =&gt; &#123; // 每次value,delay发生变化的时候生成一个定时器 const timeout = setTimeout(() =&gt; &#123; setDebounceValue(value); &#125;, delay); // 在执行下一个useEffect之前,会执行上一个useEffect的返回函数 return () =&gt; clearTimeout(timeout); &#125;, [value, delay]); return debounceValue;&#125; useDebounce是一个hook风格的函数 每次param发生变化都会触发useDebounce中的useEffect 而在2000ms时间内如果重复触发就会执行上一个effect return的函数 进而不修改debounceValue，直到2000ms内无任何操作，触发setDebounceValue修改属性，改变了debounceParam 第一个useEffect触发，触发打印log log react中使用TS做代码静态检查 函数类型 fn: () =&gt; void any类型是危险的，应当尽量不用，但是对于模糊的类型，我们可以在标注类型为unknown，这样就不会对赋值做任何校验，但是ts不允许我们对unknown类型做出任何处理，所以可以吧unknown理解成为加强版any 针对参数不固定，返回值不确定的场景，应当使用泛型，在方法名称后面加,然后在参数上指定某一个为T，则T跟这参数的类型而变化 自定义hook useArray 传入一个hook，我们返回针对这个hook的可使用的对应方法，总体来说实现一个hook还是一个比较简单 1234567891011121314151617181920212223242526/** * hook处理的Array * @param value * @returns */export function useArray&lt;V&gt;(value: V[]) &#123; const [arrayValue, setArrayValue] = useState(value); const clear = () =&gt; &#123; setArrayValue([]); &#125;; const add = (value: V) =&gt; &#123; setArrayValue([...arrayValue, value]); &#125;; const removeIndex = (index: number) =&gt; &#123; let value = [...arrayValue]; value.splice(index, 1); setArrayValue(value); &#125;; return &#123; value: arrayValue, add, clear, removeIndex, &#125;;&#125; 关于TS中interface的属性继承123456789101112131415161718interface a &#123; a: number;&#125;interface b extends a &#123; b: number;&#125;let c: b = &#123; a: 1, b: 2,&#125;;function test(p: a) &#123; console.log(p);&#125;test(c); // 不会报错，因为b包含了a，所以这个传入b也不会出现错误 useContext useContext主要用于多个组件之间共享状态 在parent组件中存在child1.child2，child3组件，我们希望这些组件之前都共享一个状态1 生成createContext 1const TestContext = React.createContext(&#123;&#125;); 使用createContext.Provider包裹parent组件 1234567891011&lt;TestContext.Provider value=&#123;&#123; username: &#x27;我是变量&#x27;, &#125;&#125;&gt; &lt;div className=&quot;parent&quot;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;Child3 /&gt; &lt;/div&gt;&lt;TestContext.Provider/&gt; 在子组件中就可以使用useContext来获取父级创建的TestContext 12345678const Child1 = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext); return ( &lt;div className=&quot;child1&quot;&gt; &lt;p&gt;1 message for &#123;username&#125;&lt;/p&gt; &lt;/div&gt; )&#125; 通过useContext就可以做到子组件共享一个状态，如果状态被改变，所有使用变量的都放都会发生变化 TS类型的一些知识Parameters 获取函数的全部参数，并且以元祖类型进行返回,Utiltity Types 123456function test(a: string, b: number, c: number[], d: any) &#123;&#125;// 直接继承test函数的全部参数类型function testPlus(...[a, b, c, d]: Parameters&lt;typeof test&gt;) &#123; console.log(a, b, c, d);&#125; 联合类型12345678910111213141516let a:string | number; // 可以是多种类型// 抽象联合类型type aType:string | number;let a:aType// 也可以通过interface可以实现类型功能，但是指定单个类型是无法实现的，但是interface的全部功能type都可以实现// 例如：interface aaa &#123; a:string&#125;type aaa = &#123; a:string&#125;// 以上2种效果都是一致的 js的typeof与ts的typeof123// js: typeof runtime阶段运行 检查参数的类型// ts: typeof 静态检查阶段运行 识别函数的参数 Partial与Omit关键字123456789101112131415type Preson = &#123; name: string; age: String; sex: string;&#125;;// Partial关键字会将传入的类型处理成为非必填const xiaoMin: Partial&lt;Preson&gt; = &#123; age: &quot;非必填&quot;, name: &quot;非必填&quot;, sex: &quot;非必填&quot;,&#125;;// Omit 会删除第一个参数 类型 中的第二个参数中的变量 并返回结果 例如这里删除 name ageconst shenMiRen: Omit&lt;Preson, &quot;age&quot; | &quot;name&quot;&gt; = &#123; sex: &quot;男&quot; &#125;; 关于css一些不知道的关于remem表示相对于父级的font-size rem表示相对于根元素html的font-size 正常默认font-size为16px，那么1rem &#x3D;&#x3D;&#x3D; 16px 如果希望rem的比例自定义只需要将html的font-size设置为对应的百分就行，例如设置为62.5的时候1rem &#x3D;&#x3D;&#x3D; 10px 关于vhvh的全称为viewport height，100vh就是代表视口的高度 emotion emotion是一个css in js的方案，也就是使用js来写css代码，这样的话就可以在css中直接写逻辑 12345678910111213import styled from &quot;@emotion/styled&quot;;export const Row = styled.div&lt;&#123; gap: number;&#125;&gt;` display: flex; align-items: center; &gt; * &#123; margin-top: 0 !important; margin-bottom: 0 !important; margin-right: $&#123;(props) =&gt; `$&#123;props.gap&#125;rem`&#125;; &#125;`; 自定义hook useAsync的实现 useAsync可以理解为针对请求体再次封装，经过封装之后的请求体，自带请求进度，以及针对catch更加优雅的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; useState &#125; from &quot;react&quot;;interface State&lt;D&gt; &#123; error: Error | null; data: D | null; status: &quot;idle&quot; | &quot;loading&quot; | &quot;error&quot; | &quot;success&quot;;&#125;// 建立初始化的值const defaultState: State&lt;null&gt; = &#123; data: null, error: null, status: &quot;idle&quot;,&#125;;// 实现函数export const useAsync = &lt;D&gt;(initState?: State&lt;D&gt;) =&gt; &#123; // 默认状态 const [state, setState] = useState&lt;State&lt;D&gt;&gt;(&#123; ...defaultState, ...initState, &#125;); // 请求成功的调用 const setData = (data: D) =&gt; &#123; setState(&#123; data, status: &quot;success&quot;, error: null, &#125;); &#125;; // 请求失败的调用 const setError = (error: Error) =&gt; &#123; setState(&#123; data: null, error: error, status: &quot;error&quot;, &#125;); &#125;; // 请求开始的调用 const setLoading = () =&gt; &#123; setState(&#123; data: null, error: null, status: &quot;loading&quot;, &#125;); &#125;; // 对外实际执行的函数 const run = (promise: Promise&lt;D&gt;) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&quot;请传入 promise 类型数据&quot;); &#125; setLoading(); return promise .then((data) =&gt; &#123; setData(data); &#125;) .catch((err) =&gt; &#123; setError(err); &#125;); &#125;; return &#123; isIdle: state.status == &quot;idle&quot;, isLoading: state.status == &quot;loading&quot;, isError: state.status == &quot;error&quot;, isSuccess: state.status == &quot;success&quot;, run, setData, setLoading, setError, ...state, &#125;;&#125;; 使用阶段 12345678// 逻辑顶部应用相关逻辑 const projectData = useAsync&lt;any[]&gt;(); // 泛型为后台返回的数据的类型// 启动请求，传入请求体projectData.run(request);// 请求完成后，projectData中的数据状态会被同步更新let &#123; data, isLoading,isError,...other&#125; = projectData react中实现捕捉边界错误 关于错误边界的概念在react官网中是这样描述的，组件内的JavaScript错误会导致React的内部状态被破坏，并且在下一次的渲染时会产生可能无法追踪的错误，但是部分ui的JavaScript错误不应该导致整个应用的崩溃，所以react16中引入了错误边界的概念， 错误边界是一种react组件，最终组件可以捕获发生在其朱组件树任何位置的JavaScript错误，并打印错误，同时展示降级ui，而并不会渲染发生崩溃的子组件树，错误边界在渲染期间，生命周期方法和整个组件数的构造函数中捕获错误 123456789101112131415161718192021222324252627282930import React, &#123; ReactNode &#125; from &quot;react&quot;;type FallBackRender = (props: &#123; error: Error | null &#125;) =&gt; React.ReactElement;// 1 2 两种写法一致type Components1 = &#123; children: ReactNode; fallbackRender: FallBackRender &#125;;type Components2 = React.PropsWithChildren&lt;&#123; fallbackRender: FallBackRender &#125;&gt;;export class ErrorBoundary extends React.Component&lt; Components2, &#123; error: Error | null &#125;&gt; &#123; state = &#123; error: null, &#125;; // 当子组件抛出异常, state中的errir就会被调用 static getDerivedStateFromError(error: Error) &#123; return &#123; error &#125;; &#125; render() &#123; const &#123; error &#125; = this.state; const &#123; fallbackRender, children &#125; = this.props; if (error) &#123; console.log(&quot;错误执行&quot;, error); return fallbackRender(error); &#125; else &#123; return children; &#125; &#125;&#125; 使用App.tsx 123456789&lt;ErrorBoundary fallbackRender=&#123;fallPageErrorFallback&#125;&gt; &#123;user ? &lt;AuthenicatedApp /&gt; : &lt;UnAuthenicated /&gt;&#125;&lt;/ErrorBoundary&gt;// 发生错误的时候就会渲染这个domexport const fallPageErrorFallback = (&#123; error &#125;: &#123; error: Error | null &#125;) =&gt; ( &lt;p&gt;请求失败了,错误信息&#123;error&#125;&lt;/p&gt;); 阶段性结束 关于react hook的理念学习已经结束了，这段时间学习来看，确实react在很多方面更加易于理解，更加工程化，同时也学会了很多ts的知识，一直以来ts在我手中都是anyscript，本次学习让我对ts的运用更加熟练；在这个过程中也学会了很多hook相关的理念以及实例，并且可以带着这思想去优化项目代码 可惜我是一名vuer，继续学习react的实际编码，意义已经不是很大，所以关于这个课程的学习，本次告一段落；通过本次学习，非常深刻的体会到了hook的优雅，后面会深入学习vue3，在vue3中将hook与业务结合，让代码更加健壮","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"关于“输出”这件事","slug":"日常/关于记录这件事","date":"2021-09-11T16:00:00.000Z","updated":"2022-12-11T13:51:24.090Z","comments":true,"path":"2021/09/12/日常/关于记录这件事/","link":"","permalink":"https://bluedancers.github.io/2021/09/12/%E6%97%A5%E5%B8%B8/%E5%85%B3%E4%BA%8E%E8%AE%B0%E5%BD%95%E8%BF%99%E4%BB%B6%E4%BA%8B/","excerpt":"","text":"​ 这段时间工作比较忙，没有输出，倒也不是懒，不想输出，而是最近工作上事情非常杂乱，并且工作角色发生转变后，工作内容也跟着发生了很大变化，而我又是一个做事追求完美的人，所以这段时间很多杂七杂八的事情让我焦头烂额，关于工作的事情日后再谈吧，今天聊聊输出这件事情 举个栗子​ 在聊聊输出之前，我先说一个日常的例子。 ​ 去年夏天，我爸妈给了一些茶叶，虽然一直没有喝茶叶的习惯，但是本着不浪费的心态，便从犄角旮旯里找到了不知几年前的双层玻璃杯。 大概是这样的 ​ 这种茶杯喝茶叶确实还可以，我逐渐便养成了喝茶叶的习惯，可惜好景不长，不小心摔碎了，之后又从爸妈那里拿了一个双层玻璃杯，依旧好景不长，玻璃杯又碎了，后面我想，这一直碎下去不是个办法，便买了一个茶叶过滤器。 ​ 心想这次不需要再担心杯子碎掉的问题了，到手使用了一段时间后便发现与我现象的不一样，这玩意特别不方便清理，每次拆卸特别麻烦，并且每次都需要手接触，感觉很不卫生，于是喝茶叶的习惯便与我渐行渐远。 ​ ​ 通过这个小事，大家就能发现一个习惯的形成与良好的体验有非常大的关系，并且就算大众方案也不一定就是相对个人的最佳方案 ，例如有些人使用双层玻璃杯易碎（比如我），有些人觉得不美观，这些问题都会导致一个习惯无法形成； ​ 即使当事人存在内在动机，但是不理想的外在因素也会导致最终意愿无法未达成。输出也是这样，即使有一个想输出的心，但是没有良好的输出环境，也可能造成输出习惯的养成失败。 ​ 工欲善其事，必先利其器；一个适合自己的编写环境是如此的重要。 输出工具的选择​ 在我还没有正式工作之前，就接触到了Typora，简单高效的语法 + 所见即所的功能，让我至今都离不开Typora ​ 但是随着1.0版本后的收费以及自身不具备生态能力，让我在多个设备切换上造成了很大的困扰，虽然我几乎所有的文档都在github上，但是因为未知原因，每次pull push失败的可能性很大，所以谈不上好的体验。 ​ 后来接触了【羽雀】 【飞书】 【wolai】 【Notion】，这些专业工具中最让我感觉眼前一亮的是“Notion”，其强大的all-in-one理念确实实现的不错，但是因为他是国外软件，分享出去的链接，别人偶尔会打不开，亦或者打开速度缓慢，这让我心里非常犹豫，结果兜兜转转还是回到Typora（作者使用的是免费版本）。 ​ 关于各种工具，各位同学可以都试用一下，没有好与坏，只有合适或者不合适，目的是选择一个最适合自己的，自己最满意的文档记录工具。 在这个过程中我也参考了别人的一些工具集，最终确定了以下方案 坚果云 + Typora + Picgo + 七牛云 坚果云：同步文件夹资料，补充Typora不具备的云功能 Picgo + 七牛云：解决图片资源上云问题 ​ 目前这一套使用感觉还可以，比较满足个人开发角色的需求，除了安装部署有点麻烦，使用过程·中仅需要关注输出本身；如果大家有什么比较好的方案，也请评论区推荐~ 输出的意义​ 为什么要输出？为什么要把自己的劳动成果开放给还不相关的人？ ​ 因为输出会让你更加了解你正在输出的内容，很多事情，在编程世界，其实过程比结果更加重要，也许某一篇博客的一段话，是作者花费很多时间，经过多方论证得到的结论；而相对于结论，多方论证的过程对于当事人更加具有价值。 ​ 在输出中我个人非常推崇费曼学习法，在写作中我们带入费曼学习法 ​ 首先将文章的全部内容输出出来，再这个过程中带入阅读者角色，思考他们需要知道些什么。 ​ 然后便是回顾，通读自己的文章，看看是否存在论点不足的情况，在这一步可以交给你的同事、同行，从第三者视角在看看 ​ 获得反馈后回到原始资源，再次学习，再次输出，在二次输出的过程中简化文章，查缺补漏； ​ 最后便是传授，在确保自己理解没有问题后，便输出到社区，教会另一个人，经过了费曼学习法的过程，你面对读者的任何问题，都可以给出合理解释。 ​ 在这样长期的成长性思维中，你的深入思考会让你的个人能力越加厚重，同样是三年开发，你的’功力’便更显深厚，同时高质量的输出也帮助了其他人，这样一劳多得的事我们有什么理由不去做呢？ ​ 这里就有同学说了，我做业务开发没啥深度，写的文章也没人看，甚至怕输出错误的关键，没有任何动力啊。 ​ 我想告诉大家，这是非常非常正常的现象，回想刚开始写代码的时候，是不是也是磕磕盼盼不自信，没有人可以一开始就达到高水平状态，都是需要慢慢练习。 遇到实现问题，输出问题记录文章 闲暇时间可以解读、实现一些常用函数的源码解读文章 针对业务难题可以输出核心方案实现文章 ​ 最开始可以仅仅输出给自己看，将自己作为一名读者，看看是否能轻松看懂你想表述的含义，在这个过程中要记住，输出是为了在深度学习中加深自己的理解 ​ 将反复优化的文章发布到社区，是为了验证自己的理解是否正确，是否有价值，在这个过程中如果能帮助到别人，那是锦上添花的事情，即使没人阅读，无人点赞，你已经得到你深度学习的目。 ​ 在这个过程中，你的沉淀会越来越深，核心竞争力越来越强，输出的文章也会越发高质量，进入不断增长的正向循环。 最后​ 说了这么多输出的好处，其实都是内在因素，需要当事人发自内心的认同，正确的认识输出的价值。 ​ 而我们可以控制的外在因素是如果通过工具创造更好的输出环境，这也是我想告诉大家的一点，一个较好的输出环境，会对输出起到正面作用，提升当事人的输出意愿。 ​ 如果在输出上出现太多门槛，最终会造成当事人失去输出意愿；不进行输出世界不会有任何影响，依旧有很多人认识到输出的重要性，损失最大的是失去深度学习机会的自己。","categories":[{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"输出","slug":"输出","permalink":"https://bluedancers.github.io/tags/%E8%BE%93%E5%87%BA/"}]},{"title":"JS文件格式相互转换","slug":"技术类文章/JavaScript 文件格式互转","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.086Z","comments":true,"path":"2021/06/15/技术类文章/JavaScript 文件格式互转/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/JavaScript%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%92%E8%BD%AC/","excerpt":"","text":"base64 转 File1234567891011121314151617181920/** * base64转file文件 * @param dataurl * @param filename * @returns */ export function dataURLtoFile(dataurl: string, filename: string) &#123; // 获取到base64编码 const arr = dataurl.split(&#x27;,&#x27;) // 将base64编码转为字符串 const bstr = window.atob(arr[1]) let n = bstr.length const u8arr = new Uint8Array(n) // 创建初始化为0的，包含length个元素的无符号整型数组 while (n--) &#123; u8arr[n] = bstr.charCodeAt(n) &#125; return new File([u8arr], filename, &#123; type: &#x27;image/jpeg&#x27;, &#125;)&#125; base64 转 blob12345678910111213141516/** * base64转blob文件 * @param dataURI * @returns */export function dataURItoBlob(dataURI) &#123; var mimeString = dataURI.split(&#x27;,&#x27;)[0].split(&#x27;:&#x27;)[1].split(&#x27;;&#x27;)[0] // mime类型 var byteString = atob(dataURI.split(&#x27;,&#x27;)[1]) //base64 解码 var arrayBuffer = new ArrayBuffer(byteString.length) //创建缓冲数组 var intArray = new Uint8Array(arrayBuffer) //创建视图 for (var i = 0; i &lt; byteString.length; i++) &#123; intArray[i] = byteString.charCodeAt(i) &#125; return new Blob([intArray], &#123; type: mimeString &#125;)&#125; blob转url1234567891011121314151617181920/** * blob 转 url * @param base64 * @param contentType * @returns */export function translateBase64ImgToBlob(base64, contentType) &#123; var arr = base64.split(&#x27;,&#x27;) //去掉base64格式图片的头部 var bstr = atob(arr[1]) //atob()方法将数据解码 var leng = bstr.length var u8arr = new Uint8Array(leng) while (leng--) &#123; u8arr[leng] = bstr.charCodeAt(leng) //返回指定位置的字符的 Unicode 编码 &#125; var blob = new Blob([u8arr], &#123; type: contentType &#125;) var blobImg: any = &#123;&#125; blobImg.url = URL.createObjectURL(blob) //创建URL blobImg.name = new Date().getTime() + &#x27;.png&#x27; return blobImg&#125;","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"在Option API中使用 Custom hook","slug":"技术类文章/使用reactivity 在vue2中编写hook函数","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.088Z","comments":true,"path":"2021/06/15/技术类文章/使用reactivity 在vue2中编写hook函数/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/%E4%BD%BF%E7%94%A8reactivity%20%E5%9C%A8vue2%E4%B8%AD%E7%BC%96%E5%86%99hook%E5%87%BD%E6%95%B0/","excerpt":"","text":"适应人群： 项目的vue2.x的版本， 还没在正式环境使用过composition API 但是又想享受hook带来的优势 ​ 注：本文提出的方法并非最佳实践，而是是vue2项目渐进式切换到vue3的方案，保留的大家熟悉的编写方式，也保留了hook的优势，如果开发团队条件允许的话，建议直接使用composition API语法来完成逻辑编写 什么是hook​ hook 翻译过来是钩子，在程序上体现为在行为执行之前，先把行为勾住，不让其继续，优先执行你的hook函数 用一张图来表示即为 左边为正常函数执行流程，右边为存在hook的执行流程 没有hook之前，我们如何对待代码复用​ 我们假设一种场景，你正在开发一个后台管理系统，在这个后台管理系统中，大部分都是查询表单，他们虽然业务不同，但是逻辑上存在一定的共性 共性元素：查询条件 列表数据 分页相关数据 加载状态 以上4个特征几乎每个表单都有，这就意味这你在写每一个表单的时候都需要重复对接相关的逻辑，这个问题在vue2中存在两种解决办法 每次都复制逻辑相同的代码 使用vue mixins完成逻辑公用 然而这2种方式都存在问题 复制代码低效率，虽然相对稳定，但是编码与测试工作量较大 vue mixins可以实现逻辑抽象，但是这种方案过于简单粗暴的方案，数据全局共享，过多使用mixin会导致项目走向失控，是一个比较危险的方案 假设表单页面数据结构如下 12345678&#123; data: [], // 列表数据 currentPage: 1, // 当前页面 pageSize: 0, // 每一个分页的数量 thePageSize: 0, // 本页数量 totalPages: 0, // 总页数 totalSize: 0, // 总记录数&#125; 除了以上后端返回的数据，我们还需要在页面增加一些状态值,用于优化用户体验 1status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;error&#x27; | &#x27;success&#x27; | ... // 当前列表请求的状态 以上的数据 + 状态每一个后台表单页面都存在，这就意味着重复的声明，重复的对接，重复的测试 ​ 复制代码的方式看似稳定，实则不稳定，因为每一次都要对重复逻辑进行测试，并且由于此类工作繁琐且重复劳动，开发人员一般比较抵触此类任务 ​ 这个问题在vue2中并没有非常好的解决方案，针对这个问题隔壁react从mixin到HOC最后到现在hook，给出了还不错的解决方案。 ​ 现在@vue&#x2F;composition-api提供了hook的能力，我们可以在vue中使用hook来优化提出的问题 通过hook来完成逻辑共用​ 接着上面的场景，我们现在假设我们有3个后台表单页面需要写 ​ 传统编码方案（未使用hook） ​ 可以看到我们需要写的三个页面流程上存在很多相似的地方，对接数据环节，虽然是大部分代码相同，但是还是需要重复的编写测试，例如页码相关，状态相关逻辑 ​ 使用hook完成重复逻辑抽象 每次调用useHook都会生成一次独立的状态 虽然状态与逻辑依赖与组件，但是useHook可以在组件外部进行定义，这一点是之前无法做到的 ​ 虽然不同页面的内部逻辑细节都是不一样，但是总体流程、数据结构都是一样的，基于这样的前提，我们就可以针对共性来进行抽象，之后不论多少个页面，我们都使用抽象逻辑，也只需要维护抽象逻辑 提供 组合式 API 的 Vue 2 插件​ 虽然hook是vue3版本才提出的，但是这并不代表hook与vue3是绑定关系，实际上在任何前端应用中都可以使用vue3中提供的hook功能 文档地址：@vue&#x2F;composition-api 所以不论是vue3还是vue2，还是react，甚至html都可以使用这个npm包 关于vue3的响应式核心包 @vue&#x2F;reactivity的具体实现，可以看看之前的文章 简易版Reactivity源码解析，读懂源码之后，自然解答了你对reactivity的全部疑问 实战（useReqList） 为了方便理解，以下代码为vue2.x，使用js进行编写 ​ useReqList是一个自定义hook，作用是帮助我们抽象后台表单的公共逻辑，我们先看看未使用的情况，使用了之后，代码的变化，再看看如何实现 未使用useReqList123456789101112131415161718192021222324252627282930313233// ...data() &#123; return &#123; // ... shopList: [], // 数据 homePage: 0, // 本页有多少数据 allPage: 0, // 总共多少页 totalSize: 0, //总共多少条数据 pageSize: 0, // 每页最多多少条数据 currentPage: 1, // 当前页码 &#125; &#125;,methods:&#123; init() &#123; this.loading = true const data = &#123; currentPage: this.currentPage, //... &#125; request(data) // 请求 .then((res) =&gt; &#123; this.shopList = res.data.data this.currentPage = res.data.currentPage this.pageSize = res.data.pageSize this.totalSize = Number(res.data.totalSize) this.homePage = res.data.thePageSize this.allPage = res.data.totalPages &#125;) .finally(() =&gt; &#123; this.loading = false &#125;) &#125;,&#125; 使用useReqList123456789101112131415161718import &#123; useReqList &#125; from &#x27;@/utils/hook/useReqList&#x27;// ...data() &#123; return &#123; dataList: useReqList() &#125;&#125;,methods:&#123; init() &#123; const data = &#123; currentPage: this.listData.currentPage || 1, //... &#125; this.listData.run(request(data)) // 请求 &#125;,&#125;// let &#123; data, currentPage, pageSize, thePageSize, totalPages, totalSize, status &#125; = this.listData 通过上面的例子可以看到，使用了useReqList之后 公共变量，公共逻辑部分被抽象出去，页面代码变得更加纯粹 因为reactivity的特性，它们都是具备响应式 避免重复编码，重复测试环节，节省开发时间 hook可以给n个接口使用，只要是请求表单接口，都不需要写重复部分的代码，避免调试，测试环节 接下里我们可以看看这是如何实现上面使用的自定义（Custom） Hook useReqList useReqList具体实现 ​ 内部实现就是对公共逻辑的封装，被读取的数据被reactive处理后具备了响应式，每次声明都会因为闭包的特性而开启一片独立的内存来供声明单位使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import &#123; reactive &#125; from &#x27;@vue/reactivity&#x27;/** * 针对后台表单页面逻辑的抽象 * @returns */export function useReqList() &#123; const defaultState = &#123; data: [], // 表格数据 currentPage: 1, // 当前页面 pageSize: 0, // 分页数量 thePageSize: 0, // 当前页面数量 totalPages: 0, // 总页数 totalSize: 0, // 总数量 error: null, // 错误原因 status: &#x27;idle&#x27;, // 当前状态 idle | loading | success | error &#125; let state = reactive(&#123; ...defaultState, &#125;) /** * 请求成功 * @param data */ const setData = (data) =&gt; &#123; state.currentPage = data.currentPage state.pageSize = data.pageSize state.thePageSize = data.thePageSize state.totalPages = data.totalPages state.totalSize = Number(data.totalSize) state.data = data.data state.status = &#x27;success&#x27; &#125; /** * 请求失败 * @param error */ const setError = (error) =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = error state.status = &#x27;error&#x27; &#125; const setLoading = () =&gt; (state.status = &#x27;loading&#x27;) const setPage = (num) =&gt; &#123; state.currentPage = num &#125; const setReset = () =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = null state.status = &#x27;idle&#x27; &#125; const run = (promise) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&#x27;请传入 promise 类型数据&#x27;) &#125; if ([&#x27;loading&#x27;].includes(state.status)) &#123; return Promise.reject(&#x27;当前正在请求中&#x27;) &#125; setLoading() return promise .then((res) =&gt; &#123; setData(res.data) &#125;) .catch((err) =&gt; &#123; console.log(err) setError(err) &#125;) .finally(() =&gt; &#123;&#125;) &#125; return &#123; run, setReset, setData, setPage, setLoading, setError, state, &#125;&#125; ​ 这样的封装体基本适配大部分vue2.x开发的后台管理系统的项目，如果想在项目中使用只需要修改一下setData部分适配一下后端数据即可 更多的vue hook函数​ hook工具库，VueUse，库里面提供了大量的常用方法，掘金上面有该工具库的介绍文章，官网说明该库是兼容vue2文档了 vue项目应当在什么使用下使用hook关于Class API与Composition API​ 从Class API&#x2F;Option API转变向Composition API的过程中是阵痛的，这2种API在思维方式上存在很大差异 ​ 对于长时间写Class、vue2.x的人来说，最初接触vue3几乎发现不了非常明显的优点，setup语法不熟练的情况下基本还是按照Class的思维进行编码，无法发挥Hook的优势，导致写一段时间Vue3后的结论是：在单文件中class的代码组织能力几乎完爆setup语法… ​ 后来组件有一些项目经验，重新学习了react hook，逐渐对hook有了一些理解；Hook主要完成逻辑与逻辑的分离，在react和vue中使用hook可以实现 视图与视图的分析，视图与逻辑的分离，逻辑与逻辑的分离，用这个的方式来实现单一职责，在此基础上完成逻辑与视图的低耦合高内聚代码 ​ 对于vue2的开发者在而言，可以渐进式的从vue2到vue3，先熟悉hook，在熟悉Composition API 关于hook与vuex | observable​ 从普遍意义上来说hook是可以替代vuex的，react中的API useContext就提供了类似功能。 vuex是无法替代hook的，他并不具备闭包的特性，使用vuex的话，那仅仅是拆分逻辑，有多少页面还是要写多少重复逻辑只是重复代码转义到vuex中而已 ​ 但是刚接触hook不久的新手而言，很容易进入一个误区；将变量，逻辑封装在一个hook中的情况下，又在多个页面中使用，就会在内存中创建多个不共享的内容一致的空间，对于公共变量还是要使用全局状态管理库的。 ​ hook风格的全局状态管理库，建议可以试试Pinia 结语​ 使用过了一段时间的setup语法之后，对其看法也是慢慢从谨慎疑惑转变成为拥抱hook，Composition API 在逻辑抽象、类型推导、多方面均占优，虽然目前还存在一些小问题，后面的迭代都会解决的，在未来几年Custom Hook将会越来越普及，拥抱Custom Hook,Vue3吧! 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"使用gitlabCI/CD完成前端自动化部署","slug":"项目解决方案/使用gitlabCICD完成前端自动化部署","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.094Z","comments":true,"path":"2021/06/15/项目解决方案/使用gitlabCICD完成前端自动化部署/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8gitlabCICD%E5%AE%8C%E6%88%90%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","excerpt":"","text":"2021年11月16日更新 静态数据提取为变量 增加备份版本 前言为什么使用CI&#x2F;CD？ ​ 目前我们公司更新使用的轻量化更新脚本，更新操作虽然简单,但是不够规范，并且敏感信息存在开发者电脑中，虽然我们git上进行了配置文件忽略，但是依旧存在泄密的风险，为了防止以上情况出现，我们将敏感信息移植到gitlab中，并且将更新操作从人工变为自动化 CI&#x2F;CD的优点自动构建并且状态是每个人都可见的 减少手工的错误，解放了重复劳动力 更好，更快，更加安全，更加稳定的交付 在CI的过程中可以进行代码质量的自动检测，减少人工检查的劳动力 打包环境一致，不会出现编译后代码异常 减少等待时间，更快的交付成果 前置概念CI​ 持续集成（continuous Integration）频繁的将代码继承到主干。目的是让产品可以快速迭代，同时还能保证高质量，他的核心措施就是代码继承到主干之前，必须通过自动化测试，只有存在失败，就不能集成。”持续继承并不能消除bug，而是让他非常容易发现和修改” CD​ 持续交付（continuous Delivery）与持续部署（continuous Deployment）频繁的将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过就会进入生产阶段，持续交付可以看做持续集成的下一步，它强调的是不论怎么更新，软件都是随时随地可以交付的；代码通过评审之后，自动部署到生产环境，持续部署是持续交付的下一步，持续部署的目标是，软件在任何时刻都是可以部署的，可以进入生产阶段 gitLab​ gitLab是一个开源的应用程序，他可以实现私有化的Gti项目仓库，可以通过web界面进行访问公开或者私人项目 gitLab CI&#x2F;CD​ gitLab持续集成，只要在仓库的根目录添加.gitlab-ci.yml文件，并且配置了gitLab runner（运行器），每次代码发生变成的时候就会执行.gitlab-ci.yml中的配置 gitLab Runner​ gitLab Runner是一个开源项目，支持多平台运行，他的作用是每次代码发生变更的时候gitlab CI会根据.gitlab-ci.yml，配置文件执行流水线（Pipeline）中每个阶段Stages中的Jobs，并将结果发送回gitLab。gitLab Runner是基于gitLab CI的API进行构建的相互隔离的机器，所以gitLab Runner 与gitlab本身不需要安装在同一台机器上，并且考虑到执行Runner对资源的消耗，以及安全性问题，所以并不建议安装在同一台机器上 Pipelines​ 流水线，是分阶段的构建任务，比如安装依赖，运行测试，打包部署，流水线由gitLab Runner进行触发，流水线运行的依据是gitlab-ci.yml Stages​ 构建阶段,也就是流水线的每一个环节，我们可以在 Pipelines中建立多个Stages，所有Stages都会按顺序同步进行，只有当所有的Stages都完成了Pipelines才算成功，默认情况下上一个Stages失败，这条流水线则为失败 Jobs​ 表示构建阶段的作业，关于jobs的设置有很多，比如指定手动触发，指定分支触发，同时运行多个jobs，等等，相同的Stages中的jobs会异步进行，Stages中的jobs全部成功了，Stages才为成功，默认情况下存在jobs失败，这条流水线则为失败 .gitlab-ci.yml​ 在gitLab CI&#x2F;CD中，具体如何运行流水线，是由 .gitlab-ci.yml来管理的，这个文件放在项目仓库的根目录 实例代码： 12345678910111213141516# stages：定义Pipeline中的各个构建阶段，并且定义Stages名称stages: - install - build# 定义 install 阶段的一个 jobinstall-job: stage: install script: - echo &quot;hello install&quot;# 定义 build 阶段的一个 jobbuild-job: stage: build script: - echo &quot;Hello, build&quot; 环境搭建​ 此类文章太多了，请自行查找，本文不做搭建介绍 ​ 针对已经搭建好的gitLab以及runner，为了适应前端开发环境，需要安装了node，cnpm，等等依赖 前置技能git：不会git可以退出直播间了，赶快去学吧 linux：常用命令必须会，不然配置runner，以及编写ci.yml脚本的时候会寸步难行 创建组织，导入git的项目 创建组织主要是为了方便配置CI&#x2F;CD的全局变量，也方便项目的集中管理 ​ 在使用gitlab之前，我们的项目可能会在github，gitee，等等其他代码仓库，为了保留之前记录，我们需要将git仓库移植过来 我们之前使用的是gitee，gitlab没有对此做快捷支持，所以我们使用Repo URL,填写好地址与账号，就可以将git仓库导入进来 更新git文件我们将git迁移到gitlab之后，现有项目中的.git文件都需要进行更换，不能再向之前的仓库提交代码。 停止代码提交 获取最新代码，切换到master分支 clone 新的gitlab的仓库 获取新的.git文件，覆盖原本项目中的.git，完成迁移 到目前为止，我们就可以完成git项目的迁移操作 配置组织的CI&#x2F;CD变量​ 组织中的项目大部分都是更新到一个服务器，例如服务器地址与密码，我们可以将这部分数据统一配置到全局变量，这样组织中的项目则无需再次进行设置 注意： 因为我们的项目不仅仅是master分支会运行runner，如果这里不关闭State，除了master（受保护的分支）其他的分支都访问不了这个变量 CI&#x2F;CD的变量功能可以很好的保护项目的隐私数据，可以隔离使用者与项目更新配置 配置gitlab-runner（linux） 注意：本文无搭建gitlab以及gitlab-runner相关教程，一切都是在已经搭建完成的基础上进行使用的 ​ 我们针对项目就要注册一个runner，来完成我们接下来配置中的命令操作，这部分界面操作无法完成，需要对gitlab runner的服务器进行操作 获取配置相关数据 注册自定义runner我们需要注册一个特定的runner，这里官方提示顺序为 安装runner 注册一个runner，并且URL指定为xxx，token指定为xxx 接下来我们就要去runner宿主机上面注册 使用终端工具链接宿主机 输入命令 1gitlab-runner register 完成配置之后，在回到项目CI&#x2F;CD部分的设置,就会发现下面多一个runner 注：刚刚注册的runner状态是黑色的，等会就会变成绿色 到此为止，runner已经准备就绪，他会执行我们项目中的.gitlab-ci.yml文件中的配置 编写.gitlab-ci.yml 具体编写过程请查看官方教程 ps：注意一点，线上静态文件最好不要命名为dist，CI脚本中dist为中转站文件夹，命名为dist会出现问题 1234567891011121314151617181920212223242526272829303132333435363738394041stages: # 分段 - install - build - deploycache: # 缓存 paths: - node_modules - admininstall-job: stage: install only: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - npm install - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./dist $USERNAME@$HOST:$UPLOADDIR/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/xxxx # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/xxxx # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 在配置文件中配置了执行的分支，当我们在prod-pre分支上提交代码的时候，脚本就会自动执行 install项目依赖 build项目 发射到目标服务器 这样就完成我们项目的自动化部署 CI脚本的优化优化自动化部署速度上面我们完成了一个简单的流水线，他可以完成 install build delay，已经满足了基本要求，但是还存在一些小问题 流水线任务时间过长 频繁install存在失败的概率 我们需要优化我们的CI，让速度更快更加稳定 build环节与delay环节没有太大的操作空间，并且大部分的时间都花在install环节，我们启用了gitlab的cache，实际上并不需要每次都打包，针对这个思路我们修改我们job中的 install，在job中增加当前是否存在**node_modules&#x2F;**的判断 123456789install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot; 这样存在缓存的时候就会跳过install阶段，但是这样还存在一个问题，我们修改了依赖，但是gitlab里面缓存还在，必然会出现打包异常的情况，针对package.json发生变化，我们再增加一个job，监听package.json 是否发生变化 静态数据提取为变量 假如存在多个项目，使用本脚本只需要修改此处的variables即可，不需要改script部分 1234variables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹 增加备份功能 删除原有备份文件(仅在生产环境) 删除原有文件 备份原本的代码(仅在生产环境) 将打包完成的文件复制到目标服务器 将目标文件改为服务端真正文件 .gitlab-ci.yml（正式版本） 指定了prod分支，根据实际项目进行修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263stages: # 分段 - repInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹cache: # 缓存 paths: - node_modules - distrepInstall-job: stage: repInstall only: refs: - prod changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - echo &quot;发射到目标服务器✨✨✨&quot; - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/backup/$BACKUPDIR # 删除原有备份文件(仅在生产环境) - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/$PRODDIR/ $UPLOADDIR/backup/$BACKUPDIR/ # 删除原有文件 备份原本的代码(仅在生产环境) - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 - echo &quot;完成更新👏👏👏&quot; after_script: - echo &quot;完成更新👏👏👏&quot; .gitlab-ci.yml（简化） 指定了prod-pre分支，根据实际项目进行修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758stages: # 分段 - preInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist_test # 线上文件名cache: # 缓存 paths: - node_modules - distpreInstall-job: stage: preInstall only: refs: - prod-pre changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/$PRODDIR # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 代码地址：github 结语​ 除了使用gitlabCI&#x2F;CD来完成自动化部署之外也可以使用Jenkins+webHook来完成，效果都是一样的，如果这两种方案对你，或者你的公司来说都比较复杂，那么我建议试试轻量化更新方案，我们也在实际项目上使用过很久，可以确保不会出现稳定性，是可以在生产环境使用的 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"使用iframe+postMessage通信实现商城多页面装修","slug":"项目解决方案/使用iframe实现页面装修方案","date":"2021-06-14T16:00:00.000Z","updated":"2022-12-11T13:51:24.094Z","comments":true,"path":"2021/06/15/项目解决方案/使用iframe实现页面装修方案/","link":"","permalink":"https://bluedancers.github.io/2021/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8iframe%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E8%A3%85%E4%BF%AE%E6%96%B9%E6%A1%88/","excerpt":"","text":"演示视频演示视频 背景​ 开发项目是多商家的类似有赞的商城后台，需要支持客户端的店铺装修功能 ​ 系统用户多为企业用户对页面效果要求较高，导致首页变化非常频繁 前言2020年第一版本装修上线了，方案是后台“模拟”客户端样式实现可视化，实现首页装修功能 实际上也就是后台写一套与客户端一样的样式解析装修json，实现装修预览的效果 模拟版本的装修上线后，确实解决了多店铺个性化首页的问题，实现了定制化首页，但是随着时间的推移，模拟版本暴露了很多问题，高频率的改版导致需求几乎无法满足 装修数据为静态数据，不会根据商城商品状态而变化，例如某某商品下架了，但是首页装修数据里面依旧存在 每次客户端样式发生变化，后台都需要同步编写一份，否则就无法可视化，导致工作量非常大 不具备扩展性，只能可视化的装修首页，无法可视化装修其他页面，其他页面都是通过一个插槽实现 插槽就是一个json对象的载体，因为不想写2套样式，所以采取这种很抽象的方案 随着业务的拓展，暴露出来的问题也是越来越严重，为了满足需求，很多场景下需要牺牲整个技术部门的效率，以及使用者的体验感，为了解决这个问题必须另辟蹊径，寻找其他解决方案 新方案必须解决以下问题 装修中的商品数据必须为非静态数据 避免2套样式的问题 装修中的商品数据实时刷新可以通过约定有规律的数据结构，后端解析并实时更新商品数据，实现装修中数据的更新 抛弃模拟方案后，也是思考很多方向，但是因为基于业务组件装修是没办法整个装修数据都json化的，所以最终尝试了一个理论上可行的方案，客户端通过iframe嵌入到后台，使用postMessage来完成后台与客户端之间的数据交互，实现装修功能 方案逻辑图 后台装修与客户端的主要思路 装修模式下获取上次的装修记录 建立前后台iframe之前的的联系 后台装修发生变化，触发watch，watch触发postmessage，客户端得到相应，客户端watch触发，实时更新装修数据 装修完成保存到数据库 具体实现方案之前在掘金发布过一篇（开源）从0打造H5可视化搭建系统 - 易动（vue+ts+egg）文章，易动是更加灵活的装修方案，感兴趣的同学可以了解一下 按基础组件定制装修方案，基础模块为： 按钮 文本 图片 轮播图此类数据 等等 本次的装修是基于业务组件进行区分，他的核心原理就是通过iframe进行数据交互实现实时装修功能 定制组件数据结构客户端根据json数据进行组件的展示的，所有首先，我们需要定义好客户端与后台通用的数据结构，用于声明我们的装修数据 例如我定义的数据结构，仅供参考 示例 搜索框 轮播图 1234567891011121314151617181920212223242526272829303132333435363738&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, &#123; id: guid(), compName: &#x27;drag-swiper&#x27;, name: &#x27;轮播图&#x27;, data: [ &#123; interval: 5000, data: [], // 数据 item: &#123; // 单个数据 img: &#x27;https://images.591wsh.com/2021/02/03/thumb_32371580472397824.png&#x27;, isLogin: false, // 是否需要登录, linkType: 2, // 1 无链接 2 商品 3 外部链接 4分类 commodity: &#123;&#125;, // 商品id dataurl: &#x27;&#x27;, // 外部链接 categoryid: &#x27;&#x27;, // 类目id &#125;, isUpdate: true // 告诉服务器是否需更新data里面的商品数据 &#125; ], css: &#123; height: 266, // marginTop: 20 &#125; &#125;, 为装修中的客户端页面增加一个组件 增加，修改，删除都会走如下逻辑，一句话说就是数据后台操作数据，客户端可以做出响应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 后台点击右侧装修组件，例如点击 搜索框// 匹配到搜索框的文字匹配定制的数据结构，得到如下点击的数据结构&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, // 后台通过监听存储装修数据变化的字段通知到客户端 computed: &#123; // ..... // 可使用组件 pageComponents: &#123; get() &#123; let &#123; pageComponents &#125; = this.$store.state.template if (pageComponents instanceof Array) &#123; // 组件数据发生变化的时候需要通知到客户端 this.iframeMessage(pageComponents) return pageComponents &#125; else &#123; return [] &#125; &#125;, set(data) &#123; // 更新组件顺序 this.$store.commit(&#x27;template/update_current&#x27;, data) &#125; &#125; // ...... &#125;, methods:&#123; // iframe加载完成的回调函数 iframeLoad() &#123; console.log(&#x27;iframe加载完成&#x27;) this.frm = document.getElementById(&#x27;iframe&#x27;) // 告诉客户端，目前处于装修中 this.frm.contentWindow.postMessage( &#123; isIframe: true &#125;, &#x27;*&#x27; ) &#125;, // 通知客户端数据发生了更新 iframeMessage(data) &#123; console.log(data) if (this.frm) &#123; this.frm.contentWindow.postMessage( &#123; tempLateData: data &#125;, &#x27;*&#x27; ) &#125; &#125;, &#125; // 客户端通过postMessage进行最新的装修数据接收window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.tempLateData) &#123; store.commit(&#x27;app/setTempLateData&#x27;, event.data.tempLateData) &#125; // ....&#125;// 客户端对应的页面再监听存在在vuex中的装修数据computed: &#123; ...mapState(&#123; tempLateData: state =&gt; state.app.tempLateData, // 后台的装修数据 hoverComponent: state =&gt; state.app.hoverComponent, // 当前鼠标浮动的元素id clickComponent: state =&gt; state.app.clickComponent, // 当前鼠标点击选中的数据 isIframe: state =&gt; state.app.isIframe, // 当前是否在装修模式里面 &#125;),&#125;,// 客户端替换从接口获取的之前的页面装修数据，装修数据显示在页面上watch: &#123; tempLateData() &#123; // 一旦后台通过postMessage更新装修数据，就可以替换原本接口获取的数据，实现实时装修功能 this.indexData = this.tempLateData || [] &#125;,&#125;, 修改装修的组件数据12345678910111213141516// 后台选取选中的组件// 后台针对每个装修组件都建立一个vue文件进行json内数据的改变‘// activeComponent.compName 为选中的组件compName，例如我选中搜索框 这里就是`drag-search-data`组件，这里可以是xxx-xxx-data组件&lt;template&gt; &lt;div class=&quot;template_right&quot;&gt; &lt;component v-if=&quot;activeComponent != false &amp;&amp; activeComponent.compName&quot; :is=&quot;activeComponent.compName + &#x27;-data&#x27;&quot; :compData=&quot;activeComponent&quot; &gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;// 组件内部绑定搜索框的提示文字，每次修改都会触发后台的计算属性·pageComponents·，进而后台通过postMessage通知到客户端，客户端进而存储到vuex，vuex值发生变化，客户端页面的watch起作用，页面发生变化，就吃实现组件数据的变化 点击客户端组件，通知后台并实现选中我们知道，在装修里面点击客户端，就直接点击到了客户端，所以点击客户端的跳转函数，我们必须进行拦截， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 前提须知 客户端每个装修组件的id都会在客户端写入到class中&lt;component :is=&quot;xxxxx&quot;:class=&quot;[`decoration_$&#123;item.id&#125;`,]&quot;&gt;&lt;/component&gt;// 装修监听函数体内window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.isIframe) &#123; console.log(&#x27;装修开发模式启动&#x27;) store.commit(&#x27;app/setIsIframe&#x27;, true) // 拦截跳转函数 uni.navigateTo = () =&gt; &#123;&#125; uni.switchTab = () =&gt; &#123;&#125; // 监听点击(装修用于选中组件) window.addEventListener(&#x27;click&#x27;, _decoratioclick, false) &#125; // ....&#125;function _decoratioclick(event) &#123; let path: string = &#x27;&#x27; // 每次点击的时候都获取一下包含组件id的class event.path.map((res: any) =&gt; &#123; if (res.className &amp;&amp; res.className.includes(&#x27;decoration_&#x27;)) &#123; path = res.className.split(&#x27;decoration_&#x27;)[1] &#125; &#125;) // 选中客户端当前组件 store.commit(&#x27;app/setClickComponent&#x27;, path) // 告知父级当前选中组件 window.parent.postMessage( &#123; activePage: path, // 将当前点击的组件id通过postMessage传递到后台 &#125;, &#x27;*&#x27; )&#125;// 装修后台mounted() &#123; window.addEventListener( &#x27;message&#x27;, e =&gt; &#123; if (e.data.activePage) &#123; // 获取客户端传递过来的当前组件id 这就是实现点击客户端组件装修后台得到数据 this.$store.commit(&#x27;template/set_activeComponent&#x27;, e.data.activePage) &#125; &#125;, false )&#125;, 添加组件到页面的流程图 客户端与装修后台相互传值总结1234567891011121314151617181920212223242526// 客户端发送window.parent.postMessage( &#123; activePage: path, &#125;, &#x27;*&#x27;)// 客户端接收window.addEventListener(&#x27;message&#x27;, （）=&gt; &#123; // ....&#125;)// 装修后台发送this.frm = document.getElementById(&#x27;iframe&#x27;)this.frm.contentWindow.postMessage( &#123; // ..... &#125;, &#x27;*&#x27;)// 装修后台接收window.addEventListener(&#x27;message&#x27;,e =&gt; &#123; // ...&#125;) postMessage的数据都是实时监听的，所以任意一边传值另一边都可以快速接收到，这是实现本方案的核心，通过postMessage解决了通信上的所有问题，例如 装修后台点击对应组件，客户端可以得到当前点击的组件的id 客户端点击组件可以告知后台，当前用户选中的组件 包括没实现的拖拽排序，都是可以实现的 多页面装修 做页面装修一定要想明白一件事，我们玩的不是装修，只是在操作页面抽象的数据结构 根据上面的想法，我们可以明白，活动页面很多仅仅是换换商品，换换链接，不会动不动就改页面 那个就可以抽象活动页的json数据结构 那么这里对应的就是图片组件 图片组件（优惠券也是图片样式） 商品组件 商品组件 在装修的时候我们定义好数据结构，依次添加这几个组件，客户端活动增加一行watch代码，就可以完美的实现活动页的装修，以及更新活动商品 注：公司项目无法透露，具体逻辑需要大家自己理解了 iframe装修方案优势 100%的完美还原装修样式 可以动态更新装修里面选中的商品的数据，需要数据结构统一化，后端即可按规律解析装修json 如果出现新组件，不需要写2套样式 后台装修定义好数据结构，客户端约定项目结构不变化，理论上整个项目所有页面都可以配置化 iframe装修方案弊端​ 通过iframe实现的前后台交互装修方案中，不仅需要动后台的装修代码，还需要客户端进行“兼容处理”，即客户端需要识别装修模式，与不断更新后台传入的装修数据，存在一定的耦合性 ​ 这种装修方案的弊端就是，如果希望操作起来更加便捷就需要在客户端进行功能的实现，并通过postMessage提交给装修后台 最后大家可以再看一下演示视频 联系我欢迎大家加入qq群吹吹水,一起成长 或者关注我的公众号，不定期更新各种文章：吴凯的随笔","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"使用Prettier完成代码提交的自动格式化","slug":"项目解决方案/使用gitHook来完成代码的自动格式化","date":"2021-05-31T16:00:00.000Z","updated":"2022-12-11T13:51:24.094Z","comments":true,"path":"2021/06/01/项目解决方案/使用gitHook来完成代码的自动格式化/","link":"","permalink":"https://bluedancers.github.io/2021/06/01/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8gitHook%E6%9D%A5%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/","excerpt":"","text":"最终效果 执行git commit 代码自动完成我们定制规则的格式化功能，并提交到本地 使用的npm包prettier：功能依赖包 husky：提供gitHook相关功能 lint-staged：让命令只对发生更改的文件生效 为什么做（WhyHow）​ 在未建立规范之前，每个人的代码风格都是不一致的，并且开发过程中可能会出现忘记格式化，手误的问题，如果在提交之前，可以自动抹平差异统一多人开发风格，这时候作用就体现出来了 ​ 代码风格是每一个程序员都要面对的问题，不论是在个人开发还是在团队协作中，都明白较好的代码风格是保证日后可维护性的关键，所以连不懂的开发或许都知道，要注意代码风格 怎么做（How）​ 到了正在的推进时期，就会面对很多难题，无法确定一个所有人都满意的方案，而就算是少数服从多数，在实际开发中落实也会遇到一大堆问题，例如，编辑器的不同，格式化工具不同，或者说完全没这个习惯，好不容易决定推进了，每次代码审核都需要修改这种细节问题，一来二去就搁置了，实在是头疼，到底该如何将事情完美的落实下去呢？ ​ 这里我们就需要一个权威的规范来帮助我们约束成为一个风格，Prettier表示我先给一个规范，大家先用起来，保证代码的可读性与可维护性，然后大家都遵循这和规则。 ​ 而prettier本身是一个An opinionated code formatter 的格式化工具，我是一个规矩非常严格的框架，并不会给你很多的配置项，喜欢用就用，不喜欢就不用，绝大部分的编辑器集成了prettier，在编辑器的约束下，大家都遵循这个方案就好了 具体配置（What）Vscode下载插件 prettier 项目按下依赖prettier，按文档完成步骤prettier官网 配置commit钩子 ​ 安装好之后，会在项目下生成文件.husky，并修改你的package.json，到目前为止，其实已经配置好了，他会在你每次commit之前执行npx lint-staged，这个命令会执行prettier --write，并且只对本次修改的文件生效 具体命令（躲懒不看文档的看这里~） 当前的prettier版本是2.4.1，如果版本号不一致，建议还是看官网 vscode安装prettier 项目安装prettier 1npm install --save-dev --save-exact prettier 创建配置文件 1echo &#123;&#125;&gt; .prettierrc.json 创建说明不需要格式化的文件 创建文件.prettierignore 写入内容 123# Ignore artifacts:buildcoverage 执行命令npx prettier --write .,格式化现有代码，测试功能是否正常 编写配置文件 1234567891011// json文件改为js文件（看个人习惯）写入内容module.exports = &#123; singleQuote: true, // 单引号 trailingComma: &#x27;es5&#x27;, // 对象属性最后有 &quot;,&quot; semi: false, // 是否需要分号 printWidth: 110, // 一行最多120 jsxSingleQuote: true, // jsx使用单引号 tabWidth: 2, // 一个tab代表几个空格数，默认就是2 useTabs: false, // 不使用缩进符，而使用空格 jsxBracketSameLine: true,&#125; 再次执行npx prettier --write .，对格式化规则有建议参考文档对配置进行修改，知道自己满意 配置gitHook钩子(必须先加入git仓库，不然会无效果) 1npx mrm@2 lint-staged 将代码格式改乱，尝试commit一下，查看功能是否正常（提交之前会被自动格式化） 一些注意事项win电脑.prettierrc.json写入失败这个问题在同事电脑上发现的，使用vscode中powershell执行echo &#123;&#125;&gt; .prettierrc.json,会无写入内容，后面执行的命令也会失败，这里请使用电脑的cmd打开目标文件夹，执行该命令，这样测试是可行的 配置gitHook之后 commit不会自动格式化vue文件这里需要修改在package.json中默认写入的lint-staged中的命令 这里根据项目中是否存在eslint，会写入不太一致，但是问题不打 123&quot;lint-staged&quot;: &#123; &quot;*.js&quot;: &quot;eslint --cache --fix&quot;&#125; 统一改成 123&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,css,md,vue&#125;&quot;: &quot;prettier --write&quot;&#125; 这样每次commit的时候就会自动格式化代码了 结语​ 如果查看本文遇到了一些问题，请到QQ群 530496237，一起吹吹水~","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"同域名下通过一级路由区分实现“前端微构架”","slug":"项目解决方案/单域名下通过子路由区分项目的实现方案","date":"2021-05-31T16:00:00.000Z","updated":"2024-01-04T07:18:02.213Z","comments":true,"path":"2021/06/01/项目解决方案/单域名下通过子路由区分项目的实现方案/","link":"","permalink":"https://bluedancers.github.io/2021/06/01/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%8D%95%E5%9F%9F%E5%90%8D%E4%B8%8B%E9%80%9A%E8%BF%87%E5%AD%90%E8%B7%AF%E7%94%B1%E5%8C%BA%E5%88%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 公司的客户端项目比较庞大，并且由于改动相对频繁，导致更新频率较高，web项目高频率的更新就会引发一系列的问题，例如公众号缓存问题，尤其是ios手机容易出现白屏的情况，访问过程中的用户回退页面会出现白屏的情况，等等很多未知的bug，虽然更新在一瞬间完成，但是还是会影响到部分用户的使用，针对现存的条件以及项目需求 思考到如下优化方案 更新时间上尽量选择用户访问量小的时间段 程序内频繁变化的图片，文字的页面，尽量后台配置装修化，达到减少更新的效果，此处参考使用iframe+postMessage通信实现商城多页面可视化装修 项目能否进行拆分，权重不高的页面（例如：活动页面），与主程序分离，达到减少主程序包更新频率 思考与分析 第一条与第二条非本文重点，只做简要说明 更新时间主要参照我们的客户端监控平台提供的检测数据，一般选择用户访问量较小的时候进行更新 对于项目中频繁改动，但是数据格式固定的活动页，我们使用装修功能，达到不更新代码，只更新数据的效果 ​ 而项目拆分就是我们本文要说到的重点，在调查过程中也了解过微前端，但是我们的客户端项目是uniapp完成的，考虑到技术难度与改动成本，最终放弃了微前端的方案 要怎么做到一个路径下面的项目拆分呢？ 拆分的项目需要满足一下2个条件 拆分的项目必须在同域名下，不可出现跨域名的情况，不然就会出现无法共享localStorage的问题 本次改动不能影响到线上已经存在的业务，不能出现主程序的路由变动 为了满足以上2个条件，则主程序不能进行任何改动，同时需要在当前域名下，想办法再指向一个项目，在同一个域下，localStorage被共享，虽然是2个项目但是在同一个域下 最开始一直在思考客户端如何修改实现，但是一直没想到完美方案，后来，我们另辟蹊径，通过nginx实现通过子路由进行项目区分 nginx进行一级路由区分 通过nginx进行一级路由的判断实现访问不同的静态资源 理想情况下方案是可行的，nginx配置也比较简单 12345678910111213server &#123; // ..... server_name xxxx.com // ..... location / &#123; root /xxx/xxx/xxxx/packageA; try_files $uri $uri/ /index.html; &#125; location ~ /activity/ &#123; root /xxx/xxx/xxxx/packageB try_files $uri $uri/ /index.html; &#125;&#125; 只要访问的项目路由 xxxx.com&#x2F;activity&#x2F;xxxxx,就会访问到项目包packageB，其他的一级路由都会访问到packageA 部署因为项目activityB的访问路由是确定的，所以我们在webpack的配置中就需要对publicPath进行修改 1publicPath: &#x27;/activity/&#x27;, ​ 然后我们nginx会去访问项目包下面的index.html，而经过我们上面对publicPath的修改，打包之后的index.html里面的路径应用就变成了 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/activity/favicon.ico&quot; /&gt; &lt;title&gt;xxxxx&lt;/title&gt; &lt;link href=&quot;/activity/css/app.xxxx.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/activity/js/chunk-vendors.xxx.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/activity/js/app.xxxxx.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时打包上线就会遇到资源访问不到的问题，因为webpack编译出来的程序包里面没有activity这个文件夹，所以对indexPath,outputDir也要进行修改 最终我们的vue.config.js 1234567891011module.exports = &#123; publicPath: &#x27;/activity/&#x27;, // 资源路径 outputDir: &#x27;./dist/activity&#x27;, // 生产环境构建文件的目录 indexPath: &#x27;../index.html&#x27;, // 指定生成的index.html的输出路径 configureWebpack: (config) =&gt; &#123; // .. &#125;, chainWebpack: (config) =&gt; &#123; // .. &#125;,&#125; 到此为止，通过一级路由区分项目已经完成了全部配置 优点 对项目进行拆分，对于非核心程序的页面，例如活动页面等等，即可与主程序进行区分，上线活动页面不干涉主程序 项目分离后，单个项目的页面变少，单个代码包打包速度得到提升，增加项目可维护性 缺点没办法共享公共逻辑代码，例如支付模块，登录模块，等等模块，因为跨项目了，当然这是有解决办法的，即公共模块打包成为npm包，但是这存在一定的工作量 最后欢迎大家加入qq群吹吹水（群号：530496237）一起成长","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"轻量化前端更新方案","slug":"项目解决方案/轻量化前端更新方案","date":"2021-05-31T16:00:00.000Z","updated":"2022-12-11T13:51:24.095Z","comments":true,"path":"2021/06/01/项目解决方案/轻量化前端更新方案/","link":"","permalink":"https://bluedancers.github.io/2021/06/01/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BD%BB%E9%87%8F%E5%8C%96%E5%89%8D%E7%AB%AF%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 一句话介绍：它是可以一行命令将代码更新到服务器的脚本 ​ 轻量级更新方案最开始源于掘金的文章，后来我们从零实现了一个更新脚本，并且已在是生产环境中进行使用很长时间，算是非常稳定的版本，个人认为轻量化更新方案是非常使用小型开发团队 ​ 现在我们切换到了gitlab的CI&#x2F;CD。所以这种方案已经不再是我们的主流方案，但是一路使用过来，非常稳定的解决了更新问题，还是非常不错的 优点： 快速，稳定，自动备份指定文件夹（灵活性高，但是需要自己实现） 缺点：需要手动回滚（自动回滚需要编码），相对来说没那么规范，没有留下记录，敏感数据存储在电脑中，配置文件可以git忽略 核心流程 确认并打包项目 通过node-ssh连接线上服务器 将打包代码指定名称进行压缩 备份之前的代码，删除以前的代码包，并解压压缩包 删除本次打包代码，断开ssh链接 如何使用代码地址 将仓库文件放入项目 安装依赖 1npm install node-ssh inquirer archiver -D 修改upload.config.js内容 增加脚本命令 1&quot;upload&quot;: &quot;node build/upload.js&quot; 运行命名，验证是否功能正常 核心代码build/upload.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const &#123; NodeSSH &#125; = require(&#x27;node-ssh&#x27;)const archiver = require(&#x27;archiver&#x27;)const inquirer = require(&#x27;inquirer&#x27;)const exec = require(&#x27;child_process&#x27;).execconst ssh = new NodeSSH()const uploadFun = require(&#x27;../upload.js&#x27;)/** * 获取当前平台 */let objName = process.argv[2] // 更新名字let startTime = null // 程序开始更新的时间// 获取上传服务器配置let config = uploadFun(objName)const verifyList = [ &#123; type: &#x27;input&#x27;, message: &#x27;您正在更新到线上环境,请确认接口域名&#x27;, name: &#x27;objName&#x27;, &#125;,]inquirer.prompt(verifyList).then(() =&gt; &#123; uploadBuild()&#125;)function uploadBuild() &#123; startTime = new Date() console.log(`$&#123;objName&#125;开始更新`) let buildcmd = exec(config.buildScript, (error, stdout, stderr) =&gt; &#123; if (!error) &#123; console.log(&#x27;打包完成&#x27;, stdout) app() &#125; else &#123; console.error(&#x27;打包出现错误&#x27;, stderr) process.exit(0) &#125; &#125;) buildcmd.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(data.toString()) &#125;)&#125;/** * 通过ssh链接服务器 */function app() &#123; ssh .connect(&#123; host: config.host, username: config.username, password: config.password, &#125;) .then((res) =&gt; &#123; // 上传代码压缩包 uploadData() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)&#125;/** * 上传代码 压缩现有代码 */function uploadData() &#123; // 创建文件输出流 let output = fs.createWriteStream(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`) // 设置压缩级别 let archive = archiver(&#x27;zip&#x27;, &#123; zlib: &#123; level: 8, &#125;, &#125;) // 存档警告 archive.on(&#x27;warning&#x27;, function(err) &#123; if (err.code === &#x27;ENOENT&#x27;) &#123; console.warn(&#x27;stat故障和其他非阻塞错误&#x27;) &#125; else &#123; throw err &#125; &#125;) // 存档出错 archive.on(&#x27;error&#x27;, function(err) &#123; throw err &#125;) // 通过管道方法将输出流存档到文件 archive.pipe(output) archive.directory(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.buildobj&#125;`, &#x27;/&#x27;) archive.finalize() // 文件输出流结束 output.on(&#x27;close&#x27;, function() &#123; console.log(`总共 $&#123;(archive.pointer() / 1024 / 1024).toFixed(2)&#125; MB,完成源代码压缩`) ssh .putFile( `$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, `$&#123;config.uploadDir&#125;/$&#123;config.objname&#125;.zip` ) .then(() =&gt; &#123; console.log(&#x27;程序zip上传成功,判断线上是否需要备份&#x27;) runcmd() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;)&#125;/** * 执行ssh命令 判断当前是否存在备份 */function runcmd() &#123; ssh .execCommand(&#x27;ls&#x27;, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stdout) &#123; let fileList = res.stdout.split(&#x27;\\n&#x27;) if (config.objname == config.backObject) &#123; if (fileList.includes(config.objname)) &#123; console.log(&#x27;当前更新为线上正常环境,开始进行备份&#x27;) backupData() &#125; else &#123; console.log(&#x27;当前更新为线上正常环境,并且是第一次,将跳过备份&#x27;) cmdunzip() &#125; &#125; else &#123; console.log(&#x27;当前为测试环境,无需备份,直接解压上传压缩包&#x27;) cmdunzip() &#125; &#125; else if (res.stderr) &#123; console.log(&#x27;查询指定目录失败&#x27;) &#125; else &#123; console.log(&#x27;ssh链接发生了错误&#x27;) &#125; &#125;)&#125;/** * 备份项目 */function backupData() &#123; ssh .execCommand(`mv $&#123;config.objname&#125; backup/$&#123;config.objname&#125;_backup$&#123;new Date().getTime()&#125;`, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stderr) &#123; console.log(&#x27;备份发生错误&#x27;, res.stderr) &#125; else &#123; console.log(&#x27;完成备份,解压最新代码&#x27;) cmdunzip() &#125; &#125;) .catch((err) =&gt; &#123; console.log(&#x27;备份发生未知链接错误&#x27;, err) &#125;)&#125;/** * 解压最新代码zip */function cmdunzip() &#123; // 解压程序 ssh .execCommand( `rm -rf $&#123;config.objname&#125; &amp;&amp; unzip -o -d $&#123;config.uploadDir&#125;/$&#123;config.objname&#125; $&#123;config.objname&#125;.zip &amp;&amp; rm -f $&#123;config.objname&#125;.zip`, &#123; cwd: config.uploadDir, &#125; ) .then(() =&gt; &#123; console.log(`项目包完成解压,$&#123;config.objname&#125;项目部署成功了!`) console.log(`项目更新时长$&#123;(new Date().getTime() - startTime.getTime()) / 1000&#125;s`) return deletelocalFile().then(() =&gt; &#123; console.log(&#x27;本地缓存zip清除完毕&#x27;) &#125;) &#125;) .then(() =&gt; &#123; ssh .execCommand(`rm -rf $&#123;config.objname&#125;/static/.DS_Store`, &#123; cwd: config.uploadDir, &#125;) .then(() =&gt; &#123; console.log(&#x27;线上项目.DS_Store删除完成&#x27;) ssh.dispose() process.exit(0) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;) .catch((err) =&gt; &#123; console.log(&#x27;解压出现错误&#x27;, err) &#125;)&#125;/** *删除本地生成的压缩包 */function deletelocalFile() &#123; return new Promise((resolve, reject) =&gt; &#123; fs.unlink(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, (err) =&gt; &#123; if (err) &#123; reject(err) throw err &#125; else &#123; resolve() &#125; &#125;) &#125;)&#125; 配置文件upload.config.js 123456789101112131415161718192021222324// 打包核心配置文件let Available = [&#x27;dist-a&#x27;, &#x27;dist-b&#x27;] // dist-a 环境a代码包 dist-b 环境b代码包 npm run upload dist-a/** * 获取更新配置 * @param &#123;String&#125; objName 当前更新名称 * @returns */module.exports = (objName) =&gt; &#123; if (!Available.includes(objName)) &#123; console.log(&#x27;当前项目不存在您输入的更新命令,请检查更新名称&#x27;) process.exit(0) &#125; return &#123; host: &#x27;xx.xx.xx.xx&#x27;, // 服务器地址 username: &#x27;root&#x27;, password: &#x27;xxxxxxxxxx&#x27;, buildPath: &#x27;&#x27;, // 本地打包项目地址(多层路径用这个) buildobj: &#x27;dist&#x27;, // 本地打包文件名称 uploadDir: &#x27;/xx/xx/xx&#x27;, // 服务端项目地址 objname: objName, // 打包项目名称 backObject: &#x27;objName&#x27;, // 备份的文件夹名称 buildScript: &#x27;npm run build&#x27; // 更新命令 &#125;&#125; 触发命令最后在package.json增加一行命令，运行前面的脚本文件 1234&quot;scripts&quot;: &#123; // ...... &quot;upload&quot;: &quot;node build/upload.js&quot; &#125;, 依赖版本​ 因为更新脚本是在项目里面的，所以需要额外安装依赖 推荐版本号 123&quot;node-ssh&quot;: &quot;^12.0.0&quot;,&quot;inquirer&quot;: &quot;^7.3.3&quot;,&quot;archiver&quot;: &quot;^3.1.1&quot;, 实际使用1npm run upload xxxx // 线上代码文件夹名称 upload 命令后面的字符串就是服务器上的文件夹名称，这里为了防止更新命名敲错了，需要首先在upload.config.js中进行更新白名单声明，如果配置都正确的情况下，你就可以看到，这就代表成功了~ 最后​ 脚本文件还存在很高的上限，可以优化一下备份部分的备份代码生成规则，再增加一个回滚代码的脚本，就可以实现线上的无感知回滚了 ​ 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"}]},{"title":"一些算法题","slug":"算法与数据结构/一些题目","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.091Z","comments":true,"path":"2021/03/22/算法与数据结构/一些题目/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/","excerpt":"","text":"题目 两个数组的交集思路： 在一个while循环中不断寻找两个链表的最小值，将其加入结果链表，同时该数据指针向后一位，结果链表也许要向后一位，假如while循环完成还存在某一个未处理的链表数据，直接加入到结果链表 https://leetcode-cn.com/problems/merge-two-sorted-lists/ 时间复杂度：O(n) 空间复杂度：O(1) 123456789101112131415161718192021222324252627282930/** * @param &#123;ListNode&#125; list1 * @param &#123;ListNode&#125; list2 * @return &#123;ListNode&#125; */var mergeTwoLists = function (list1, list2) &#123; let res = new ListNode(0) // 结果 let p0 = res; let p1 = list1 // 指针 let p2 = list2 // 指针 while (p1 &amp;&amp; p2) &#123; // 找到小的值,将其被指向p0,同时概念表后移一位 if (p1.val &lt; p2.val) &#123; p0.next = p1 p1 = p1.next &#125; else &#123; p0.next = p2 p2 = p2.next &#125; // 每次p0都会增加指向,,所以需要每次都手动指向最后一位 p0 = p0.next &#125; // p1或者p2其中一个还存在值,则全部消化掉 if (p1) &#123; p0.next = p1 &#125; else if (p2) &#123; p0.next = p2 &#125; return res.next&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://bluedancers.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树","slug":"算法与数据结构/二叉树","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.091Z","comments":true,"path":"2021/03/22/算法与数据结构/二叉树/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"一种分层数据的抽象模型，例如dom，菜单，树形控件，多层联动选择器 JavaScript中没有树，但是可以用Object和Array构建树 常见操作 深度&#x2F;广度有限遍历，先中后序遍历 二叉树: 树中的每个节点最多只能两个子节点，在JavaScript 中使用Object进行模拟 深度优先遍历含义： 尽可能深的搜索树的分支 12345// 深度优先遍历function inter1(tree) &#123; console.log(tree.value); tree.child.map(e =&gt; inter(e)) // 递归调用&#125; 广度优先遍历含义： 先访问离根节点最近的节点 12345678910111213// 广度优先遍历function inter2(tree) &#123; const q = [tree] // 使用队列存储广度数据 while (q.length &gt; 0) &#123; let c = q.shift() // 每次取队列最后一个 console.log(c.value); c.child.forEach(e =&gt; &#123; q.push(e) // 再次将下一层数据加入队列 &#125;) &#125;&#125;inter2(tree) 先序遍历二叉树定义：先根节点，后左子树，再右子树 123456789// 先序遍历function preorder(root) &#123; if (!root) &#123; return &#125; console.log(root.key); // 首先访问 preorder(root.left) preorder(root.right)&#125; 中序遍历二叉树定义：先左子树，后根节点，再右子树 123456789// 中序遍历function inorder(root) &#123; if (!root) &#123; return &#125; inorder(root.left) console.log(root.key); inorder(root.right)&#125; 后序遍历二叉树定义：先左子树，后右子树，再根节点 123456789// 后序遍历function postorder(root) &#123; if (!root) &#123; return &#125; postorder(root.left) postorder(root.right) console.log(root.key);&#125; 先序遍历二叉树（非递归）1234567891011121314// 先序遍历function preorder(root) &#123; if (!root) return const task = [root] while (task.length) &#123; const n = task.pop() console.log(n.key); if (n.right) task.push(n.right) if (n.left) task.push(n.left) // pop拿最后面的,数组需要保证后进先出,所以left放后面,这样每次循环都会优先使用left,直到left用完,就会用right,当前层级全部用完就会到更加深处或者右边的二叉树 &#125;&#125;preorder(bt) 中序遍历二叉树（非递归）123456789101112131415161718192021function inorder(root) &#123; if (!root) return const task = [] let p = root while (task.length || p) &#123; while (p) &#123; task.push(p) p = p.left &#125; const n = task.pop() console.log(n.key); p = n.right &#125;&#125;inorder(bt)// 首先找到最右边的全部节点,在从最左边开始递归// 在每次将右节点放入下一次循环,因为当前一定是中节点// 右节点完成后找上的中节点,中节点完成后找下右节点,完成二叉树的从左到右的覆盖// task存储所有左节点,当前阶段存在右节点的情况下,数组最后一位是右节点,下次一定会被抛出// p存储下一个右节点,开始下级树的查询 后序遍历二叉树（非递归）12345678910111213141516171819// 后序遍历(非递归)function postorder(root) &#123; if (!root) return const task = [root] const outputTask = [] while (task.length) &#123; const n = task.pop() outputTask.push(n.key) if (n.left) task.push(n.left) if (n.right) task.push(n.right) &#125; while (outputTask.length) &#123; let n = outputTask.pop() console.log(n); &#125;&#125;// 后序的顺序是 先右 再左 再中 首先倒叙先序遍历,获取先中 再左 再右// 最后倒序输出postorder(bt) 题目 二叉树的最大深度https://www.youtube.com/watch?v=H8SjbVxGB1c&amp;list=PLwIrqQCQ5pQmjH6YyFvH2A9FYL6bBB4Ra 时间复杂度：O(n) 空间复杂度：O(n) 思路：使用深度优先遍历（先序）,记录最大递归数量，最后返回 12345678910111213141516171819202122/** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function (root) &#123; let res = 0 /** * * @param &#123;*&#125; n 树 * @param &#123;*&#125; l 层级 */ const dfs = (n, l) =&gt; &#123; if (!n) return if (!n.left &amp;&amp; !n.right) &#123; res = Math.max(res, l) &#125; dfs(n.left, l + 1) dfs(n.right, l + 1) &#125; dfs(root, 1) return res&#125;; 题目 二叉树的最小深度时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历，同时记录当前层级，当遇到没有叶子节点，则说明找到最小深度，最后返回 12345678910111213141516171819/** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var minDepth = function (root) &#123; if (!root) return 0; let task = [ [root, 1] ] while (task.length) &#123; let [n, l] = task.shift() if (!n.left &amp;&amp; !n.right) &#123; return l &#125; if (n.right) task.push([n.right, l + 1]) if (n.left) task.push([n.left, l + 1]) &#125;&#125;; 题目 二叉树的层序遍历（广度遍历解法）https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历二叉树，同时记录当前层级，以层级为数组下标，完成层序遍历结果记录 12345678910111213141516171819202122/** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function (root) &#123; if (!root) return [] let task = [ [root, 0] ] let res = [] while (task.length) &#123; let [n, level] = task.shift() if (!res[level]) &#123; res.push([n.val]) &#125; else &#123; res[level].push(n.val) &#125; if (n.left) task.push([n.left, level + 1]) if (n.right) task.push([n.right, level + 1]) &#125; return res&#125;; 题目 二叉树的层序遍历（新陈代谢+广度遍历解法）https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历二叉树，在遍历中，每次都将本层级全部遍历完成，再进行下一个层级的遍历，这样在同一个循环里面把当前数据都放入遍历结果的最后，循环累加完成结果记录 123456789101112131415161718192021/** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function (root) &#123; if (!root) return [] const q = [root] const res = [] while (q.length) &#123; let len = q.length res.push([]) // 每次while之前都把上一层的全部提出,下一层的全部记录下来 while (len--) &#123; const n = q.shift() res[res.length - 1].push(n.val) if (n.left) q.push(n.left) if (n.right) q.push(n.right) &#125; &#125; return res&#125;; 题目 二叉树的中序遍历(递归)https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function (root) &#123; const res = [] const rec = (n) =&gt; &#123; if (!n) return; rec(n.left) res.push(n.val) rec(n.right) &#125; rec(root) return res&#125;; 题目 二叉树的中序遍历(非递归)https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function (root) &#123; const res = [] const task = [] // 遍历数据 let p = root // 指针 while (task.length || p) &#123; // 找到所有左子树 while (p) &#123; task.push(p) p = p.left &#125; // 获取最后一个节点 初始化的时候都是左子树 后面可能为右子树 const n = task.pop() res.push(n.val) p = n.right &#125; return res&#125;; 题目 路径总和https://leetcode-cn.com/problems/path-sum/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：使用深度遍历所有节点的值，在这个过程中不断累加，直到遇到最底部节点，对比与目标是否一致，如果一致则说明有，没有则继续找 12345678910111213141516171819/** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;boolean&#125; */var hasPathSum = function (root, targetSum) &#123; if (!root) return false; let res = false const dfs = (n, s) =&gt; &#123; // console.log(n.val); if (!n.left &amp;&amp; !n.right &amp;&amp; targetSum == s) &#123; res = true &#125; if (n.left) dfs(n.left, s + n.left.val) if (n.right) dfs(n.right, s + n.right.val) &#125; dfs(root, root.val) return false&#125;; 深度优先遍历json的全部节点1234567891011121314151617const json = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;, d: [1, 2]&#125;function dfs(json, path) &#123; console.log(json, path); Object.keys(json).map(e =&gt; &#123; dfs(json[e], path.concat(e)) &#125;)&#125;dfs(json, [])","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图","slug":"算法与数据结构/图","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/图/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/","excerpt":"","text":"深度优先遍历12345678910111213141516171819const graph = &#123; 0: [1, 2], 1: [2], 2: [0, 3], 3: [3]&#125;let visited = new Set() // 存储已经被访问数据const dfs = (n) =&gt; &#123; console.log(n) visited.add(n) graph[n].forEach(e =&gt; &#123; if (!visited.has(e)) &#123; dfs(e) // 未访问数据继续递归 &#125; &#125;)&#125;dfs(2) // 确定起点 广度优先遍历12345678910111213let visited = new Set() // 存储已经被访问过的数据visited.add(2) // 增加起点值let q = [2] // 设定起点while (q.length) &#123; let n = q.shift() // 弹出开头的 console.log(n); graph[n].map(e =&gt; &#123; if (!visited.has(e)) &#123; // 不存在才遍历节点 q.push(e) visited.add(e) &#125; &#125;)&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"字典","slug":"算法与数据结构/字典","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/字典/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8/","excerpt":"","text":"与集合类似，字段也是一种存储唯一值的数据结构吗，但是他是以键值对的形式来存储 ES6中增加了字段，也就是Map 123456789let a = new Map([ // 默认值 [&#x27;a&#x27;, &#x27;aa&#x27;]])a.set(&#x27;b&#x27;, &#x27;bb&#x27;) // 加入值a.delete(&#x27;b&#x27;, &#x27;bb&#x27;) // 删除a.set(&#x27;a&#x27;, &#x27;aaa&#x27;) // 替换值console.log(a.get(&#x27;a&#x27;), a.get(&#x27;b&#x27;)); // 读取值 题目 两个数组的交集时间复杂度：O(n) 空间复杂度：O(n) 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; // 集合的方式 // return [...new Set(nums1.filter(e =&gt; nums2.includes(e)))] // 字典的方式 const map = new Map(); nums1.forEach(e =&gt; &#123; map.set(e, true) &#125;) const res = [] nums2.map(e =&gt; &#123; if (map.get(e)) &#123; res.push(e) map.delete(e) &#125; &#125;) return res&#125;; 题目 有效的括号时间复杂度：O(n) 空间复杂度：O(n) 12345678910111213141516171819202122232425/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function (s) &#123; const stack = [] var map = new Map([ [&#x27;(&#x27;, &#x27;)&#x27;], [&#x27;&#123;&#x27;, &#x27;&#125;&#x27;], [&#x27;[&#x27;, &#x27;]&#x27;], ]) for (let i = 0; i &lt; s.length; i++) &#123; if (map.has(s[i])) &#123; stack.push(s[i]) &#125; else &#123; if (map.get(stack[stack.length - 1]) === s[i]) &#123; stack.pop() &#125; else &#123; return false &#125; &#125; &#125; return stack.length === 0&#125;; 题目 两数之和时间复杂度：O(n) 空间复杂度：O(n) 思路： 循环中每次判断map中，是否存在匹配项，如果没有，加入到map中，等到被匹配，如果匹配到了，直接返回被匹配到的与当前元素 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123; let map = new Map() for (let i = 0; i &lt; nums.length; i++) &#123; let e = nums[i] let n = target - e if (map.has(n)) &#123; return [map.get(n), i] &#125; else &#123; map.set(e, i) &#125; &#125;&#125;; 题目 无重复字符的最长子串时间复杂度：O(n) 空间复杂度：O(n) 思路：使用双指针 + 字典的方式实现，就像剪切视频时候的滑动窗口一张 右边指针不断向前，每次向前的时候，判断当前窗口中是否存在已有元素，如果存在，就将左边指针调整到存在的问题 同时每次都判断滑动窗口的长度，最终获取到最长子串 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function (s) &#123; let res = 0 // 最长长度 let a = 0 // 滑动窗口起点 const map = new Map() // 存储字符的字典 for (let b = 0; b &lt; s.length; b++) &#123; const e = s[b]; if (map.has(e) &amp;&amp; map.get(e) &gt;= a) &#123; // 如果存在重复元素 // 如果是abba 这样的情况,需要防止滑动窗口起始点变小,已经在滑动窗口外面了,不应当考虑 a = map.get(e) + 1 // 滑动窗口左边前进一位 &#125; map.set(e, b) // 存储当前值的最后的下标 用于下次计算起始点 res = Math.max(res, b - a + 1) // 当前长度与已知最大长度 &#125; return res&#125; 题目 最小覆盖子串（困难）https://leetcode-cn.com/problems/minimum-window-substring/ 时间复杂度：O(n2) 空间复杂度：O(n) 思路: 采用字典 + 双指针滑动窗口来实现最小覆盖子串的查找，因为题目不限制子串被覆盖的顺序，所以首先将子串通过Map结构转化为 数值:数量（abc &#x3D;&gt; {‘a’ &#x3D;&gt; 1,’b’ &#x3D;&gt; 1,’c’ &#x3D;&gt; 1 }） ​ 完成了Map的构建后，开始滑动右指针，知道map中数据都为0，代表当前滑动窗口覆盖了最小子串，这时候再开始左指针的滑动，知道左指针当前值在Map中，代表已经无法覆盖最小子串，此时左指针停止，再次开始滑动右指针，再次进入循环 ​ 最后在每次滑动左边指针的时候，截取当前的最小覆盖子串，最后得到最小覆盖子串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;string&#125; */ var minWindow = function (s, t) &#123; // 最小子串大于字符串s，毕竟不存在最小子串，直接返回空 if(t.length &gt; s.length) &#123; return &#x27;&#x27; &#125; let start = 0 // 指针开头 let end = 0 // 指针结尾 let result = &#x27;&#x27; // 存储最小覆盖子串 const need = new Map() // 存储最小子串数据 for (let i = 0; i &lt; t.length; i++) &#123; const e = t[i]; need.set(e, need.has(e) ? need.get(e) + 1 : 1) &#125; // need 为 &quot;ABC&quot; =&gt; &#123;&#x27;A&#x27; =&gt; 1,&#x27;B&#x27; =&gt; 1,&#x27;C&#x27; =&gt; 1 &#125; let needType = need.size // 最小子串的长度,用于记录滑动窗户口还未包含几位数 // 先走后指针 while (end &lt; s.length) &#123; const c = s[end] // 滑动窗口右边向前 if (need.has(c)) &#123; // 判断当前元素是否在map中 need.set(c, need.get(c) - 1) // 如果在map中,其值减1 if (need.get(c) == 0) &#123; // 如果当前值,在map中为0了,说明当前滑动窗口包含了当前值的所有数量 // 所以对记录map数量的数值再减1 needType -= 1 &#125; &#125; // 如果needType为0了,说明次数滑动窗口已经包含所有子串 while (needType === 0) &#123; // 获取当前子串 let carry = s.substring(start, end + 1) // 对比存储子串与当前子串,获取最小的 if (result == &#x27;&#x27; || result.length &gt; carry.length) &#123; result = carry &#125; const c2 = s[start] if (need.has(c2)) &#123; // 判断当前元素是否在map中,在,这说明某个值移出了,此时已经不是最小子串,因此map中的当前值,+1 // 因为去除了存在的值,当前子串已经不符合标准,needType记录值+1 // 左指针停止,开始右指针行动,知道它再次覆盖了子串 need.set(c2, need.get(c2) + 1) if (need.get(c2) === 1) &#123; needType += 1 &#125; &#125; start += 1 // 左指针前进 &#125; end += 1 // 右指针前进 &#125; return result&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"排序算法","slug":"算法与数据结构/排序算法","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/排序算法/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序先找最大，从右到左 时间复杂度：O(n2) 空间复杂度：O(n) 思路：内层循环通过依次比较，将最大值放到最后面，在此基础上增加外部循环，每次外部循环都会排除已经完成排序的下标，再算出最大值，并放到排除已经排序的数组最后 1234567891011121314151617181920/** * 冒泡排序 * @param &#123;Array&#125; arr * @returns */function bubbleSort(arr) &#123; for (let j = 0; j &lt; arr.length - 1; j++) &#123; // 为什么循环体减1,因为循环体里面是当前的比较后一个,不减1,就会溢出 // 减去j是为了减少无意义的循环次数 for (let i = 0; i &lt; arr.length - 1 - j; i++) &#123; // 比较当前的与后一个大小,前面的大则换位子 if (arr[i] &gt; arr[i + 1]) &#123; let temp = arr[i] arr[i] = arr[i + 1] arr[i + 1] = temp &#125; &#125; &#125; return arr&#125; 选择排序先找最小，从左到右 时间复杂度：O(n2) 空间复杂度：O(n) 思路：内层循环每次找到最小的下标并放到数组最前面，再此基础上增加外部循环，外部循环每次以循环下标为坐标，寻找最小值换位到坐标中，一次完成排序 123456789101112131415161718192021/** * 选择排序 * @returns */function selectionSort() &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; let indexMin = i for (let j = i; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[indexMin]) &#123; indexMin = j &#125; &#125; if (indexMin != i) &#123; // 最小值就是自己,不需要交换 let temp = arr[i] arr[i] = arr[indexMin] arr[indexMin] = temp &#125; &#125; return arr&#125; 插入排序从第二开始，依次从右到左开始比较最小值 时间复杂度：O(n2) 空间复杂度：O(n) 思路：从第二位开始，和前面的进行比较，如果前面的大于后面，则后面的等于前面的，继续向前找，如果找到了前面的小于后面都，则停止查找，覆盖该下标，如果到最开始都没有找到最小的，则将第一位变成比较值 123456789101112131415161718192021222324/** * 插入排序 * @param &#123;*&#125; arr * @returns */function inSetrSort(arr) &#123; // 从第二位开始 for (let i = 1; i &lt; arr.length; i++) &#123; let j = i let temp = arr[j] while (j &gt; 0) &#123; if (temp &gt; arr[j - 1]) &#123; // 如果当前值大于前一个值,直接弹出,并且得知插入位置 break &#125; // 如果当前值小于前一个值,当前值就等于前一个字 arr[j] = arr[j - 1] j-- &#125; // 在弹出的下标填入缓存的值 arr[j] = temp &#125; return arr&#125; 归并排序难度较大，后续再看 快速排序难度较大，后续再看 顺序搜索在目标函数中寻找目标值，找不到则返回-1 时间复杂度：O(n) 123function searchSort(list, carry) &#123; return list.findIndex(e =&gt; e == carry)&#125; 二分搜索针对有序数组的单项查找方法，找到会返回下标，未找到则返回-1，他的性能要高于顺序搜索，每次搜索都会将现有数组批成两半 时间复杂度：O(logN) 1234567891011121314151617181920let bin = [1, 2, 3, 4, 5, 6, 7, 8, 9]function binarySearch(list, carry) &#123; let low = 0 let high = list.length - 1 while (low &lt;= high) &#123; const mid = Math.floor((low + high) / 2) const ele = list[mid] if (carry &gt; ele) &#123; low = mid + 1 &#125; else if (carry &lt; ele) &#123; high = mid - 1 &#125; else if (carry == ele) &#123; return mid &#125; &#125; return -1&#125;console.log(binarySearch(bin, 1));","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://bluedancers.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈","slug":"算法与数据结构/栈","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.092Z","comments":true,"path":"2021/03/22/算法与数据结构/栈/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/","excerpt":"","text":"一个后进先出的数据结构,例如蜂窝煤，先放进去的蜂窝煤是被后拿出来的，后放进去的先拿出来，放进去（push）拿出来（pop） JavaScript虽然没有栈，但是可以通过array进行实现 123456const stack = []stack.push(1)stack.push(2)const item1 = stack.pop()const item2 = stack.pop() 题目 有效括号https://leetcode-cn.com/problems/valid-parentheses/ 思路：使用栈的特性实现 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var obj = &#123; &#x27;(&#x27;: &#x27;)&#x27;, &#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;[&#x27;: &#x27;]&#x27;&#125;var isValid = function (s) &#123; if (s.length % 2 === 1) &#123; return false &#125; const stack = [] for (let i = 0; i &lt; s.length; i++) &#123; if (obj[s[i]]) &#123; stack.push(s[i]) &#125; else &#123; if (obj[stack[stack.length - 1]] === s[i]) &#123; stack.pop() &#125; else &#123; return false &#125; &#125; &#125; return stack.length === 0&#125;; 函数调用堆栈","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"链表","slug":"算法与数据结构/链表","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.093Z","comments":true,"path":"2021/03/22/算法与数据结构/链表/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表数组：增加或者删除非首尾元素时，需要移动元素 链表：增加或者删除非首尾元素时，不需要移动元素，只需要修改其next的指向即可 注： JavaScript 没有链表结构，所以我们需要用Object来模拟链表 题目 删除链表中的节点https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 时间复杂度：O(1) 空间复杂度：O(1) 12345678/** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function (node) &#123; node.val = node.next.val // 将自己变成别人 node.next = node.next.next // 干掉别人，达到自己消失的目的&#125;; 题目 反转链表https://leetcode-cn.com/problems/reverse-linked-list/ 时间复杂度：O(n) 空间复杂度：O(1) &#x2F;&#x2F; p2里面都是p1的，所以不是新内存，temp因为是单个值，不是数组与矩阵，所以是O(1) 思路：每次循环的时候首先保存之后的链表，再讲当前链表指向新的链表，最后循环”之后的链表“，进而实现 123456[1,2,3,4,5] =&gt; [][2,3,4,5] =&gt; [1][3,4,5] =&gt; [1,2][4,5] =&gt; [1,2,3][5] =&gt; [1,2,3,4][] =&gt; [1,2,3,4,5] 写法1 双指针123456789101112131415/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; let p1 = head // 链表 let p2 = null while (p1) &#123; const temp = p1.next // 首先保存当前的下一个指针 p1.next = p2 // 将当前指针指向新链表 p2 = p1 // 替换之前的链表 [] =&gt; [1] =&gt; [2,1] =&gt; [3,2,1] p1 = temp // 为了下次循环,将下一个链表给p1(本次循环的已经被弹出) [1,2,3] =&gt; [2,3] =&gt; [3] &#125; return p2 // 返回反转后的链表&#125;; 写法2 递归123456789101112131415161718/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; // 递归写法 return reverse(null, head)&#125;;function reverse(now, old) &#123; if (!old) &#123; // 老数据没了,递归反转完成 return now &#125; let temp = old.next // 首先保存链表(除了自己) old.next = now // 将当前指针指向新链表 return reverse(old, temp) // 将2个链表再执行一遍&#125; 题目 两数相加https://leetcode-cn.com/problems/add-two-numbers/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：同时循环两个链表，在将数据放入一个新的链表中，对十位数需要进行额外的处理 12345678910111213141516171819202122232425262728/** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function (l1, l2) &#123; let all = new ListNode(0) // 新建空链表 let three = all // 向新链表追加元素是需要指针,直接用all,链表头就没了 let carry = 0 // 记录超出的十位数 while (l1 || l2) &#123; // 同时循环2个链表 let val = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry // 同位数相加,并且加上上一位的超出的十位数 carry = Math.floor(val / 10) // 获取超出的十位数 three.next = new ListNode(val % 10) // 记录当前的余数 three = three.next // 指向下一个链表 if (l1) &#123; // 2个链表长度不一致,需要判断 l1 = l1.next &#125; if (l2) &#123; l2 = l2.next &#125; &#125; // 最后一位可能存在余数 if (carry) &#123; three.next = new ListNode(carry) three = three.next &#125; return all.next&#125;; 题目 删除排序链表中的重复元素https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 时间复杂度：O(n) 空间复杂度：O(1) 思路：遇到同样的，删除自己，没遇到，指针向后一位 1234567891011121314151617/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var deleteDuplicates = function (head) &#123; let all = head // 当前指针 while (all &amp;&amp; all.next) &#123; if (all.val == all.next.val) &#123; // 和下个一个节点一致,删除本阶段 all.next = all.next.next &#125; else &#123; // 没有重复的,指针到下一个 all = all.next &#125; &#125; return head&#125; 题目 环形链表https://leetcode-cn.com/problems/linked-list-cycle/ 题目解析: 给定一个特殊的链表，链表的最后一位再次指向链表中的某一个，这样会形成一个环，pos参数是未知的，通过算法判断该链表是否有环 写法1 特殊值法时间复杂度:O(n) 空间复杂度：O(1) 特殊值一定要保证不能在链表中出现 12345678910111213141516171819202122/** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; let all = head; while(all) &#123; // 定一个特殊值，将遇到的每一项都变成这个特殊值 // 如果有遇到了，就说明是存在环 if(all.val == &#x27;123456789&#x27;) &#123; all = null return true &#125; else &#123; all.val = &#x27;123456789&#x27; all = all.next &#125; &#125; // 如果一次都没遇到这说明没有环 return false&#125;; 写法2 快慢指针 为什么快指针与慢指针一定会相遇? 一旦快指针进入环中，每次都离慢指针进一步，因为到了追上的时候，要么相隔1步，下一步相遇，要么相隔2步，下下次一定相遇 快指针与慢指针相遇的时候，慢指针是否绕环超过了一圈 不会，假设环长为N，环外长度为n，N一定大于n；并且根据第一题可知每次快指针都距离慢指针进一步，所以N与n最终会距离n，所以N&gt;n 时间复杂度:O(n) 空间复杂度：O(1) 12345678910111213141516/** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; let p1 = head let p2 = head while(p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123; p1 = p1.next p2 = p2.next.next if(p1 === p2) &#123; return true &#125; &#125; return false&#125;; JavaScript原型链123obj -&gt; Object.prototype -&gt; null // 对象func -&gt; Function.prototype -&gt; Object.prototype -&gt; null // 方法arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null // 数组 如果A沿着原型链能找到B.protype，那么 A instanceof B一定为true 如果A对象上面没有找到X属性，那么就会沿着原型链找到X属性 例如：Object.prototype.x &#x3D; ‘x’,那么函数func.x也会为x,因为Function.prototype指向Object.prototype instanceof如何实现？（遍历原型链） 遍历链表，寻找是否存在一致的 12345678910function instanceOf(params, type) &#123; let p = params while (p) &#123; if (p === type.prototype) &#123; return true &#125; p = p.__proto__ &#125; return false&#125; 应用 使用链表获取json的值 在知道全部键的情况下，或者说知道json中数据的的某个值，可以使用链表，嵌套for过于暴力 123456789101112131415const json = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;&#125;const path = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]let p = jsonpath.map(e =&gt; &#123; p = p[e]&#125;)console.log(p); 总结 链表中的元素不是连续的，而是通过next指针连接的 JavaScript没有链表，但是Object可有模拟链表 常用操作：遍历链表，修改链表next JavaScript的原型链也是链表，使用__proto__进行连接","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"队列","slug":"算法与数据结构/队列","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.093Z","comments":true,"path":"2021/03/22/算法与数据结构/队列/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/","excerpt":"","text":"一个先进先出的数据结构，先放进去的后拿出来，先进先出，保持有序 JavaScript中虽然没有队列但是可以通过array进行实现 123456const stack = []stack.push(1)stack.push(2)const item1 = stack.shift()const item2 = stack.shift() 题目 最近请求次数https://leetcode-cn.com/problems/number-of-recent-calls/ 思路： 使用栈实现 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415var RecentCounter = function () &#123; this.q = []&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function (t) &#123; this.q.push(t) while (this.q[0] + 3000 &lt; t) &#123; this.q.shift() &#125; return this.q.length&#125;; 事件循环于任务队列 ​ 如果执行事件的过程中，如果遇到了异步任务，比如dom操作，ajax，setTimeout，就会将事件交给webApi执行， 不会加入任务队列 ​ 直到异步任务结束，回调函数加入任务队列，如果回调函数里面还有异步任务，就继续做放入wenAPI里面做事件循环","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"集合","slug":"算法与数据结构/集合","date":"2021-03-21T16:00:00.000Z","updated":"2022-12-11T13:51:24.093Z","comments":true,"path":"2021/03/22/算法与数据结构/集合/","link":"","permalink":"https://bluedancers.github.io/2021/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/","excerpt":"","text":"一种无序且唯一的数据结构 ES6增加了集合，Set 常用操作：去重 判断是否在集合中，求交集，差集 123456789101112// 去重const arr = [1,2,3,4,4,4,4]const arr2 = [...new Set(arr)]// 判断是否在集合中const set = new Set(arr)const has = set.has(2)// 求交集const set1 = new Set([1,2,3,4])const set2 = new Set([3,4,5,6])const set3 = new Set([...set1].filter(e =&gt; set2.has(e))) // 将其中一个变成数组，另一个has，最终结果转为Set 题目 两个数组的交集https://leetcode-cn.com/problems/intersection-of-two-arrays/ 时间复杂度：O(n^2) 空间复杂度：O(1) 12345678/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; return [...new Set(nums1.filter(e =&gt; nums2.includes(e)))]&#125;; JavaScript中Set的一些操作1234567891011121314151617181920212223242526let my = new Set()my.add(1) // 正常加入my.add(2) // 正常加入my.add(2) // set保证不会重复,依旧只有一个2my.add(&#x27;313&#x27;) // 正常加入let o = &#123; a: 1&#125;my.add(o) // 正常加入my.add(&#123; // 正常加入 a: 1&#125;)const has1 = my.has(&#123; a: 1&#125;) // 返回false 引用类型不在内存的同一个地方const has2 = my.has(o) // 返回true console.log(has1);my.delete(1) // 正常删除for (const item of my) &#123; // 迭代函数 这个不使用my 使用my.values my.keys 都可以 都是一样的 console.log(item);&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"日常","slug":"日常","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/categories/chatGPT/"},{"name":"关于程序员","slug":"关于程序员","permalink":"https://bluedancers.github.io/categories/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"产品","slug":"产品","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"},{"name":"JavaScript-2023","slug":"JavaScript-2023","permalink":"https://bluedancers.github.io/categories/JavaScript-2023/"},{"name":"书摘","slug":"书摘","permalink":"https://bluedancers.github.io/categories/%E4%B9%A6%E6%91%98/"},{"name":"日常开发","slug":"日常开发","permalink":"https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"},{"name":"产品经理","slug":"产品经理","permalink":"https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"},{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://bluedancers.github.io/categories/JavaScript-2022/"},{"name":"杂谈","slug":"杂谈","permalink":"https://bluedancers.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/categories/JavaScript/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"https://bluedancers.github.io/categories/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"},{"name":"随想集","slug":"随想集","permalink":"https://bluedancers.github.io/categories/%E9%9A%8F%E6%83%B3%E9%9B%86/"},{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://bluedancers.github.io/categories/JavaScript-2021/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bluedancers.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"经济学","slug":"经济学","permalink":"https://bluedancers.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"},{"name":"恋爱","slug":"恋爱","permalink":"https://bluedancers.github.io/tags/%E6%81%8B%E7%88%B1/"},{"name":"年终总结","slug":"年终总结","permalink":"https://bluedancers.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"四万万顾客","slug":"四万万顾客","permalink":"https://bluedancers.github.io/tags/%E5%9B%9B%E4%B8%87%E4%B8%87%E9%A1%BE%E5%AE%A2/"},{"name":"chatgpt PLUS","slug":"chatgpt-PLUS","permalink":"https://bluedancers.github.io/tags/chatgpt-PLUS/"},{"name":"虚拟币","slug":"虚拟币","permalink":"https://bluedancers.github.io/tags/%E8%99%9A%E6%8B%9F%E5%B8%81/"},{"name":"depay","slug":"depay","permalink":"https://bluedancers.github.io/tags/depay/"},{"name":"dupay","slug":"dupay","permalink":"https://bluedancers.github.io/tags/dupay/"},{"name":"calling Funtion","slug":"calling-Funtion","permalink":"https://bluedancers.github.io/tags/calling-Funtion/"},{"name":"ai机器人","slug":"ai机器人","permalink":"https://bluedancers.github.io/tags/ai%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"记录","slug":"记录","permalink":"https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"营销工具","slug":"营销工具","permalink":"https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"},{"name":"秒杀","slug":"秒杀","permalink":"https://bluedancers.github.io/tags/%E7%A7%92%E6%9D%80/"},{"name":"优惠券","slug":"优惠券","permalink":"https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"},{"name":"Vue","slug":"Vue","permalink":"https://bluedancers.github.io/tags/Vue/"},{"name":"源码解读","slug":"源码解读","permalink":"https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"name":"产品","slug":"产品","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"张小龙","slug":"张小龙","permalink":"https://bluedancers.github.io/tags/%E5%BC%A0%E5%B0%8F%E9%BE%99/"},{"name":"动态路由 - vue3","slug":"动态路由-vue3","permalink":"https://bluedancers.github.io/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-vue3/"},{"name":"vue3","slug":"vue3","permalink":"https://bluedancers.github.io/tags/vue3/"},{"name":"sku","slug":"sku","permalink":"https://bluedancers.github.io/tags/sku/"},{"name":"chatGPT","slug":"chatGPT","permalink":"https://bluedancers.github.io/tags/chatGPT/"},{"name":"关于proxy","slug":"关于proxy","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8Eproxy/"},{"name":"Vue - 源码解读","slug":"Vue-源码解读","permalink":"https://bluedancers.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"name":"阅读、游历和爱情","slug":"阅读、游历和爱情","permalink":"https://bluedancers.github.io/tags/%E9%98%85%E8%AF%BB%E3%80%81%E6%B8%B8%E5%8E%86%E5%92%8C%E7%88%B1%E6%83%85/"},{"name":"梁永安","slug":"梁永安","permalink":"https://bluedancers.github.io/tags/%E6%A2%81%E6%B0%B8%E5%AE%89/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bluedancers.github.io/tags/JavaScript/"},{"name":"产品分析","slug":"产品分析","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"},{"name":"Pinia","slug":"Pinia","permalink":"https://bluedancers.github.io/tags/Pinia/"},{"name":"Hexo","slug":"Hexo","permalink":"https://bluedancers.github.io/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://bluedancers.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"价值观","slug":"价值观","permalink":"https://bluedancers.github.io/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"},{"name":"移动端","slug":"移动端","permalink":"https://bluedancers.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"兼容性","slug":"兼容性","permalink":"https://bluedancers.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"设计模式","slug":"设计模式","permalink":"https://bluedancers.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"无障碍","slug":"无障碍","permalink":"https://bluedancers.github.io/tags/%E6%97%A0%E9%9A%9C%E7%A2%8D/"},{"name":"随选朗读","slug":"随选朗读","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB/"},{"name":"童年","slug":"童年","permalink":"https://bluedancers.github.io/tags/%E7%AB%A5%E5%B9%B4/"},{"name":"随想","slug":"随想","permalink":"https://bluedancers.github.io/tags/%E9%9A%8F%E6%83%B3/"},{"name":"低代码","slug":"低代码","permalink":"https://bluedancers.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"h5装修","slug":"h5装修","permalink":"https://bluedancers.github.io/tags/h5%E8%A3%85%E4%BF%AE/"},{"name":"Vue3","slug":"Vue3","permalink":"https://bluedancers.github.io/tags/Vue3/"},{"name":"关于C端","slug":"关于C端","permalink":"https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8EC%E7%AB%AF/"},{"name":"产品日常","slug":"产品日常","permalink":"https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81%E6%97%A5%E5%B8%B8/"},{"name":"webpack5","slug":"webpack5","permalink":"https://bluedancers.github.io/tags/webpack5/"},{"name":"响应式","slug":"响应式","permalink":"https://bluedancers.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"vw","slug":"vw","permalink":"https://bluedancers.github.io/tags/vw/"},{"name":"NPDP","slug":"NPDP","permalink":"https://bluedancers.github.io/tags/NPDP/"},{"name":"输出","slug":"输出","permalink":"https://bluedancers.github.io/tags/%E8%BE%93%E5%87%BA/"},{"name":"算法","slug":"算法","permalink":"https://bluedancers.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://bluedancers.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}