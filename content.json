{"meta":{"title":"vkcya Blog","subtitle":"","description":"","author":"vkcyan","url":"https://vkcyan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-05-24T08:17:55.744Z","updated":"2022-05-24T08:17:55.744Z","comments":true,"path":"about/index.html","permalink":"https://vkcyan.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233&#123; name: &quot;vkcyan&quot;, age: 24, gender: &quot;男&quot;, profession: &quot;Web Developer Leader &amp; Product Manager&quot;, experience: &quot;4年&quot;, address: &quot;安徽省合肥市&quot;, education: &quot;本科&quot;, github: &quot;https://github.com/vkcyan&quot;, blog: &quot;https://vkcyan.github.io&quot;, email: &quot;wu.vkcyan@gmail.com&quot;, description: &quot;一切都是为了实现技术的价值&quot;, skills: [ [&quot;Html&quot;, &quot;CSS&quot;, &quot;JavaScript&quot;, &quot;TypScript&quot;, &quot;ES6&quot;, &quot;Node&quot;], [&quot;Webpack&quot;, &quot;Vite&quot;], [&quot;Less&quot;, &quot;Sass&quot;], [&quot;Git&quot;], [&quot;Vue2.x&quot;, &quot;Vue3.x&quot;], [&quot;element-ui&quot;, &quot;element-plus&quot;, &quot;AntdV&quot;], [&quot;竞品分析&quot;, &quot;产品规划&quot;, &quot;挖掘用户需求&quot;, &quot;定制产品策略&quot;], ], devTools: [ [&quot;Visual Studio Code&quot;, &quot;Sublime Text&quot;], [&quot;Chrome DevTools&quot;, &quot;Fiddler&quot;], [&quot;SourceTree&quot;], [&quot;SwitchHosts&quot;], [&quot;Navicat&quot;, &quot;&quot;], [&quot;Sketch&quot;], [&quot;Typora&quot;], ],&#125;;"},{"title":"书籍","date":"2022-05-23T07:18:11.740Z","updated":"2022-05-23T07:18:11.740Z","comments":true,"path":"books/index.html","permalink":"https://vkcyan.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-23T07:18:39.272Z","updated":"2022-05-23T07:18:39.272Z","comments":true,"path":"links/index.html","permalink":"https://vkcyan.github.io/links/index.html","excerpt":"","text":""},{"title":"类别","date":"2022-05-23T07:18:32.733Z","updated":"2022-05-23T07:18:32.733Z","comments":true,"path":"categories/index.html","permalink":"https://vkcyan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-23T07:19:05.313Z","updated":"2022-05-23T07:19:05.313Z","comments":true,"path":"tags/index.html","permalink":"https://vkcyan.github.io/tags/index.html","excerpt":"","text":""},{"title":"存储库","date":"2022-05-23T07:18:59.980Z","updated":"2022-05-23T07:18:59.980Z","comments":true,"path":"repository/index.html","permalink":"https://vkcyan.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"第一篇文章","slug":"测试","date":"2022-06-30T16:00:00.000Z","updated":"2022-06-28T05:53:26.687Z","comments":true,"path":"2022/07/01/测试/","link":"","permalink":"https://vkcyan.github.io/2022/07/01/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"正文1​ 这是文章内容… 正文2​ 这是文章内容…","categories":[{"name":"类目","slug":"类目","permalink":"https://vkcyan.github.io/categories/%E7%B1%BB%E7%9B%AE/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://vkcyan.github.io/tags/%E6%A0%87%E7%AD%BE/"}]},{"title":"关于我使用Hexo搭建个人博客这档子事","slug":"关于我使用Hexo搭建个人博客这档子事","date":"2022-06-29T16:00:00.000Z","updated":"2022-06-28T06:37:52.768Z","comments":true,"path":"2022/06/30/关于我使用Hexo搭建个人博客这档子事/","link":"","permalink":"https://vkcyan.github.io/2022/06/30/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/","excerpt":"","text":"前言​ 在我刚工作的那年，便搭建过一次Hexo静态站点到githubPages，那时候输出不多，几乎全都是技术类文章，于是我便把学习记录、文章都放在github仓库中，也会把精品文章发布到掘金；这样的情况下，自己的博客便慢慢荒凉了； ​ 时间来到2022年，随着输出类型越来越多，自然便需要一个知识库的存储所有的输出，这里自然也可以使用在线知识库，比如语雀，飞书都是非常不错的，这便是我再次搭建githubPages的原因。 Hexo介绍​ Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的markdown文件，按照指定的主题解析成静态网页。 githubPages介绍​ GitHub Pages 是一种静态站点托管服务，它直接从 GitHub 上的存储库获取 HTML、CSS 和 JavaScript 文件，可选择通过构建过程运行文件，然后发布网站。您可以在GitHub Pages 示例集合中查看 GitHub Pages 站点示例。 ​ 通过上面的介绍我们便可以得到一个结论：githubPages + Hexo &#x3D; 个人博客，下面让我们正式开始搭建个人博客吧！ 环境要求 nodejs环境 安装git并 注册github账号，并已经将当前电脑的ssh秘钥添加到了Github（相当于告诉github，这台电脑有权操作你的github数据） 搭建github Pages 仓库创建完成后，点击 之后点击pages菜单，这里正常情况下会自动开启，这边得到了一个访问地址，这就是个人博客的链接了。 ​ 到此为止githubPages便设置完成了，到这一步已经成功一半了！上图的链接已经可以访问，只是现在里面还没有内容，接下来变解决网站内容问题。 配置hexo搭建环境首先全局安装hexo 1npm install -g hexo-cli 然后创建存放站点资源的文件夹，在你认为合适的目录下执行 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install install完成后，在该文件夹下执行 1hexo s // hexo server 正常情况下会看到依一下信息 然后我们访问http://localhost:4000/,便可以看到hexo生成的站点 能到这一步就算搭建成功了，接下来我们需要认识hexo生成文件中的信息，来个性化定制我们的个人站点 hexo文件说明_config.yml非常重要的文件，配置网站的基本信息信息，比如名称 描述 分页 主题等信息。具体含义看这里 配置参数 themes​ 第三方网站主题存放目录，后面我们会用到 source​ 该文件夹是存放站点文章的地方，_post目录为文章存放处，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。 public​ 所有打包生产的文件都会被输出到public中，其中MD html文件将会被解析再存放在其中，其他文件会被拷贝进去。 编写一篇文章我们再_post中增加一个md文件，然后文章最靠头写入以下信息，使用过wordPress的同学应该很熟悉，这是对当前文章的属性描述，具体配置可以看官方配置，然后填入文章内容，还记得我们通过hexo s启动的本地服务器吗，文章编写完成后，让我们去看看 能够看到文章便说明文章编写成功了 在文章头部编写的categories，tags字段，hexo会按照关键字自动生成索引。 下一步我们便要将其发布到githubPages中，让所有人都可以访问到。 将hexo发布到githubPages​ 由于我们之前已经配置好git本地环境与仓库，这让我们接下来部署便的非常方便 安装快速部署package 1npm install hexo-deployer-git --save 填写相关配置 12345deploy: type: git repo: https://github.com/username/username.github.io // 替换这里的username branch: master // 填写部署的分支GitHub默认为gh-pages message: &#x27;&#x27; // 提交信息，存在默认值，可以不填写 一键部署 12hexo clean // 清除缓存文件 db.json与public/hexo d // deploy的缩写，读取yml中deploy的配置并部署","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://vkcyan.github.io/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://vkcyan.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"关于消费降级","slug":"关于消费降级","date":"2022-06-27T16:00:00.000Z","updated":"2022-06-28T01:16:19.158Z","comments":true,"path":"2022/06/28/关于消费降级/","link":"","permalink":"https://vkcyan.github.io/2022/06/28/%E5%85%B3%E4%BA%8E%E6%B6%88%E8%B4%B9%E9%99%8D%E7%BA%A7/","excerpt":"","text":"当我们买东西的时候，我们支付的不是钱。 我们支付的是我们生命中，去挣这笔钱所花掉的时间。 在我们创造的消费性社会，它还会持续不断的增长。 每当无法增长的时候，变成了悲剧。 我们为自己造了一座名叫【需求过剩】的大山。 你得不停的购买然后抛弃，在这个过程中，你却买不来生命，生命只会逝去。 浪费生命，失去自由是非常糟糕的 要懂得知足，不要给自己过重的负担，保持内心的幸福，否则你将一事无成。 出自《人类Human》（2015）","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://vkcyan.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"价值观","slug":"价值观","permalink":"https://vkcyan.github.io/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"}]},{"title":"移动端兼容性那些事儿","slug":"移动端兼容性那些事儿","date":"2022-06-23T16:00:00.000Z","updated":"2022-06-27T08:01:15.017Z","comments":true,"path":"2022/06/24/移动端兼容性那些事儿/","link":"","permalink":"https://vkcyan.github.io/2022/06/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/","excerpt":"","text":"低版本IOS系统Promise不存在finally事件​ 这是几年前生产环境发生的问题，通过错误监控看到了该错误，并且集中出现在ios10.0.x版本中，出现了，网上也有开发者遇到了IOS 10 Promise不存在问题，我们没遇到该情况，如果Promise对象不存在，则引入Promise的polyfill，如果仅仅是finally函数不存在则只需要手动补充即可 12345678910Promise.prototype.finally = function (callback: any) &#123; let P = this.constructor return this.then( (value) =&gt; P.resolve(callback()).then(() =&gt; value), (reason) =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) ) &#125; IOS时间戳兼容性问题​ 在ios无法解析使用-分割的时间字符串 123new Date(&#x27;2022-6-27 12:00:00&#x27;).getTime() // Android 正常获取 IOS NaNnew Date(&#x27;2022/6/27 12:00:00&#x27;).getTime() // 均正常new Date(1656302400000) // 均正常 ​ 在移动端开发中建议统一采用时间戳记录时间，具体格式交给时间处理函数即可。 移动端1px问题点击事件300ms延时问题​ 因为历史原因，移动浏览器会在touch和click事件之间增加300ms等待时间，来判断用户是否会进行双击手势来缩放页面，自然该特性也会影响到单击事件，后来在Chrome团队的推动下，该问题逐渐有了清晰的解决方案 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; // 窗口自动调整到设备宽度，并禁止用户缩放页面 ​ 随着响应式设计的逐步推进，开发者们已经根据设备本身的尺寸对站点进行了优化，也就逐渐淘汰了诸如双击缩放的约定。 移动端长按识别二维码无效​ 有些移动端开发者在使用类似uniapp这样的框架在开发H5应用中的，长按识别二维码的时候会出现不触发识别的情况，这是因为，长按识别图片信息仅仅在img标签生效，所以只需要使用原生img标签即可。 微信小程序按钮边框无法覆盖问题​ 非常常见的问题，button的边框无法被css中的border正常覆盖掉，那是因为自带的边框是通过伪类实现的 123button::after&#123; border: none;&#125; IOS input标签type为search时候右边有放大镜​ 在ios中input的type值为search的时候，会自带一个搜索icon，而安卓则没有此icon，为了保证一致性，我们需要删除ios自带的搜索icon 12input[type=&quot;search&quot;]&#123;-webkit-appearance:none;&#125; input::-webkit-search-cancel-button &#123;display: none;&#125; vue 排序key值问题公众号登录登录路由栈无法去除问题","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://vkcyan.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://vkcyan.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"兼容性","slug":"兼容性","permalink":"https://vkcyan.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"JavaScript设计模式","slug":"JavaScript设计模式","date":"2022-06-17T16:00:00.000Z","updated":"2022-06-28T01:05:00.430Z","comments":true,"path":"2022/06/18/JavaScript设计模式/","link":"","permalink":"https://vkcyan.github.io/2022/06/18/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JavaScript设计模式基础JavaScript是一门经典动态类型语言，对变量类型的宽容给实际编码带来了很大灵活性。由于无需进行类型检测，我们可能尝试调用对象的任何方法，而无需去考虑它原本是否被设计拥有该方法。 ​ 这一切都建立在鸭子类型的概念上，鸭子类型：如果它走起路来像鸭子，叫起来像鸭子，那他就是鸭子 ​ 利用鸭子类型，我们就不必借助类型的帮助，实现一个动态语言专有原则：面向接口编程，而不是面向实现变成，例如一个对象，具备length属性，那我们就可以将其视为数组，而不需要关心它的实际类型。 多态​ 同一个操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果 ​ 例如：小狗汪汪叫 小猫喵喵叫 他们都是动物，都会发生，但是各自发出的声音并不一样 ​ 其背后的思想是将“做什么”于“谁去做以及怎么样”分离开来，也就是将“不变的事物”于“变化的事物”分离开来。这给予了我们拓展程序的能力，程序看起来是可生长的，也是符合开放封闭原则的，相对于修改代码，增加代码显然优雅安全的多。 12345678910111213141516function sound(animal) &#123; animal.sound();&#125;var Dog = function () &#123;&#125;;Dog.prototype.sound = () =&gt; &#123; console.log(&quot;汪汪汪&quot;);&#125;;var Cat = function () &#123;&#125;;Cat.prototype.sound = () =&gt; &#123; console.log(&quot;喵喵喵&quot;);&#125;;new Dog().sound()new Cat().sound() 如果是强类型语言就需要借助继承来实现向上转型，从狗可以发出叫声转变为动物可以发出叫声，从而避免我们指定了发出声音对象是某一个类型，他就不可能被替换成为另一个类型。 ​ 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 封装封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节，设计细节以及隐藏对象的类型。 原型编程JavaScript本身就是基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型业务更加合适。 ​ 在JavaScript中不存在类的概念，对象也并非从类中创建出来，所有的JavaScript对象都是从某个对象上复制出来的。 ​ 原型编程存在一个重要特性，即当对象无法响应某个请求的时候，就会把该请求委托给自己的原型；这里更好的说法是把请求委托给它的构造器的原型 ​ 在JavaScript中，一个function并不一定仅仅是一个普通函数，也可以是一个函数构造器，当使用new运算符来调用函数的时候，此时函数就是一个构造器。使用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype，再进行一些其他额外操作的过程。 原型链查找对象的过程12345678var A = function () &#123;&#125;;A.prototype = &#123; name: &quot;sven&quot; &#125;;var B = function () &#123;&#125;;B.prototype = new A();var b = new B();console.log(b.name); 首先尝试遍历对象b中的所有属性，但是没有找到name这个属性 查找name属性的请求被委托到对象b的构造器原型，它被b._proto_记录并指向B.prototype，而B.prototype又直线new A()创建的对象 再该对象中依旧没有找到name属性，于是请求又被委托到这个对象的构造器的原型A.prototype 在A.prototype中找到了name属性，返回值 闭包闭包案例123456789101112var func = function () &#123; var a = 1; return function () &#123; a++; alert(a); &#125;;&#125;;var ff = func();ff();ff();ff(); ​ 局部变量在函数执行结束后将会被销毁，但是以上的例子中，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行func的时候，func返回了一个匿名函数的引用，它可以访问到func被调用时产生的环境，而局部变量所在的环境一直处于这个环境中。既然局部变量所处的环境还能被外界访问，这个局部变量就有了不被销毁的理由；在这样的闭包结构中，局部变量实现了生命的延续。 闭包与面向对象过程与数据的结合是形容面向对象中的对象时常用的表达 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据 通常用面向对象实现的功能，用闭包也能实现，反之亦然。 闭包版本 1234567891011121314var app = function () &#123; var value = 0; return &#123; call: function () &#123; value++; console.log(value); &#125;, &#125;;&#125;;var App = app();App.call(); // 1App.call(); // 2App.call(); // 3 对象版本1234567891011var app = &#123; value: 0, call: function () &#123; this.value++; console.log(this.value); &#125;,&#125;;app.call(); // 1app.call(); // 2app.call(); // 3 类版本12345678910111213var App = function () &#123; this.value = 0;&#125;;App.prototype.call = function () &#123; this.value++; console.log(this.value);&#125;;var app = new App();app.call(); // 1app.call(); // 2app.call(); // 3 高阶函数高阶函数是指最少满足下列条件之一的函数 函数可以作为参数被传递 函数可以作为返回值输出 ​ JavaScript语言的函数显然满足高阶函数，在实际开发中将函数作为参数进行传递，让函数的执行结果返回一个另一个函数都是非常普遍的情况，例如函数执行的callback函数。 ​ 通过高阶特性，我们可以实现AOP，也就是面向切面编程 1234567891011121314151617181920212223242526272829303132// 面向切面编程Function.prototype.before = function (beforeFn) &#123; console.log(&quot;before&quot;); var _self = this; return function () &#123; beforeFn.apply(this, arguments); // 执行before本身 return _self.apply(this, arguments); // 返回函数本身 &#125;;&#125;;Function.prototype.after = function (afterFn) &#123; console.log(&quot;after&quot;); var _self = this; return function () &#123; var ret = _self.apply(this, arguments); // 先执行before afterFn.apply(this, arguments); // 最后执行after return ret; &#125;;&#125;;var func = function () &#123; console.log(2);&#125;;func = func .before(function () &#123; console.log(1);&#125;) .after(function () &#123; console.log(3);&#125;);func(); 首先执行before，打印‘before’，然后执行after，打印‘after’ 执行func()，开始执行after，进入after闭包中，然后执行ret，进入before before中首先执行了自己beforeFn，打印‘1’，然后执行func本身，打印‘2’，并返回本身 ret执行结束，开始执行afterFn，打印‘3’，返回func本身 高阶应用 - 函数柯里化​ 柯里化又被称为部分求值，一个柯里化函数首先会接受一些参数，接收参数后不会立刻求职而是继续返回当前函数，之前传入的值在函数形成的闭包种被保存了起来。待函数真正需要求值的时候，之前传入的所有参数都会被一次性求值。 ​ 例如实现一个计算每个月花费多少钱的函数，但是在实现中，我们并不关心吗，每天花费了多少，只想知道月底花掉了多少，实际上只需要计算一次 12345678910111213141516171819202122232425262728function currying(fn) &#123; var args = []; return function () &#123; if (arguments.length == 0) &#123; var res = fn.apply(this, args); args = []; return res; &#125; else &#123; [].push.apply(args, arguments); return arguments.callee; // 当前正在执行的函数 &#125; &#125;;&#125;var cost = (function () &#123; var money = 0; return function () &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; money += arguments[i]; &#125; return money; &#125;;&#125;)();var cost = currying(cost);cost(100)(100)(100)(100);cost(100);console.log(cost()); 500cost(100);console.log(cost()); 600 单例模式​ 要实现一个单例模式并不复杂，无非是用一个变量来标志是否已经为某个类创建过对象，如果是，则下一次获取该类的实例，直接返回之前创建的对象。 vue2.x 中的vuex在页面与组件中进行挂载使用的就是单例模式 使用代理实现单例模式12345678910111213141516171819202122var createDiv = function (html) &#123; this.html = html; this.init();&#125;;createDiv.prototype.init = function () &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = this.html; document.body.appendChild(div);&#125;;var proxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new createDiv(html); &#125; return instance; &#125;;&#125;)();var a = new proxySingletonCreateDiv(&quot;one&quot;);var b = new proxySingletonCreateDiv(&quot;two&quot;);console.log(a === b); // true JavaScript的单例模式​ 单例模式的核心是确保只有一个实例，比提供全局访问。在JavaScript中很多都会通过全局变量进行实现，但是JavaScript的全局变量并不是非常好的特性，在中大型项目中会存在命名冲突问题，所以应当尽量使用命名空间。 惰性单例​ 在未使用之前，相关逻辑不会被创建，并且只有第一次使用的时候才会创建，同时我们别忘记了单一职责原则 ​ 在下面的代码中，我们将创建单例与具体单例逻辑进行分离，这两个方法独立变化而且互不影响，这样避免了下次出现其他元素，我们需要将整个单例函数都复制一遍的情况，而是只需要创建对应的创建函数即可。 123456789101112131415161718192021function getSingle(fn) &#123; let result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;;&#125;function createLoginLayer() &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是登录弹窗&quot;; div.style.display = &quot;none&quot;; document.body.appendChild(div); return div;&#125;var createSingLoginLayer = getSingle(createLoginLayer);document.getElementById(&quot;loginBtn&quot;).onclick = function () &#123; var loginLayer = createSingLoginLayer(); loginLayer.style.display = &quot;block&quot;;&#125;; 小结​ 单例模式是一种简单，但是非常实用的模式，特别是惰性单例技术，在合适的时候再去创建对象，并且只创建唯一一个，同时我们将创建对象与管理单例的职责分开到不同方法中，这样的模式更加体验单例模式的优势。 策略模式​ 策略模式：定义一系列的算法，把它们一个个的封装起来，并且使它们可以相互替换。 ​ 案例：某个公司年终奖方式为基础工资乘以效绩等级，S为基础工资的4倍，A为基础工资的3倍，我们实用策略模式进行实现 1234567891011121314151617181920212223242526272829303132var performatceS = function () &#123;&#125;; // 效绩为S 工资算法performatceS.prototype.calculate = function (salary) &#123; return salary * 4;&#125;;var performatceA = function () &#123;&#125;; // 效绩为A 工资算法performatceA.prototype.calculate = function (salary) &#123; return salary * 3;&#125;;var Bonus = function () &#123; this.salary = null; // 基础工资 this.strategy = null; // 具体算法&#125;;Bonus.prototype.setSalary = function (salary) &#123; this.salary = salary;&#125;;Bonus.prototype.setStrategy = function (strategy) &#123; this.strategy = strategy;&#125;;Bonus.prototype.getBonus = function () &#123; return this.strategy.calculate(this.salary);&#125;;var bonus1 = new Bonus();bonus1.setSalary(10000);bonus1.setStrategy(new performatceS());console.log(&quot;效绩为A&quot;, bonus1.getBonus()); // 40000bonus1.setStrategy(new performatceA());console.log(&quot;效绩为A&quot;, bonus1.getBonus()); // 30000 JavaScript中策略模式的体现以上是类的实现方法，在JavaScript中我们可以通过函数进行实现，代码将会简洁很多 123456789101112var srtategies = &#123;&#125;;srtategies.S = function (salary) &#123; return salary * 4;&#125;;srtategies.A = function (salary) &#123; return salary * 3;&#125;;var calclateBonus = function (level, salary) &#123; return srtategies[level](salary);&#125;;console.log(&quot;效绩为S&quot;, calclateBonus(&quot;S&quot;, 10000));console.log(&quot;效绩为A&quot;, calclateBonus(&quot;A&quot;, 10000)); 多态在策略模式中的体现​ 通过使用策略模式，我们可以消除程序中大量的ifelse语句，并将我们将具体逻辑与实际执行函数进行分离，执行函数没有计算能力，而是委托某个策略对象来完成奖金计算，这正是多态性的体现。 策略模式在表单校验的应用​ 在通过JavaScript表单校验的场景中,我们可以通过ifelse进行校验判断，但是这种方式不符合单一职责，开放封闭原则，我们可以通过策略模式来优化他，将通用的校验逻辑与具体校验条件进行解耦合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 校验逻辑/** * 如果同时设置了required与verify，将会忽略required * verify为自定义校验函数 可以理解为一旦写了verify,其他参数都不需要写了 * @param data 被校验对象 * @param validate 校验规则 * @param isOne 是否校验到错误就立刻返回 * @returns */function starValidate(data, validate, isOne) &#123; let errBack: any[] = [] for (const key in data) &#123; if (validate[key]) &#123; if (validate[key].verify) &#123; validate[key].verify(&#123; data: data[key], allData: data &#125;, (errMsg) =&gt; &#123; if (errMsg) &#123; errBack.push(errMsg) &#125; else &#123; errBack.push(validate[key].callback(data)) &#125; &#125;) &#125; else &#123; // 开启校验 if (validate[key].required) &#123; // 数据不存在 if (!data[key]) &#123; errBack.push(validate[key].callback(data)) &#125; &#125; &#125; &#125; if (isOne &amp;&amp; errBack.length != 0) &#123; break &#125; &#125; console.log(&#x27;处理结果&#x27;, errBack) if (errBack.length == 0) &#123; return Promise.resolve() &#125; else &#123; if (isOne) &#123; return Promise.reject(errBack[0]) &#125; else &#123; return Promise.reject(errBack) &#125; &#125;&#125;// 校验条件const validateRules = &#123; cashingInstructions: &#123; required: true, callback: () =&gt; (&#123; selector: &#x27;.open_prize&#x27;, message: &#x27;请输入字段cashingInstructions&#x27; &#125;), &#125;, lotteryDescription: &#123; verify: (&#123; data &#125;, err) =&gt; &#123; if (data == &#x27;[]&#x27;) &#123; err(&#123; selector: &#x27;.launch_total&#x27;, message: &#x27;请输入字段lotteryDescription&#x27;, &#125;) &#125; &#125;, &#125;,&#125;let data = &#123; cashingInstructions:&#x27;&#x27;, lotteryDescription:&#x27;[]&#x27;&#125;// 实现表单校验 starValidate(data, validateRules, true) 策略模式的优缺点优点 策略模式利用组合，委托和多态等技术与思想，可以有效避免多重条件选择语句 策略模式符合开放封闭原则，将具体逻辑单独封装，使其易于理解易于拓展 策略模式的策略函数可以再多项目之间复用，避免复制粘贴工作 缺点 相对于ifelse，策略模式的整体代码量会有所增加 调用者需要对策略细节可能了解，才能很好的使用该策略，这违反了最少知识原则，增加了使用成本 一等公民函数与策略模式​ 在函数作为一等公民的语言中，策略模式是隐形的具体策略的值就是函数变量。 ​ 在JavaScript这种将函数作为一等对象的语言中，策略模式已经融入到语言中，例如我们经常使用高阶函数来封装不同行为，并且将它传递到另一个函数中，当我们对这些函数发出“调用”的消息，不同的函数会返回不同的结果，函数对象的多态性来到更加简单。 代理模式​ 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个提升对象来控制对这个对象的访问，客户实际上访问的是替身对象。 小红想找心仪的对象让小明作为自己的媒人(代理人) 保护代理：张三找过来了，但是张三没车没房，小红便直接帮他拒绝 虚拟代理：介绍给小明是非常重要的事情，李四对小红有兴趣，给小明好处费，小明便在小红心情好的时候给其介绍（延迟到正常需要的时候再创建） 单一职责原则​ 对一个类&#x2F;函数&#x2F;对象而言，应该仅有一个引起它变化的原因，如果一个对象承担了多种职责，就意味着这个对象将变得巨大，引起它变化的原因将会有多种。面向对象估计设计将行为分布到细颗粒度的对象中，如果一个对象承担的职责过多，等于把这些职责耦合在一起，这种耦合会导致脆弱和低内聚的设计，当变化发生时，设计会遭到意外的破坏。 开放封闭原则​ 例如我们为了更好的性能将一些数据处理成为另外的数据格式，但是2年后上游帮助我们处理过了，我们不再需要额外处理，就不得不在改动原本函数中的代码 ​ 我们可以使用代理模式 达到不改动原对象的情况下，为其提供新的行为，他们各自变化，也不影响对象。 代理与本体接口的一致性​ 通常来说，代理对象对外提供的方法名称会与本体名称保持一致，这样可以在任何使用本体的地方替换成使用代理 代理模式-合并http请求​ 这是一个应用案例，文中的例子我在日常生活中也经历过，将每次点击都请求转变为收集2s类所有请求，并统一发送出去，发送请求时一个函数，何时发送，发送什么，时另一个函数，其中用到了节流函数来控制请求频率 代理模式 - 空间复杂度换取时间复杂度面对非常复杂的计算逻辑，我们可以保存每一次的计算结果，下一个再来同样的参数可以直接走缓存，不再需要计算，这样增加空间，但是缩小了时间。 代理模式示例12345678910111213141516171819202122232425262728293031323334353637var muit = function () &#123; var a = 1; for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i]; &#125; return a;&#125;;var plus = function () &#123; var a = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; a = a + arguments[i]; &#125; return a;&#125;;// 代理模式函数var ceateProxyFactory = function (fn) &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, &quot;,&quot;); if (args in cache) &#123; console.log(&quot;存在缓存&quot;, args,cache); return cache[args]; &#125; cache[args] = fn.apply(this, arguments); return cache[args]; &#125;;&#125;;var muitFun = ceateProxyFactory(muit);var plusFun = ceateProxyFactory(plus);console.log(muitFun(1, 2, 3, 4, 5)); // 120console.log(muitFun(1, 2, 3, 4, 5)); // 走缓存 120console.log(plusFun(1, 2, 3, 4, 5)); // 15console.log(plusFun(1, 2, 3, 4, 5)); // 走缓存 15 总结​ 总体来说代理模式相对简单并且常用，就算一名开发人员没听过这个名词也会写出比较优秀的代理模式代码，并且代理模式不需要预先考虑，需要用到的时候再编写代理函数也不迟。 迭代器模式内部迭代器​ 完全接手整个迭代过程，外部只需要初始调用即可，外界不需要关心迭代器的内部实现，但是这也是内部迭代器的缺点 ​ 例如JavaScript的map forEach 外部迭代器​ 外部迭代器必须显式的请求迭代下一个元素，外部迭代器增加了程序的复杂度，但是也增强了迭代器的灵活性。 12345678910111213var current = 0;var aa = function (obj) &#123; var next = function () &#123; current += 1; &#125;; var getItem = function () &#123; return obj[current]; &#125;; return &#123; next, getItem, &#125;;&#125;; ​ 再具体业务中，使用何种迭代器并无优劣，根据实际场景而定。 总结​ 大部分语言已经内置了迭代器，并且使用频率高、门槛低；迭代器是一种非常简单设计模式，简单到大部分人不认为他是一种迭代器。 发布-订阅模式​ 发布-订阅模式它订阅了一种一对多的依赖关系,当一个对象的状态发生改变的时，所有依赖于它的对象都将得到通知 案例​ 小明看重了某一个小区的热门户型，并且得到消息，后期还会开放一批，但是时间未知，于是小明找到售楼处，预留了自己的电话号码，让售楼处在开发房源的时候通知他，同理，小张、小王都预留了手机号码，于是售楼处就会在房源发布的时候通知预留电话的客户。 ​ 客户想知道房源开售消息，于是他订阅了售楼处，售楼处得到消息后，第一时间将消息发布给订阅者，这样具备显而易见的优点。 小明不需要天天给售楼处打电话，在合适的时间售楼处会通知购房者 购房者于售楼处不再有强耦合关系 发布-订阅模式的作用​ 以上场景于程序中的异步场景是非常相似的，例如我们订阅ajax的error事件，我们无需关心异步运行期间的内部状态，只需要订阅需要的事件发生点即可。 ​ 另外发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式的调用另一个对象的某个接口。 dom事件​ 我们使用dom绑定事件函数就是发布-订阅模式的实际应用，我们不知道用户会在什么时候点击点击，所以我们订阅了dom本身的click事件。 自定义发布-订阅事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546var salesOffices = &#123;&#125;;salesOffices.clientList = [];salesOffices.listen = function (key, fn) &#123; // 创建订阅关联关系 if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn);&#125;;salesOffices.trigger = function () &#123; // 获取订阅数组 var key = Array.prototype.shift.call(arguments); var fns = this.clientList[key]; // 不存在订阅数组则直接返回 if (!fns || fns.length === 0) &#123; return false; &#125; // 执行订阅数组 for (let i = 0; i &lt; fns.length; i++) &#123; let fn = fns[i]; fn.apply(this, arguments); &#125;&#125;;// 小明订阅salesOffices.listen(&quot;sq88&quot;, function (price) &#123; console.log(&quot;我是小明，88平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);salesOffices.listen(&quot;sq88&quot;, function (price) &#123; console.log(&quot;我是小强，88平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);// 小红订阅salesOffices.listen(&#x27;sq110&#x27;, function (price) &#123; console.log(&quot;我是小红，110平方&quot;); console.log(&quot;价格=&quot;, price);&#125;);salesOffices.trigger(&quot;sq88&quot;, 20000000);salesOffices.trigger(&quot;sq110&quot;, 30000000);// 我是小明，88平方// 价格=20000000// 我是小强，88平方// 价格=20000000// 我是小红，110平方// 价格=30000000 取消订阅​ 取消订阅只需要将订阅数组中的指定订阅函数删除即可 123456789101112131415161718192021222324/** * key 订阅类型 * fn 订阅函数 */salesOffices.remove = function (key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; // 没有传入具体的回调地址，则取消所有订阅函数 if (fns) &#123; fns.length = 0; &#125; &#125; else &#123; for (let i = 0; i &lt; fns.length; i++) &#123; const fnItem = fns[i]; if (fnItem === fn) &#123; fns.splice(i, 1); // 删除订阅函数回调 break; &#125; &#125; &#125;&#125;; 关于网站登录的实际应用场景：用户登录完成后，我们需要刷新不相邻模块的数据，这种异步问题，我们一般通过回调函数的方式解决 123456login.succ(() =&gt; &#123; header.setAvatar(data.avatar) nav.setAvatar(data.avatar) message.refresh() // ....&#125;) ​ 这种编写方式将组件数据于信息产生了强耦合关系，如果在未来，我们又增加了一个模块，则需要再次修改改回调函数 ​ 而通过发布-订阅模式，我们就可以在不同模块中订阅用户信息状态的变化，当登录成功的时候，登录模块发布消息到订阅他的模块中，至于各个模块做了什么，登录模块并不关心。 123login.listen(&#x27;loginSucc&#x27;,() =&gt; &#123; // 登录成功，用户数据获取完毕&#125;) 全局模式下的发布-订阅模式​ 全局状态下的发布-订阅可以在两个毫不相关的模块之间进行使用，这样就能保持模块的封装性 ​ 但是这里也需要留意一个问题，如果模块之间又太多的全局发布-订阅模式，就会造成消息流向混乱问题，这会导致维护上出现一些问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var Event = (function () &#123; var clientList = &#123;&#125;; var listen; var trigger; var remove; listen = function (key, fn) &#123; // 创建订阅关联关系 if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function () &#123; // 获取订阅数组 var key = Array.prototype.shift.call(arguments); var fns = clientList[key]; // 不存在订阅数组则直接返回 if (!fns || fns.length === 0) &#123; return false; &#125; // 执行订阅数组 for (let i = 0; i &lt; fns.length; i++) &#123; let fn = fns[i]; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; // 没有传入具体的回调地址，则取消所有订阅函数 if (fns) &#123; fns.length = 0; &#125; &#125; else &#123; for (let i = 0; i &lt; fns.length; i++) &#123; const fnItem = fns[i]; if (fnItem === fn) &#123; fns.splice(i, 1); // 删除订阅函数回调 break; &#125; &#125; &#125; &#125;; return &#123; listen, trigger, remove, &#125;;&#125;)();var xm = function (price) &#123; console.log(&quot;小明价格&quot;, price);&#125;;Event.listen(&quot;sq88&quot;, xm); // 订阅Event.listen(&quot;sq110&quot;, xm); // 订阅Event.remove(&quot;sq88&quot;, xm); // 取消订阅Event.trigger(&quot;sq88&quot;, 220000); // 发布Event.trigger(&quot;sq110&quot;, 2020000); // 发布 JavaScript实现发布-订阅模式的便利性推模型​ 事情发生的时候，发布者会一次性将所有改变的状态与数据都推送给订阅者 拉模型​ 事情发生的时候，发布者只会告诉所有订阅者，需要订阅者手动去拉去 ​ 而在JavaScript中，因为语言特性的存在，是我们可以非常方便的将所有参数通过arguments传入订阅者，所以我们使用推模型来完成消息的订阅与发布。 总结优点 对象之间的解耦合，可以帮助我们写出更好的应对异步编程的场景。 通过订阅-发布模式可以实现以此为特性的解决方案，例如MVVM。 缺点 创建订阅-发布模式需要消耗一定的时间与内存。 订阅的消息会一直留存在内存中，产生了无意义的消耗。 过度使用订阅-发布会导致程序难以追踪与维护。 ​ 命令模式​ 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者与请求接收者能够消除彼此之间的耦合关系 ​ 命令模式还需要支持撤销、排队等等操作 命令模式的例子-菜单程序（面向对象）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var btn1 = document.getElementById(&quot;btn1&quot;);var btn2 = document.getElementById(&quot;btn2&quot;);var btn3 = document.getElementById(&quot;btn3&quot;);var setCommand = function (btn, commm) &#123; btn.onclick = function () &#123; commm.execute(); &#125;;&#125;;var MenuBar = &#123; refresh: function () &#123; console.log(&quot;刷新菜单目录&quot;); &#125;,&#125;;var SubMenu = &#123; add: function () &#123; console.log(&quot;增加子菜单&quot;); &#125;, del: function () &#123; console.log(&quot;删除子菜单&quot;); &#125;,&#125;;var RefreshMenuBarCommand = function (receiver) &#123; this.receiver = receiver;&#125;;RefreshMenuBarCommand.prototype.execute = function () &#123; this.receiver.refresh();&#125;;var AddSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;AddSubMenuCommand.prototype.execute = function () &#123; this.receiver.add();&#125;;var DelSubMenuCommand = function (receiver) &#123; this.receiver = receiver;&#125;;DelSubMenuCommand.prototype.execute = function () &#123; this.receiver.del();&#125;;var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);var addSubMenuCommand = new AddSubMenuCommand(SubMenu);var delSubMenuCommand = new DelSubMenuCommand(SubMenu);setCommand(btn1, refreshMenuBarCommand); // 将div与方法做好绑定关系,同时约定一个触发指令点击btn1触发refresh内部预留的execute方法setCommand(btn2, addSubMenuCommand);setCommand(btn3, delSubMenuCommand); 命令模式的例子-菜单程序（面向函数）123456var bindClick = function (btn, func) &#123; btn.onclick = func;&#125;;bindClick(btn1, MenuBar.refresh);bindClick(btn2, SubMenu.add);bindClick(btn3, SubMenu.del); 命令模式的由来，其实就是回调（callback）函数的一个面向对象的替代品 而再JavaScript这样函数作为一等公平的语言中，命令模式早已经融入到语言之中，函数本身就可以被四处传递，即时我们依旧需要请求“接收者”，那也未必使用面向对象的方式，闭包同样可以完成同样的功能。 命令模式的例子-菜单程序（闭包）1234567891011121314var setCommand = function (btn, func) &#123; btn.onclick = function () &#123; func(); &#125;;&#125;;var RefreshMenuBarCommand = function (receiver) &#123; return function () &#123; receiver.refresh(); &#125;;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(btn1, refreshMenuBarCommand); 命令模式 - 回放123456789101112131415161718192021222324252627282930313233343536373839var Ryu = &#123; attack: function () &#123; console.log(&quot;攻击&quot;); &#125;, defense: function () &#123; console.log(&quot;防御&quot;); &#125;, jump: function () &#123; console.log(&quot;跳跃&quot;); &#125;, crouch: function () &#123; console.log(&quot;蹲下&quot;); &#125;,&#125;;var makeCommand = function (receiver, state) &#123; return function () &#123; receiver[state](); &#125;;&#125;;var commandStack = []; // 保存命令堆栈document.onkeypress = function (ev) &#123; var commands = &#123; 119: &quot;jump&quot;, // w 115: &quot;crouch&quot;, // s 97: &quot;defense&quot;, // a 100: &quot;attack&quot;, // d &#125;; if (commands[ev.keyCode]) &#123; var command = makeCommand(Ryu, commands[ev.keyCode]); command(); // 执行命令 commandStack.push(command); // 保存到堆栈 &#125;&#125;;document.getElementById(&quot;replay&quot;).onclick = function () &#123; var command; while ((command = commandStack.shift())) &#123; command(); &#125;&#125;; 宏命令​ 宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。 ​ 在创建命令模式的时候，增加一个add方法来增加命令，并保存到任务对略，最后调用execute方法依次执行即可 总结​ 命令模式在JavaScript中因为高阶函数的存在，让其不太显眼，本质上他是将具体调用与调用的具体逻辑进行分离，具体逻辑就是命令的体现。 组合模式​ 组合模式需要通过对象的多态性进行体现，是的用户对单个对象和组合对象的使用具有一致性 示例​ 这里定义了一个通用函数execute来作为组合模式的桥梁，完成对象树的构建。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;button id=&quot;button&quot;&gt;按我&lt;/button&gt;&lt;script&gt; var MacroCommand = function () &#123; return &#123; commandsList: [], add: function (command) &#123; this.commandsList.push(command); &#125;, execute: function () &#123; for (let i = 0; i &lt; this.commandsList.length; i++) &#123; this.commandsList[i].execute(); &#125; &#125;, &#125;; &#125;;var openAcCommand = &#123; execute: function () &#123; console.log(&quot;打开空调&quot;); &#125;,&#125;;var openTvCommand = &#123; execute: function () &#123; console.log(&quot;打开电视&quot;); &#125;,&#125;;var openSoundCommand = &#123; execute: function () &#123; console.log(&quot;打开音响&quot;); &#125;,&#125;;var macroCommand1 = MacroCommand();macroCommand1.add(openTvCommand);macroCommand1.add(openSoundCommand);var closeDoorCommand = &#123; execute: function () &#123; console.log(&quot;关门&quot;); &#125;,&#125;;var openPcCommand = &#123; execute: function () &#123; console.log(&quot;打开电脑&quot;); &#125;,&#125;;var openQQCommand = &#123; execute: function () &#123; console.log(&quot;登录QQ&quot;); &#125;,&#125;;var macroCommand2 = MacroCommand();macroCommand2.add(closeDoorCommand);macroCommand2.add(openPcCommand);macroCommand2.add(openQQCommand);var macroCommand = MacroCommand();macroCommand.add(openAcCommand); // 如果是基本对象,就是直接触发到其本身的execute方法macroCommand.add(macroCommand1); // 如果是复杂对象,则触发到下一级的execute,然后以深度优点遍历直到最底部的基本对象macroCommand.add(macroCommand2);var setCommand = (function (command) &#123; document.getElementById(&quot;button&quot;).onclick = function () &#123; command.execute(); &#125;;&#125;)(macroCommand);&lt;/script&gt; ​ 组合模式最大的优点在于可以一致地对待组合对象与基本对象。客户不需要关心当前处理的是谁，只要它是一个命令，并且有execute方法，这个命令就可以被执行。 ​ 得益于JavaScript是动态类型语言，对象的多态性与生俱来，不会存在编辑器检查，所以我们实现组合模式并不需要编写抽象类，只需要保证组合对象与叶对象拥有相同的方法即可，并且用鸭子类型的思想进行接口检查 组合模式-扫描文件夹​ 我们通过组合模式，可以做到更新树的结构，但是却不需要改变原有代码，这符合开放封闭原则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Folder = function (nameParams) &#123; let name = nameParams; let files = []; function add(file) &#123; files.push(file); &#125; function scan() &#123; console.log(&quot;开始扫描文件夹&quot;, name); for (let i = 0; i &lt; files.length; i++) &#123; files[i].scan(); &#125; &#125; return &#123; add, scan, &#125;;&#125;;var File = function (nameParams) &#123; let name = nameParams; function add() &#123; throw new Error(&quot;文件中不能增加文件夹&quot;); &#125; function scan() &#123; console.log(&quot;开始扫描文件&quot;, name); &#125; return &#123; add, scan, &#125;;&#125;;var folder = new Folder(&quot;学习资料&quot;);var folder1 = new Folder(&quot;JavaScript&quot;);var folder2 = new Folder(&quot;jQuery&quot;);var file1 = new File(&quot;JavaScript设计模式与开发实践&quot;);var file2 = new File(&quot;精通jQuery&quot;);var file3 = new File(&quot;重构与模式&quot;);folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3);var folder3 = new Folder(&quot;Nodejs&quot;);var file4 = new File(&quot;深入浅出Node.js&quot;);folder3.add(file4);var file5 = new File(&quot;JavaScript语言精髓与编程实战&quot;);folder.add(folder3);folder.add(file5);folder.scan(); 一些需要注意的地方 组合模式不是父子关系 对一组叶对象的操作必须具有一致性，只有用一致的方式对待列表中的每一个叶对象，才适合使用组合模式 如果存在一个叶子元素存在多个父级，可能就需要管理映射关系，避免子元素多次被执行 总结​ 组合模式可以让我们把相同的操作应用在组合对象和单个对象上。 组合模式的美国和对象看起来都和其他对象差不多，他们的区别只能在运行中才能显现出来，这会使代码难以理解 组合模式会大量创建变量，会让系统负担不起 模板方法模式​ 模板方法是一种只需要继承就可以实现的非常简单的模式（多态性） 模板方法由2部分组成，第一部分是抽象父类，第二部分是具体的实现子类 在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留到子类中进行实现，这很好的体现了泛化的思想。 ​ 在模板方法中，子类实现中的相同部分被上移到父类中，而将不同的部分留给子类实现，子类可以复写其具体实现。 咖啡与茶1234567891011121314151617181920212223242526272829303132333435363738394041var Beverage = function () &#123;&#125;;Beverage.prototype.boilWater = function () &#123; console.log(&quot;把水煮沸&quot;);&#125;;Beverage.prototype.brew = function () &#123;&#125;;Beverage.prototype.pourInCup = function () &#123;&#125;;Beverage.prototype.addCondiments = function () &#123;&#125;;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;;var Coffee = function () &#123;&#125;;Coffee.prototype = new Beverage();Coffee.prototype.brew = function () &#123; console.log(&quot;沸水冲泡咖啡&quot;);&#125;;Coffee.prototype.pourInCup = function () &#123; console.log(&quot;把咖啡倒进杯子&quot;);&#125;;Coffee.prototype.addCondiments = function () &#123; console.log(&quot;加糖和牛奶&quot;);&#125;;var Coffee = new Coffee();Coffee.init();var Tea = function () &#123;&#125;;Tea.prototype = new Beverage();Tea.prototype.brew = function () &#123; console.log(&quot;沸水冲泡咖啡&quot;);&#125;;Tea.prototype.pourInCup = function () &#123; console.log(&quot;把咖啡倒进杯子&quot;);&#125;;Tea.prototype.addCondiments = function () &#123; console.log(&quot;加糖和牛奶&quot;);&#125;;var Tea = new Tea();Tea.init(); ​ 在以上例子中Beverage.prototype.init就是所谓的模板方法，因为该帆帆中封装了子类的算法框架。 抽象类模板方法模式是一种严格依赖抽象类的设计模式。 抽象帆帆被声明在抽象类中，抽象方法并没有具体的实现过程，是一些哑巴方法 如果每个子类中都有一些同样的具体实现方法，那么这些方法也可以选择放在抽象类中，这样可以节省代码以达到复用的效果，这些方法被叫做具体方法。 钩子方法​ 模板方法是固定不变的，但是在某些场景下却又要求他变化，有什么办法可以让子类不受这个约束呢？ ​ 我们可以使用钩子方法来实现，放置一个钩子在特定的逻辑。例如以上的例子中咖啡有些人不希望加调料 12345678910111213141516171819// ...Beverage.prototype.custonmerWantsCondiments = function () &#123; return true; // 默认需要调料&#125;;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); if (this.custonmerWantsCondiments()) &#123; this.addCondiments(); &#125;&#125;;// ...Coffee.prototype.custonmerWantsCondiments = function()&#123; return window.confirm(&#x27;请问需要调料吗？&#x27;)&#125;var Coffee = new Coffee();Coffee.init(); 好莱坞原则​ 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历投递过去之后，只能回家等电话，有些等不及的就会打电话过去问，而好莱坞每次都会回答：“不太来找我，有消息我会通知你” ​ 在设计中，这种模式被称为好莱坞原则，在程序中，高层组件决定什么时候以何种方式使用这些底层组件 ​ 这种模式在模板方法模式中很常见，在发布订阅模式，回调函数都非常适用，就像出租车司机告诉你别问我还有多远到，到了我会告诉你。 小结​ 模板方法是一种典型的通过封装变化提高系统拓展性的设计模式。我们把部分抽象逻辑抽象到父类的模板方法，而子类的方法具体怎么实现是可变的，于是我们把这部分变化的逻辑封装到子类中。 享元模式案例​ 假设有一个服装工厂，目前里面50个男士样式，50个女士样式，他们都需要模特穿上拍宣传片，正常情况下就需要分别50个模特来拍照，程序实现逻辑为 123456789101112131415var Model = function (sex, underwear) &#123; this.sex = sex; this.underwear = underwear;&#125;;Model.prototype.takePhoto = function () &#123; console.log(`$&#123;this.sex&#125;:$&#123;this.underwear&#125;`);&#125;;for (let i = 0; i &lt; 50; i++) &#123; var maleModel = new Model(&quot;male&quot;, `underwear$&#123;i&#125;`); maleModel.takePhoto();&#125;for (let i = 0; i &lt; 50; i++) &#123; var femaleModel = new Model(&quot;female&quot;, `underwear$&#123;i&#125;`); femaleModel.takePhoto();&#125; ​ 现在分别50种内衣，一共有100个对象，后面如果越来越多，10000个，可能就会导致程序崩溃。其实我们仔细想想就会发现，我们不需要一套内衣都搭一个模特，只需要一个男模特，一个女模特就够了，我们根据这样的思路再次改写代码 123456789101112131415var Model = function (sex) &#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function (underwear) &#123; console.log(`$&#123;this.sex&#125;:$&#123;underwear&#125;`);&#125;;var maleModel = new Model(&quot;male&quot;);var femaleModel = new Model(&quot;female&quot;);for (let i = 0; i &lt; 50; i++) &#123; maleModel.takePhoto(`underwear$&#123;i&#125;`);&#125;for (let i = 0; i &lt; 50; i++) &#123; femaleModel.takePhoto(`underwear$&#123;i&#125;`);&#125; ​ 改造之后，我们只需要两个对象就实现了相同的功能，并且开销是固定的2个，就算10000间衣服也不会出现问题 外部状态与内部状态 享元模式的目标是尽量减少共享对象的数量，是优先使用时间换取空间的优化模式 上传文件的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var id = 0;window.startUpload = function (uploadType, files) &#123; for (let i = 0; i &lt; files.length; i++) &#123; let file = files[i]; var uploadObj = new Upload(uploadType, file.fileName, file.fileSize); // 实例化传入变量 uploadObj.init(id++); // init中创建dom &#125;&#125;;var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null;&#125;;Upload.prototype.init = function (id) &#123; var that = this; this.id = id; this.dom = document.createElement(&quot;div&quot;); this.dom.id = id; this.dom.innerHTML = `&lt;span&gt;文件名称：$&#123;this.fileName&#125; 文件大小：$&#123;this.fileSize&#125; 上传方式:$&#123;this.uploadType&#125;&lt;/span&gt;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;`; this.dom.querySelector(&quot;.delFile&quot;).onclick = function () &#123; that.delFile(); &#125;; document.body.appendChild(this.dom);&#125;;Upload.prototype.delFile = function () &#123; if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm(&quot;确定删除文件吗？&quot; + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;;startUpload(&quot;plugin&quot;, [ &#123; fileName: &quot;1.txt&quot;, fileSize: 1000, &#125;, &#123; fileName: &quot;2.txt&quot;, fileSize: 2000, &#125;,]);startUpload(&quot;flash&quot;, [ &#123; fileName: &quot;5.txt&quot;, fileSize: 6000, &#125;, &#123; fileName: &quot;6.txt&quot;, fileSize: 7000, &#125;,]); ​ 在以上例子中，我们上传多少文件就需要创建多少个对象，接下来我们用享元模式重构以上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; &#125;; Upload.prototype.delFile = function (id) &#123; let carry = uploadManager.setExternalState(id); return carry.dom.parentNode.removeChild(carry.dom); &#125;; var UploadFactoy = (function () &#123; var createFlyWeghtObjs = &#123;&#125;; return &#123; create: function (uploadType) &#123; if (createFlyWeghtObjs[uploadType]) &#123; return createFlyWeghtObjs[uploadType]; &#125; createFlyWeghtObjs[uploadType] = new Upload(uploadType); return createFlyWeghtObjs[uploadType]; &#125;, &#125;; &#125;)(); var uploadManager = (function () &#123; var uploadDataBase = &#123;&#125;; return &#123; add: function (id, uploadType, fileName, fileSize) &#123; var flyWeight = UploadFactoy.create(uploadType); var dom = document.createElement(&quot;div&quot;); dom.innerHTML = `&lt;span&gt;文件名称：$&#123;fileName&#125; 文件大小：$&#123;fileSize&#125; 上传方式:$&#123;uploadType&#125;&lt;/span&gt;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;`; dom.querySelector(&quot;.delFile&quot;).onclick = function () &#123; flyWeight.delFile(id); &#125;; document.body.appendChild(dom); uploadDataBase[id] = &#123; fileName, fileSize, dom, &#125;; console.log(uploadDataBase); return flyWeight; &#125;, setExternalState: function (id) &#123; return uploadDataBase[id]; &#125;, &#125;; &#125;)(); var id = 0; window.startUpload = function (uploadType, files) &#123; for (let i = 0; i &lt; files.length; i++) &#123; let file = files[i]; uploadManager.add(++id, uploadType, file.fileName, file.fileSize); &#125; &#125;; startUpload(&quot;plugin&quot;, [ &#123; fileName: &quot;1.txt&quot;, fileSize: 1000, &#125;, &#123; fileName: &quot;2.txt&quot;, fileSize: 2000, &#125;, ]); startUpload(&quot;flash&quot;, [ &#123; fileName: &quot;5.txt&quot;, fileSize: 6000, &#125;, &#123; fileName: &quot;6.txt&quot;, fileSize: 7000, &#125;, ]); ​ 通过享元模式创建后，实例化的对象因为工厂模式的存在只创建了2个。 享元模式的适用性 一个程序中使用了大量相似的对象，并且这些对象大多数状态是可以成为外部状态的 可以使用共享对象取代大量对象，将外部状态剥离出去 对象池​ 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不会再去new，还是从对象池中进行获取，如果对象池不存在可用对象，则创建一个新对象，当获取处的对象完成了他的职责之后，再次进入池子等待下次获取 地图标点demo ​ 进入地图软件后，首先搜索A地点，存在2个坐标点，通过工厂函数便创建了2个，而后搜索了B地点，存在6个坐标，便会利用之前空闲的2个，再新增加4个坐标点 ​ 对象池的模式与享元模式类，知识没有状态分离的过程。 12345678910111213141516171819var objectPoolFactory = function (createObjFun) &#123; var objectPool = []; return &#123; create: function () &#123; // 创建对象 if (objectPool.length === 0) &#123; // 如果对象池中没有对象，就创建一个新的对象 return createObjFun.apply(this, arguments); &#125; else &#123; // 如果对象池中有对象，就从对象池中取出一个对象 return objectPool.shift(); &#125; &#125;, recover: function (obj) &#123; // 回收对象 objectPool.push(obj); &#125;, &#125;;&#125;; 总结​ 享元模式主要为解决性能问题，在一个存在大量相似对象的系统中，享元模式可以很好的解决大量对象带来的性能问题。 职责链模式​ 使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 ​ 职责链优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/categories/JavaScript/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://vkcyan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"随选朗读 - 给长辈更好的手机使用体验","slug":"随选朗读 - 赋予长辈手机使用能力","date":"2022-06-11T16:00:00.000Z","updated":"2022-06-14T01:32:06.561Z","comments":true,"path":"2022/06/12/随选朗读 - 赋予长辈手机使用能力/","link":"","permalink":"https://vkcyan.github.io/2022/06/12/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB%20-%20%E8%B5%8B%E4%BA%88%E9%95%BF%E8%BE%88%E6%89%8B%E6%9C%BA%E4%BD%BF%E7%94%A8%E8%83%BD%E5%8A%9B/","excerpt":"","text":"时代背景​ 在历史上的1952年5月24日是一个特殊的日子，在那一天正式开始大规模扫盲运动。新中国成立之初，全国5.5亿人口，80%都是文盲，农村的文盲率达到了95%以上，让我们把时间拉回2022年的今天，今天我想描述的是90后的父母一代，大约是1960-1975诞生于华夏文明的人，根据官方调查90后父母一代的文盲率大约为40%。 ​ 90后父母一代是疲惫的，他们大多从农村出来，为城市建设添砖加瓦，拿着微薄的薪水，做着繁重的工作，赶上了房价翻了一番又一番，他们的压力从来不会出现在主流媒体中，他们也大多数已经年过半百，身体机能开始衰退，视力开始下降，在互联网时代与90、00后赚个满怀的时候，他们只能踉踉跄跄的跟紧时代的步伐，他们是社会上看不见的大多数。而随着岁月的流失，亦或者时代的影响，存在很大一部分人因为视力问题，或者文盲，失去了使用手机的能力。 随选朗读 ​ 大部分年轻人可能并不知道这个名词，因为我们正值身体的最佳状态，本身便不存在工具来创造无障碍的场景，我们来了解一下“随选难度”的官方定义吧。 ​ “随选难度”可帮助障碍用户在无法使用视觉获取信息、阅读困难等情况下通过读取屏幕的无障碍接口来获取用户想要阅读的界面的文本信息，然后再调用语音库将之朗读出来。简而言之，用户在开启该功能后，可将他想获取的文本信息转化为音频被接收。 目标人群 低视力、老花眼人群 低文化水平、文盲人群 场景性障碍人群 ​ 随着岁数的增加，亦或者长期疲劳用眼，老花眼必然会出现在人类的生命轨迹之中，面对这样的情况，一般需要配一个老花镜，在阅读较小较密集文字的时候带上眼镜才能看清文字，正常生活并不需要长时间戴眼镜，而有了随选朗读功能后，查看手机咨询只需要滑动文字区域，即可让手机完成其识别与阅读，规避用眼场景，这将大幅度改善中老年人的手机使用体验。 ​ 90后的父母一代，文盲比例已经相对较少，但是在华夏大地庞大的人口基数下，也算是5%也是非常大的人口体量，因为不认识字，他们使用手机困难重重，但是又不得不使用智能手机，例如在进出都需要扫码的疫情时代，遍地移动支付的互联网时代，如果没有家人或者朋友的反复教学，他们可能永远都无法正常使用智能手机，甚至家人微信聊天都只能发送语音，而随选朗读则给予了文盲人群识别文字的能力，遇到不认识的字，滑动一下就会读出来，这给予了文盲用户独立使用智能手机的能力，作为晚辈也减小了压力。 ​ 最后是场景性障碍人群，例如开车中，做饭中暂时无法看长时间看屏幕的场景，不过从现实来看此类场景需求不大，因为长文可以等会看，一小段文本则很快就看完了，此处便不再赘述。 如何使用小米手机设置 - 更多设置 - 无障碍 - 视觉 - 随选朗读 开启后点击小喇叭就会出现一个红色按钮，即可选中你想被阅读的区域，松手即可开始朗读，朗读完毕后自动关闭，如果想下次使用，可以再次点击小喇叭，不同手机入口显示方式不同，有些是显示小人形状。 华为手机设置 - 辅助功能 - 无障碍 - 随选朗读 - 开启 iphone设置 - 辅助功能 - 朗读内容 - 朗读屏幕 - 语音控制器 - 打开显示控制器 其他手机​ 身边手机有限，就算一个品牌的手机不同版本设置路径也存在一定区别，不过可以放心无障碍功能所有手机都有，因为这是android，ios系统原生功能，一般都在其他设置&#x2F;无障碍菜单中。 没有随选朗读​ 我把周围同事的手机大致都研究了一遍，发现如果是20年之前的手机，大部分是没有“随选朗读”功能的，无障碍套件由安卓系统提供，低版本系统存在没有随选朗读的现象，手机没有自带没有关系，可以第三方下载，我在百度网盘放了一个，android无障碍套件v12.1，有需要的朋友请自取。 结语​ 看到这里，不知道你是否想到了长辈们，为了看手机上的微信消息而着急寻找眼镜的匆忙场景，是否想到了长辈们因为看不懂文字而无法正常使用手机的窘境，而通过简单设置，就可以赋予有困难的长辈们更好使用智能手机的能力，机器无情，人间有情，沉舟侧畔千帆过，病树前头万木春，记得多回头看看驻留在原地的那群可爱的人。","categories":[{"name":"玩机技巧","slug":"玩机技巧","permalink":"https://vkcyan.github.io/categories/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"无障碍","slug":"无障碍","permalink":"https://vkcyan.github.io/tags/%E6%97%A0%E9%9A%9C%E7%A2%8D/"},{"name":"随选朗读","slug":"随选朗读","permalink":"https://vkcyan.github.io/tags/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB/"}]},{"title":"三辆自行车","slug":"三辆自行车","date":"2022-06-09T16:00:00.000Z","updated":"2022-06-14T01:34:55.933Z","comments":true,"path":"2022/06/10/三辆自行车/","link":"","permalink":"https://vkcyan.github.io/2022/06/10/%E4%B8%89%E8%BE%86%E8%87%AA%E8%A1%8C%E8%BD%A6/","excerpt":"","text":"​ 初中的时候，我特别想要一个自行车，大概觉得骑车很酷吧，或者是幼年的虚荣心作祟，那时候家里条件还很差，三口之家租住在一个没有空调的老旧矮楼的二楼第一间，大约12平方的四方四正的小屋，大家可以想象一下电视剧蜗居的样子吧，父母自然不同意卖一辆自行车，上学的路程只有2公里，这点距离还要骑自行车，在爸妈眼里是不可理喻的，可终究是拗不过我，在那个夏天的夜晚，爸带我到一个破破烂烂的修车铺，那是一辆蓝色有点破旧的小轮自行车，依稀记得车头是一个T形的，黑漆上零星的白点，刹车线已经泛黄仿佛蒙上了茶油的滤镜，这似乎在告诉我它的年纪，我爸对此很满意，大约150吧，带着我带着它一起回家了，我相信爸妈是开心的，因为终于不用听这小子天天嚷嚷了，我也就是这么迷迷糊糊的有了一台自行车。 ​ 好景不长，这辆蓝色小轮车骑起来轴承里面会发出宛如鞭炮一样哒哒哒的，这让一个刚刚满12岁的小孩内心倍感自卑，因为我害怕因为这个声音招来马路上嘲笑的目光，以至于放学路上同学都骑走了，我才会开始骑车，我又开始不断嚷嚷自行车的问题，我妈耳根子软，心里虽然气愤儿子不懂事，但是依旧妥协了，没多久换了一辆新的凤凰牌自行车，蓝色小车被我爸骑电瓶车带回了老家，给了在村里的表姐，因为离镇上很远，她非常需要一辆车，而我终于如愿以偿的得到了一辆崭新的真正的自行车，那是一辆的银灰色自行车，车架在阳光下发射着宛如银河的色彩，黑色的车头一尘不染的深邃，仿佛在告诉全世界，他的诞生，也终于没有了哒哒哒的骑行背景音乐；而这属于我的第一辆新自行车的命运却是如此的凄惨，在我还没来得及和他好好人认识的时候，便戛然而止，是的，没多久他就被偷了；记得那天早上我骑着它到补习班，补习班对面是人流量很大的商业街，我用买车赠送的那把蓝色细锁火速锁好车便跑进补习班，等到中午补习结束回到停车点的时候，我傻眼了，同学一个个离开，而我在那片不大的地方反复寻找，恨不得把地下的砖都扒开，我可能找了半小时，最后我浑浑噩噩的走回家，那段路挺远，大概4个路口，回到家已经12点多了，我妈没有打我，但是我害怕极了，后续发生了什么也记不清了，也许是因为选择性忘记，最后，补习班和老师还赔了200块。 ​ 车丢了，但是习惯已经养成了，自然还是要买自行车，人总是贪婪的，得到了谷子就想得到糖，得到了糖就想得到肉，十三岁的我自然也不例外，这次我斗胆提议要一辆变速山地自行车，每次放学我都会偷偷观察同桌的捷安特，那卡卡的变速声音不断挠动我心中的痒，夜里做梦都想拥有一辆这样的自行车，去享受大家羡慕的目光；变速自行车比较贵，是普通自行车的2-3倍，爸妈自然非常不愿意，毕竟赚钱真的很不容易，那时候依旧在12平小屋中，夏天的下午会被太阳从侧面暴晒，晚上睡觉都能感受到从墙体深处散发的热浪，实在无法忍受，加装了空调；耐不住我的软磨硬泡，耐不住这是他的儿子，最后还是给我买了，就在我丢掉凤凰牌自行车的商业街附近，我获得了我人生中第三辆自行车 ​ 那是一辆黑红相见的变速山地自行车，品牌名为“巨凤”，不是名牌所以也比较便宜，不过我依旧很喜欢，他看起来是那么具有运动感，如此的个性鲜明，花费了500多，这对我们家庭来说已经是一笔巨款，我带着它回家了，我至今都记得，在回家的路上有一段上坡，我将变速调节到比较省力的轮档，我向往常一样踩着踏板，但是这却是一种未曾有过的体验，如此的轻巧，如此安稳，第二天早上5点多我便醒来，迫不及待的我想骑上的我新车去学校，那时已经是晚秋，我踏着淡淡曙光，仿佛骑行在云端之上，到学校的时候，天都未亮，对于那一刻的我来说，我的虚荣心大概已经得到了满足。在后来的日子里，我经常骑着它去偏远的谭冲湖，去几公里外的古梗公园，去杂草丛生的老肥西火车站，没有理由，随便定一个目标的骑行，在我那平淡如水的初中时光，我和“巨凤”游览了肥西大大小小很多角落。在天气还不算燥热的初夏，在平坦又人际罕见的单排公路，路旁的山丘跑向我的身后，柏油路前方看不见尽头，河水流淌声不断微弱，我不断加速，尽情的享受与风的交流。 ​ 在我初中阶段中，我对自行车是如此的执着，我认为我热爱自行车，但是我错了；在买“巨凤”的第二年，我初三了，中考勉勉强强的考上了高中，但是分数线只够去比较远的地方，我与我的“巨凤”便失联了，我再次见到的他的时候，它已经落满了灰尘，斜靠在墙角，嶙峋的轮胎上满是龟裂，前轮已经完全漏气，夕阳下，他就像一匹消瘦的老马，我路过很多次都没注意到他，直到在大学入学前夕，我对家恋恋不舍的时候，我终于注意到了它，我已经不记得当时面对它的表情，是我抛弃了它，就像随着岁月不断被丢弃的东西们一样。 ​ 前往古梗公园的路依旧平整，谭冲湖的河水依旧川流不息，到现在也依旧会时常回想起与它们们在路上的时光，只是再也找不回记忆中的强风拂过的感觉。 ​ ​","categories":[{"name":"随想集","slug":"随想集","permalink":"https://vkcyan.github.io/categories/%E9%9A%8F%E6%83%B3%E9%9B%86/"}],"tags":[{"name":"童年","slug":"童年","permalink":"https://vkcyan.github.io/tags/%E7%AB%A5%E5%B9%B4/"},{"name":"随想","slug":"随想","permalink":"https://vkcyan.github.io/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0","slug":"【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0","date":"2022-05-24T16:00:00.000Z","updated":"2022-05-26T06:04:32.573Z","comments":true,"path":"2022/05/25/【5000字长文】（开源） 低代码H5可视化搭建系统 - 易动v3.0/","link":"","permalink":"https://vkcyan.github.io/2022/05/25/%E3%80%905000%E5%AD%97%E9%95%BF%E6%96%87%E3%80%91%EF%BC%88%E5%BC%80%E6%BA%90%EF%BC%89%20%E4%BD%8E%E4%BB%A3%E7%A0%81H5%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%20-%20%E6%98%93%E5%8A%A8v3.0/","excerpt":"","text":"前言​ 作者在2020年的时候开源了易动第一个版本（开源）从0打造H5可视化搭建系统 - 易动（vue+ts+egg），这两年在公司针对装修技术方案做了大量的实践，使用过draggable方案 iframe装修方案 绝对定位方案，对其在技术，产品层面都存在更深入的理解，今天给大家带来新一代企业级H5装修方案易动v3.0 开源地址 拖拽生成h5页面，支持页面全局设置，组件，自定义URL，插件市场，公共npm组件库 基于最新vue技术栈， 易动v3.0 已上线，欢迎体验~~ YD 管理端 YD_Client 客户端 开源不易，给个Star吧~ 技术栈管理端：vue3 + vite + pinia + vueuse + TypeScript 客户端：vue3 + vite + TypeScript 集成组件库（ydh5-ui）：基于Vue3 + TypeScript进行开发 服务端：serverLess 项目架构​ 在正文开始之前先为大家介绍一下项目架构，我们从底层到上层依次介绍 ​ 易动3使用腾讯云serverless作为后端服务，serverless在易动系统中提供组件schema的数据存储服务，为什么使用serverless下文在说明。 ​ 易动3将客户端、管理端的公共装修组件进行了统一封装发布成为npm包，解决了以往存在的一个组件需要写、改两遍代码的核心问题。 ​ 易动管理端是项目的最核心系统，除了核心的保存，修改之外，以及一系列提供装修效率的功能，例如组件市场、辅助线、复制、粘贴、撤销、放撤销，这个低代码装修系统的上限于下限皆由此项目决定。 ​ 易动客户端功能比较单纯，主要是根据约定好的js Schema结合集成组件库进行数据渲染于逻辑触发。 使用方向​ 这几年关于低代码领域开始不断有大厂入场，这也变相的说明了该领域巨大的提效需求，愿望是美好的，但是现实是骨感的，低代码无法做到全盘通吃，只能聚焦某个领域，易动v3.0也是这样的，他无法处理存在大量逻辑的页面，所以易动v3.0选择专注于营销单页，在营销单页领域他可以发挥自己的优势。 ​ 除了基础的按钮、图片组件外，业务组件可以做很多场景化组件，例如banner，商品专区，甚至从接口获取数据的组件都可以通过js Schema的约定进行实现 ​ 而营销单页的需求络绎不绝，这样的工作就像在工厂“打螺丝”，大部分前端开发者并不愿意做这件事情，并且工作流程比较繁琐，可能因为业务原因频繁改动，大致工作流程如下 ​ ​ 一个再简单的单页都需要走一样的固定流程，并且一旦某个环节出现了问题就需要回滚好几步，在这儿个过程中开发者也需要跟着回滚，遍出现了频繁改样式，重复机械行为。 ​ 如果有了低代码平台 流程可以变成这样 ​ 这样的架构中权责变的更加清晰，开发者从“螺丝钉”变成了技术解决方案开发者 ​ 而业务的决定权也掌握在专人手中；大家各司其职，技术根据实际需求不断优化技术解决方案，运营使用低代码平台的搭建能力 物料能力也能提高运营的效率。 H5装修常见方案​ 据作者了解，目前市面上所有的低代码平台几乎都是基于Schema进行实现的，这种方案的核心原理比较简单 ​ 基于这样的Schema结构，便衍生出来了多种实现方案，在这里简单描述一下我在实际工作中都使用过方案以及他们的优缺点； 绝对定位方案​ 简介：所有的装修组件都是再后台直接拖拽放置，没有组件群组的概念，可以任意放置你的组件到任何地方。 ​ 优点：灵活 ​ 缺点：无法流式布局，需要维护公共组件库，操作门槛较高，需要通过技术能力填补，例如吸附辅助线。 流式布局方案​ 简介：装修组件遵循流式布局，从上到下从左到右进行排序，就像搭积木一件，这种方案仅限移动端 ​ 优点：操作简单 ​ 缺点：组件不够灵活，因为只能上下移动，想做到非常规布局比较麻烦，需要维护公共组件库 iframe方案​ 简介：将客户端通过iframe内嵌到装修管理端中，再通过postMessage进行项目间通信，客户端识别环境开启装修模式与后台进行实时通信 ​ 优点：不需要维护公共组件库 ，只需要维护客户端代码 ​ 缺点：客户端与管理端代码耦合严重 装修操作部分代码需要写在客户端中 流式布局 + 绝对定位方案​ 简介：为绝对定位组件增加一个流式布局的父级容器，让装修数据具备二级结构， ​ 优点：灵活 具备可生成代码的规范结构 ​ 缺点：操作麻烦，存在一定学习成本 ，需要维护公共组件库，相对其他方案多了一层结构，难度相对更加大 易动3选择的方案​ 在公司生产环境项目中，凭借易动v1.0的经验，我使用了流式布局方案，最初效果还是非常不错的，那时候没想到将公共组件发布到npm，两端项目公用组件的方案，后期组件改动频繁，出现了极大的维护问题，这迫使我寻找其他出路。 ​ 为了解决流式布局中一套组件，两套代码问题，在生产环境项目中实验性的使用管理端 + 客户端耦合的iframe方案，满足了公司的需求只需要维护一套代码，并且可以将Schema抽象出来应用到单页中，实现活动页装修，iframe装修方案在公司也是沿用至今，帮助公司搭建了200+的页面。 ​ 再后来，我准备重启易动项目，开发易动v2.0，我们在易动v2.0中实验性的尝试了流式布局 + 绝对定位方案，在开发之前普遍觉得这是一个天才的主意，同时具备流式布局与绝对定位方案的优点，而且易动v2.0开发技术中还存在类似易企秀的多页的需求，大概经过2个月的代码编写，最终发现还是我们的想法过于理想化，首先操作上就存在比较高的门槛，技术难度也很大，而且因为Schema结构复杂，后期代码难度也是几何级别的提升，最终我们PASS了这个方案。 ​ 在后面一段时间我一直在思考一个问题，也就是低代码的边界性，他应该做什么，他可以做什么，我们如何通过低代码来创造产品价值，在不断的思考中我也逐渐明确了开发方向，不再去想他还能做什么，而是在开发之前就确定一个目标，易动3.0将会在营销领域发挥它的作用，所有的功能都围绕这个核心目标 ​ 基于这样的目标，易动v3.0再出发，依旧采用绝对定位方案，因为绝对定位方案符合需求，难度最小，具备拓展性，后期维护性更强。 ​ 方案确定好了，接下来将会介绍一些核心的实现思路。 核心实现思路Schema的编写​ schema的结构将会决定你的装修系统的上限，一个良好的设计结构将会为后面的开发降低很大的难度，我们需要定义好页面的结构与组件的结构。 ​ 而在代码中增加组件，或者增加组件类的数据，例如在轮播图组件中增加一项轮播图，都需要通过函数return的方式进行对象创建，以免出现多个组件使用的数据为一个数据源。 在项目中增加一个组件，只需要将组件Schema push到模板变量中即可 代码位置：https://github.com/vkcyan/YD/blob/main/src/modules/component/index.ts 123456789101112131415161718192021222324252627282930/** * 组件信息列表 * @param name 组件名称 * @param tempLen 本次层级 * @returns */function baseComList(name: string, tempLen) &#123; const list: baseComponent[] = [ &#123; id: guid(), name: &#x27;y-img&#x27;, showTitle: `图片$&#123;tempLen&#125;`, // 显示组件名称 show: true, cssModule: &#123; ...absolute(tempLen), ...borderData(), ...compSize(100, 60), &#x27;background-color&#x27;: &#x27;#ffffff00&#x27;, &#125;, // 样式 staticData: &#123; imglUrl:&#x27;xxxx.png&#x27;, ...linkData(), &#125;, // 行为 function: &#123;&#125;, // 方法 animation: [], // 动画 &#125;, // ..... ] return list.find((e) =&gt; e.name == name)&#125; ​ 例如增加一个图片组件，我们只需要将参数’y-img’，传入函数，即可得到一个图片组件的Schema，这样我们便具备搭建页面Schema树的能力。 实现拖拽 实现良好的拖拽是一件非常有难度的事情，它不仅仅是简单元素的移动，而是通过技术的手段降低装修的操作门槛。 元素位移​ 在易动v3.0中，弃用了以往采用的监听鼠标单次移动距离实现方案，因为这会导致快速移动后出现坐标不准确的情况，改成获取相对父级绝对坐标。 ​ 全局鼠标监听使用vueuse的useMouseInElementAPI，帮助我们获取每次的相对位置，鼠标按下同时保存元素下标，再通过watchEffect全局监听useMouseInElement的变化，拿着鼠标按下阶段保存的下标去寻找需要位移的元素，不断更新其Schema中的cssModule字段中的top与left值，进而实现元素移动。 元素缩放 ​ 我们为元素增加 上 下 左 右 左上 左下 右上 右下，八个操作点，是元素支持任意缩放功能，再点击任意缩放点的时候，我们都会保存一个标识，来确定当前点击的点是什么，然后在 全局监听鼠标移动的watchEffect中执行对应缩放逻辑，来不断更新选中的元素的 top left width height的组合值，进而实现元素缩放功能。 元素多选 ​ 支持元素位移与缩放其实已经完成了装修的最核心功能，已经可以完成简单的页面搭建了，但是仅凭位移与缩放操作起来不方便，这时候就需要开发多选功能，我们把之前保存的单个选中下标改成一个选中数组。 ​ 这里说明一下为什么保存数组下标，而不是组件的唯一id，这是一个时间复杂度的问题，如果保存组件唯一id，更新组件数据就需要通过循环再找到下标，进而通过下标更新数据，这时候时间复杂度为On，而直接保存数组下标，在通过下标直接更新数据，时间复杂度为O1。 ​ 回到正题，我们开发一个选中框组件，在拖动选中框的时候判断是否包含了组件，不断更新当前选中框多选的元素，进而实现多选删除，多选拖动，等等多选功能。 ​ 目前多选框计算逻辑还比较单一，仅支持从左上向右下拖动，后续有时间会继续完善。 辅助线 ​ 辅助线是低代码系统必备功能，这将会极大的降低使用门槛，实现辅助线相对来说也是非常复杂的，假如页面有4个组件，我们点击了任意一个的时候，就需要去保存其他3个组件的 top top + height/2 top + height left left + width/2 left+width，并且将其数组保存成为字典结构，也就是ES6的Set，相对数组实现可以将时间复杂度从On2降低到On，有效避免了卡顿的情况，在被选中元素不断拖动的时候，我们会不断对比当前变化坐标与之前保存的3个组件的坐标，一旦对比到了一致，就会将其值push到存储变量，并在页面上显示，表明已经对齐。 辅助线吸附​ 先声明一下，辅助线吸附作者的实现还存在瑕疵，目前还在寻找更好的方案，也希望有大佬可以指点一二，目前吸附还存在一点操作上的不流畅情况，所以这部分我便不多赘述。找到最佳解决方案再更新。 时间旅行 pinia的subscribes存在差异，并且events在生产环境无法获取，导致现在线上无法相关使用 ​ 所谓时间旅行就是可以进行撤销 反撤销操作操作，，具体原理感兴趣可以看看vuex版本的实现，本质原理都是一样的，基于vuex实现 撤销 与 反撤销 的plugins，采用数组 + 单指针进行实现。 more​ 移动端如何读取schema，使其还原装修效果；如何实现二次编辑组件的保存到创建市场；还有很多拖拽细节的实现；章节有限，这里不再一一赘述，有兴趣可以加入微信群在一起聊聊。 基础组件or业务组件 基础组件：按钮 图片 输入框 文字 模块（html自带的标签元素） 业务组件：富文本 轮播图 若干营销组件（由开发人员定制化产出的标签元素） ​ 在早期开发低代码，无代码产品的时候，我将绝对定位方案与基础组件绑定，业务组件与流式布局绑定，随着对低代码的深入理解，我在这里必须纠正之前的偏见，正确的观点应该是：基础组件 + 绝对定位方案更加和谐、业务组件 + 流式布局方案更加和谐。 ​ 随着将装修组件发布成为npm包，他们的隔阂已经几乎不存在，全部视为公共组件，公共npm组件包中将会抹平平台差异，任何可以描绘的组件可以看作为静态结构组件都可以被低&#x2F;无代码平台使用。 关于低代码​ 这几年关于低代码讨论也非常多，最近一直看到大厂开源的低代码工具，例如腾讯的tmagic-editor，阿里的LowCodeEngine，还有5月28号掘金直播低代码的探索与实践，其背后是前沿开发者们对效率的思考，是从局部效率转变到全局效率思想的转变。 ​ 在技术条件有限的情况下，低代码产品的广度与深度只能选择其一，我们自然希望低代码可以做的事情越多越好，生成页面，生成代码，直接编写事件，支持单页，支持多页，支持无限嵌套dom，达到降低门槛，提效降成本的作用，甚至解放劳动力，创造更大的社会价值，但是如果没有足够的技术基础，做的功能越多，就死的越惨。所以如果你也发现存在类似需求，切勿在产品设计期间不断加功能，要专注细分领域，只有这样，低代码项目才有发光发热的机会，有了经验之后再决定做什么也不迟。 ​ 从发现需求到明确定位有很长的路要走，低代码产品从可用到好用还有很长的路要走。 其他问题为什么易动v3.0选择绝对定位方案​ 易动v3.0考虑到营销页面的多样化，他并不是理想化的流式布局，而是多样化的，甚至你意想不到的UI实现方式，这也是易动v3.0使用绝对定位方案实现的一个重要原因，后续作者也会不断加强可用性，进一步降低搭建门槛。贯彻技术为业务服务，而不是业务为技术服务的理念。 为什么使用serverless​ 做出这个决定处于两点考虑 大部分公司不会使用node作为服务端框架，接入会重写服务端。 本人是前端工程师，node 以及服务端周边服务不算精通，低代码的项目核心也不在服务端，serverless满足了作者的需求，后续我会提供表结构，以及关联关系。 因为腾讯云serverless已经开始收费了，后续可能会换成fastify进行服务端编写，主要看作者是否有时间，也非常欢迎有志之士为开源做出贡献。 关于PC端​ 易动3的实现方案是绝对定位方案，这让实现pc端装修的可能性，但是个人感觉这部分需求比较小，B端的客户都是ToC，所以并没有做相关功能开发，但是理论上可以实现的。 后续还会做什么 目前易动v3.0 并不是完整状态，因为作者比较忙碌，很多功能依旧在开发中，大家也可以提出需求，如果存在价值，作者会加入后面的工作计划。 数据分析能力：页面的曝光情况是客户非常关心的指标，这也是易动v3.0非常关注的功能 模板市场功能：物料市场也是低代码平台非常重要的功能，配合组件市场，实现团队资源最大化利用，降低搭建门槛 丰富业务组件：根据客户需求开发其满足业务场景的组件，达到一次开发，多次使用的效果 增强装修能力：组件旋转，多选组件辅助对齐，搭建页面快捷操作，进一步降低大家门槛 最后​ 这个开源项目将会一直做下去，未来可能也会尝试做收费版本，毕竟为爱发电还是过于理想化了，如果你也是同道中人或者有这样的潜在需求，可以加入微信群，一起交流学习，共同进步~ 讨论群","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"},{"name":"低代码","slug":"低代码","permalink":"https://vkcyan.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"h5装修","slug":"h5装修","permalink":"https://vkcyan.github.io/tags/h5%E8%A3%85%E4%BF%AE/"},{"name":"Vue3","slug":"Vue3","permalink":"https://vkcyan.github.io/tags/Vue3/"}]},{"title":"关于免登录的一些实践与思考","slug":"针对免登录的一些实践与思考","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-24T07:34:17.938Z","comments":true,"path":"2022/05/24/针对免登录的一些实践与思考/","link":"","permalink":"https://vkcyan.github.io/2022/05/24/%E9%92%88%E5%AF%B9%E5%85%8D%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"前言​ 听用户说，但是不要照着做。 ​ 这句话来自苏杰的《人人都是经理》这本书；在产品维度我们遵循这样的原则，其实在程序维度，也需要遵循这样的原则，如果没有意识到这一点我们也许会深陷泥潭。 案例：免登录到商品详情页面聊一个我们之前遇到的问题，场景是这样的 用户在第三方平台登录，用户登录后点击商品会免登录到我们商城 跳转过来后，我们商城需要完成免登录操作，服务端同时给用户发放优惠券，在这个过程中必须保证通过免登录进入后同步调用登录 发券 获取商品详情接口顺序。 ​ 场景就是这么简单，似乎并不是太难的问题，于是我们将我方的商品详情URL给对方，对方在URL后面拼接token，web端拿到token之后将token给后台，完成登录 发券 获取详情逻辑，流程图如下 ​ 按照我们上面的思路似乎没啥问题，无非就是用Promise控制代码顺序，但是在逻辑达到一定复杂程度后，这个问题就会变的非常棘手。 问题：非业务逻辑与业务逻辑的耦合​ 本质上来说，从第三方平台免登陆到我们商城中，并不属于购买商品逻辑，那就不应该将其逻辑写在商品详情页中 ​ 况且这必须同步，用户没有完成我们这边的登录逻辑之前，我们不能发起商品详情接口，因为我们的商品详情数据包括用户最新的优惠券信息，如果异步，就会出现用户第一次进入是没有券的情况；这样的规则就导致我们需要对商品详情页面的业务逻辑进行改动。 ​ 在这样的不安中，我们修改了商品详情页面的生命周期逻辑，一旦检测到需要免登录就会先执行登录再执行商品详情的获取。 ​ 后续又多次出现了其他平台免登录到商品详情页面，并且流程都不太一样，最终导致了我们的商品详情页生命周期代码凌乱不堪，异步流程难以维护，甚至会出现逻辑相互冲突的情况。 问题2：封装问题​ 最后我们商城对接的免登录越来越多，慢慢的我们便在逻辑层面进行了封装，但是依旧还是要动具体页面生命周期代码，而有些页面比如首页就存在很多第三方平台登录进来的，在生命周期代码中就出现大量的来源判断用来调用我们封装好的免登录逻辑，并且有些第三方还是具备时效性的，虽然我们在技术层面已经尽力，但是开发起来依旧很别扭，尤其是对于频繁需要维护的模块。 解决方案​ 再后面遇到这样一件事情，存在一个第三方商城免登录到我们的任意页面，听到需求的时候，我内心有点凌乱，因为我们目前免登录逻辑都是一对一的针对单个页面 ​ 最开始我们聊了能否在nginx中进行统一拦截，后面觉得性能很差，也有种走进死胡同的感觉，后台后端同事提出一个方案，这是一个技术上微不足道，但是却非常好的解决这个问题的方案。 ​ 我们将免登录的封装维度从单个逻辑的角度，提升为在对方跳转到我们目标页面中间的一层拦截 举个例子 ​ 原本 www.abc.com/goods/index?token=xxxxx，我们在具体页面中处理 ​ 最新 www.abc.com/autoLogin?sc=xxx&amp;redirectUrl=www.abc.com/goods/index&amp;token=xxxxx 如果redirectUrl存在参数一定要将该参数encodeURIComponent处理以下，以免参数解析异常 这样做有三个优点也有一个缺点 优点一：非业务逻辑与业务逻辑的耦合的问题，将免登录代码与业务代码完美的隔离开了，不论有多少，多个性化的免登录场景，都不会影响被跳转页面的逻辑 优点二：不再需要逻辑封装，直接将与服务端交互的代码写在该页面即可，因为他已经与业务逻辑解耦合了 优点三：可以形成对接规范，降低开发对接门槛，以及出现问题的可能性。 缺点一：对于用户来说需要多跳转一层页面，有可能需要多等待20-100ms。这一点就要看取舍了，我们是单页应用，站内跳转很快，从线上效果来看对用户影响很小，几乎忽略不计。 总结​ 回头看优化后的实现方案，其实技术难度非小，如果把需求说明白了，这是一个大学生都能写好的需求，这样一个毫无技术难度的方案，在项目中却完成让人非常头疼的部分非业务逻辑与业务逻辑的解耦合。 ​ 虽然作为一名开发人员，我们的本质工作就是实现需求，但是实现需求并不代表别人怎么说你就怎么做，而是根据需求加以自己的思考，在非开发角度提供自己宝贵的建议，也许，换一种思路，一个非常复杂的需求就会变得如此简单。 ​ 现在让我们回到文章开头的那句话，听用户说，但是不要照着做，是不是有点感悟了。","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://vkcyan.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"关于C端","slug":"关于C端","permalink":"https://vkcyan.github.io/tags/%E5%85%B3%E4%BA%8EC%E7%AB%AF/"}]},{"title":"上瘾模型如何应用到产品","slug":"上瘾模型如何应用到产品","date":"2022-05-22T16:00:00.000Z","updated":"2022-05-23T10:51:27.523Z","comments":true,"path":"2022/05/23/上瘾模型如何应用到产品/","link":"","permalink":"https://vkcyan.github.io/2022/05/23/%E4%B8%8A%E7%98%BE%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E5%88%B0%E4%BA%A7%E5%93%81/","excerpt":"","text":"前言​ 为什么有些产品有抓住我们的注意力，而其他产品却不能？是什么让我们出于习惯而建立与产品的联系？是否有一种潜在模式能够通过技术将用户紧紧吸引，欲罢不能。 ​ 这是《上瘾》的引言，我相信看到上面这些话的时候，你的脑海中一定出现了让你上瘾的产品，比如抖音，这样现象级的产品是如何被设计出来的呢？《上瘾》通过大量实验案例，社会调研，总结并抽象了用户上瘾的产品设计原则。最后提炼出一个通用模型，掌握这样的通用模型，你就会得到一个产品设计框架。 当你从0到1设计产品的时候，或者分析市面上的产品，你就可以将上瘾模型应用到你的产品。 上瘾模型是什么触发 行动 多变的奖励 投入 触发 内部触发​ 内部触发是用户与产品建立的感情链接，不需要被打广告，不需要被通知，我主动去使用，就好像短视频APP，没有给我钱，也没有被推广，但是我们每天都高频使用，内部触发是给予用户情感的满足，让产品融入到了生活，是用户内心真实情感的触发，获得快乐、认同与安慰，具体类型会在行动中说明 下班后无聊，打开短视频APP 自拍几张照片，发布到社交平台 ​ 这就是发生在我们身边的日常，我们选择某个产品是因为它能够为我们带来快乐或者解决烦恼，这就是为什么说要洞察用户的用户需求，而内部触发就是研究用户需求，而且是最深处的情感需求 ​ 所以常说做产品是发现用户需求，要去思考，我们的产品能够为用户解决什么问题，这自然是需要深入了解用户的痛苦与挣扎，然后设计出给予用户安慰的产品。 外部触发指用户在非主动情况下接收的信息，有清晰的动作指令进行行动召唤 付费型触发：电梯广告 APP中推广 回馈型触发：某某软件因为做的好，被APP Store上了推荐位 人际型触发：小明觉得某个软件特别有意思，推荐给小红 自主型触发：小明毕业了需要找工作，下载了一个BOOS直聘 ​ 一般会采用简单重复或者“经典+创新”的方式来完成外部触发，效果更加好，例如蜜雪冰城 还有很多老歌+新词的电梯广告 行动 ​ 用户完成触发后，就会来到产品中，让用户开始使用产品就是行动，而长时间高频率的行动才能养成用户习惯 用户行为模型公式：行动 &#x3D; 动机 * 能力 *触发 ​ 如果一个用户想完成一个行动，这三者是缺一不可的。例如，周末你打算找你朋友开黑王者荣耀，但是朋友突然有事，你放弃了周末打王者 动机：渴望快乐 能力：有手机 有网络 有时间 触发：和朋友一起玩做王者荣耀 然后因为朋友突然放弃了，缺少触发条件，放弃 亦或者网络太差，缺少能力，放弃 亦或者由于某种突发紧急事件，没心情去体会游戏里面的快乐，缺少动机，放弃 动机能够驱使用户采取行动的核心动机无非就是以下三种 - 追求快乐，逃避痛苦 - 追求希望，逃避恐惧 - 追求认同，逃避排斥 ​ 补充：相对与失去快乐，人们更加害怕痛苦，就像捡到100块钱，你会很快乐，但是你丢失一百块钱，你会非常痛苦，这远比捡到100块情绪更加激烈，这在产品中常常表现为厌恶损失心理 能力能力是行动的门槛，福格教授提出六要素 - 时间：完成这件事情需要的时间 - 金钱：从事这件事情需要的经济投入 - 体力：完成这件事所消耗的体力 - 脑力：完成这件事所消耗的脑力 - 社会偏差：他人对这项活动的接受度 - 非常规性：该活动与常规活动的匹配程度或矛盾程度 ​ 一个行动需要的能力越少，用户就越轻松使用你的产品，所以我们反复强调降低用户使用门槛，从而减少因为能力问题而造成的流失 多变的奖励 ​ 用户通过触发进入产品，并做出了行动，但是如果用户在你的产品中没有得到物质或者精神的奖励，用户自然会离你而去 猎物奖励​ 猎物奖励就是获取自己想要的资源，刷抖音，寻找带来满足的视频，刷知乎，发现自己感兴趣的问题与回答，这就像原始人类追逐猎物一样，抓住他会充满获得感的 社交奖励​ 社交奖励即为被认同，被赞美，被尊重，人类是情感动物，对社交奖励非常上瘾，会陶醉到社交带来的快乐中，这是及其有效的奖励方式，所以社交类产品经久不衰的原因，他的本质是获得一种社会认同 自我奖励​ 自我奖励主要为使用产品时候的成就感，满足感，控制感。比如你喜欢收集手办，没人让你收集，收集了也没钱，但是让自己快乐了，同时找到了志同道合的朋友，我把我的手办发布到社区，被点赞，被评论这就很快乐，还有例如蚂蚁森林浇水，这都会带来内心的满足，从而实现自我价值 多变性​ 灵长动物大都喜欢新奇的东西，一件事情，如果已经经历过很多次，再次经历将会失去兴趣，你的大脑不会获取快乐，因为你已经可以预感到下一步的行动，预感到你将会得到什么，大数据精准推荐、千人千面都是为了满足用户喜欢新奇的心理 ​ 如果某一次刷新知乎，推荐的都是你看过的或者不感兴趣的问答，那你自然不会上瘾，反之，如果你总是给用户带来新奇感，用户必定会进行更多的行动，来获取更多奖励，所以多变性是奖励的核心概念 ​ 最后补充一点，除了让用户经常获得奖励之外，让用户在第一次接触你的东西就有一个好印象也是关键点，例如首次打开小红书，QQ，他的登录背景视频是美好切令人向往的，让你感受到产品倡导的价值，如果恰好这也是你向往的，这个产品毫无疑问会吸引了你的注意力，你将会继续使用他 投入 ​ 想象一个简单的场景，小明经过朋友推荐下载了王者荣耀，玩了1年时间，在游戏中达到了王者段位，期间在王者荣耀中购买了大量付费皮肤，同时认识了游戏好友；这时候出来了另一个竞品，不比王者荣耀逊色 ​ 但是该竞品想吸引小明，难度是极大的，因为小明已经在王者荣耀中投入太多，时间，皮肤，游戏好友，对局资料，绝活英雄，这都会让小明无法脱离。 ​ 投入是上瘾模型闭环的最后一步，当用户通过触发，采取了行动，并获得了奖励，这时候如果能让用户进一步进行投入，那么这个产品在用户心中的地址将会达到顶峰 内容​ 在微信上添加好友，添加群，这都是内容，随着使用的时间越长，你就会越离不开微信，让你换掉微信，那真的比登天还难 数据资料​ 以作者为例子，作为一名前端开发者，我的开源代码都存放在GitHub，随着我工作年限越长，我越舍不得离开GitHub，我的大量资料都在github中，对我而言，他有很高的价值 关注者​ 小红是一位大厂产品经理，通过长期在知乎发表高质量文章获得了20w关注，随着人数的变多，小红将会越来越离不开知乎，微博，小红书 B站社区都是这样，关注者对于当事人来说是不可忽视的隐形价值 信誉​ 小明觉得咸鱼不错，经常在咸鱼上售卖一些东西，你已经售卖一些东西，在未来会越来越关注你的信用情况，你就会花更多的经历去经营他 技能​ 以我自己举例子，学习编程的时候，使用的是vscode（编程开发软件），至今我已经使用了5年，已经对他产生了依赖，通过他学会了编辑技能，投入了很大的时间成本，学习成本，尽管竞品某些细节更好，但者依旧很难让我行动起来去换掉vscode 总结​ 至此我们走完了上瘾模型，我们回顾一下，首先通过外部或者内部触发来让用户进入行动阶段，在行动中给予用户多变的奖励，最后让用户不断投入，时间，金钱，内容，或者资料，也可以为用户到来价值 信誉 关注这，经过这样的闭环后，用户将会越来越依赖你的产品 ​ 似乎这个模型很棒，是一个值得思考的方法论，但是一个有价值的产品是一切的前提，如果产品没有挠到用户痒点，或者本身就是伪需求，那上瘾模型也无济于事，他不是救命稻草，而是锦上添花，让你的产品变的更加好。 ​ 屏幕前的你此时此刻是否脑海中已经想到了很多，或者是对产品的理解，或者是对你正在进行中的项目产生了新的想法；后续内容提供了基于上瘾模型的产品设计模板，通过这样的模板可以分析别人的项目，也可以构建你准备开发或者正在进行中的项目 将上瘾模型应用到产品中以内部触发为起点​ 如果一款产品无法让用户内部触发，这就意味着用户感知不到其价值，产品的本质是满足客户需求，帮助用户解决问题；在这阶段我们需要研究、定位我们的客户群体，提炼特性，描述用户画像，通过丰田5Why法，深入了解用户的核心诉求，保证内部触发的合理性 设计多变的奖励​ 一款产品可以为用户带来什么？这是极其重要的问题，我们通过内部触发确定我们的用户群体，下一步就需要思考给予用户什么奖励，猎物奖励更好，还是社交奖励更好，同时要在奖励环节中贯彻多变性原则，这里再次强调：多变性是奖励的关键 注：如何给用户第一次良好的体验，让用户感知到价值，引导其内部触发，这也是关键的一环，其中越是生命周期短的产品，首次的啊哈时刻（一个用户对产品感知最强的点）必须要越早出现 用户可以投入什么​ 用户可以在你的产品中生产什么样的内容，数据资料，还是关注者，找准类型，同时要研究用户心理，找到用户可能想投入的实际，再引导用户去完成 利用外部触发推广​ 上瘾模型一旦形成，便需要源源不断的用户进入其中，这里可以根据自身的产品类型来选择外部触发方式，例如自身有钱，可以付费完成触发，或者通过社群进行人际型触发，具体触发方式需要根据产品特性来决定 重复测试迭代优化​ 当用户进行上瘾模型，并产生依赖之后，我们就需要不断检查每个环节是否符合预期，是否存在短板，根据实际数据进行测试，并进行优化迭代，不断完善上瘾模型 对抽奖助手小程序的上瘾模型分析 参考资料参考文章：http://www.woshipm.com/pd/5386132.html 参考书籍：上瘾：让用户养成使用习惯的四大产品逻辑 尼尔·埃亚尔 瑞安·胡佛","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"产品日常","slug":"产品日常","permalink":"https://vkcyan.github.io/tags/%E4%BA%A7%E5%93%81%E6%97%A5%E5%B8%B8/"}]},{"title":"Vue + webpack项目的移动端适配","slug":"vue项目使用vw进行移动端适配","date":"2022-05-19T16:00:00.000Z","updated":"2022-05-24T07:59:39.414Z","comments":true,"path":"2022/05/20/vue项目使用vw进行移动端适配/","link":"","permalink":"https://vkcyan.github.io/2022/05/20/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8vw%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","excerpt":"","text":"2022-5-20更新技术栈：vue3 + webpack5 安装插件1npm i postcss-px-to-viewport -D 增加配置新建配置文件postcss.config.js 1234567891011121314151617181920212223module.exports = () =&gt; &#123; return &#123; plugins: &#123; autoprefixer: &#123;&#125;, &quot;postcss-px-to-viewport&quot;: &#123; unitToConvert: &quot;px&quot;, // 需要转换的单位，默认为&quot;px&quot; viewportWidth: 750, // 设计稿的视口宽度 unitPrecision: 5, // 单位转换后保留的精度 propList: [&quot;*&quot;], // 能转化为vw的属性列表 viewportUnit: &quot;vw&quot;, // 希望使用的视口单位 fontViewportUnit: &quot;vw&quot;, // 字体使用的视口单位 selectorBlackList: [&quot;.ignore&quot;, &quot;.hairlines&quot;, &quot;.ig-&quot;], // 需要忽略的CSS选择器 minPixelValue: 1, // 最小的转换数值，如果为1的话，只有大于1的值会被转换 mediaQuery: false, // 媒体查询里的单位是否需要转换单位 replace: true, // 是否直接更换属性值，而不添加备用属性 include: undefined, // 如果设置了include，那将只有匹配到的文件才会被转换，例如只转换 &#x27;src/mobile&#x27; 下的文件 (include: /\\/src\\/mobile\\//) landscape: false, // 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape) landscapeUnit: &quot;vw&quot;, // 横屏时使用的单位 landscapeWidth: 568, // 横屏时使用的视口宽度 &#125;, &#125;, &#125;;&#125;; end以下配置已经过时，请看最新内容 需要安装一下的插件 1npm install postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano cssnano-preset-advanced postcss-import postcss-url --S postcss.config.js配置 123456789101112131415161718192021222324252627module.exports = &#123; plugins: &#123; &#x27;postcss-import&#x27;: &#123;&#125;, &#x27;postcss-url&#x27;: &#123;&#125;, &#x27;postcss-aspect-ratio-mini&#x27;: &#123;&#125;, &#x27;postcss-write-svg&#x27;: &#123; utf8: false &#125;, &#x27;postcss-cssnext&#x27;: &#123;&#125;, &#x27;postcss-px-to-viewport&#x27;: &#123; viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: &#x27;vw&#x27;, // 指定需要转换成的视窗单位，建议使用vw selectorBlackList: [&#x27;.ignore&#x27;, &#x27;.hairlines&#x27;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 0, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换`px` &#125;, &#x27;postcss-viewport-units&#x27;: &#123; filterRule: rule =&gt; rule.nodes.findIndex(i =&gt; i.prop === &#x27;content&#x27;) === -1 &#125;, cssnano: &#123; preset: &#x27;advanced&#x27;, autoprefixer: false, &#x27;postcss-zindex&#x27;: false &#125; &#125;&#125;; 这里注意假如生成的项目里面没有.postcssrc.js 说明写在package.json里面,记得把package里面的部分配置删除 12345&quot;postcss&quot;: &#123; &quot;plugins&quot;: &#123; &quot;autoprefixer&quot;: &#123;&#125; &#125; &#125;, 最后在index.html里面进行引入viewport-units-buggyfill解决兼容问题 123456&lt;script src=&quot;//g.alicdn.com/fdilab/lib3rd/viewport-units-buggyfill/0.6.2/??viewport-units-buggyfill.hacks.min.js,viewport-units-buggyfill.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; window.viewportUnitsBuggyfill.init(&#123; hacks: window.viewportUnitsBuggyfillHacks &#125;); &#125; &lt;/script&gt; 注意如果遇到图片无法正常显示 1.img图片不显示： 全局引入 123img &#123; content: normal !important;&#125; 2.与第三方UI库兼容问题： 使用postcss-px-to-viewport-opt，然后使用exclude配置项，具体参考 Vue+ts下的移动端vw适配（第三方库css问题）","categories":[{"name":"移动端","slug":"移动端","permalink":"https://vkcyan.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://vkcyan.github.io/tags/vue3/"},{"name":"webpack5","slug":"webpack5","permalink":"https://vkcyan.github.io/tags/webpack5/"},{"name":"响应式","slug":"响应式","permalink":"https://vkcyan.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"vw","slug":"vw","permalink":"https://vkcyan.github.io/tags/vw/"}]},{"title":"NPDP产品经理国际资格认证","slug":"NPDP产品经理介绍","date":"2022-03-17T16:00:00.000Z","updated":"2022-05-23T08:34:34.787Z","comments":true,"path":"2022/03/18/NPDP产品经理介绍/","link":"","permalink":"https://vkcyan.github.io/2022/03/18/NPDP%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"产品经理与项目经理对比 内容 产品经理 项目经理 职责 发现并定义范围 执行并交付范围 范围 对产品整个生命周期负责 阶段性对项目负责 角色 母亲，定义目标，发布计划，然后在生命周期的各个阶段继续培育产品 像家庭教师，一直待在产品旁边，帮助产品成长，让他最后成为产品满意的样子 主题知识组合管理 新产品开发战略 新产品流程 产品生命周期管理 文化，组织与团队 工具与效绩度量 市场研究 知识点分布新产品流程 20% 新产品开发 20% 组合管理 10% 产品生命周期管理 10% 市场研究 10% 工具与绩效度量 20%","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://vkcyan.github.io/tags/NPDP/"}]},{"title":"工具与绩效度量","slug":"工具与绩效度量","date":"2022-03-17T16:00:00.000Z","updated":"2022-05-23T08:33:01.270Z","comments":true,"path":"2022/03/18/工具与绩效度量/","link":"","permalink":"https://vkcyan.github.io/2022/03/18/%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%BB%A9%E6%95%88%E5%BA%A6%E9%87%8F/","excerpt":"","text":"9种创意工具 名称 内容 SCAMPER 特别是在生产改进现有产品，产生新的产品的想法上很有帮助，SCAMPER是一些行为东西的首字母缩略词。又叫奔驰法 奔奔法S：替代 C： 合并 A：改造 M：调整 P：改变用途 E：去除 R：逆向操作 头脑风暴 在群体决策中，由于群体成员心理相互作用影响，易屈于权威或大多数人意见，形成“群体思维”。群体思维削弱了 思维导图 在各种信息或创意之间建立思维链接的图形化技术。首先，讲一个关键字或者短语写在一页纸的中间，然后，从这一中心点触发，将其与不同方向的新创意连接，从而建立起网络式思维关系","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://vkcyan.github.io/tags/NPDP/"}]},{"title":"文化、组织与团队","slug":"文化、组织与团队","date":"2022-03-17T16:00:00.000Z","updated":"2022-05-23T08:33:27.357Z","comments":true,"path":"2022/03/18/文化、组织与团队/","link":"","permalink":"https://vkcyan.github.io/2022/03/18/%E6%96%87%E5%8C%96%E3%80%81%E7%BB%84%E7%BB%87%E4%B8%8E%E5%9B%A2%E9%98%9F/","excerpt":"","text":"文化定义​ 组织中人们共同拥有接受的信念、核心价值观、行为准则、思维方式、假设与期望 示例 反应组织的价值观，彰显与习惯、仪式、典礼、故事、英雄榜样 指出如何完成工作 表达生存力，即为了活下去我们应当做些什么 文化是否正确取决于组织本身​ 一个组织中运作良好的文化可能对于另一个组织是完全错误的 成功的创新文化具备的共同特点 清晰的方向和目标 鼓励尝试 个人绩效与组织绩效密切相关 契合创新文化是招聘标准之一 鼓励内部和外部的有效沟通 鼓励建设性冲突 让工作尽可能愉悦有回报 氛围定义​ 是员工可直接或者间接感知到的工作环境特点的集合，对员工的行为有重大的影响 示例 领导人水平、沟通、责任、信任、公平的认可与回报、机会，员工参与 新产品开发中的管理者角色战略纬度 管理内容 角色与职责分配 使命愿景、价值观 整体的企业愿景、使命价值观是由公司高管以及关键职能部门的负责人一起指定，在董事会层面通过 业务战略 通常由某个特定的业务单元的执行团队指定（有歧义） 职能战略 职能部门负责人以及高管团队定制 产品战略 高级产品经理（高级产品副总裁，首席产品官等）指定 创新战略 跨职能团队的高级经理定制，由一位董事会成员领导 流程纬度 角色 管理内容 流程拥护人process champion 负责推动组织内正式商业流程的日常工作，对流程进行调整、创新和持续改进 类似考委会，负责定制和改进考试规则 流程主管process owner 对新产品开发流程的战略性结果，包括生产能力、输出质量和组织类的参与度负责的执行经理，敏捷中由PO和敏捷教练来负责 类似巡场老师，负责监督规则的执行效果 流程经理process manager 确保流程中的创意和项目按时有序进行的运营经理。有时被成为业务流程经理或者工艺经理 类似监考老师，负责规则的按时有序执行 项目经理project manager 采用组织认可的流程，负责管理特定的产品开发项目 类似班主任，组织学生按规则试试考试项目 组织与团队 职责 说明 建立文化氛围 组织的文化和氛围由最高层管理者领导，并受其影响 推动积极氛围 是职能经理和各个团队或项目经理的职责 团队开发 整体团队开发的责任由高级产品开发经理承担，包括：团队成员的选拔，高绩效团队的建立，气氛的保持 产品管理者的关键职责落实产品开发战略，跨职能合作。 职位 职责 首席产品官 先CEO回报，定制整体的产品战略，监控、管理好产品的营销与开发 高级副总裁 领导大型产品经理团队，与工程、销售、制造、营销职能的主要领导紧密配合工作，确保开发中的产品是正确的，且有助于实现公司目标 产品群经理 为负责某个产品群的产品团队提供指导，负责执行高级管理者指定的战略，领导跨职能团队 产品经理 对具体的产品和产品类别负责 产品经理 VS 项目经理 产品经理 项目经理 发现与定义范围（要做什么，做成什么样） 范围的执行与交付（执行并交付产品） 对产品整个生命周期负责 阶段性的对项目负责 团队领导者的角色和职责-高级管理者新产品开发中高级管理者角色为战略负责 定制企业级和事业群级战略的终极责任在于高级管理者 而包括产品研发战略在内的职能型战略定制的责任人在于职能部门负责人 高级管理者角色倡导者：项目倡导者并非团队的一员，可能是市场部或者是研发部的总经理，他们对项目充满了热情，有感染力，并且愿意为推进项目承担风险，能够帮助团队获得资源，帮助团队承担风险 发起者：提供项目所需的资源，总资源需求承诺以及优化配置，评估绩效，提供激励奖励，关口评审，运营规划等 引导者：帮助团队尽量减少官僚主义，突破繁文缛节的限制和其他组织壁垒，从而提高生产力 高级管理者任务方向引领者： 奖励公司战略 确保为新产品所做的一切努力是一致的 产品线缔造者 为理解目前及未来的产品线确立框架 定义产品类型 组合管理 确定项目设置 匹配项目容量、生产力 高级管理者总结 跨职能团队和矩阵结构组织结构类型​ 矩阵结构式一种组织结构，其中的汇报关系按网格或者矩阵奖励，而不按照传统的层级结构，换言之，一个员工具有双重的回报关系，通常是指职能经理和产品经理（项目经理）汇报 矩阵结构 团队类型 项目经理 上下级 团队成员 团队能力 适合的产品任务类型 职能型团队 无 有 分散 最弱 改进的，轻微的（支持型项目） 轻量级团队 有无实权 无 兼职 弱 派生的扩张产品线（衍生型项目） 重量型团队 有有实权 无（交叉） 临时专职 强 新领域，不确定，复杂的（平台型项目） 自主型团队 创业团队领导 有 专职 最强 全新的，长周期，高风险（突破性项目）","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://vkcyan.github.io/tags/NPDP/"}]},{"title":"新产品开发战略","slug":"新产品开发战略","date":"2022-03-17T16:00:00.000Z","updated":"2022-05-23T08:33:40.020Z","comments":true,"path":"2022/03/18/新产品开发战略/","link":"","permalink":"https://vkcyan.github.io/2022/03/18/%E6%96%B0%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E6%88%98%E7%95%A5/","excerpt":"","text":"战略定义：能够引向未来的一种方法与战略，例如，某个目标的实现路径或某个问题的解决方法 商业环境下的战略定义： 战略能够定义与传播一个组织的独特定位，说明应当如何调整组织的资源、技能与能力以获取竞争优势（波特，2008） 给予行业定位、机遇和资源，企业为实现长远目标而定制的计划（科特勒 2012） 经营战略的设计步骤 战略制定与执行责任人​ 整体的企业愿景和使命通常由公司高管团队以及关键职能部门（财务、营销、制造等）的负责人一起正式制定，这些内容在董事会层面得到了正式通过 业务战略：通常由某个特定的业务单元的执行团队进行制定 职能战略：通常由职能部门负责人及高管管理团队（财务，营销）进行制定 产品战略：通常由高级产品经理（如高级产品管理副总裁）进行制定 创新战略：同工厂由跨职能部门的高级经理制定，由一位董事会成员领导，他可能是创新副总裁，首席技术官或首席执行官 使命 愿景 价值观使命定义： 公司信念、哲学、目的、经营原则或者企业信仰的声明 目的：阐述企业为什么存在(Why)。为了凝聚公司能量与资源 案例： 发布创意 克服困难(3M公司使命) 愿景定义： 透过预见与洞察的现象，透过实际上的限制，借此想象出企业对于未来发展的可能性 目的：阐述企业要往哪里(Where) 案例： 设计各式精良，优异的家居用品，并且价格低到让许多人都买得起(IKEA宜家家居愿景) 价值观 参与的成员为了完成任务需要遵守的行为准则 一个人或者公司带来某种程度的情感来遵守一个原则 目的： 阐述企业的行为准则与价值观(How) 案例： 诚信正直 承诺 创新 客户伙伴关系(TSMC公司价值观) 四种创新战略框架波特战略框架波特将公司优势最终划分成为2个部分：成本优势与差异化 通过运营这些优势或宽或窄的范围，定义了三种通用战略 成本领先战略 差异化战略 细分市场战略 战略名称 特点 优势 劣势 例子 成本领先战略 吸引价格敏感性客户提升市场份额规模生产降低成本优化供应链 在价格竞争激烈市场中有保持竞争的方法 利润低降低成本影响质量导致客户流失 世界工厂，中国制造 差异化战略 聚焦较宽产品基础交付优质产品建立忠诚客户关系获取市场份额更关注产品品质和性能 利于建立客户忠诚度可以获得更高的利润率 必须持续创新，开发新产品吸引客户性能不好可能导致市场份额的大幅度下滑 星巴克苹果 细分市场战略 也称”聚焦战略”适用于狭小市场对市场有深入认识与独特见解 聚焦营销和新产品开发工作具备很高的竞争壁垒增加产品开发投入提高利润率 依赖单一狭小市场风险大新技术冲击 医美行业月子中心 迈尔斯.斯诺战略框架基于企业对于变更响应的研究，提供有用框架去描述产品开发战略方法 类型 动作 方式 探索者Prospector 首先上市寻求增长敢于冒险 开发和应用新技术借助快速上市，占领市场份额 分析者Analyzer 快速跟随产品通常更好 经常跟随探索型公司，开发模仿产品被称为”快速跟随者”新产品开发成本低 防御者Defender 在稳定市场中维护其市场份额 风险厌恶型，聚焦于狭窄的，稳定的市场与产品类别通常不具备技术进攻能力 反应者Eeactor 只有在遭遇威胁时才会有所反应 没有清晰的战略目标没有明确的技术开发计划和市场进入计划 持续式创新 VS 颠覆式创新持续式创新 不创造新的市场与新价值主张，致力于把现有产品做的更加好 从审美，功能，特性或成本角度关注产品变更和改进的渐进过程 颠覆式创新 克莱顿.克里斯坦森首次提出颠覆式创新的概念(1997) 有助于创建新市场与新的价值网络(价值主张) 初期关注小众有影响力的目标市场，该市场产品具有重要的新特性或功能，但是因为开发成熟度不够充分，还无法与现在已被广泛接受的产品竞争 初期在目标市场的影响力加上产品改进将会扩大市场，导致现有产品最终退出市场 促成和创造颠覆式影响的通常是一个商业模式，而非是一项技术 颠覆式创新不会一夜之间实现，而是逐渐发生的 皮萨诺战略框架 - 创新画布在技术与商业模式创新的两个方面有效分配精力和资源 其他战略库珀的战略 库珀是门径管理流程的奠基人，库珀的战略从技术和市场的角度来讨论 差异化战略： 与波特的差异化战略类似，提供高价格，高质量的产品，满足客户需求 高成本战略： 研发成本高，较少关注市场和客户需求 技术推动战略： 最新技术，高度创新想法，较少关注用户需求 保守战略： 低风险，有限研发投入，非差异化产品 非博弈战略： 与迈尔斯.斯诺的反应者战略类似 平台战略平台战略被定为为一系列子系统及其接口，由此可以建一个通用架构，继而高效的开发，制造出其延伸产品 优势： 快速，连续的推出一系列产品 鼓励从长期视角定制产品战略 能大幅度提升运营效率 公司与市场能清晰理解产品平台的底层要素 能带来巨大的差异化，使自身产品与竞争产品得以区分开来 技术战略技术战略是一份有关技术维护和技术发展的计划，这些技术能够支持组织的未来发展，有助于组织战略目标的实现 技术战略与经营战略和创新战略相连 技术预测方法 头脑风暴法 专家小组法 德尔菲法 (专家 匿名 多轮 趋向一致) SWOT法 专利分析法 趋势分析法 技术S曲线基本上显示了大多数技术的生命周期阶段 引入期 成长期 成熟期 知识产权战略知识产权： 智力制造出来东西，比如发明、文学、艺术、设计、符号、名称、商业用户图像的所有权；同其他产权一样可以出售，授权，交换或者被拥有者放弃；知识产权被法律保护，例如专利、版权和商标可以让所有人从他们的创造中获取荣誉和金钱回报。 知识产权的类型专利：在一定时间阶段生效的，由政府授权或许可的权利，特别指禁止他人制造，使用或者销售一个发明的所有权力 版权：一定年限内，给予原创者独家的，指定的法律权利，可以印刷，发行，制作 商标：代表公司、产品的经由法定注册或许可的符号，单词或者词组 植物品种权： 给予独家权力生产和销售某种可繁殖的植物 商业机密：和企业相关的保密信息 营销战略从业务目标到营销计划，其中包含业务目标、营销战略、公司组合、营销计划 市场营销组合4P产品Product：外观 功能 特色 质量 包装 支持 质保 品牌 促销Promotion：主题&#x2F;信息 社交媒体 公关 销售团体 商品展会 纸质媒体 定价Price：目录价格 折扣 捆绑销售 信用条款 渗透定价（低价占领市场） 撇脂定价（高价回收成本） 地点Place：渠道 库存 物流 实体分销 如何定价 无论何时何地，对产品经理而言必须明确点：总利润比市场份额、效率更加重要 维持低成本是产品的事情，维持高售价是运营的事情 降价是最昂贵的运营策略，而提价的效果未必会有想象中的糟糕 如何应对竞争对手的价格变化​ 某一家酒企的一款酒经过多年经营，在市场上占有率一度达到20%，后来竞争对手也出了类似的产品，比他要低1美元，这时候酒企应该进行价格竞争吗？显然这会导致自己总利润降低，这时候决策者决定，将这款酒提价1美元，同时出这款酒的不同包装的产品，可以理解为青春版，其价格更加低廉，以此与对手竞争，一方面提高了前者酒的地位，一方面拉低了对手的品牌力，使销售量增加，利润量增加 如何“忽悠”用户付费在一定得到3w 80%的几率得到4w，20%的概念得到0元面前，大部分用户会选择前者 在一定失去3w 80%的几率失去4w，20%的概念失去0元面前，大部分用户会选择后者 结论：人性在面对失去与风险的时候更加害怕失去 策略：不要告诉用户买了产品会得到什么，而是告诉用户不购买会失去什么 场景：儿童兴趣班 阅读到一半的付费阅读 营销理念的历史演变 4P - 4C - 4R 4P 产品导向 4C 顾客导向 4R 顾客忠诚度导向 产品（product） 顾客需求（Consumer） 关系（Relation） 促销（promotion） 便利性（Convenience） 反应（Respond） 价格（price） 沟通（Communication） 回报（Return） 分销（place） 成本（Cost） 关联（Relevancy） 产品三环靶核心利益：产品核心价值（不是有形物理属性） 有形性能：赋予产品外观和功能的物理和美学设计特征 附加性能： 产品提供的额外性能可以是免费的 产品描述FAB每个产品或者品牌都具备的三个要素 产品的F-A-B结构（总结每个产品的卖点，特点，优势和利益） 特点（Feature）：对产品本身的技术性解释，通常包含产品专业化词语 优势（Advantage）：由于产品本身的特性所导致的产品表现 利益（benefit）：与消费者的感受密切相关，由产品带给消费者的价值 基于感觉上的体验，往往是针对个人而言，相对的，类比的，定性的 采用FAB表述产品卖点示例 名称 特点（F） 优势（A） 利益（B） 海飞丝 富含最新丝源蛋白 头屑去无踪 秀发更出众 潘婷 含丰富的维他命原B5 能由发根渗透到发烧，补充养分 使他浦发健康，亮泽 飘柔 含丝质润发素 洗发洗护一次完成 令头发柔顺飘逸 为产品卖点塑造画面感（场景） 产品卖点 普通文案 有画面感的文案 耳机音质好 声声震撼，激发梦想 犹如置身音乐会现场 笔记本噪音低 创想极致，精心由我 闭上眼睛，感受不到电脑开机 工资辛苦，不如旅行 乐享生活，畅意人生 你写PPT时，阿拉斯加的鳕鱼正跃出水面 波士顿矩阵分析 商业画布主要内容与要点 亚马逊商业画布 能力战略能力来源能力要求 技术 营销 研发 内部来源 保持现有能力 获取新能力 重新培训，重新开发现有能力 外部来源 兼并或收购 合资企业 开放式创新 咨询 封闭式创新 VS 开放式创新 封闭式创新的基本原则 开放式创新的基本原则 本行业里最聪明的员工为我们工作 并非所有的聪明人都给我们工作，我们需要和企业内外部的聪明人合作 为了从研发中会哦你，我们必须自己进行发明创造，开发产品并推向市场 外部研发工作可以穿在巨大价值，而要分享其中的一部分，则必须进行内部研发 如果我们自己进行研究，就能最先把产品推向市场 我们不是非要自己进行研究才能从中受益 最先将创新商业化的企业将成为赢家 建立一个更好的商业模式要比贸然冲进市场好很多 如果我们创造出商业中最多最好的创意，我们必将胜利 如果我们能充分利用企业内外部的创意，我们必将胜利 我们必须控制知识产权，这样竞争对手就无从我们的创意中获利 我们应当通过让他人使用我们的知识产权而从中获利，同时应当购买他人的知识产权只要它能提升我们的商业模式 保持市场竞争优势的办法 如果在一个相对封闭的行业，应当着重发展内生优势，提升自身能力但产业融合与跨界合作兴起时，生态优势的重要性会特别明显 定位观​ 认为决定竞争优势的因素有两个，一是行业盈利能力，二是企业在行业中的地位。因此企业的盈利能力取决于其竞争战略选择，而竞争战略的选择则是：选择有吸引力、高潜在利润的行业并建立自己的优势竞争地位 资源能力观​ 认为企业在竞争优势产生与企业内部运作（组织过程，包括协调&#x2F;整合、学习&#x2F;重构与转变）、流程和当前所处位置，具有路径依赖性 生态优势观​ 认为在新技术应用层出不穷、产业环境日趋动荡、消费者对一体化解决方案的期望越来越高的背景下，产业边界逐渐模糊，跨界合作与价值共创成为潮流，他不仅仅关注自身的价值链还要重新定义和优化价值网上面的活动，管理好未拥有的资源 互联网思维“孤独九剑”剑谱 互联网+​ “互联网+”就是“互联网+各个传统行业”，但这并不是简单的两者相加，而是利用信息通信技术以及互联网平台，让互联网与传统行业进行深度融合，创造新的发证生态 ​ “互联网+”行动加护将重点促进云计算、物联网、大数据为代表的新一代信息技术与现代制造业、生产性服务业等的融合创新，发展壮大新兴业态，打造新的产品增长点，为大众创业、万众创新提供环境，为企业智能化提供支撑，增强新的经济发展动力，促进国民经济提质增效升级 互联网+ 开展的前提用户中心不充分 行业通点多，低效环节多，用户体验不好的行业 充分竞争市场，行政垄断少，市场化长度比较高的地方 数据驱动不充分 产品或者服务可虚拟化、数据化的行业 价值环节可数据化的地方，将面临数据化改造 生态协作不充分 利用信息不对称，靠中介型的商业模式盈利的地方，会被改变","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://vkcyan.github.io/tags/NPDP/"}]},{"title":"新产品流程","slug":"新产品流程","date":"2022-03-17T16:00:00.000Z","updated":"2022-05-23T08:33:50.399Z","comments":true,"path":"2022/03/18/新产品流程/","link":"","permalink":"https://vkcyan.github.io/2022/03/18/%E6%96%B0%E4%BA%A7%E5%93%81%E6%B5%81%E7%A8%8B/","excerpt":"","text":"思维导图管控产品失败（降低不确定性）的方法不确定性、累计成本与开发阶段的关系 标准的决策框架 产品开发流程基本阶段 探索（Exploration） 筛选（Screening） 商业评估（Business Evaluation） 开发（Development） 测试（Testing） 商业化（Commercialization） 常见产品开发流程 门径管理流程（Stage - Gate@） 集成产品开发（IPD） 精益开发（Lean） 敏捷开发（Agil） 设计思维（Design Thinking） 模糊前端FFE​ 模糊前段（Fuzzy front end，FFE）：产品开发项目的前端是一个早期极端的起点，在进入正式的产品开发流程前，组织在该阶段识别机会，形成概念。 ​ 该阶段包括创意生成阶段，初始概念发展阶段和高级业务阶段。 ​ 是项目中定义最不确定的一个阶段 ​ 注：创意阶段可能有5个，概念开发阶段经过淘汰与融合变成了2个，最后立项分析，确定要做的项目 门径管理流程 阶段-关口概念什么是阶段产品开发流程中的一个确认区域，包括： 活动：项目负责人及团队成员依照项目计划必须完成的工作 综合分析：通过跨职能部门及团队成员依照项目计划必须完成的工作 可交付成果：是综合分析结果的呈现，这是团队必须完成的并在关口时所以提交的内容 什么是关卡基本上，他是产品开发流程中的一个确认节点，在该阶段时需要做出有关项目未来的关键决策。包括 可交付成果：关口评审点的输入内容（阶段中的可交付成果）。它是前阶段行为的结果，是实现确定的，在每个关口都有一个可交付成功的标准清单 标准：判断项目是继续还是停止以及优先级决策的标准，这些标准通过以分数呈现，包括财务和定向标准 输出：关口评审结果。关口必须有明确的输出包括一个决策（继续或者停止）以及下一个阶段的路径 阶段 - 关口（Stage - Gate）新产品开发过程 根据需要，可灵活裁剪与添加 分为六个阶段，由来自公司内部不同职能领域的人员一起完成： 发现（Discovery）：寻找新机会和新产品创意 筛选（Scoping）：也叫观察，初步评选市场机会、技术需求以及能力的可获得性 立项分析（Business Case）：也叫构建产品框架，建立在筛选阶段之上的一个关键阶段，包括更为深入的技术，市场和商业可行性分析 开发（Development）：产品设计，原生制造，生产设计，制造准备和上市规划 测试与修正（Testing and Validation）：也翻译成测试与确认，测试产品以及商业化计划的所有方面，以修正所有假设和结论，和证实对产品的预期和总结 上市（Launch）：也翻译为投放市场，产品的完整商业化，包括规模制造以及商业化上市 阶段：一个确定区域，包括 活动，综合分析，可交付成果 关卡：一个确定阶段，必须又明确的输出包括一个决策（继续或者停止等）以及下一阶段的路径。包括：可交付成果，标准，输出 瀑布模型 要求：了解要设计产品需要什么功能、目的、用户需求 设计：确定完成项目所需的软件与硬件，之后被转化为物理设计 实施：根据项目要求和设计规范编写实际代码 验证：确保产品符合顾客的期望 维护：通过客户确定产品设计中的不足或错误，进行修正 集成产品开发IPD integrated Product Development，PID 前身 - 并行工程含义​ 在产品的设计与制造流程中，跨职能团队采用并行模式进行工作，而不是各个功能的顺序依次开发，从而促使团队全面考虑产品生命周期中从概念到实施的全部元素，包括质量、成本、维护等方面 主要特征 并行交叉：并行工程强调产品设计与工艺过程设计、生产准备、采购等活动交叉进行 按部件并行交叉，将一个产品分成若干部分，使其各部件能并行进行交叉开发 各个组件的设计、采购、生产等各种互动尽可能的交叉并行 尽早开始工作，目的就是争取时间 具体做法​ 在产品开发的初期，组织多种可协同工作的项目组，使得有关人员从一开始就获得有关项目的最新消息，积极研究涉及本部门的工作任务，并将需求提供给设计人员，使得许多问题在开发早期就得到了解决从而保证设计质量，减少返工与浪费 发展 - 集成产品开发IPD含义​ 系统综合地应用不同职能体系的成果和理念，有效、高效的开发新产品，满足客户需求的方式 IPD管理的精髓 IPD基于并行工程发展而来 IPD首先是一个商业流程，关注商业结果，将产品开发作为一项投资进行审慎管理 IPD采用跨职能团队，加强部门合作，形成合力，共同承担 IPD流程分为不同的阶段，通过在决策评审点的决策实现集成组合管理团队（IPMT）和产品开发团队（PDT）互动，资源受控分配与投入，既满足项目进展的需求，又避免了投资失控的风险 IPD是灵活的，发展的，持续改进设计的，在不断吸纳业界实践和解决业务问题的过程与时俱进 IPD流程是基于市场的开发，关注市场需求和竞争分析，鼓励创新基于着二者之上 集成产品开发系统分级 精益产品开发定义（Lean Product Development）：创建在丰田首创的精益方法（TPS）的基础之上。目的是：从流程中去掉浪费 精益开发的原则（提升生产效率） 确定客户定义的价值 尽最大努力探索不同的解决方案 创造顺畅的产品开发流程 尊重颜色的标准，以减少变异 首席工程师全程参与 跨职能整合 学习不断改进 准求卓越与不断学习的文化 团队整个组织 消除浪费 + 强化学习 + 慎重政策 + 尽快交付 + 授权团队 + 品质为先 + 全局优化 + 消除浪费 &#x3D; 精益产品 潜在的浪费来源包括 混乱的工作环境 缺乏可用的资源 缺乏明确的优先级顺序 不同职能之间的沟通存在障碍 糟糕的产品需求定义 缺乏对可制造性的早期考虑 过度设计 太多无效会议 太多的电子邮件 直接效益 显著提升生产效能 准时制准时制生产方式（Just In Time简称JIT），又称作无库存生产方式（stockless production），零库存（zero inventories），单件流（one - piece flow）或者超市市场生产方式（supermarket production） JIT的基本理念：只在需要的时候、按需要的量，生产所需的产品，故又被称为准时生产、适时生产方式。 JIT的目标：彻底消除无效劳动和浪费。具体要达到以下目标 废品量最低 2. 库存量最低 3. 准备时间最短 4. 生产提前期最短 5. 减少零件搬运，搬运量低 6. 机器损坏低 7. 事故降低 单件流批量生产虽然是降低成本的生产方法，但是容易出现堆积浪费，周转麻烦，容错率低的问题 单件流则有目的的降低周转问题，并且减少堆积浪费，同时增加容错率 5WHY法（刨根问底法） 安灯法操作：产线异常，按下按钮 - 产线报警 - 领班支持 收益： 一线员工既要动手，也要动脑 鼓励员工持续成长，获得成就感 公司流程优化，持续改善 现场现物亲临现场 - 细致观察，分析&#x2F;评估 - 找出原因 构建学习型组织 超越短期利益，着眼长期利益 致力提升员工，合作伙伴能力 继任领导延续公司文化基因 丰田模式的核心精神是通过支持和鼓励员工持续改善工作流程 让他们不断成长与进步，进而获得工作成就感和主人翁意识 精益产品开发过程的核心概念 精益产品开发的优劣势优势 流程的聚焦点在于信息的顺畅流动,而非严厉管控 通过事件驱动方法简化合作，优化设计 重视对进度、成本、消极和质量方面的风险的积极管控 适用于各种规模的项目 用于记录学习和进展、判定优先级和解决问题的工具是简单的，可视化的 劣势 参与人员必须是相当敬业并且经验丰富的 需要改变组织的结构和文化 需要强有力的供应商管理 组织有意愿且有能力接受项目目标的和方向上的变化 敏捷开发传统方法VS敏捷方法 传统的写作方式 敏捷的写作方式 确定主题 与读者互动 整理大纲、搭建框架 确定主题 书写内容 与读者互动。收集反馈 设计、排版、校对 试写第一张 出版 与读者互动，收集反馈 与读者见面 试写第二章 筹集反馈 … 设计、排班、校对 出版 传统VS敏捷之客户互动对比 确定性项目VS不确定性项目 生命周期类型 增量型：楼盘 定下来不会变 但是要不断交付 敏捷性：互联网项目 不断在变化 预测型：铁路建造 变化极小，有规律的项目 迭代型：研发疫苗 不断变化，但是只需要交付一次 Stacy斯泰西图 敏捷宣言 敏捷宣言 价值观 个体以及互动 胜于 流程和工具 以人为本 可工作的软件 胜过 完整的文档 以价值为导向 客户合作 胜过 合同谈判 合作共赢 响应变化 胜过 遵循原则 拥抱变化 敏捷开发十二大原则 通过尽早和持续地交付有价值的软件来满足客户 欢迎对需求提出变更，敏捷过程要善于利用需求变更，帮助客户获得竞争优势 经常交付可用软件，并周期越短越好 业务人员与开发人员必须通力合作 要善于激励项目人员，基于他们所需的环境和支持，并相信他们能完成任务 团队内部和各个团队之间，最有效的沟通方式是面对面沟通 可工作的软件是衡量进度的首要指标 敏捷过程体长可持续的开发。项目方、开发人员和用户应该能够保持稳定恒久的进展速度 对技术的精益求精以及对设计的不断完善将提高敏捷性 尽量做到简洁，尽最大可能减少不必要工作，这是一门艺术 最佳的架构、需求和设计出自于自组织团队 团队要定期回顾和反思如何能够做到更有效，并相应地调整团队的行为 敏捷Scrum框架 敏捷实践SCRUM的333555 三个支柱 三个角色 三个工件 透明性（Transparency） 产品负责人（Product Owner） 产品待办事项列表（Product Backlog） 检查（Inspection） 敏捷教练（Scrum Master） 冲刺待办事项列表（Sprint Backlog） 适应（Adaptation） 项目团队（Scrum Team） 可交付产品增量（Increment） 五个事件 五大价值观 冲刺 承诺（Commitment） - 愿意对目标做出承诺 冲刺规划会议 专注（Focus） - 全身心都用到你承诺的工作上去 每日站会 开放（Openness） - 团队内所有信息对所有人开发 迭代评审会议 尊重（Respect） - 每个人都有他独特的价值与经验 迭代回顾会议 勇气（Courage） - 勇于承诺，履行承诺，敢于说不 敏捷实践 - 3个角色 产品负责人 敏捷教练 敏捷团队 确定产品的功能和标准维护产品待办事项列表指定软件的交付内容代表客户利益拥有最终解释权平衡有竞争关系的利益相关者 团队和产品主管之间的协调者，消除他们之间的障碍工作职责不是管理团队激发团队的创造力，给团队授权提升团队生产率改进工程工具的实践确保团队取得进展的信息实时更新与同步服务团队、教导团队、保护团队 5到9个人多职能部门人员组成冲刺阶段，团队通过自组织的方式实现冲刺目标实现目标的帆帆上有选择自主权责任属于整个开发团队一起成功，一起失败一起调整，一起改进 敏捷实践 - 用户故事作为 学员 我想 看直播课 以便于 和老师互动 作为老师 我想 提前排课表 以便于 合理安排事件 作为xx 我想 xx 以便于xxxxx 用户说出自己的问题而不是给出具体解决方案 敏捷实践 - 产品代办列表​ 待办事项是所有工作的有序列表，他以故事形式呈现给团队。价值大的排在上面。他是产品需求变更的唯一来源 ​ 他是一个持续完善的清单，根据产品和开发环境的变化而演进。 ​ 产品负责人Product Owner负责待办事项列表的内容，可用性和优先级 几种开发流程的对比瀑布模型 VS 敏捷流程 瀑布模型 敏捷流程 瀑布使用阶段 敏捷使用迭代 瀑布使用不提供高低频率的互动（开发阶段低频率，业务测试阶段高频率） 有频繁的业务互动 瀑布模式一个项目经理 敏捷流程是scrum master 瀑布不能迭代 敏捷能迭代 敏捷与精益敏捷开发：敏捷设计的初衷是再短时间内执行任务，与客户进行频繁互动，并能够对变化做出迅速相应，比较常用于软件开发 精益开发：精益旨在减少浪费，提高运营效率，特别适用于制造过程中常见的重复性任务 门径管理 VS 敏捷 特征 门径管理 敏捷 模型类型 宏观技术 微观计划，项目管理 范围 创意到结束，端点到端点 只有开发与测试阶段 组织广度 跨职能 - 技术、市场、生产 技术 结束点 上市成为新产品 已开发或测试的软件 决策模型 投资模型：设计高级管理层治理的继续或停止模型 主要是战术性的：下一个冲刺需要的动作 集成产品开发与其他流程对比 集成产品开发提供一种将产品开发中的功能，角色和行为集成起来的框架。 定义为系统地、综合的应用不同职能体系的成功和理念，有效、高效地开发新产品，满足客户需求的方式 集成产品开发模型的一个重要功能是“学习与持续改进”，模型表明专注于产品开发过程和技术的组织如何发展以知识为基础的学习型组织 各流程模型是潜在互补的，而不是相互排斥的，应以持续学习和改进为重点，将每个模型中的元素融合为一个真正适合于产品开发的模型 特点 门径管理模型 宏观规划、决策基础 敏捷模型 微观技术和灵活性 精益生产 减少浪费 集成产品开发 学习型组织，对新产品开发的综合集成 开发流程的治理治理：用于指导项目、程序和项目组合管理中的活动框架、功能和流程。治理是采取高层级和战略性的视角，而不是陷入过程和项目细节 治理 管理 职能 监督、控制、整合和决策 技术、组织、领导和控制 关注点 结果和目标 方法和技术 层面 宏观（战略、决策角度） 中观和微观（战术、执行角度） 负责人 董事会 管理层 作用 为管理提供框架、功能和过程授予管理者经营权并加以监督 再治理提供的框架和监督中形式经营权，实现经营目标 总结所有流程模型均遵从一下共同原则 关注战略一致性 基于知识进行决策 降低产品失败的风险 剪掉将利益相关者的输入信息融入设计决策 应用跨职能团队 是一个结构化框架，要被整个项目所理解和应用 门径管理流程 集成产品开发 精益开发 敏捷开发 是否对整个新产品开发流程进行管理 是 是 是 否 是否专注于跨职能团队的使用 是 是 是 是 能加快上市速度吗 是 是 是 是 最适用什么类型的产品行业 硬件、实物 多产品 制造 软件 软件类 如何降低产品失败的风险 关口 决策点 消除浪费 快速迭代 是线性还是迭代 线性 线性 线性+迭代 迭代+线性","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://vkcyan.github.io/tags/NPDP/"}]},{"title":"组合管理","slug":"组合管理","date":"2022-03-17T16:00:00.000Z","updated":"2022-05-23T08:34:07.039Z","comments":true,"path":"2022/03/18/组合管理/","link":"","permalink":"https://vkcyan.github.io/2022/03/18/%E7%BB%84%E5%90%88%E7%AE%A1%E7%90%86/","excerpt":"","text":"组合管理大纲 产品组合产品组织：一个组织正在投资的并将其做出战略性权衡取舍的一系列项目或产品 产品组合管理：以组合形式被管理的一系列程序、项目和&#x2F;或操作的集合。一个组合的构成元素未必是相互依赖的，甚至未必是相关的，但他们被集合成一个组合，以此为单位接受管理，以实现战略目标。 在产品开发和产品管理中，企业可以通过两种途径实现新产品成功 正确的完成项目（项目管理） 完成正确的项目（组合管理） 管理组合的五大高层次目标价值最大化​ 进行资源配置将组合价值最大化（独立项目商业价值的综合）（非财务评估与财务评估） 战略协同​ 确保整体组合战略与经营战略及创新战略始终保持一致（自下而上，自下而上，结合法） 项目平衡​ 根据预定设定的标准如长期或短期、高风险或低风险、特定产品或市场分类等，保持正确的项目之间的平衡 管道平衡​ 确保资源及焦点不会过度分散，避免组合囊括的项目过多，导致被过度分流（资源配置） 财务稳健​ 确保产品组合所选项目能够实现新产品创新战略中所设定的财务目标（财务可行性） 产品规划定义​ 运营严格、规范的方法对市场走势及客户的要求及需求进行分析，创建合理的市场细分规则，对要投资和取得领先地位的细分市场进行选择和优先级排序，从而设计确保市场营销取得成功需要执行的活动，定制可盈利，可执行的业务计划和驱动产品平台、新产品包的开发 老板决定 集体决定 成立规划部门 跨部门团队运行 优点 决策迅速 体现集体意志，形成共识 保证资源，提升专业能力 提升规划质量 缺点 随意、混乱 方法不严谨，责任容易分散 存在局限性，影响规划执行 对管理要求高，决策可能较慢 适用情况 公司创业阶段 公司规模不大，产品较少 公司规模较大，产品较多 公司多产品线，众多产品 组合管理流程 组合中的项目类型 类型 特点 团队（一般而言） 突破型项目Breakthrouth 有时被称为激进的或颠覆式的努力通过技术将新产品带进市场与公司现行的项目大不相同，有高风险 自主团队 平台型项目LpatForm 开发出一系列子系统及其接口，由此创建一个通用架构，继而高效的卡覅和生产一系列衍生产品为发现衍生产品、项目提供平台风险比产品改进或增量提升要高，但比开发突破性产品低 重量级团队 衍生项目Derivative 从其他现有产品或平台中衍生出来可以填补有产品线的空白，提供更具有成本竞争力的制造能力基于组织的核心技术提升性能和引入新特效风险较低 轻量级团队 支持项目Support 对现有产品渐进式改革提高现有产品的制造效率低风险 职能团队 产品组合与战略的关系自上而下法 开发过程中首先考虑愿景与战略 确定整个项目组合中可获得的资源平衡，根据重要战略可能对新产品的贡献，确定业务单元和产品种类的顺序 “战略水桶方法”规定了不同业务单元或产生种类理想的投入比例 在路径上，项目按优先级排序 自下而上法 始于单个项目，经评估筛选，形成项目组合 战略标准依据评估每个项目的选择标准而定 不同与自上而下法，单个的产品组合即是结果不对业务部门和产品类型进行特别考虑（不是很懂） 该法保证项目与战略是保持一致的，但可能无法对特定的项目类型头图理想比例的成本 自上而下和自下而上的结合法 具备两种方法的优点 确定能根据业务部门或产品类型的投入，进行战略优先级的排序 所有潜在的项目都要根据战略标准和每个项目的预估投入进行排序 通过战略预算分配项目时，要综合考虑独立的目标优先顺序和预算投入，并与业务部门或产品类型优先顺序保持一致 从上而下的确定计划，从下而上确定执行 产品机会评估新产品技术评估常用方法气泡图、选项标价、评分方法、项目排序、战略水桶、折现现金单、检查清单、投资回收期 一般分为财务方法与非财务方法 非财务性评估非财务评估方法或评分依据是主观判断。确定要采用的标准包括： 战略一致 产品优势 风险高低程度 法律法规影响 上市时间 市场吸引 利用核心竞争力的能力 技术可行性 通过&#x2F;失败评估示例 财务性评估建立对每个产品机会进行潜在财务评估的基础上 决定新产品在财务上是否可行 决定项目的优先级 具体可用的财务评估方法有： 净现值（Net Persent Value，NPV） 投资回收期（Payback Period） 内部回报率（Internal Rate of Return，IRR） 投入产出比、投资回报率（Return on Invesment， Rol） 以上每种方法都需要 销售潜力及回报的相对值 制造和营销成本的相对值 资金投入预估（对新厂房、设备等进行的投资） 财务可行性研究 - 净现值分析净现值NPV，表示期望项目未来收益折算到此刻的值的总和 财务可行性研究 - 投资回报期投资回报率（Payback period）：指多长时间能够收回在产品上的自由投入 静态投资回收期：不考虑资金的时间成本计算投资回收期 动态投资回收期：考虑资金的时间成本计算投资回收期 投资回收率 &#x3D; 1&#x2F;投资回收期 * 100%（假设3.2年成本收回，则投资回收率为30%左右） 投资回报率（ROI） &#x3D; 运营期年均收益&#x2F;投资总额 * 100%（投资收益率）（假设运营了5年，平均每年收益100，投资总额500，则投资回报率为20%） 内部收益率 &#x3D; 净现值等于0的折现率 什么是平衡组合目的：达到良好的风险与回报平衡，加入一些新产品机会 新产品机会所属的业务单元、产品类别、目标市场，或者产品特征，都可以作为新产品机会的分类标准。 例如： 突破性项目、衍生项目、平台型项目、支持性项目 研发成本、商业化成本 潜在的回报和利益 风险水平 - 开发阶段或商业化阶段 技术难度 - 开发或维护 上市时间 - 从决定开发到获得商业汇报时间 设施设备上的资金投入 知识产权的价值创造潜力 气泡图组合分析用气泡图（Bubble Diagram）来展示产品组合是否有效 通常，用气泡图来表示处于二维坐标图中的项目 X轴和Y轴表示具体的利益标准，如风险和回报 气泡表示单个项目，是根据项目在X轴和Y轴的排序所绘 气泡的大小表示第三个标准，如所需投入资金数额或资源份额 资源配置新产品开发成功率受限因素 同时项目太多 项目计划糟糕，执行任务能力差 产品开发项目与其他业务有优先级之争 上市延期，按照完成难度极大 产品资源竞争，流程不合理，缺乏辅助支持 任务优先级不断变化，资源配置随之改变 管理者陷入困境，无法施救项目 资源配置方法 基于项目资源的需求 基于新业务的目标 将资源配置作为一个业务流程","categories":[{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"}],"tags":[{"name":"NPDP","slug":"NPDP","permalink":"https://vkcyan.github.io/tags/NPDP/"}]},{"title":"JS数据结构与算法","slug":"JS数据结构与算法","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:22:09.379Z","comments":true,"path":"2022/03/15/JS数据结构与算法/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"数据结构为算法提供服务，算法围绕数据结构操作 时间复杂度 一个函数用大O表示，比如O(1)，O(n)，O(logN)… 定性描述该算法的运行时间 O(1)12let a = 1a += 1 每次执行改逻辑的时候，之后执行一次，复杂度不会随着时间的变化而变化 O(n)123for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; for循环里面的代码执行n次 O(1) + O(n) &#x3D; O(n)123456let a = 1a += 1for (let i = 0; i &lt; n; i += 1) &#123; console.log(i)&#125; 两个时间复杂度先后排列就需要相加，相加的情况下低的的忽略不计，取更高的时间复杂度 O(n) * O(n) &#x3D; O(n ^ 2)12345for (let i = 0; i &lt; n; i += 1) &#123; for (let j = 0; j &lt; n; j += 1) &#123; console.log(i, j) &#125;&#125; 两个时间复杂度嵌套排列，时间复杂度就需要相乘 O(logN)$$对数函数：如果ax&#x3D;N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x&#x3D;loga$$ 12345let i = 1while(i &lt; n) &#123; console.log(i) i *= 2&#125; 这里的logN以2为底数，目的是就是求2的多少次方为N， 上面的代码while循环每次*2，实际上就是求2的多少次方为N，所以时间复杂度就是O(logN) 空间复杂度 一个函数用O表示，比如O(1)，O(n)，O(n^2) 算法在运行过程中临时占用存储空间的大小的量度 O(1)12let i = 0i += 1 声明了变量i，单个变量所占用的内存为1，所以空间复杂度为O(1) O(n)1234let list = []for (let i = 0; i &lt; n; i += 1) &#123; list.push(i)&#125; 声明了变量list，通过循环我们增加了n个值，相当于占用了n个内存单元，所以这段代码的空间复杂度为O(n) O(n^2)1234567const matrix = []for (let i = 0; i &lt; n; i += 1) &#123; matrix.push([]) for (let j = 0; j &lt; n; j += 1) &#123; matrix[i].push(j) &#125;&#125; O(n^2)实际上就是一个矩阵，矩阵的本质就是一个二维数据，存储了n的二次方的变量 小知识调试工具栏每个图标的作用 第一个箭头：程序运行到下一个断点，没有断点，程序执行完毕 第二个图标：一行一行执行代码 第三个图标：当前处如果调用了fun，点击此图标就会进入函数里面 第四个图标：点击跳出当前函数 第五个图标：重启调试 第六个图标：停止调试","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vue3 + jsx开发指南","slug":"Vue3 使用jsx开发指南","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:18.409Z","comments":true,"path":"2022/03/15/Vue3 使用jsx开发指南/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/Vue3%20%E4%BD%BF%E7%94%A8jsx%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"","text":"​ 在2021年，vue3发布了正式版本，并且经过一年的维护已经越来越稳定，我们在公司项目中也小范围的上线了vue3的项目，总体还是很不错的 ​ 但是setup语法需要return比较麻烦，还有.value问题，尝试过setup语法糖，依旧觉得setup语法的api记忆负担比较重 ​ 所以下半年逐渐拾起了jsx的语法，并在开源项目中使用，总体感觉还是相当不错的，前人栽树后人乘凉，本文对jsx for vue的常见问题进行说明 jsx学习成本更低，这么多年jsx没有大改动； 无记忆负担，同时足够灵活，如果你是vue开发者，同时对setup语法并不是太合得来， vue3 + jsx也是非常不错的选择~ 前置知识​ 在vue3中使用jsx需要安装@vitejs&#x2F;plugin-vue-jsx（webpack版本的不了解，有需要者执行搜索），根据文档配置一下就行了，官方提供了文档供参考，提供了相关示例jsx-next,有react基础的同学可以先看官方文档，在开发过程中出现问题再看本文 指令v-modelJSX for vue是支持v-model语法的，这一点比react的setState,体验感确实要好 1234567891011// 正常写法&lt;input v-model=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;value&#125; /&gt; // jsx// 指定值写法&lt;input v-model:modelValue=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;]&#125; /&gt; // jsx // 修饰符写法&lt;input v-model:modelValue.trim=&quot;value&quot; /&gt; // vue&lt;input v-model=&#123;[value,&#x27;modelValue&#x27;,[&#x27;trim&#x27;]]&#125; /&gt; // jsx v-show这个api与在vue中的表现形式一致 12&lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt; // vue&lt;div v-show=&#123;isShow&#125;&gt;&lt;/div&gt; // jsx v-bind1234567891011121314// vue&lt;a-modal :width=&quot;&#x27;400px&#x27;&quot; :title=&quot;&#x27;设置组件名称&#x27;&quot; &gt; // ....&lt;/a-modal&gt;// jsx&lt;a-modal width=&#123;&quot;400px&quot;&#125; title=&#123;&quot;设置组件名称&quot;&#125; &gt; // ....&lt;/a-modal&gt; v-if在jsx for vue中没有这个api，我们需要用jsx风格来实现v-if的效果 可以简单理解为jsx直接将if搬到html中 12&lt;div v-if=&quot;isShow&quot;&gt; ... &lt;/div&gt; // vue&#123;isShow &amp;&amp; &lt;div&gt; ... &lt;/div&gt;&#125; // jsx 事件事件语法jsx for vue，所有的事件都按照react风格来 所有事件有on开头 所有事件名称首字母大写 例如：@click &#x3D;&gt; onClick @change &#x3D;&gt; onChange @drop &#x3D;&gt; onDrop 事件修饰符这里没有找到权威的资料，有小伙伴知道也请告知一下，目前建议大家通过原生JavaScript来实现vue事件修饰符的效果 .stop ： 阻止事件冒泡，在JSX中使用event.stopPropagation()来代替 .prevent：阻止默认行为，在JSX中使用event.preventDefault() 来代替 APIref与reactivevue3的template会自动解析ref的.value,在jsx中ref的.value是不会被自动解析的 1234//声明变量 let type = ref(1)&lt;p&gt;&#123;&#123; type &#125;&#125;&lt;/p&gt; // vue&lt;p&gt;&#123;type.value&#125;&lt;/p&gt; // jsx props在jsx for vue中，props的语法使用的就是setup的语法，实际表现形式完全一致 1234567891011export default defineComponent(&#123; props: [&#x27;title&#x27;], setup(props) &#123; onMounted(() =&gt; &#123; console.log(props.title); &#125;) return () =&gt; ( &lt;div&gt;&#123;props.title&#125;&lt;/div&gt; ) &#125;&#125;) emit同样与vue3的setup语法保持一致，注意子父方法需要符合react规范 123emit(&#x27;changeVisible&#x27;, false) // 子组件 &lt;xxx onChangeVisible=&#123;(params) =&gt; xxxFun(params)&#125;&gt;&lt;/xxx&gt; // 父组件 solt如何写插槽这里以antd for vue的Popover 气泡卡片，为例子 Vue3语法123456&lt;a-popover title=&quot;Title&quot;&gt; &lt;template #content&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/template&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; jsx for vue语法123456789&lt;a-popover title=&quot;Title&quot; content=&#123; &lt;&gt; &lt;span&gt;Content&lt;/span&gt; &lt;/&gt; &#125;&gt; &lt;a-button type=&quot;primary&quot;&gt;Hover me&lt;/a-button&gt;&lt;/a-popover&gt; 基础模板12345678910111213import &#123; defineComponent, onMounted, ref &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; // props: [&#x27;xx&#x27;], setup(props,&#123; emit &#125;) &#123; onMounted(() =&gt; &#123; // ... &#125;) return () =&gt; ( &lt;div&gt;&lt;/div&gt; ) &#125;&#125;) 结语 国内这方面资料比较少，查问题的时候注意vue版本，以及jsx的使用（render方式本文不适用） 如果代码里面存在问题，如果是ui框架，建议直接看react版本的代码，例如antdv的jsx版本直接看antd的实例代码 直接看jsx语法的项目代码，H5-YD.v2 不接受杠精，例如写jsx为啥不去用使用react 如果在学习过程中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vite配置alias（设置别名）","slug":"vite配置alias","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:16.257Z","comments":true,"path":"2022/03/15/vite配置alias/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/vite%E9%85%8D%E7%BD%AEalias/","excerpt":"","text":"Vite配置alias需要两步进行（TS项目） 1、修改vite.config.ts（让程序支持） 2、修改tsconfig.json（让编辑器支持） 修改vite配置12345678910111213141516171819import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;function _resolve(dir: string) &#123; return path.resolve(__dirname, dir)&#125;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], // 配置项目别名 resolve: &#123; alias: &#123; &#x27;@&#x27;: _resolve(&#x27;src&#x27;), &#125;, &#125;,&#125;) 修改tsconfig.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;noImplicitAny&quot;: false, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true, &quot;importHelpers&quot;: true, // 不让同样的辅助函数重复的出现在多个文件中 &quot;allowSyntheticDefaultImports&quot;: true, // 允许对不包含默认导出的模块使用默认导入。 &quot;baseUrl&quot;: &quot;.&quot;, // 非相对模块的导入可以相对于baseUrl或通过下文会讲到的路径映射来进行解析 &quot;lib&quot;: [ &quot;esnext&quot;, &quot;dom&quot; ], &quot;paths&quot;: &#123; // 配置导出路径（这里根据自己项目执行修改） &quot;@/stores*&quot;: [ &quot;./src/stores*&quot; ], &quot;@/components*&quot;: [ &quot;./src/components*&quot; ], &quot;@/modules*&quot;: [ &quot;./src/modules*&quot; ], &quot;@/utils*&quot;: [ &quot;./src/utils*&quot; ], &#125;, &quot;types&quot;: [ &quot;element-plus/global&quot; ] &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot;, ], &quot;include&quot;: [ &quot;src/*&quot;, &quot;src/**/*.vue&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.jsx&quot;, &quot;src/**/*.ts&quot;, &quot;src/**/*.js&quot; ]&#125; 结语 修改后请重启编辑器 本文验证与2022年1月10号，mac，win双平台均有效，如果以上配置无效了，请查看相关api的改动 如果帮助你解决了问题，动动小手点个赞吧！:)","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"Vue3.x 预渲染 Unable to prerender all routes错误排查","slug":"vue3.x 预渲染 Unable to prerender all routes错误排查","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:22:23.794Z","comments":true,"path":"2022/03/15/vue3.x 预渲染 Unable to prerender all routes错误排查/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/vue3.x%20%E9%A2%84%E6%B8%B2%E6%9F%93%20Unable%20to%20prerender%20all%20routes%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/","excerpt":"","text":"前言​ BOOS最近对前几年做的公司官网不太满意，觉得没有有效体现公司的优势，表明随着公司这几年的努力发展，我们将会接触到更大规模的合作伙伴，自然要展示更好的企业形象，所以官网重做。 需求分析 没有交互的静态页面，但是存在大量动画 需要支持良好的SEO ​ 最早期的官网是vue2.x + webpack3.x + vue-cli-plugin-prerender-spa进行实现的，效果挺不错，很快各大搜索引擎就收录了我们的网站，所以这次我们打算沿用此方案，不过使用最新技术栈； 为什么不用vite​ 查阅vite的生态后，未找到类似prerender-spa的plugin，没办法支持预渲染，所以vite就被淘汰了。 为什么不用unxtjs​ 我们的官网不具备大量的接口交互，用Nnxtjs多少有点杀鸡用牛刀了，并且还需要使用pm2部署代码，付出于收获不成正比，被淘汰。 最终方案​ 我们部门是vue技术栈，团队不考虑react，通过以上排除法，只能使用vue3.x + webpack5.x + prerender-spa进行业务实现了。 技术实现基础模板我们使用最新的vue-cli进行项目搭建，选择vue3版本，最近的cli默认就是webpack5 安装预渲染插件1npm i prerender-spa-plugin -D 增加配置123456789101112131415161718const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)const path = require(&#x27;path&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, &#x27;dist&#x27;), routes: [&#x27;/xxx&#x27;], &#125;) ) &#125; &#125;,&#125;) 打包测试1npm run build 然后就出现一个错误 1[prerender-spa-plugin] Unable to prerender all routes! 让我们一起抽丝剥茧，看看报错的具体原因。 错误排查因为报错提示很模糊，我们打开他的源码，在源码line144发生错误的地方增加log，了解具体报错。 再次执行npm run build，得到真正的错误。 1Building for production...error TypeError: compilerFS.mkdirp is not a function ​ 我们继续最终源码发现 compilerFS 由webpack进行提供，我们带着错误前往webpack官网查询错误，于是就找到了Filesystems，因为这个插件已经好几年没有更新，而我们当前使用的是webpack5，出现了API变更的情况。 ​ 于此同时，根据错误提示，我们也在该库的issues中找到了历史讨论。 在讨论中，找到了两种解决方案 修改node_modules源码，使其兼容webpack5 1234567891011// From https://github.com/ahmadnassri/mkdirp-promise/blob/master/lib/index.js const mkdirp = function (dir, opts) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;\\ndir&#x27;, dir, opts, &#x27;\\n&#x27;); try &#123; compilerFS.mkdirp(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; catch(e) &#123; compilerFS.mkdir(dir, opts, (err, made) =&gt; err === null ? resolve(made) : reject(err)) &#125; &#125;) &#125; 使用已经被修改的库，感谢这位大哥 1npm i @dreysolano/prerender-spa-plugin 我们使用第二种方案，重新修改vue.config.js 12- const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)+ const PrerenderSPAPlugin = require(&#x27;@dreysolano/prerender-spa-plugin&#x27;) 然后再次打包测试 打包成功，通过启动本地服务器curl命令测试得知，SEO功能正常，未发现问题。 总结​ 使用prerender-spa-plugin打包出现报错[prerender-spa-plugin] Unable to prerender all routes!，更换库为**@dreysolano&#x2F;prerender-spa-plugin**，即可解决问题。","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"写给前端新人的nginx教程","slug":"前端工程师的nginx教程","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:07.710Z","comments":true,"path":"2022/03/15/前端工程师的nginx教程/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84nginx%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言​ 我相信大部分前端新手是接触不到部署相关的工作的，一般都是将代码包交给后端，或者通过CI，FTP完成代码的更新，至于代码如何部署，如何从域名到前端代码包，很多前端仔没有实际操作过，自然是不知道的，这篇文章就是要帮助未接触过部署的人学会在服务器上线部署一个前端项目，在这个主线中带大家慢慢的熟悉nginx ​ 记得在2017年暑假，那时候大二还没开学，当时我只会写一点简单代码，linux和运维完全没接触过，一冲动在阿里云购买了一个服务器，外加一个域名，好像还是xiaowuasy.top,现在已经不能访问了；那时候单纯的兴趣使然，想搭建一个网站，因为实力不足，也不知道求助别人，前前后后折腾了一个月，最终竟然成功在服务器上面部署了wordpress服务，后面域名备案也成功了； ​ 这段经历是曲折的，依稀记得在盛夏的傍晚，我坐在慢慢暗下来的客厅，头上还残留着因为紧张流下的细汗，眼睛因为专注而干涩，面对不太看得懂的文档，一遍一遍尝试；我自然不希望大家在这上面浪费时间，这也是写这篇文章的初衷 前置知识 一个云服务器，阿里云，腾讯云，xx云都行，首次购买或者学生认证都是有很大的优惠（本文以阿里云为例子） 了解linux基础命令，也就是对各种文件的增删改查 本教程基于CentOS 7.5系统，如果是图形化界面，或者其他系统，命令可能不完全一致，但是流程都是一致的，建议看对应教程 如果linux基础命令不会。下面的也不用看了，立刻去学 搭建环境连接服务器通过远程工具（CRT，Xshell）或者自带的远程连接进入自己的服务器，连接方式选择公网ip 安装nginx CentOS自带yum命令，这个命令很关键，自行了解 执行命令 1yum install nginx // 终于遇到需要确认的，直接确认即可 安装完成后,主机中便有了nginx服务，相关命令如下，启动完成后 1nginx 启动完成后，浏览器访问公网IP,就可以访问到nginx的默认主页 到这一步就算是nginx部署成功了 nginx相关文件路径12/etc/nginx/ // 配置文件/usr/share/nginx/ // 默认前端代码存放处 ​ 默认配置在/etc/nginx/nginx.conf,nginx根据默认配置，监听80端口，80端口指定了&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html这个文件夹，于是你访问公网ip -&gt; 公网ip:80 -&gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html,于是”Welcome to CentOS“便呈现在你的面前 ​ 如果你希望不显示默认的页面，而是显示你自己写的项目，直接替换/etc/nginx/nginx.conf中的root,字段为自己程序包的路径 在6666端口上搭建一个站点​ 我们的代码除了部署在默认80端口上面，还可以其他端口上，例如8888，7777，等等 ​ 接下来我们就在一个自定义的端口上面部署一个站点 ​ 这里我们需要注意nginx.conf中的一行配置 含义：在&#x2F;etc&#x2F;nginx&#x2F;conf.d下面所有nginx的配置文件都会自动生效 根据配置文件的提示我们到目标文件夹下面，建立test.conf，名字无所谓，配置文件里面是通配符匹配的 并通过vi 写入内容 123456server &#123; listen 7777; server_name _; root /usr/share/nginx/test;&#125; 再去文件夹/usr/share/nginx/test下建立一个index.html 123mkdir test cd testvi index.html 将一下内容放入index.html种 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是7777端口&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后重启nginx 1nginx -s reload 访问我们部署的项目ip:7777 然后你会发现访问不了，最终访问超时(&#x3D;&#x3D;)，这是因为服务器限制了可访问端口，此时需要到云管理后台设置安全组 在阿里云后台增加安全组规则 之后就可以正常访问了！ 至此，便完成了第一个nginx项目的部署 部署一个vue项目​ 通过上面的例子，我们已经可以完成一个自定义站点的部署了，那么真实项目呢，例如将一个vue项目部署到3006端口 首先编写xxx.conf 1234567891011121314151617181920server &#123; listen 3006; server_name _; # 开启gzip相关配置 gzip on; gzip_static on; gzip_min_length 2k; gzip_buffers 4 8k; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/x-icon application/javascript; gzip_comp_level 9; gzip_disable &quot;MSIE [1-6]\\.&quot;; # 站点代码路径 root /usr/share/nginx/client; # 单页应用必须设置（刷新404问题） location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 将打包之后的代码，通过FTP上传代码到目标文件夹/usr/share/nginx/client（注意文件夹名称） ftp 重启nginx nginx -s reload 这边完成了一个站点的部署！是不是很简单 绑定域名​ 直接拿ip+端口给别人访问是不太好的，大家都给自己站点绑定上一个好记忆的域名，那么nginx如何绑定域名呢？ 购买一个域名https://wanwang.aliyun.com/domain/，备案域名，这个流程很麻烦，需要10-30天 备案完成后，域名就可以使用了 我们需要去修改我们的nginx配置，将server_name的值修改为需要绑定的域名即可； 1234server &#123; listen 3006; server_name xxx.com;// .... 增加https支持 申请一个https证书，数字证书管理，以阿里云为例子，国内云厂商都有 将证书放在服务器中你可以记得住的文件夹里面 修改nginx配置 12345678910111213141516171819202122232425server &#123; // # 将当前域名的http自动打到https listen 80; server_name xxx.com; rewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123; listen 443 ssl http2; server_name xxx.com; ssl_certificate xxxx/yy.pem; # 证书 ssl_certificate_key xxxx/yy.key; # 证书秘钥 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; root /usr/share/nginx/client; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 结语​ 虽然部署一个站点，仅仅是用到nginx，但是涉及到的知识点还是很多的 ​ 如果遇到了错误，一定要仔细检查报错信息，问题百度百度基本都能得到答案，如果实在搞不定，直接重做云服务器系统，重头再来；遇到问题并把它解决了，便成了你的技能 ​ 一个有经验的开发人员部署一个站点，可能半小时就弄完了，想要熟练的话，一定要多练习多实践，从0到1部署一个项目还是一件很酷的事情！ 如果搭建中遇到了解决不了的问题，请到QQ群 530496237，大佬解答疑惑~","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"浏览器读取xls并生成二维码下载到本地","slug":"浏览器读取xls生成二维码并下载","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:04.591Z","comments":true,"path":"2022/03/15/浏览器读取xls生成二维码并下载/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96xls%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"需求一次普通的技术需求会议 ​ 项目经理首先发言 我们技术这边需要将xls表格中的几千条数据变成二维码，并且中间镶嵌logo，图片底部放置编号，由于xls表格数据私密，不能通过第三方完成 ​ 平常这个事情都是后端处理的，前端就是来摸鱼的，但是这次一反常态，后端脸黑了，带样式搞不来，脚一蹬，直接装死 ​ 项目经理用期盼的眼神看着我，顿时我紧张了起来，眼神飘忽，我已经好多年没搞过node了啊！！会议室都沉默了，在项目经理不断精神攻击下，后端装死的情况下，看来注定要大前端来拯救世界了，毕竟JavaScript万能语言，俺来试试吧！ 实现方案​ 以上情节纯属虚构，但是需求确实是这样的，虽然好几年没碰过node，好歹年轻记性好，用过的基本都还记得，调研实现方案上没出现太多问题，有如下方案 puppeteer地址：https://github.com/puppeteer/puppeteer ​ 使用基于node环境的puppeteer，进行二维码绘制，图片绘制，是JavaScript开发者面对此类需求的主流选择 node-canvas地址：https://github.com/Automattic/node-canvas ​ 同样是在服务端完成渲染，但是这个库依赖node-gyp，如果不安装python2，那安装过程懂得都懂，不过这也是很不错的方案 浏览器​ 通过浏览器canvas绘制，然后下载下来，会有刷刷刷下载图片的炫酷效果 很明显有刷刷刷下载图片炫酷效果的方案更好，所以就选择你了 浏览器方案！ 问题分解确定了技术方案，就要考虑具体实现了 JavaScript读取execl文件，并处理成理想格式 将读取到的execl中的网址字段生成一张二维码 将二维码写入canvas，在其中间加上logo，并在底部加一行文字 将canva转化为DataURL，下载它 不断递归生成，直到xls数据全部处理完毕 理论存在，实践开始！ 具体实现启动一个本地服务器首先我们通过VScode Live Server 启动一个本地服务器 这里有好奇宝宝要问了，为啥第一步是这？ 答：因为浏览器是访问不了电脑的文件系统的，所以只能通过启动一个本地服务器的方案，来读取我们的资源文件 创建html，引入资源库分析需要用到的第三方开源库 解析xls https://github.com/sheetjs/sheetjs 生成QRcode https://github.com/soldair/node-qrcode 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生成二维码&lt;/title&gt; &lt;script src=&quot;./qrcode.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./xlsx.full.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 用于生成载体 最终生成的图片大小，按自己的需求来 --&gt; &lt;canvas width=&quot;260&quot; height=&quot;310&quot; id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; const ctx = initCanvas(); // 获取ctx实例 // 初始化画布 function initCanvas() &#123; const canvas = document.getElementById(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); return ctx; &#125; &lt;/script&gt;&lt;/html&gt; 解析xls文件1234567891011121314151617181920212223242526272829303132333435363738readWorkbookFromRemoteFile().then((res) =&gt; &#123; // res 为实际解析代码 [&#123;key:&#x27;xxxx&#x27;,value:&#x27;xxxx&#x27;&#125;,....]&#125;);// 读取xls信息，并处理function readWorkbookFromRemoteFile() &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;http://127.0.0.1:5500/xls.xls&quot;, true); xhr.responseType = &quot;arraybuffer&quot;; xhr.onload = (e) =&gt; &#123; if (xhr.status == 200) &#123; var data = new Uint8Array(xhr.response); var workbook = XLSX.read(data, &#123; type: &quot;array&quot; &#125;); // 获取实际表格长度（去除表头） let carryLen = 0; for (const key in workbook.Sheets[&quot;Sheet&quot;]) &#123; const ele = workbook.Sheets[&quot;Sheet&quot;][key]; if (key.includes(&quot;A&quot;)) &#123; carryLen++; &#125; &#125; // 解析数据 let xls = []; for (let i = 2; i &lt;= carryLen; i++) &#123; let data = workbook.Sheets[&quot;Sheet&quot;]; xls.push(&#123; key: data[&quot;A&quot; + i].w, value: data[&quot;B&quot; + i].w, &#125;); &#125; resolve(xls); &#125; &#125;; xhr.send(); &#125;);&#125; 看到这里肯定也有细心的好奇宝宝问，为啥循环体中的i为2呢? 答案：因为表格中的A1，B1为表格的第一行，而第一行是表头，要去除 将链接生成为二维码12345678910111213141516171819new Promise((resolve, reject) =&gt; &#123; // 生成二维码 QRCode.toDataURL( &#x27;xxxxxxx&#x27;, &#123; width: 260, height: 260, margin: 3, &#125;, (error, url) =&gt; &#123; if (error) console.error(error); const code = new Image(); code.src = url; code.onload = () =&gt; &#123; ctx.drawImage(code, 0, 0); resolve(code); &#125;; &#125; ); 写入中间logo12345678return new Promise((resolve, reject) =&gt; &#123; const code = new Image(); code.src = &quot;http://127.0.0.1:5500/logo.jpeg&quot;; code.onload = () =&gt; &#123; ctx.drawImage(code, 260 / 2 - 20, 260 / 2 - 20, 40, 40); resolve(); &#125;;&#125;); 写入底部文字123456// 写入编号ctx.font = &quot;24px Arial&quot;;ctx.fillStyle = &quot;#000&quot;;ctx.textAlign = &quot;center&quot;;ctx.textBaseline = &quot;middle&quot;;ctx.fillText(xls[index].value, 130, 270); canvas转化为图片，并下载到本地1234567// 用于预览let url = document.getElementById(&quot;canvas&quot;).toDataURL(&quot;image/png&quot;);var a = document.createElement(&quot;a&quot;); // 生成一个a元素var event = new MouseEvent(&quot;click&quot;); // 创建一个单击事件a.download = xls[index].value; // 将a的download属性设置为我们想要下载的图片名称，若name不存在则使用‘下载图片名称’作为默认名称a.href = url; // 将生成的URL设置为a.href属性a.dispatchEvent(event); // 触发a的单击事件 第一张图片，完成生成 递归调用我们修改发起逻辑代码，逻辑尾部增加递归调用就好啦 12345678910111213141516171819202122232425262728readWorkbookFromRemoteFile().then((res) =&gt; &#123; createImg(res, 0); // 递归生成&#125;);// ......// 实际生成逻辑function createImg(xls, index) &#123; new Promise((resolve, reject) =&gt; &#123; // 生成二维码 &#125;) .then((res) =&gt; &#123; // 生成中间logo &#125;) .then(() =&gt; &#123; // 写入编号 &#125;) .then(() =&gt; &#123; // 下载图片 &#125;) .then(() =&gt; &#123; setTimeout(() =&gt; &#123; if (xls.length &gt; index + 1) &#123; ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, 260, 310); // 初始化画布 createImg(xls, index + 1); &#125; &#125;, 20); // 爱惜机器，加个延时，也可以去掉延时，体会机器的极致速度 &#125;);&#125; 最终效果 至此，终于实现了刷刷刷下载图片炫酷效果，此时可以脑部一段很快的rap，如果华佗再世，崇洋可以医治，外邦来学汉字…………… 最终生成的文件 最终代码地址 一定要针对该项目启动一个本地服务器，否则资源无法访问 web-Output-QRcode 结语​ 首先纠正一点，JavaScript开发者针对生成二维码类似的任务，首选肯定是puppeteer，使用浏览器绕个弯这种实现方案，多少带点科研味道，长期项目自然是不推荐的 ​ 带着学习的态度去完成需求，并且不断优化代码、总结问题，将遇到的未知知识点学会，（比如创建a链接，自动触发点击事件），这才是本文的目的。 ​ 感谢阅读，觉得还不错就点个赞吧~ ​ QQ交流群：530496237 大佬解答疑惑~（内有微信群二维码） ​","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"三个案例带你理解Event Loop流程","slug":"聊一聊宏任务与微任务以及EventLoop","date":"2022-03-14T16:00:00.000Z","updated":"2022-05-23T08:02:01.480Z","comments":true,"path":"2022/03/15/聊一聊宏任务与微任务以及EventLoop/","link":"","permalink":"https://vkcyan.github.io/2022/03/15/%E8%81%8A%E4%B8%80%E8%81%8A%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEventLoop/","excerpt":"","text":"为什么 JavaScript 需要 Event Loop JavaScript 在创建之初就确认了一点，JavaScript 是一门单线程语言，因为 JavaScript 主要提供用户互动以及操作 DOM，假定存在两个线程，同时对一个 Dom 进行操作，那究竟以谁为准呢，为了避免这种复杂性，JavaScript 确认了单线程这个核心概念 在单线程中，除了 JavaScript 本身的逻辑之外，还存在一些 IO 操作，例如从服务端获取数据，在单线程中就需要等待结果的返回才能继续下面的逻辑，这时候机器是挂起状态，为了避免这个低效问题，这里就引入了同步任务与异步任务的概念，依旧是是单线程，但是有些任务不等待其运行结果 于是同步任务都在函数执行栈（Stack）上执行，所有的异步任务，在有了运行结果之后，就会将其放入任务队列（callback queue），如果 Stack 中任务执行完毕，就会再去检查任务队列是否存在待执行的回调任务，将其任务放入 Stack，再执行，这里就会不断循环此操作 Stack 执行 - Stack 执行完毕 - 检查任务队列 - 将任务加入 Stack - Stack 执行，这样重复的过程就需要 Event Loop 来持续不断的循环检查任务队列，确保异步任务被准时加入到 Stack 相关名词介绍函数执行栈（Stask）：遵循后进先出原则，同步函数执行栈 webAPIs：异步任务的发起者，事件是首先进入 stack，例如 click，change，再将 callback 加入任务队列 回调队列（callback queue）：也可以被称为任务队列，回调函数到达了执行时机就会进入任务队列，他们将会被 Event Loop 持续打入函数执行栈 事件循环解析我们用 Event Loop 来解释一个简单的 demo 1234567consoleo.log(&quot;1&quot;);setTimeout(() =&gt; &#123; console.log(&quot;2&quot;);&#125;, 5000);console.log(&quot;3&quot;); 我相信大部分人都知道，这里打印的顺序为 1 3 2，下面我们用事件循环的流程来说明为什么是这个结果 注： cb 为 callback console.log(&#39;hi&#39;)，进栈 执行 出栈，打印 1 setTimeout进栈 执行 cb 加入异步队列 自身出栈 console.log(&#39;end&#39;)，进栈 执行 出栈 打印 3 5s 后，cb 加入任务队列，event Loop 检查当前执行栈是否存在函数，检查发现不存在，将 cb 加入函数执行栈 cb进栈 执行 出栈 打印 2 我们通过 event Loop 的角度进行解析，就能很轻易的解释为什么代码执行顺序是 1 3 2，这是非常简单的场景，接下来我们会分析一些更加有难度的代码 关于宏任务与微任务 通过上面的介绍，我相信大部分人都事件循环有一个基础的认知的，但是与以上我们通过简单的示例，演示了异步代码在事件循环中的运行流程，并没有涉及宏任务与微任务，这两货是什么呢，为什么要在这里出现？ 首先，宏任务（macrotask），微任务（microtask）都是异步任务 宏任务：setTimeout setInterval setImmediate I/O 键盘事件 网络事件 UI rendering 微任务：pormise MutationObserver process.nextTick 他们在执行层面上存在一定差异 例子 1123456789101112131415console.log(&quot;script start&quot;);setTimeout(function () &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);Promise.resolve() .then(function () &#123; console.log(&quot;promise1&quot;); &#125;) .then(function () &#123; console.log(&quot;promise2&quot;); &#125;);console.log(&quot;script end&quot;); 结果为 script start script end promise1 promise2 setTimeout pormise 与 setTimeout 虽然都是异步任务，但是上图的代码你会发现，promise 仿佛插队了，这便是宏任务与微任务在任务队列最大的不同之处 event Loop 在事件循环中,首先解析 script，将宏任务加入宏任务队列，将微任务加入微任务队列，栈空了之后，执行当前微任务，第一轮事件循环结束 在第二轮事件循环中，首先执行宏任务 callback 中的第一个，执行完毕，栈空了之后，再执行当前微任务，后面同理 例子 212345678910111213141516171819202122232425console.log(&quot;a&quot;);setTimeout(() =&gt; &#123; console.log(&quot;b&quot;); setTimeout(() =&gt; &#123; console.log(&quot;g&quot;); &#125;, 0); new Promise((resolve) =&gt; &#123; resolve(); &#125;).then(() =&gt; &#123; console.log(&quot;h&quot;); &#125;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&quot;c&quot;); resolve();&#125;) .then(function () &#123; console.log(&quot;d&quot;); &#125;) .then(function () &#123; console.log(&quot;e&quot;); &#125;);console.log(&quot;f&quot;); 大家可以先别看答案，自己先尝试将答案推算出来 第一轮事件循环console.log(&quot;a&quot;);进入栈 执行 出栈 打印 a setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 console.log(&quot;c&quot;);进入栈 执行 出栈 打印 c new Promise.then 进入微任务队列 console.log(&quot;f&quot;);进入栈 执行 出栈 打印 f new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;d&quot;)进入栈 执行 出栈 打印 d console.log(&quot;e&quot;)进入栈 执行 出栈 打印 e –微任务执行完毕 第一轮事件循环完毕– 结果为 a c f d e 第二轮事件循环第一轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;b&quot;) 进入栈 执行 出栈 打印 b setTimeout进入栈 callback 加入宏任务队列 本身出栈 new Promise 进入栈 执行 new Promise.then 进入微任务队列 new Promise 出栈 —宏任务完毕，开始执行微任务— console.log(&quot;h&quot;)进入栈 执行 出栈 打印 h –微任务执行完毕 第二轮事件循环完毕– 结果为 b h 第三轮事件循环第二轮循环中 setTimeout 在宏任务中，开始执行 console.log(&quot;g&quot;);进入栈 执行 出栈 打印 g —宏任务完毕，开始执行微任务— –微任务队列为空 第三轮事件循环完毕– 结果为 g 结果a c f d e b h g 宏&#x2F;微任务的结论通过上面三个例子，我们可以得出以下结论 函数执行栈中如果还存在函数，则等待其结束，才会继续事件循环 Event Loop 先执行同步任务，再微任务，下一轮循环，宏任务加入队列，执行，所以说先微任务，再宏任务是合理的 单次 Event Loop 中，只会执行一次宏任务，但是微任务可以一次执行多个 推荐文章做一些动图，学习一下 EventLoop 通过动图看 Event Loop 更加便于理解 总结 JavaScript 单线程语言的特性注定其需要异步队列，让网页交互体验上更加友好，对于开发来说，需要尽量了解其特性 首先我们需要了解事件循环机制，搞懂代码执行栈 异步队列的概念，再后面搞懂宏任务与微任务，读懂异步队列的运行机制，这样基本上就可以解决大部分 Event Loop 问题，了解宏任务 微任务 将会对代码执行顺序有更加底层的理解，这样就可以解决","categories":[{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"基于PromiseA+，从零实现Promise","slug":"promise的源码解读","date":"2021-12-14T16:00:00.000Z","updated":"2022-05-23T08:22:14.257Z","comments":true,"path":"2021/12/15/promise的源码解读/","link":"","permalink":"https://vkcyan.github.io/2021/12/15/promise%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"ECMAScript6中promise是划时代的API，他的出现解决了一直困扰前端开发者的异步问题，从此面对异步回调，我们有了更好的武器 前言​ 面对天天都能见面的promise，不知道你是否有以下的一些问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 为什么resolve之后才会执行then或者catch？ 为什么可以链式.then，并且还都会按同步进行？ 为什么执行promise.resolve()，后面的函数就支持promise了？ promise.all是如何实现的？ 是否被面试题中的promise题目迷惑的头晕目眩？ 让我们了解Promise的实现原理，所有问题答案自然浮出水面~ ​ promise在潜移默化之间帮助我们简化了复杂的异步代码，降低逻辑难度，说promise是划时代的异步解决方案也不为过，他很好的提现了开放封闭原则，解决耦合性过高的问题 ​ 说一个小知识，es6发布之前类似prmise的异步方案已经存在，在jquery的ajax中已经应用了类似的技术方案的jQuery.deferred()，感兴趣的同学可以去了解一下 123$.ajax(&quot;test.html&quot;).done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;).fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 简化版Primise 基础版本的实现虽然简单，但是解释了很多问题 建议将代码复制到本地，通过断点的方式查看代码的执行流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const PEDDING = &#x27;pending&#x27; // 等待状态const FULFILLED = &#x27;fulfilled&#x27; // 成功状态const REJECTED = &#x27;rejected&#x27; // 失败状态class APromise &#123; constructor(executor) &#123; this.status = PEDDING // 初始化状态 this.value = undefined // 成功的数据 this.reason = undefined // 失败的原因 this.onFulfilledCallbacks = [] // 保存成功状态的回调队列 this.onRejectCallbacks = [] // 保存失败状态的回调队列 const resolve = (data) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = FULFILLED this.value = data &#125; this.onFulfilledCallbacks.map((e) =&gt; e()) &#125; const reject = (err) =&gt; &#123; if (this.status == PEDDING) &#123; this.status = REJECTED this.reason = err &#125; this.onRejectCallbacks.map((e) =&gt; e()) &#125; try &#123; executor(resolve, reject) &#125; catch (error) &#123; rejected(error) &#125; &#125; then(onFulfilled, onRejected) &#123; if (this.status == FULFILLED) &#123; onFulfilled(this.value) &#125; if (this.status == REJECTED) &#123; onRejected(this.reason) &#125; if (this.status == PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(this.value) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; &#125;&#125;new APromise((resolve, reject) =&gt; &#123; console.log(&#x27;开始回调&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;执行回调&#x27;) resolve(11111) &#125;, 1000)&#125;).then( (value) =&gt; &#123; console.log(&#x27;成功回调&#x27;, value) &#125;, (err) =&gt; &#123; console.log(&#x27;失败回调&#x27;, err) &#125;) 代码运行流程 初始化APromise，开始执行class中的constructor 在constructor中初始化当前promise的一些状态值以及resolve，reject函数 最后将resolve函数与reject函数以参数的形式给promise的回调函数，同时执行函数，打印开始回调 运行setTimeout，并且开始解析then函数 如果是成功，或者失败状态，直接执行回调，如果是pedding状态，则存储成功与失败回调函数 1s之后，setTimeout执行完毕，resolve执行触发constructor中的resolve resolve函数中执行之前初始化.then时候存储的回调函数，打印 成功回调，11111或者失败回调 逻辑流程图 基础版本的实现，不支持链式调用，不支持then穿透，不支持catch，只实现了最基础的逻辑 我们在这里解答一下前言中提出的问题 我们new Promise((resolve,reject) &#x3D;&gt;{})，resolve，reject都是哪来的？ 答：new的时候执行Promise中的constructor，声明了resolve与reject，并且在执行Promise回调函数的时候将参数传入到函数中 为什么resolve之后才会执行then或者catch？ 答：因为在初始化阶段，pedding状态下，我们存储了当前Promise的成功与失败回调，当执行resolve的时候，当前Promise的状态发生变化，开始执行之前存储的回调函数，如果不是padding，则立即执行回调函数 后面的问题我们暂时还无法解释，但是随着我们进一步的实现，答案都会浮出水面 正式版（链式回调，then值穿透，.catch 等）链式回调​ 我们一般写promise都会写多个.then，在多个.then中我们将异步代码变成同步代码块，但是我们基础版本的promise中无法显示链式调用，因为执行.then之后函数没有任何返回值，自然不会存在.then方法，在这个思路上，我们对promise的.then解析过程进行改写,尝试让其支持链式调用 每次.then中都需要返回一个promise来触发下一个.then 对then回调函数的各种情况需要进行判断，例如。then中返回的是一个string还是返回了一个promise，如果是则需要增加链式回调触发父级的resolve then函数执行需要通过settimeout进行包裹，让其加入宏任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * then可能返回的是普通值,也可能返回一个promise，这里的写法参照PromiseA+标准进行完成 * 逻辑较为复杂，可以先看静态变量代码逻辑，再看针对promise的处理逻辑 * @param &#123;*&#125; promise 当前promise * @param &#123;*&#125; x 当前返回值 * @param &#123;*&#125; resolve 成功回调 * @param &#123;*&#125; reject 失败回调 */const resolvePromise = (promise, x, resolve, reject) =&gt; &#123; if (promise === x) &#123; return reject(new TypeError(&#x27;检测到promise的循环调用&#x27;)) // &#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27; &#125; let called = false if ((typeof x === &#x27;object&#x27; &amp;&amp; x !== null) || typeof x === &#x27;function&#x27;) &#123; try &#123; const then = x.then if (typeof then === &#x27;function&#x27;) &#123; then.call( x, (y) =&gt; &#123; if (called) return called = true resolvePromise(promise, y, resolve, reject) &#125;, (r) =&gt; &#123; if (called) return called = true reject(r) &#125; ) &#125; else &#123; resolve(x) &#125; &#125; catch (err) &#123; if (called) return called = true reject(err) &#125; &#125; else &#123; resolve(x) &#125;&#125;then(onFulfilled, onRejected) &#123; let apromise = new APromise((resolve, reject) =&gt; &#123; if (this.status === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125; if (this.status === PEDDING) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) this.onRejectCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.reason) resolvePromise(apromise, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;, 0) &#125;) &#125; &#125;) return apromise&#125; 经过上面的内部promise处理，函数的运行逻辑发生了很大的变化 我们直观看到的逻辑是 ​ 实际的运行逻辑是每次.then中都会再次创建一个Promise，以便于下次进行调用，并且对.then的回调函数进行处理，区分.then中返回了Promise对象还是普通对象，这样的思路实现了.then链式调用 当then中存在return promise的情况，逻辑会发生一些变化，这些主要体现在resolvePromise函数中 then值穿透首先查看一种场景 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then() .then() .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) ​ 这里我们就会发现，then的回调函数都不存在，自然无法将resolve的值传递到最下面的.then中，所以这里我们需要对这种情况做一些处理 123456789then(onFulfilled, onRejected) &#123; // 值穿透问题 如果then是空的话,就手动的将上一个resolve的值带入到下一个then中 onFulfilled = typeof onFulfilled == &#x27;function&#x27; ? onFulfilled : (data) =&gt; data onRejected = typeof onRejected == &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err &#125; let apromise = new APromise((resolve, reject) =&gt; &#123; // .... &#125;) return apromise&#125; 当我们对then值中的回调函数进行处理后，实际运行的函数变成 12345678910new APromise((resolve, reject) =&gt; &#123; resolve(11111);&#125;) .then((data) =&gt; data) .then((data) =&gt; data) .then(data =&gt; &#123; console.log(&#x27;成功回调&#x27;, data); &#125;, err =&gt; &#123; console.log(&#x27;失败回调&#x27;, err); &#125;) 这样便实现了then穿透问题 .catch目前我们错误回调在.then的第二个参数中，并不支持.catch的写法，我们可以在原型链上面增加catch方法 catch其实也是对.then方法的封装，只不过不存在成功回调，只有失败回调 123APromise.prototype.catch = function (errCallback) &#123; return this.then(null, errCallback)&#125; .finally 由于finally无法预知promise的最终状态，所以finally的回调函数中不接受任何参数，他仅用于无论最终结果都要执行的情况 需要注意的一点是如果finally中存在Promise，这需要等待promise执行完毕 123456789101112APromise.prototype.finally = function (callBack) &#123; return this.then( (data) =&gt; &#123; return APromise.resolve(callBack()).then(() =&gt; data) &#125;, (err) =&gt; &#123; return APromise.reject(callBack()).then(() =&gt; &#123; throw err &#125;) &#125; )&#125; 关于finally的小知识123Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 此时传递下去的是undefinedPromise.resolve(2).finally(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;) // 传递下去的是 2，finally本身未接收参数，但是将上次的回调数据放入到了下次的回调 Promise.resolve() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回成功回调 12345APromise.resolve = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; resolve(data) &#125;)&#125; Promise.reject() 调用Promise.resolve()就会返回一个真实的promise，并且直接返回失败回调 12345APromise.reject = function (data) &#123; return new APromise((resolve, reject) =&gt; &#123; reject(data) &#125;)&#125; Promise.race() 当调用race方法的时候，必须传入一个数组，数组中可以存在不同类型以及函数类型，在初始化过程中会再次创建一个promise，当数组中的某个promise对象最先执行的时候，触发自身的.then在回调函数中触发了race本身的resolve，后面执行完毕之后，因为race的状态已经发生了变化，自然无法再执行 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 同时执行多个promise,但是最返回最先返回的结果 * @param &#123;*&#125; promiseList * @returns */APromise.race = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须传递数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; promiseList.forEach((item) =&gt; &#123; if (item &amp;&amp; typeof item.then == &#x27;function&#x27;) &#123; item.then(resolve, reject) &#125; else &#123; resolve(item) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;ok2&#x27;) &#125;, 2000)&#125;)APromise.race([1, p1, p2]).then( (data) =&gt; &#123; console.log(&#x27;success1&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error1&#x27;, err) &#125;) Promise.all() all的实现逻辑非常简单，all的时候创建一个promise，内部记录当前传入的列表状态成功的单个数据，当所有的then数据都成功，调用自己的resolve，当有一个失败的时候，调用自己的reject 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 同时执行多个promise,会等待每次promise的结果,最后一起返回,有一个失败,这都不会返回 * @param &#123;&#125; promiseList * @returns */APromise.all = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resulteArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (key, val) =&gt; &#123; resulteArr[key] = val if (++currentIndex == len) &#123; resolve(resulteArr) &#125; &#125; for (let i = 0; i &lt; len; i++) &#123; const val = promiseList[i] if (val &amp;&amp; typeof val.then === &#x27;function&#x27;) &#123; val.then((data) =&gt; &#123; getResult(i, data) &#125;, reject) &#125; else &#123; getResult(i, val) &#125; &#125; &#125;)&#125;let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;); &#125;, 1000);&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;); &#125;, 2000);&#125;)Promise.all([1,2,3,p1,p2]).then(data =&gt; &#123; console.log(&#x27;success&#x27;, data);&#125;, err =&gt; &#123; console.log(&#x27;error&#x27;, err);&#125;) Promise.any() 实现方法与all非常相似，是all完全相反的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * any与all完全相反,只要有个一个成功就会返回成功,全部失败才会返回失败 * @param &#123;*&#125; promiseList * @returns */APromise.any = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, err) =&gt; &#123; resultArr[index] = err if (++currentIndex == len) &#123; reject(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then(resolve, (err) =&gt; &#123; getResult(index, err) &#125;) &#125; else &#123; resolve(res) &#125; &#125;) &#125;)&#125;let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.any([p3, p4]).then( (data) =&gt; &#123; console.log(&#x27;success&#x27;, data) &#125;, (err) =&gt; &#123; console.log(&#x27;error&#x27;, err) &#125;) Promise.allSettled() allSettled是ES2020加入的工具方法，一句话总结：他是永远都不会失败处理的promise.all 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 保存所有的成功与失败 * @param &#123;*&#125; promiseList * @returns */APromise.allSettled = function (promiseList) &#123; if (!Array.isArray(promiseList)) &#123; throw new TypeError(&#x27;必须是数组&#x27;) &#125; return new APromise((resolve, reject) =&gt; &#123; const resultArr = [] const len = promiseList.length let currentIndex = 0 const getResult = (index, data, status) =&gt; &#123; if (status == FULFILLED) &#123; resultArr.push(&#123; status: status, value: data, &#125;) &#125; if (status == REJECTED) &#123; resultArr.push(&#123; status: status, reason: data, &#125;) &#125; if (++currentIndex == len) &#123; resolve(resultArr) &#125; &#125; promiseList.map((res, index) =&gt; &#123; if (res &amp;&amp; typeof res.then == &#x27;function&#x27;) &#123; res.then( (data) =&gt; &#123; getResult(index, data, FULFILLED) &#125;, (err) =&gt; &#123; getResult(index, err, REJECTED) &#125; ) &#125; else &#123; getResult(index, res, FULFILLED) &#125; &#125;) &#125;)&#125;let p1 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok1&#x27;) &#125;, 3000)&#125;)let p2 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok2&#x27;) &#125;, 2000)&#125;)let p3 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err3&#x27;) &#125;, 1000)&#125;)let p4 = new APromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err4&#x27;) &#125;, 2000)&#125;)APromise.allSettled([1, 2, 3, p1, p2, p3, p4]).then((res) =&gt; &#123; console.log(&#x27;success&#x27;, res)&#125;) 测试函数首先需要安装测试脚本 npm install -g promises-aplus-tests 测试命令 promises-aplus-tests xxxx.js 测试文件末尾需要加入如下代码 不存在错误则为符合promiseA+标准 12345678910APromise.defer = APromise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new APromise((resolve, reject) =&gt; &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd&#125;module.exports = APromise 源码地址github-promise 可以通过chrome DevTool或者Vscode Debug的方式，加上断点，查看代码运行流程，便于理解promise运行逻辑 参考链接重学Promise，基于A+规范实现它，感谢掘金@关er的promise解读文章，大大降低了深入promise的门槛 PromiseA+规范 MDN-Promise 45道Promise面试题","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"简易版Reactivity源码解析","slug":"简易版Reactivity源码解析","date":"2021-11-30T16:00:00.000Z","updated":"2022-05-23T08:17:48.866Z","comments":true,"path":"2021/12/01/简易版Reactivity源码解析/","link":"","permalink":"https://vkcyan.github.io/2021/12/01/%E7%AE%80%E6%98%93%E7%89%88Reactivity%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言​ 首先感谢__mxin同学的简易版本，没有这个简化版本，我大概率也没办法沉下心来将代码读下去，再次表示感谢，通读下来简化之后的逻辑清晰，只需要对几个JavaScript原生API进行了解，走完代码流程，便了解了核心流程 代码地址：传送门 前置知识Proxy Reflect WeakMap 核心流程图​ 尝试绘制了一遍代码流程图，主要流程就是初始化时候对reactive，computed，effect的依赖收集，以及在触发set事件的时候，对收集到的依赖的触发 reactive123456789const object = &#123; r: 0, g: 0, b: 0, o: &#123; a: 1, &#125;, &#125; const proxy = reactive(object) ​ reactive是一个赋予对象响应式特征的方法，传入的数据会被proxy代理，变量一旦被代理，就将会被加入reactiveMap，以后都会触发reactiveMap内的proxy 12345678910111213141516171819202122232425262728/** * 定义响应式对象，返回proxy代理对象 * @param &#123;*&#125; object */function reactive(object) &#123;// 判断是否已经代理，已经存在直接取自 if (reactiveMap.has(object)) return reactiveMap.get(object) // 第一次进行处理，进行proxy代理 const proxy = new Proxy(object, &#123; // 处理器对象，定义捕获器 get(target, key) &#123; console.log(&#x27;get方法&#x27;, target, key) // 针对effect，computed依赖进行处理 track(target, key) // 如果当前代理的值为object类型，将会对当前的值再次进行proxy,否则直接获取数据 return typeof target[key] === &#x27;object&#x27; ? reactive(target[key]) : Reflect.get(...arguments) &#125;, set(target, key) &#123; console.log(&#x27;设置的值&#x27;, ...arguments) // 在set事件中对原本的数据进行修改 Reflect.set(...arguments) // trigger(target, key) &#125;, &#125;) reactiveMap.set(object, proxy) return proxy&#125; 完成代理的数据 effect effect会在依赖的经过reactive处理后的对象发生变化的时候，自动执行一次回调函数，通常称它为副作用函数 effect的实现是Reactivity最核心的部分，也是比较难理解的部分，依赖WeakMap进行实现，如果不了解WeakMap，务必先去看一下文档 1234567const computedObj = computed(() =&gt; &#123; return proxy.r * 2&#125;)effect(() =&gt; &#123; console.log(`proxy.o.a: $&#123;proxy.o.a&#125;`)&#125;) 初始化的过程中触发effect，将函数fn放入effectStack，同时执行effect中的函数，一旦执行，必定会触发经过reactive代理的get函数，进行数据获取 123456789101112131415161718192021222324252627282930313233343536373839404142const effectStack = [] // 收集副作用函数/** * 副作用函数 */function effect(fn) &#123; try &#123; // 将需要执行的effect入栈 effectStack.push(fn) // **** 执行该effect，进入proxy的get拦截 **** return fn() &#125; finally &#123; // 依赖收集完毕及所有get流程走完，当前effect出栈 effectStack.pop() &#125;&#125;// ......// get方法触发了track方法get(target, key) &#123; // .... track(target, key) // ....&#125;/** * 依赖收集 */function track(target, key) &#123; // 初始化依赖Map let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; // 第二层依赖使用Set存放key对应的effect let dep = depsMap.get(key) if (!dep) &#123; targetMap.get(target).set(key, (dep = new Set())) &#125; // 取当前栈中的effect存入第二层依赖中 const activeEffect = effectStack[effectStack.length - 1] activeEffect &amp;&amp; dep.add(activeEffect) // 最后触发effect函数的finally，将处理完毕的effect进行弹出，完成依赖收集&#125; 初始化完成后，effect全部完成处理，我们可以看一下targetMap的数据 我们可以看到，变量a与effect中的函数关联在了一起，经过track处理后，effect内部用到的变量都与effect建立了某种关联，至此我们就完成了依赖收集 computedReactivity计算属性的实现是依赖effect进行实现，仅仅是增加了一个value函数进行包裹 12345678910/** * 计算属性 */function computed(fn) &#123; return &#123; get value() &#123; return effect(fn) &#125;, &#125;&#125; 变量发生变化数据发生变化的时候，例如我们将proxy.o.a&#x3D;1,他是如何完成响应式，以及effect的触发的呢？ 首先一定是触发proxy的set函数 123456789101112131415161718192021222324set(target, key) // 修改代理的值 Reflect.set(...arguments) // 等同于arguments[0][arguments[1]] = arguments[2] // 触发依赖收集器 trigger(target, key)&#125;, /** * 依赖收集触发器 */function trigger(target, key) &#123; // target: &#123;a:1&#125; key: a // 获取当前修改的值 const depMap = targetMap.get(target) // 开始执行effect方法 if (depMap) &#123; // 如果存在，开始寻找Map的value，在通过key找到对应的回调函数 const effects = depMap.get(key) effects &amp;&amp; effects.forEach((run) =&gt; &#123; // 执行收集的effect函数 run() &#125;) &#125;&#125; 至此完成数据的响应式，effect的函数触发完成 关键概念reactive 创建响应式对象 effect 副作用函数，存储匿名函数，同时调用自身收集依赖，最后弹出匿名函数 computed 计算属性，其原理是对effect的包装 track 收集依赖，绑定变量与使用该变量的effect trigger 触发依赖，根据变量触发对应的effect 总结​ 这个文章是一个代码记录贴，希望大家看到可以静下心来看看__mxin同学的文章，或者传送门代码，了解了基础的原理后再去看@vue&#x2F;Reactivity的代码，将会事半功倍； ​ 日积月累，将知识变成你的财富吧","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"React17学习记录","slug":"react17学习","date":"2021-10-14T16:00:00.000Z","updated":"2022-05-23T08:22:16.813Z","comments":true,"path":"2021/10/15/react17学习/","link":"","permalink":"https://vkcyan.github.io/2021/10/15/react17%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"为什么学习React17​ 公司使用的是vue技术栈，并且因为历史原因，以及外部因素，可能不会使用react来做生产环境的项目，最近vue3走上正轨，大家都需要抛弃vue2.x的编码思想，在vue3中，hook思想开始越发明显，所以学习react17也是想借此加深对hook的理解，同时取长补短，综合vue与react的优点，在实际的开发中更好的完成开发任务 useState的疑问​ 关于react的useState有一个疑问，useState里面是一个对象，我想要修改对象里面的某一个字段，每次都需要...state,把之前的数据预先填入，这做法感觉有点傻 自定义hookhook是在特定换下调用自己的代码 实现自定义hook必须使用关键字use开头，这是ESLint的规则 自定义hook一般用于需要持续监听的值，而针对纯工具函数则不需要进行处理 实现一个hook风格的防抖函数1234567891011121314151617181920212223242526const [param, setParam] = useState(&#x27;ha ha&#x27;);const debounceParam = useDebounce(param, 2000);useEffect(() =&gt; &#123; console.log(&#x27;log log&#x27;)&#125;, [debounceParam]);/** * 去抖函数 * @param value 监听的值 * @param delay 防抖时间 * @returns 变化后变量 */export function useDebounce(value, delay) &#123; // 声明一个保存防抖结果的字段 const [debounceValue, setDebounceValue] = useState(value); useEffect(() =&gt; &#123; // 每次value,delay发生变化的时候生成一个定时器 const timeout = setTimeout(() =&gt; &#123; setDebounceValue(value); &#125;, delay); // 在执行下一个useEffect之前,会执行上一个useEffect的返回函数 return () =&gt; clearTimeout(timeout); &#125;, [value, delay]); return debounceValue;&#125; useDebounce是一个hook风格的函数 每次param发生变化都会触发useDebounce中的useEffect 而在2000ms时间内如果重复触发就会执行上一个effect return的函数 进而不修改debounceValue，直到2000ms内无任何操作，触发setDebounceValue修改属性，改变了debounceParam 第一个useEffect触发，触发打印log log react中使用TS做代码静态检查 函数类型 fn: () =&gt; void any类型是危险的，应当尽量不用，但是对于模糊的类型，我们可以在标注类型为unknown，这样就不会对赋值做任何校验，但是ts不允许我们对unknown类型做出任何处理，所以可以吧unknown理解成为加强版any 针对参数不固定，返回值不确定的场景，应当使用泛型，在方法名称后面加,然后在参数上指定某一个为T，则T跟这参数的类型而变化 自定义hook useArray 传入一个hook，我们返回针对这个hook的可使用的对应方法，总体来说实现一个hook还是一个比较简单 1234567891011121314151617181920212223242526/** * hook处理的Array * @param value * @returns */export function useArray&lt;V&gt;(value: V[]) &#123; const [arrayValue, setArrayValue] = useState(value); const clear = () =&gt; &#123; setArrayValue([]); &#125;; const add = (value: V) =&gt; &#123; setArrayValue([...arrayValue, value]); &#125;; const removeIndex = (index: number) =&gt; &#123; let value = [...arrayValue]; value.splice(index, 1); setArrayValue(value); &#125;; return &#123; value: arrayValue, add, clear, removeIndex, &#125;;&#125; 关于TS中interface的属性继承123456789101112131415161718interface a &#123; a: number;&#125;interface b extends a &#123; b: number;&#125;let c: b = &#123; a: 1, b: 2,&#125;;function test(p: a) &#123; console.log(p);&#125;test(c); // 不会报错，因为b包含了a，所以这个传入b也不会出现错误 useContext useContext主要用于多个组件之间共享状态 在parent组件中存在child1.child2，child3组件，我们希望这些组件之前都共享一个状态1 生成createContext 1const TestContext = React.createContext(&#123;&#125;); 使用createContext.Provider包裹parent组件 1234567891011&lt;TestContext.Provider value=&#123;&#123; username: &#x27;我是变量&#x27;, &#125;&#125;&gt; &lt;div className=&quot;parent&quot;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;Child3 /&gt; &lt;/div&gt;&lt;TestContext.Provider/&gt; 在子组件中就可以使用useContext来获取父级创建的TestContext 12345678const Child1 = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext); return ( &lt;div className=&quot;child1&quot;&gt; &lt;p&gt;1 message for &#123;username&#125;&lt;/p&gt; &lt;/div&gt; )&#125; 通过useContext就可以做到子组件共享一个状态，如果状态被改变，所有使用变量的都放都会发生变化 TS类型的一些知识Parameters 获取函数的全部参数，并且以元祖类型进行返回,Utiltity Types 123456function test(a: string, b: number, c: number[], d: any) &#123;&#125;// 直接继承test函数的全部参数类型function testPlus(...[a, b, c, d]: Parameters&lt;typeof test&gt;) &#123; console.log(a, b, c, d);&#125; 联合类型12345678910111213141516let a:string | number; // 可以是多种类型// 抽象联合类型type aType:string | number;let a:aType// 也可以通过interface可以实现类型功能，但是指定单个类型是无法实现的，但是interface的全部功能type都可以实现// 例如：interface aaa &#123; a:string&#125;type aaa = &#123; a:string&#125;// 以上2种效果都是一致的 js的typeof与ts的typeof123// js: typeof runtime阶段运行 检查参数的类型// ts: typeof 静态检查阶段运行 识别函数的参数 Partial与Omit关键字123456789101112131415type Preson = &#123; name: string; age: String; sex: string;&#125;;// Partial关键字会将传入的类型处理成为非必填const xiaoMin: Partial&lt;Preson&gt; = &#123; age: &quot;非必填&quot;, name: &quot;非必填&quot;, sex: &quot;非必填&quot;,&#125;;// Omit 会删除第一个参数 类型 中的第二个参数中的变量 并返回结果 例如这里删除 name ageconst shenMiRen: Omit&lt;Preson, &quot;age&quot; | &quot;name&quot;&gt; = &#123; sex: &quot;男&quot; &#125;; 关于css一些不知道的关于remem表示相对于父级的font-size rem表示相对于根元素html的font-size 正常默认font-size为16px，那么1rem &#x3D;&#x3D;&#x3D; 16px 如果希望rem的比例自定义只需要将html的font-size设置为对应的百分就行，例如设置为62.5的时候1rem &#x3D;&#x3D;&#x3D; 10px 关于vhvh的全称为viewport height，100vh就是代表视口的高度 emotion emotion是一个css in js的方案，也就是使用js来写css代码，这样的话就可以在css中直接写逻辑 12345678910111213import styled from &quot;@emotion/styled&quot;;export const Row = styled.div&lt;&#123; gap: number;&#125;&gt;` display: flex; align-items: center; &gt; * &#123; margin-top: 0 !important; margin-bottom: 0 !important; margin-right: $&#123;(props) =&gt; `$&#123;props.gap&#125;rem`&#125;; &#125;`; 自定义hook useAsync的实现 useAsync可以理解为针对请求体再次封装，经过封装之后的请求体，自带请求进度，以及针对catch更加优雅的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; useState &#125; from &quot;react&quot;;interface State&lt;D&gt; &#123; error: Error | null; data: D | null; status: &quot;idle&quot; | &quot;loading&quot; | &quot;error&quot; | &quot;success&quot;;&#125;// 建立初始化的值const defaultState: State&lt;null&gt; = &#123; data: null, error: null, status: &quot;idle&quot;,&#125;;// 实现函数export const useAsync = &lt;D&gt;(initState?: State&lt;D&gt;) =&gt; &#123; // 默认状态 const [state, setState] = useState&lt;State&lt;D&gt;&gt;(&#123; ...defaultState, ...initState, &#125;); // 请求成功的调用 const setData = (data: D) =&gt; &#123; setState(&#123; data, status: &quot;success&quot;, error: null, &#125;); &#125;; // 请求失败的调用 const setError = (error: Error) =&gt; &#123; setState(&#123; data: null, error: error, status: &quot;error&quot;, &#125;); &#125;; // 请求开始的调用 const setLoading = () =&gt; &#123; setState(&#123; data: null, error: null, status: &quot;loading&quot;, &#125;); &#125;; // 对外实际执行的函数 const run = (promise: Promise&lt;D&gt;) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&quot;请传入 promise 类型数据&quot;); &#125; setLoading(); return promise .then((data) =&gt; &#123; setData(data); &#125;) .catch((err) =&gt; &#123; setError(err); &#125;); &#125;; return &#123; isIdle: state.status == &quot;idle&quot;, isLoading: state.status == &quot;loading&quot;, isError: state.status == &quot;error&quot;, isSuccess: state.status == &quot;success&quot;, run, setData, setLoading, setError, ...state, &#125;;&#125;; 使用阶段 12345678// 逻辑顶部应用相关逻辑 const projectData = useAsync&lt;any[]&gt;(); // 泛型为后台返回的数据的类型// 启动请求，传入请求体projectData.run(request);// 请求完成后，projectData中的数据状态会被同步更新let &#123; data, isLoading,isError,...other&#125; = projectData react中实现捕捉边界错误 关于错误边界的概念在react官网中是这样描述的，组件内的JavaScript错误会导致React的内部状态被破坏，并且在下一次的渲染时会产生可能无法追踪的错误，但是部分ui的JavaScript错误不应该导致整个应用的崩溃，所以react16中引入了错误边界的概念， 错误边界是一种react组件，最终组件可以捕获发生在其朱组件树任何位置的JavaScript错误，并打印错误，同时展示降级ui，而并不会渲染发生崩溃的子组件树，错误边界在渲染期间，生命周期方法和整个组件数的构造函数中捕获错误 123456789101112131415161718192021222324252627282930import React, &#123; ReactNode &#125; from &quot;react&quot;;type FallBackRender = (props: &#123; error: Error | null &#125;) =&gt; React.ReactElement;// 1 2 两种写法一致type Components1 = &#123; children: ReactNode; fallbackRender: FallBackRender &#125;;type Components2 = React.PropsWithChildren&lt;&#123; fallbackRender: FallBackRender &#125;&gt;;export class ErrorBoundary extends React.Component&lt; Components2, &#123; error: Error | null &#125;&gt; &#123; state = &#123; error: null, &#125;; // 当子组件抛出异常, state中的errir就会被调用 static getDerivedStateFromError(error: Error) &#123; return &#123; error &#125;; &#125; render() &#123; const &#123; error &#125; = this.state; const &#123; fallbackRender, children &#125; = this.props; if (error) &#123; console.log(&quot;错误执行&quot;, error); return fallbackRender(error); &#125; else &#123; return children; &#125; &#125;&#125; 使用App.tsx 123456789&lt;ErrorBoundary fallbackRender=&#123;fallPageErrorFallback&#125;&gt; &#123;user ? &lt;AuthenicatedApp /&gt; : &lt;UnAuthenicated /&gt;&#125;&lt;/ErrorBoundary&gt;// 发生错误的时候就会渲染这个domexport const fallPageErrorFallback = (&#123; error &#125;: &#123; error: Error | null &#125;) =&gt; ( &lt;p&gt;请求失败了,错误信息&#123;error&#125;&lt;/p&gt;); 阶段性结束 关于react hook的理念学习已经结束了，这段时间学习来看，确实react在很多方面更加易于理解，更加工程化，同时也学会了很多ts的知识，一直以来ts在我手中都是anyscript，本次学习让我对ts的运用更加熟练；在这个过程中也学会了很多hook相关的理念以及实例，并且可以带着这思想去优化项目代码 可惜我是一名vuer，继续学习react的实际编码，意义已经不是很大，所以关于这个课程的学习，本次告一段落；通过本次学习，非常深刻的体会到了hook的优雅，后面会深入学习vue3，在vue3中将hook与业务结合，让代码更加健壮","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"JS文件格式相互转换","slug":"JavaScript 文件格式互转","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:22:06.432Z","comments":true,"path":"2021/06/15/JavaScript 文件格式互转/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/JavaScript%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%92%E8%BD%AC/","excerpt":"","text":"base64 转 File1234567891011121314151617181920/** * base64转file文件 * @param dataurl * @param filename * @returns */ export function dataURLtoFile(dataurl: string, filename: string) &#123; // 获取到base64编码 const arr = dataurl.split(&#x27;,&#x27;) // 将base64编码转为字符串 const bstr = window.atob(arr[1]) let n = bstr.length const u8arr = new Uint8Array(n) // 创建初始化为0的，包含length个元素的无符号整型数组 while (n--) &#123; u8arr[n] = bstr.charCodeAt(n) &#125; return new File([u8arr], filename, &#123; type: &#x27;image/jpeg&#x27;, &#125;)&#125; base64 转 blob12345678910111213141516/** * base64转blob文件 * @param dataURI * @returns */export function dataURItoBlob(dataURI) &#123; var mimeString = dataURI.split(&#x27;,&#x27;)[0].split(&#x27;:&#x27;)[1].split(&#x27;;&#x27;)[0] // mime类型 var byteString = atob(dataURI.split(&#x27;,&#x27;)[1]) //base64 解码 var arrayBuffer = new ArrayBuffer(byteString.length) //创建缓冲数组 var intArray = new Uint8Array(arrayBuffer) //创建视图 for (var i = 0; i &lt; byteString.length; i++) &#123; intArray[i] = byteString.charCodeAt(i) &#125; return new Blob([intArray], &#123; type: mimeString &#125;)&#125; blob转url1234567891011121314151617181920/** * blob 转 url * @param base64 * @param contentType * @returns */export function translateBase64ImgToBlob(base64, contentType) &#123; var arr = base64.split(&#x27;,&#x27;) //去掉base64格式图片的头部 var bstr = atob(arr[1]) //atob()方法将数据解码 var leng = bstr.length var u8arr = new Uint8Array(leng) while (leng--) &#123; u8arr[leng] = bstr.charCodeAt(leng) //返回指定位置的字符的 Unicode 编码 &#125; var blob = new Blob([u8arr], &#123; type: contentType &#125;) var blobImg: any = &#123;&#125; blobImg.url = URL.createObjectURL(blob) //创建URL blobImg.name = new Date().getTime() + &#x27;.png&#x27; return blobImg&#125;","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"使用gitlabCI/CD完成前端自动化部署","slug":"使用gitlabCICD完成前端自动化部署","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:21:57.486Z","comments":true,"path":"2021/06/15/使用gitlabCICD完成前端自动化部署/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/%E4%BD%BF%E7%94%A8gitlabCICD%E5%AE%8C%E6%88%90%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","excerpt":"","text":"2021年11月16日更新 静态数据提取为变量 增加备份版本 前言为什么使用CI&#x2F;CD？ ​ 目前我们公司更新使用的轻量化更新脚本，更新操作虽然简单,但是不够规范，并且敏感信息存在开发者电脑中，虽然我们git上进行了配置文件忽略，但是依旧存在泄密的风险，为了防止以上情况出现，我们将敏感信息移植到gitlab中，并且将更新操作从人工变为自动化 CI&#x2F;CD的优点自动构建并且状态是每个人都可见的 减少手工的错误，解放了重复劳动力 更好，更快，更加安全，更加稳定的交付 在CI的过程中可以进行代码质量的自动检测，减少人工检查的劳动力 打包环境一致，不会出现编译后代码异常 减少等待时间，更快的交付成果 前置概念CI​ 持续集成（continuous Integration）频繁的将代码继承到主干。目的是让产品可以快速迭代，同时还能保证高质量，他的核心措施就是代码继承到主干之前，必须通过自动化测试，只有存在失败，就不能集成。”持续继承并不能消除bug，而是让他非常容易发现和修改” CD​ 持续交付（continuous Delivery）与持续部署（continuous Deployment）频繁的将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过就会进入生产阶段，持续交付可以看做持续集成的下一步，它强调的是不论怎么更新，软件都是随时随地可以交付的；代码通过评审之后，自动部署到生产环境，持续部署是持续交付的下一步，持续部署的目标是，软件在任何时刻都是可以部署的，可以进入生产阶段 gitLab​ gitLab是一个开源的应用程序，他可以实现私有化的Gti项目仓库，可以通过web界面进行访问公开或者私人项目 gitLab CI&#x2F;CD​ gitLab持续集成，只要在仓库的根目录添加.gitlab-ci.yml文件，并且配置了gitLab runner（运行器），每次代码发生变成的时候就会执行.gitlab-ci.yml中的配置 gitLab Runner​ gitLab Runner是一个开源项目，支持多平台运行，他的作用是每次代码发生变更的时候gitlab CI会根据.gitlab-ci.yml，配置文件执行流水线（Pipeline）中每个阶段Stages中的Jobs，并将结果发送回gitLab。gitLab Runner是基于gitLab CI的API进行构建的相互隔离的机器，所以gitLab Runner 与gitlab本身不需要安装在同一台机器上，并且考虑到执行Runner对资源的消耗，以及安全性问题，所以并不建议安装在同一台机器上 Pipelines​ 流水线，是分阶段的构建任务，比如安装依赖，运行测试，打包部署，流水线由gitLab Runner进行触发，流水线运行的依据是gitlab-ci.yml Stages​ 构建阶段,也就是流水线的每一个环节，我们可以在 Pipelines中建立多个Stages，所有Stages都会按顺序同步进行，只有当所有的Stages都完成了Pipelines才算成功，默认情况下上一个Stages失败，这条流水线则为失败 Jobs​ 表示构建阶段的作业，关于jobs的设置有很多，比如指定手动触发，指定分支触发，同时运行多个jobs，等等，相同的Stages中的jobs会异步进行，Stages中的jobs全部成功了，Stages才为成功，默认情况下存在jobs失败，这条流水线则为失败 .gitlab-ci.yml​ 在gitLab CI&#x2F;CD中，具体如何运行流水线，是由 .gitlab-ci.yml来管理的，这个文件放在项目仓库的根目录 实例代码： 12345678910111213141516# stages：定义Pipeline中的各个构建阶段，并且定义Stages名称stages: - install - build# 定义 install 阶段的一个 jobinstall-job: stage: install script: - echo &quot;hello install&quot;# 定义 build 阶段的一个 jobbuild-job: stage: build script: - echo &quot;Hello, build&quot; 环境搭建​ 此类文章太多了，请自行查找，本文不做搭建介绍 ​ 针对已经搭建好的gitLab以及runner，为了适应前端开发环境，需要安装了node，cnpm，等等依赖 前置技能git：不会git可以退出直播间了，赶快去学吧 linux：常用命令必须会，不然配置runner，以及编写ci.yml脚本的时候会寸步难行 创建组织，导入git的项目 创建组织主要是为了方便配置CI&#x2F;CD的全局变量，也方便项目的集中管理 ​ 在使用gitlab之前，我们的项目可能会在github，gitee，等等其他代码仓库，为了保留之前记录，我们需要将git仓库移植过来 我们之前使用的是gitee，gitlab没有对此做快捷支持，所以我们使用Repo URL,填写好地址与账号，就可以将git仓库导入进来 更新git文件我们将git迁移到gitlab之后，现有项目中的.git文件都需要进行更换，不能再向之前的仓库提交代码。 停止代码提交 获取最新代码，切换到master分支 clone 新的gitlab的仓库 获取新的.git文件，覆盖原本项目中的.git，完成迁移 到目前为止，我们就可以完成git项目的迁移操作 配置组织的CI&#x2F;CD变量​ 组织中的项目大部分都是更新到一个服务器，例如服务器地址与密码，我们可以将这部分数据统一配置到全局变量，这样组织中的项目则无需再次进行设置 注意： 因为我们的项目不仅仅是master分支会运行runner，如果这里不关闭State，除了master（受保护的分支）其他的分支都访问不了这个变量 CI&#x2F;CD的变量功能可以很好的保护项目的隐私数据，可以隔离使用者与项目更新配置 配置gitlab-runner（linux） 注意：本文无搭建gitlab以及gitlab-runner相关教程，一切都是在已经搭建完成的基础上进行使用的 ​ 我们针对项目就要注册一个runner，来完成我们接下来配置中的命令操作，这部分界面操作无法完成，需要对gitlab runner的服务器进行操作 获取配置相关数据 注册自定义runner我们需要注册一个特定的runner，这里官方提示顺序为 安装runner 注册一个runner，并且URL指定为xxx，token指定为xxx 接下来我们就要去runner宿主机上面注册 使用终端工具链接宿主机 输入命令 1gitlab-runner register 完成配置之后，在回到项目CI&#x2F;CD部分的设置,就会发现下面多一个runner 注：刚刚注册的runner状态是黑色的，等会就会变成绿色 到此为止，runner已经准备就绪，他会执行我们项目中的.gitlab-ci.yml文件中的配置 编写.gitlab-ci.yml 具体编写过程请查看官方教程 ps：注意一点，线上静态文件最好不要命名为dist，CI脚本中dist为中转站文件夹，命名为dist会出现问题 1234567891011121314151617181920212223242526272829303132333435363738394041stages: # 分段 - install - build - deploycache: # 缓存 paths: - node_modules - admininstall-job: stage: install only: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - npm install - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./dist $USERNAME@$HOST:$UPLOADDIR/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/xxxx # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/xxxx # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 在配置文件中配置了执行的分支，当我们在prod-pre分支上提交代码的时候，脚本就会自动执行 install项目依赖 build项目 发射到目标服务器 这样就完成我们项目的自动化部署 CI脚本的优化优化自动化部署速度上面我们完成了一个简单的流水线，他可以完成 install build delay，已经满足了基本要求，但是还存在一些小问题 流水线任务时间过长 频繁install存在失败的概率 我们需要优化我们的CI，让速度更快更加稳定 build环节与delay环节没有太大的操作空间，并且大部分的时间都花在install环节，我们启用了gitlab的cache，实际上并不需要每次都打包，针对这个思路我们修改我们job中的 install，在job中增加当前是否存在**node_modules&#x2F;**的判断 123456789install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot; 这样存在缓存的时候就会跳过install阶段，但是这样还存在一个问题，我们修改了依赖，但是gitlab里面缓存还在，必然会出现打包异常的情况，针对package.json发生变化，我们再增加一个job，监听package.json 是否发生变化 静态数据提取为变量 假如存在多个项目，使用本脚本只需要修改此处的variables即可，不需要改script部分 1234variables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹 增加备份功能 删除原有备份文件(仅在生产环境) 删除原有文件 备份原本的代码(仅在生产环境) 将打包完成的文件复制到目标服务器 将目标文件改为服务端真正文件 .gitlab-ci.yml（正式版本） 指定了prod分支，根据实际项目进行修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263stages: # 分段 - repInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist # 线上文件名 BACKUPDIR: dist_back # 备份文件夹cache: # 缓存 paths: - node_modules - distrepInstall-job: stage: repInstall only: refs: - prod changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - echo &quot;发射到目标服务器✨✨✨&quot; - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/backup/$BACKUPDIR # 删除原有备份文件(仅在生产环境) - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/$PRODDIR/ $UPLOADDIR/backup/$BACKUPDIR/ # 删除原有文件 备份原本的代码(仅在生产环境) - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 - echo &quot;完成更新👏👏👏&quot; after_script: - echo &quot;完成更新👏👏👏&quot; .gitlab-ci.yml（简化） 指定了prod-pre分支，根据实际项目进行修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758stages: # 分段 - preInstall - install - build - deployvariables: BUILDDIR: dist # 打包文件名 PRODDIR: dist_test # 线上文件名cache: # 缓存 paths: - node_modules - distpreInstall-job: stage: preInstall only: refs: - prod-pre changes: - package.json script: - echo &quot;依赖发生变化,开始install🔥🔥🔥&quot; - cnpm install - echo &quot;完成install🔥🔥🔥&quot;install-job: stage: install only: refs: - prod-pre script: - echo &quot;开始install🔥🔥🔥&quot; - if [ ! -d &quot;./node_modules/&quot; ];then npm install; else echo &quot;缓存存在,跳过install&quot;; fi - echo &quot;完成install🔥🔥🔥&quot;build-job: stage: build only: - prod-pre script: - echo &quot;开始代码打包💪💪💪&quot; - npm run build - echo &quot;完成代码打包💪💪💪&quot;deploy-job: stage: deploy only: - prod-pre before_script: - echo &quot;发射到目标服务器✨✨✨&quot; script: - sshpass -p $PASSWORD scp -o StrictHostKeyChecking=no -r ./$BUILDDIR/. $USERNAME@$HOST:$UPLOADDIR/dist/ # 将打包完成的文件复制到目标服务器 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST rm -rf $UPLOADDIR/$PRODDIR # 删除原有文件 - sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no $USERNAME@$HOST mv $UPLOADDIR/dist $UPLOADDIR/$PRODDIR # 将目标文件改为服务端真正文件 after_script: - echo &quot;完成更新👏👏👏&quot; 代码地址：github 结语​ 除了使用gitlabCI&#x2F;CD来完成自动化部署之外也可以使用Jenkins+webHook来完成，效果都是一样的，如果这两种方案对你，或者你的公司来说都比较复杂，那么我建议试试轻量化更新方案，我们也在实际项目上使用过很久，可以确保不会出现稳定性，是可以在生产环境使用的 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"使用iframe+postMessage通信实现商城多页面装修","slug":"使用iframe实现页面装修方案","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:21:59.779Z","comments":true,"path":"2021/06/15/使用iframe实现页面装修方案/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/%E4%BD%BF%E7%94%A8iframe%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E8%A3%85%E4%BF%AE%E6%96%B9%E6%A1%88/","excerpt":"","text":"演示视频演示视频 背景​ 开发项目是多商家的类似有赞的商城后台，需要支持客户端的店铺装修功能 ​ 系统用户多为企业用户对页面效果要求较高，导致首页变化非常频繁 前言2020年第一版本装修上线了，方案是后台“模拟”客户端样式实现可视化，实现首页装修功能 实际上也就是后台写一套与客户端一样的样式解析装修json，实现装修预览的效果 模拟版本的装修上线后，确实解决了多店铺个性化首页的问题，实现了定制化首页，但是随着时间的推移，模拟版本暴露了很多问题，高频率的改版导致需求几乎无法满足 装修数据为静态数据，不会根据商城商品状态而变化，例如某某商品下架了，但是首页装修数据里面依旧存在 每次客户端样式发生变化，后台都需要同步编写一份，否则就无法可视化，导致工作量非常大 不具备扩展性，只能可视化的装修首页，无法可视化装修其他页面，其他页面都是通过一个插槽实现 插槽就是一个json对象的载体，因为不想写2套样式，所以采取这种很抽象的方案 随着业务的拓展，暴露出来的问题也是越来越严重，为了满足需求，很多场景下需要牺牲整个技术部门的效率，以及使用者的体验感，为了解决这个问题必须另辟蹊径，寻找其他解决方案 新方案必须解决以下问题 装修中的商品数据必须为非静态数据 避免2套样式的问题 装修中的商品数据实时刷新可以通过约定有规律的数据结构，后端解析并实时更新商品数据，实现装修中数据的更新 抛弃模拟方案后，也是思考很多方向，但是因为基于业务组件装修是没办法整个装修数据都json化的，所以最终尝试了一个理论上可行的方案，客户端通过iframe嵌入到后台，使用postMessage来完成后台与客户端之间的数据交互，实现装修功能 方案逻辑图 后台装修与客户端的主要思路 装修模式下获取上次的装修记录 建立前后台iframe之前的的联系 后台装修发生变化，触发watch，watch触发postmessage，客户端得到相应，客户端watch触发，实时更新装修数据 装修完成保存到数据库 具体实现方案之前在掘金发布过一篇（开源）从0打造H5可视化搭建系统 - 易动（vue+ts+egg）文章，易动是更加灵活的装修方案，感兴趣的同学可以了解一下 按基础组件定制装修方案，基础模块为： 按钮 文本 图片 轮播图此类数据 等等 本次的装修是基于业务组件进行区分，他的核心原理就是通过iframe进行数据交互实现实时装修功能 定制组件数据结构客户端根据json数据进行组件的展示的，所有首先，我们需要定义好客户端与后台通用的数据结构，用于声明我们的装修数据 例如我定义的数据结构，仅供参考 示例 搜索框 轮播图 1234567891011121314151617181920212223242526272829303132333435363738&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, &#123; id: guid(), compName: &#x27;drag-swiper&#x27;, name: &#x27;轮播图&#x27;, data: [ &#123; interval: 5000, data: [], // 数据 item: &#123; // 单个数据 img: &#x27;https://images.591wsh.com/2021/02/03/thumb_32371580472397824.png&#x27;, isLogin: false, // 是否需要登录, linkType: 2, // 1 无链接 2 商品 3 外部链接 4分类 commodity: &#123;&#125;, // 商品id dataurl: &#x27;&#x27;, // 外部链接 categoryid: &#x27;&#x27;, // 类目id &#125;, isUpdate: true // 告诉服务器是否需更新data里面的商品数据 &#125; ], css: &#123; height: 266, // marginTop: 20 &#125; &#125;, 为装修中的客户端页面增加一个组件 增加，修改，删除都会走如下逻辑，一句话说就是数据后台操作数据，客户端可以做出响应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 后台点击右侧装修组件，例如点击 搜索框// 匹配到搜索框的文字匹配定制的数据结构，得到如下点击的数据结构&#123; id: guid(), compName: &#x27;drag-search&#x27;, name: &#x27;搜索框&#x27;, data: [ &#123; placeholder: &#x27;想要什么呢,快来搜一下吧&#x27;, tbHeader: false, // 是否显示淘宝推荐 isUpdate: false &#125; ]&#125;, // 后台通过监听存储装修数据变化的字段通知到客户端 computed: &#123; // ..... // 可使用组件 pageComponents: &#123; get() &#123; let &#123; pageComponents &#125; = this.$store.state.template if (pageComponents instanceof Array) &#123; // 组件数据发生变化的时候需要通知到客户端 this.iframeMessage(pageComponents) return pageComponents &#125; else &#123; return [] &#125; &#125;, set(data) &#123; // 更新组件顺序 this.$store.commit(&#x27;template/update_current&#x27;, data) &#125; &#125; // ...... &#125;, methods:&#123; // iframe加载完成的回调函数 iframeLoad() &#123; console.log(&#x27;iframe加载完成&#x27;) this.frm = document.getElementById(&#x27;iframe&#x27;) // 告诉客户端，目前处于装修中 this.frm.contentWindow.postMessage( &#123; isIframe: true &#125;, &#x27;*&#x27; ) &#125;, // 通知客户端数据发生了更新 iframeMessage(data) &#123; console.log(data) if (this.frm) &#123; this.frm.contentWindow.postMessage( &#123; tempLateData: data &#125;, &#x27;*&#x27; ) &#125; &#125;, &#125; // 客户端通过postMessage进行最新的装修数据接收window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.tempLateData) &#123; store.commit(&#x27;app/setTempLateData&#x27;, event.data.tempLateData) &#125; // ....&#125;// 客户端对应的页面再监听存在在vuex中的装修数据computed: &#123; ...mapState(&#123; tempLateData: state =&gt; state.app.tempLateData, // 后台的装修数据 hoverComponent: state =&gt; state.app.hoverComponent, // 当前鼠标浮动的元素id clickComponent: state =&gt; state.app.clickComponent, // 当前鼠标点击选中的数据 isIframe: state =&gt; state.app.isIframe, // 当前是否在装修模式里面 &#125;),&#125;,// 客户端替换从接口获取的之前的页面装修数据，装修数据显示在页面上watch: &#123; tempLateData() &#123; // 一旦后台通过postMessage更新装修数据，就可以替换原本接口获取的数据，实现实时装修功能 this.indexData = this.tempLateData || [] &#125;,&#125;, 修改装修的组件数据12345678910111213141516// 后台选取选中的组件// 后台针对每个装修组件都建立一个vue文件进行json内数据的改变‘// activeComponent.compName 为选中的组件compName，例如我选中搜索框 这里就是`drag-search-data`组件，这里可以是xxx-xxx-data组件&lt;template&gt; &lt;div class=&quot;template_right&quot;&gt; &lt;component v-if=&quot;activeComponent != false &amp;&amp; activeComponent.compName&quot; :is=&quot;activeComponent.compName + &#x27;-data&#x27;&quot; :compData=&quot;activeComponent&quot; &gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;// 组件内部绑定搜索框的提示文字，每次修改都会触发后台的计算属性·pageComponents·，进而后台通过postMessage通知到客户端，客户端进而存储到vuex，vuex值发生变化，客户端页面的watch起作用，页面发生变化，就吃实现组件数据的变化 点击客户端组件，通知后台并实现选中我们知道，在装修里面点击客户端，就直接点击到了客户端，所以点击客户端的跳转函数，我们必须进行拦截， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 前提须知 客户端每个装修组件的id都会在客户端写入到class中&lt;component :is=&quot;xxxxx&quot;:class=&quot;[`decoration_$&#123;item.id&#125;`,]&quot;&gt;&lt;/component&gt;// 装修监听函数体内window.addEventListener(&#x27;message&#x27;, _fundecoratio)function _fundecoratio(event) &#123; // .... if (event.data.isIframe) &#123; console.log(&#x27;装修开发模式启动&#x27;) store.commit(&#x27;app/setIsIframe&#x27;, true) // 拦截跳转函数 uni.navigateTo = () =&gt; &#123;&#125; uni.switchTab = () =&gt; &#123;&#125; // 监听点击(装修用于选中组件) window.addEventListener(&#x27;click&#x27;, _decoratioclick, false) &#125; // ....&#125;function _decoratioclick(event) &#123; let path: string = &#x27;&#x27; // 每次点击的时候都获取一下包含组件id的class event.path.map((res: any) =&gt; &#123; if (res.className &amp;&amp; res.className.includes(&#x27;decoration_&#x27;)) &#123; path = res.className.split(&#x27;decoration_&#x27;)[1] &#125; &#125;) // 选中客户端当前组件 store.commit(&#x27;app/setClickComponent&#x27;, path) // 告知父级当前选中组件 window.parent.postMessage( &#123; activePage: path, // 将当前点击的组件id通过postMessage传递到后台 &#125;, &#x27;*&#x27; )&#125;// 装修后台mounted() &#123; window.addEventListener( &#x27;message&#x27;, e =&gt; &#123; if (e.data.activePage) &#123; // 获取客户端传递过来的当前组件id 这就是实现点击客户端组件装修后台得到数据 this.$store.commit(&#x27;template/set_activeComponent&#x27;, e.data.activePage) &#125; &#125;, false )&#125;, 添加组件到页面的流程图 客户端与装修后台相互传值总结1234567891011121314151617181920212223242526// 客户端发送window.parent.postMessage( &#123; activePage: path, &#125;, &#x27;*&#x27;)// 客户端接收window.addEventListener(&#x27;message&#x27;, （）=&gt; &#123; // ....&#125;)// 装修后台发送this.frm = document.getElementById(&#x27;iframe&#x27;)this.frm.contentWindow.postMessage( &#123; // ..... &#125;, &#x27;*&#x27;)// 装修后台接收window.addEventListener(&#x27;message&#x27;,e =&gt; &#123; // ...&#125;) postMessage的数据都是实时监听的，所以任意一边传值另一边都可以快速接收到，这是实现本方案的核心，通过postMessage解决了通信上的所有问题，例如 装修后台点击对应组件，客户端可以得到当前点击的组件的id 客户端点击组件可以告知后台，当前用户选中的组件 包括没实现的拖拽排序，都是可以实现的 多页面装修 做页面装修一定要想明白一件事，我们玩的不是装修，只是在操作页面抽象的数据结构 根据上面的想法，我们可以明白，活动页面很多仅仅是换换商品，换换链接，不会动不动就改页面 那个就可以抽象活动页的json数据结构 那么这里对应的就是图片组件 图片组件（优惠券也是图片样式） 商品组件 商品组件 在装修的时候我们定义好数据结构，依次添加这几个组件，客户端活动增加一行watch代码，就可以完美的实现活动页的装修，以及更新活动商品 注：公司项目无法透露，具体逻辑需要大家自己理解了 iframe装修方案优势 100%的完美还原装修样式 可以动态更新装修里面选中的商品的数据，需要数据结构统一化，后端即可按规律解析装修json 如果出现新组件，不需要写2套样式 后台装修定义好数据结构，客户端约定项目结构不变化，理论上整个项目所有页面都可以配置化 iframe装修方案弊端​ 通过iframe实现的前后台交互装修方案中，不仅需要动后台的装修代码，还需要客户端进行“兼容处理”，即客户端需要识别装修模式，与不断更新后台传入的装修数据，存在一定的耦合性 ​ 这种装修方案的弊端就是，如果希望操作起来更加便捷就需要在客户端进行功能的实现，并通过postMessage提交给装修后台 最后大家可以再看一下演示视频 联系我欢迎大家加入qq群吹吹水,一起成长 或者关注我的公众号，不定期更新各种文章：吴凯的随笔","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"在Option API中使用 Custom hook","slug":"使用reactivity 在vue2中编写hook函数","date":"2021-06-14T16:00:00.000Z","updated":"2022-05-23T08:22:02.513Z","comments":true,"path":"2021/06/15/使用reactivity 在vue2中编写hook函数/","link":"","permalink":"https://vkcyan.github.io/2021/06/15/%E4%BD%BF%E7%94%A8reactivity%20%E5%9C%A8vue2%E4%B8%AD%E7%BC%96%E5%86%99hook%E5%87%BD%E6%95%B0/","excerpt":"","text":"适应人群： 项目的vue2.x的版本， 还没在正式环境使用过composition API 但是又想享受hook带来的优势 ​ 注：本文提出的方法并非最佳实践，而是是vue2项目渐进式切换到vue3的方案，保留的大家熟悉的编写方式，也保留了hook的优势，如果开发团队条件允许的话，建议直接使用composition API语法来完成逻辑编写 什么是hook​ hook 翻译过来是钩子，在程序上体现为在行为执行之前，先把行为勾住，不让其继续，优先执行你的hook函数 用一张图来表示即为 左边为正常函数执行流程，右边为存在hook的执行流程 没有hook之前，我们如何对待代码复用​ 我们假设一种场景，你正在开发一个后台管理系统，在这个后台管理系统中，大部分都是查询表单，他们虽然业务不同，但是逻辑上存在一定的共性 共性元素：查询条件 列表数据 分页相关数据 加载状态 以上4个特征几乎每个表单都有，这就意味这你在写每一个表单的时候都需要重复对接相关的逻辑，这个问题在vue2中存在两种解决办法 每次都复制逻辑相同的代码 使用vue mixins完成逻辑公用 然而这2种方式都存在问题 复制代码低效率，虽然相对稳定，但是编码与测试工作量较大 vue mixins可以实现逻辑抽象，但是这种方案过于简单粗暴的方案，数据全局共享，过多使用mixin会导致项目走向失控，是一个比较危险的方案 假设表单页面数据结构如下 12345678&#123; data: [], // 列表数据 currentPage: 1, // 当前页面 pageSize: 0, // 每一个分页的数量 thePageSize: 0, // 本页数量 totalPages: 0, // 总页数 totalSize: 0, // 总记录数&#125; 除了以上后端返回的数据，我们还需要在页面增加一些状态值,用于优化用户体验 1status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;error&#x27; | &#x27;success&#x27; | ... // 当前列表请求的状态 以上的数据 + 状态每一个后台表单页面都存在，这就意味着重复的声明，重复的对接，重复的测试 ​ 复制代码的方式看似稳定，实则不稳定，因为每一次都要对重复逻辑进行测试，并且由于此类工作繁琐且重复劳动，开发人员一般比较抵触此类任务 ​ 这个问题在vue2中并没有非常好的解决方案，针对这个问题隔壁react从mixin到HOC最后到现在hook，给出了还不错的解决方案。 ​ 现在@vue&#x2F;composition-api提供了hook的能力，我们可以在vue中使用hook来优化提出的问题 通过hook来完成逻辑共用​ 接着上面的场景，我们现在假设我们有3个后台表单页面需要写 ​ 传统编码方案（未使用hook） ​ 可以看到我们需要写的三个页面流程上存在很多相似的地方，对接数据环节，虽然是大部分代码相同，但是还是需要重复的编写测试，例如页码相关，状态相关逻辑 ​ 使用hook完成重复逻辑抽象 每次调用useHook都会生成一次独立的状态 虽然状态与逻辑依赖与组件，但是useHook可以在组件外部进行定义，这一点是之前无法做到的 ​ 虽然不同页面的内部逻辑细节都是不一样，但是总体流程、数据结构都是一样的，基于这样的前提，我们就可以针对共性来进行抽象，之后不论多少个页面，我们都使用抽象逻辑，也只需要维护抽象逻辑 提供 组合式 API 的 Vue 2 插件​ 虽然hook是vue3版本才提出的，但是这并不代表hook与vue3是绑定关系，实际上在任何前端应用中都可以使用vue3中提供的hook功能 文档地址：@vue&#x2F;composition-api 所以不论是vue3还是vue2，还是react，甚至html都可以使用这个npm包 关于vue3的响应式核心包 @vue&#x2F;reactivity的具体实现，可以看看之前的文章 简易版Reactivity源码解析，读懂源码之后，自然解答了你对reactivity的全部疑问 实战（useReqList） 为了方便理解，以下代码为vue2.x，使用js进行编写 ​ useReqList是一个自定义hook，作用是帮助我们抽象后台表单的公共逻辑，我们先看看未使用的情况，使用了之后，代码的变化，再看看如何实现 未使用useReqList123456789101112131415161718192021222324252627282930313233// ...data() &#123; return &#123; // ... shopList: [], // 数据 homePage: 0, // 本页有多少数据 allPage: 0, // 总共多少页 totalSize: 0, //总共多少条数据 pageSize: 0, // 每页最多多少条数据 currentPage: 1, // 当前页码 &#125; &#125;,methods:&#123; init() &#123; this.loading = true const data = &#123; currentPage: this.currentPage, //... &#125; request(data) // 请求 .then((res) =&gt; &#123; this.shopList = res.data.data this.currentPage = res.data.currentPage this.pageSize = res.data.pageSize this.totalSize = Number(res.data.totalSize) this.homePage = res.data.thePageSize this.allPage = res.data.totalPages &#125;) .finally(() =&gt; &#123; this.loading = false &#125;) &#125;,&#125; 使用useReqList123456789101112131415161718import &#123; useReqList &#125; from &#x27;@/utils/hook/useReqList&#x27;// ...data() &#123; return &#123; dataList: useReqList() &#125;&#125;,methods:&#123; init() &#123; const data = &#123; currentPage: this.listData.currentPage || 1, //... &#125; this.listData.run(request(data)) // 请求 &#125;,&#125;// let &#123; data, currentPage, pageSize, thePageSize, totalPages, totalSize, status &#125; = this.listData 通过上面的例子可以看到，使用了useReqList之后 公共变量，公共逻辑部分被抽象出去，页面代码变得更加纯粹 因为reactivity的特性，它们都是具备响应式 避免重复编码，重复测试环节，节省开发时间 hook可以给n个接口使用，只要是请求表单接口，都不需要写重复部分的代码，避免调试，测试环节 接下里我们可以看看这是如何实现上面使用的自定义（Custom） Hook useReqList useReqList具体实现 ​ 内部实现就是对公共逻辑的封装，被读取的数据被reactive处理后具备了响应式，每次声明都会因为闭包的特性而开启一片独立的内存来供声明单位使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import &#123; reactive &#125; from &#x27;@vue/reactivity&#x27;/** * 针对后台表单页面逻辑的抽象 * @returns */export function useReqList() &#123; const defaultState = &#123; data: [], // 表格数据 currentPage: 1, // 当前页面 pageSize: 0, // 分页数量 thePageSize: 0, // 当前页面数量 totalPages: 0, // 总页数 totalSize: 0, // 总数量 error: null, // 错误原因 status: &#x27;idle&#x27;, // 当前状态 idle | loading | success | error &#125; let state = reactive(&#123; ...defaultState, &#125;) /** * 请求成功 * @param data */ const setData = (data) =&gt; &#123; state.currentPage = data.currentPage state.pageSize = data.pageSize state.thePageSize = data.thePageSize state.totalPages = data.totalPages state.totalSize = Number(data.totalSize) state.data = data.data state.status = &#x27;success&#x27; &#125; /** * 请求失败 * @param error */ const setError = (error) =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = error state.status = &#x27;error&#x27; &#125; const setLoading = () =&gt; (state.status = &#x27;loading&#x27;) const setPage = (num) =&gt; &#123; state.currentPage = num &#125; const setReset = () =&gt; &#123; state.data = [] state.currentPage = 1 state.pageSize = 0 state.thePageSize = 0 state.totalPages = 0 state.totalSize = 0 state.error = null state.status = &#x27;idle&#x27; &#125; const run = (promise) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&#x27;请传入 promise 类型数据&#x27;) &#125; if ([&#x27;loading&#x27;].includes(state.status)) &#123; return Promise.reject(&#x27;当前正在请求中&#x27;) &#125; setLoading() return promise .then((res) =&gt; &#123; setData(res.data) &#125;) .catch((err) =&gt; &#123; console.log(err) setError(err) &#125;) .finally(() =&gt; &#123;&#125;) &#125; return &#123; run, setReset, setData, setPage, setLoading, setError, state, &#125;&#125; ​ 这样的封装体基本适配大部分vue2.x开发的后台管理系统的项目，如果想在项目中使用只需要修改一下setData部分适配一下后端数据即可 更多的vue hook函数​ hook工具库，VueUse，库里面提供了大量的常用方法，掘金上面有该工具库的介绍文章，官网说明该库是兼容vue2文档了 vue项目应当在什么使用下使用hook关于Class API与Composition API​ 从Class API&#x2F;Option API转变向Composition API的过程中是阵痛的，这2种API在思维方式上存在很大差异 ​ 对于长时间写Class、vue2.x的人来说，最初接触vue3几乎发现不了非常明显的优点，setup语法不熟练的情况下基本还是按照Class的思维进行编码，无法发挥Hook的优势，导致写一段时间Vue3后的结论是：在单文件中class的代码组织能力几乎完爆setup语法… ​ 后来组件有一些项目经验，重新学习了react hook，逐渐对hook有了一些理解；Hook主要完成逻辑与逻辑的分离，在react和vue中使用hook可以实现 视图与视图的分析，视图与逻辑的分离，逻辑与逻辑的分离，用这个的方式来实现单一职责，在此基础上完成逻辑与视图的低耦合高内聚代码 ​ 对于vue2的开发者在而言，可以渐进式的从vue2到vue3，先熟悉hook，在熟悉Composition API 关于hook与vuex | observable​ 从普遍意义上来说hook是可以替代vuex的，react中的API useContext就提供了类似功能。 vuex是无法替代hook的，他并不具备闭包的特性，使用vuex的话，那仅仅是拆分逻辑，有多少页面还是要写多少重复逻辑只是重复代码转义到vuex中而已 ​ 但是刚接触hook不久的新手而言，很容易进入一个误区；将变量，逻辑封装在一个hook中的情况下，又在多个页面中使用，就会在内存中创建多个不共享的内容一致的空间，对于公共变量还是要使用全局状态管理库的。 ​ hook风格的全局状态管理库，建议可以试试Pinia 结语​ 使用过了一段时间的setup语法之后，对其看法也是慢慢从谨慎疑惑转变成为拥抱hook，Composition API 在逻辑抽象、类型推导、多方面均占优，虽然目前还存在一些小问题，后面的迭代都会解决的，在未来几年Custom Hook将会越来越普及，拥抱Custom Hook,Vue3吧! 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水 也可以添加我的微信：carpediem-rollin，加入微信群","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"使用Prettier完成代码提交的自动格式化","slug":"使用gitHook来完成代码的自动格式化","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-23T08:05:05.679Z","comments":true,"path":"2021/06/01/使用gitHook来完成代码的自动格式化/","link":"","permalink":"https://vkcyan.github.io/2021/06/01/%E4%BD%BF%E7%94%A8gitHook%E6%9D%A5%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/","excerpt":"","text":"最终效果 执行git commit 代码自动完成我们定制规则的格式化功能，并提交到本地 使用的npm包prettier：功能依赖包 husky：提供gitHook相关功能 lint-staged：让命令只对发生更改的文件生效 为什么做（WhyHow）​ 在未建立规范之前，每个人的代码风格都是不一致的，并且开发过程中可能会出现忘记格式化，手误的问题，如果在提交之前，可以自动抹平差异统一多人开发风格，这时候作用就体现出来了 ​ 代码风格是每一个程序员都要面对的问题，不论是在个人开发还是在团队协作中，都明白较好的代码风格是保证日后可维护性的关键，所以连不懂的开发或许都知道，要注意代码风格 怎么做（How）​ 到了正在的推进时期，就会面对很多难题，无法确定一个所有人都满意的方案，而就算是少数服从多数，在实际开发中落实也会遇到一大堆问题，例如，编辑器的不同，格式化工具不同，或者说完全没这个习惯，好不容易决定推进了，每次代码审核都需要修改这种细节问题，一来二去就搁置了，实在是头疼，到底该如何将事情完美的落实下去呢？ ​ 这里我们就需要一个权威的规范来帮助我们约束成为一个风格，Prettier表示我先给一个规范，大家先用起来，保证代码的可读性与可维护性，然后大家都遵循这和规则。 ​ 而prettier本身是一个An opinionated code formatter 的格式化工具，我是一个规矩非常严格的框架，并不会给你很多的配置项，喜欢用就用，不喜欢就不用，绝大部分的编辑器集成了prettier，在编辑器的约束下，大家都遵循这个方案就好了 具体配置（What）Vscode下载插件 prettier 项目按下依赖prettier，按文档完成步骤prettier官网 配置commit钩子 ​ 安装好之后，会在项目下生成文件.husky，并修改你的package.json，到目前为止，其实已经配置好了，他会在你每次commit之前执行npx lint-staged，这个命令会执行prettier --write，并且只对本次修改的文件生效 具体命令（躲懒不看文档的看这里~） 当前的prettier版本是2.4.1，如果版本号不一致，建议还是看官网 vscode安装prettier 项目安装prettier 1npm install --save-dev --save-exact prettier 创建配置文件 1echo &#123;&#125;&gt; .prettierrc.json 创建说明不需要格式化的文件 创建文件.prettierignore 写入内容 123# Ignore artifacts:buildcoverage 执行命令npx prettier --write .,格式化现有代码，测试功能是否正常 编写配置文件 1234567891011// json文件改为js文件（看个人习惯）写入内容module.exports = &#123; singleQuote: true, // 单引号 trailingComma: &#x27;es5&#x27;, // 对象属性最后有 &quot;,&quot; semi: false, // 是否需要分号 printWidth: 110, // 一行最多120 jsxSingleQuote: true, // jsx使用单引号 tabWidth: 2, // 一个tab代表几个空格数，默认就是2 useTabs: false, // 不使用缩进符，而使用空格 jsxBracketSameLine: true,&#125; 再次执行npx prettier --write .，对格式化规则有建议参考文档对配置进行修改，知道自己满意 配置gitHook钩子(必须先加入git仓库，不然会无效果) 1npx mrm@2 lint-staged 将代码格式改乱，尝试commit一下，查看功能是否正常（提交之前会被自动格式化） 一些注意事项win电脑.prettierrc.json写入失败这个问题在同事电脑上发现的，使用vscode中powershell执行echo &#123;&#125;&gt; .prettierrc.json,会无写入内容，后面执行的命令也会失败，这里请使用电脑的cmd打开目标文件夹，执行该命令，这样测试是可行的 配置gitHook之后 commit不会自动格式化vue文件这里需要修改在package.json中默认写入的lint-staged中的命令 这里根据项目中是否存在eslint，会写入不太一致，但是问题不打 123&quot;lint-staged&quot;: &#123; &quot;*.js&quot;: &quot;eslint --cache --fix&quot;&#125; 统一改成 123&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,css,md,vue&#125;&quot;: &quot;prettier --write&quot;&#125; 这样每次commit的时候就会自动格式化代码了 结语​ 如果查看本文遇到了一些问题，请到QQ群 530496237，一起吹吹水~","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"同域名下通过一级路由区分实现“前端微构架”","slug":"单域名下通过子路由区分项目的实现方案","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-23T08:04:01.733Z","comments":true,"path":"2021/06/01/单域名下通过子路由区分项目的实现方案/","link":"","permalink":"https://vkcyan.github.io/2021/06/01/%E5%8D%95%E5%9F%9F%E5%90%8D%E4%B8%8B%E9%80%9A%E8%BF%87%E5%AD%90%E8%B7%AF%E7%94%B1%E5%8C%BA%E5%88%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 公司的客户端项目比较庞大，并且由于改动相对频繁，导致更新频率较高，web项目高频率的更新就会引发一系列的问题，例如公众号缓存问题，尤其是ios手机容易出现白屏的情况，访问过程中的用户回退页面会出现白屏的情况，等等很多未知的bug，虽然更新在一瞬间完成，但是还是会影响到部分用户的使用，针对现存的条件以及项目需求 思考到如下优化方案 更新时间上尽量选择用户访问量小的时间段 程序内频繁变化的图片，文字的页面，尽量后台配置装修化，达到减少更新的效果，此处参考使用iframe+postMessage通信实现商城多页面可视化装修 项目能否进行拆分，权重不高的页面（例如：活动页面），与主程序分离，达到减少主程序包更新频率 思考与分析 第一条与第二条非本文重点，只做简要说明 更新时间主要参照我们的客户端监控平台提供的检测数据，一般选择用户访问量较小的时候进行更新 对于项目中频繁改动，但是数据格式固定的活动页，我们使用装修功能，达到不更新代码，只更新数据的效果 ​ 而项目拆分就是我们本文要说到的重点，在调查过程中也了解过微前端，但是我们的客户端项目是uniapp完成的，考虑到技术难度与改动成本，最终放弃了微前端的方案 要怎么做到一个路径下面的项目拆分呢？ 拆分的项目需要满足一下2个条件 拆分的项目必须在同域名下，不可出现跨域名的情况，不然就会出现无法共享localStorage的问题 本次改动不能影响到线上已经存在的业务，不能出现主程序的路由变动 为了满足以上2个条件，则主程序不能进行任何改动，同时需要在当前域名下，想办法再指向一个项目，在同一个域下，localStorage被共享，虽然是2个项目但是在同一个域下 最开始一直在思考客户端如何修改实现，但是一直没想到完美方案，后来，我们另辟蹊径，通过nginx实现通过子路由进行项目区分 nginx进行一级路由区分 通过nginx进行一级路由的判断实现访问不同的静态资源 理想情况下方案是可行的，nginx配置也比较简单 12345678910111213server &#123; // ..... server_name xxxx.com // ..... location / &#123; root /xxx/xxx/xxxx/packageA; try_files $uri $uri/ /index.html; &#125; location ~ /activity/ &#123; root /xxx/xxx/xxxx/packageB try_files $uri $uri/ /index.html; &#125;&#125; 只要访问的项目路由 xxxx.com&#x2F;activity&#x2F;xxxxx,就会访问到项目包packageB，其他的一级路由都会访问到packageA 部署因为项目activityB的访问路由是确定的，所以我们在webpack的配置中就需要对publicPath进行修改 1publicPath: &#x27;/activity/&#x27;, ​ 然后我们nginx会去访问项目包下面的index.html，而经过我们上面对publicPath的修改，打包之后的index.html里面的路径应用就变成了 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/activity/favicon.ico&quot; /&gt; &lt;title&gt;xxxxx&lt;/title&gt; &lt;link href=&quot;/activity/css/app.xxxx.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/activity/js/chunk-vendors.xxx.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/activity/js/app.xxxxx.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时打包上线就会遇到资源访问不到的问题，因为webpack编译出来的程序包里面没有activity这个文件夹，所以对indexPath,outputDir也要进行修改 最终我们的vue.config.js 1234567891011module.exports = &#123; publicPath: &#x27;/activity/&#x27;, // 资源路径 outputDir: &#x27;./dist/activity&#x27;, // 生产环境构建文件的目录 indexPath: &#x27;../index.html&#x27;, // 指定生成的index.html的输出路径 configureWebpack: (config) =&gt; &#123; // .. &#125;, chainWebpack: (config) =&gt; &#123; // .. &#125;,&#125; 到此为止，通过一级路由区分项目已经完成了全部配置 优点 对项目进行拆分，对于非核心程序的页面，例如活动页面等等，即可与主程序进行区分，上线活动页面不干涉主程序 项目分离后，单个项目的页面变少，单个代码包打包速度得到提升，增加项目可维护性 缺点没办法共享公共逻辑代码，例如支付模块，登录模块，等等模块，因为跨项目了，当然这是有解决办法的，即公共模块打包成为npm包，但是这存在一定的工作量 最后欢迎大家加入qq群吹吹水（群号：530496237）一起成长","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"轻量化前端更新方案","slug":"轻量化前端更新方案","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-23T08:04:51.111Z","comments":true,"path":"2021/06/01/轻量化前端更新方案/","link":"","permalink":"https://vkcyan.github.io/2021/06/01/%E8%BD%BB%E9%87%8F%E5%8C%96%E5%89%8D%E7%AB%AF%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言​ 一句话介绍：它是可以一行命令将代码更新到服务器的脚本 ​ 轻量级更新方案最开始源于掘金的文章，后来我们从零实现了一个更新脚本，并且已在是生产环境中进行使用很长时间，算是非常稳定的版本，个人认为轻量化更新方案是非常使用小型开发团队 ​ 现在我们切换到了gitlab的CI&#x2F;CD。所以这种方案已经不再是我们的主流方案，但是一路使用过来，非常稳定的解决了更新问题，还是非常不错的 优点： 快速，稳定，自动备份指定文件夹（灵活性高，但是需要自己实现） 缺点：需要手动回滚（自动回滚需要编码），相对来说没那么规范，没有留下记录，敏感数据存储在电脑中，配置文件可以git忽略 核心流程 确认并打包项目 通过node-ssh连接线上服务器 将打包代码指定名称进行压缩 备份之前的代码，删除以前的代码包，并解压压缩包 删除本次打包代码，断开ssh链接 如何使用代码地址 将仓库文件放入项目 安装依赖 1npm install node-ssh inquirer archiver -D 修改upload.config.js内容 增加脚本命令 1&quot;upload&quot;: &quot;node build/upload.js&quot; 运行命名，验证是否功能正常 核心代码build/upload.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const &#123; NodeSSH &#125; = require(&#x27;node-ssh&#x27;)const archiver = require(&#x27;archiver&#x27;)const inquirer = require(&#x27;inquirer&#x27;)const exec = require(&#x27;child_process&#x27;).execconst ssh = new NodeSSH()const uploadFun = require(&#x27;../upload.js&#x27;)/** * 获取当前平台 */let objName = process.argv[2] // 更新名字let startTime = null // 程序开始更新的时间// 获取上传服务器配置let config = uploadFun(objName)const verifyList = [ &#123; type: &#x27;input&#x27;, message: &#x27;您正在更新到线上环境,请确认接口域名&#x27;, name: &#x27;objName&#x27;, &#125;,]inquirer.prompt(verifyList).then(() =&gt; &#123; uploadBuild()&#125;)function uploadBuild() &#123; startTime = new Date() console.log(`$&#123;objName&#125;开始更新`) let buildcmd = exec(config.buildScript, (error, stdout, stderr) =&gt; &#123; if (!error) &#123; console.log(&#x27;打包完成&#x27;, stdout) app() &#125; else &#123; console.error(&#x27;打包出现错误&#x27;, stderr) process.exit(0) &#125; &#125;) buildcmd.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(data.toString()) &#125;)&#125;/** * 通过ssh链接服务器 */function app() &#123; ssh .connect(&#123; host: config.host, username: config.username, password: config.password, &#125;) .then((res) =&gt; &#123; // 上传代码压缩包 uploadData() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)&#125;/** * 上传代码 压缩现有代码 */function uploadData() &#123; // 创建文件输出流 let output = fs.createWriteStream(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`) // 设置压缩级别 let archive = archiver(&#x27;zip&#x27;, &#123; zlib: &#123; level: 8, &#125;, &#125;) // 存档警告 archive.on(&#x27;warning&#x27;, function(err) &#123; if (err.code === &#x27;ENOENT&#x27;) &#123; console.warn(&#x27;stat故障和其他非阻塞错误&#x27;) &#125; else &#123; throw err &#125; &#125;) // 存档出错 archive.on(&#x27;error&#x27;, function(err) &#123; throw err &#125;) // 通过管道方法将输出流存档到文件 archive.pipe(output) archive.directory(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.buildobj&#125;`, &#x27;/&#x27;) archive.finalize() // 文件输出流结束 output.on(&#x27;close&#x27;, function() &#123; console.log(`总共 $&#123;(archive.pointer() / 1024 / 1024).toFixed(2)&#125; MB,完成源代码压缩`) ssh .putFile( `$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, `$&#123;config.uploadDir&#125;/$&#123;config.objname&#125;.zip` ) .then(() =&gt; &#123; console.log(&#x27;程序zip上传成功,判断线上是否需要备份&#x27;) runcmd() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;)&#125;/** * 执行ssh命令 判断当前是否存在备份 */function runcmd() &#123; ssh .execCommand(&#x27;ls&#x27;, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stdout) &#123; let fileList = res.stdout.split(&#x27;\\n&#x27;) if (config.objname == config.backObject) &#123; if (fileList.includes(config.objname)) &#123; console.log(&#x27;当前更新为线上正常环境,开始进行备份&#x27;) backupData() &#125; else &#123; console.log(&#x27;当前更新为线上正常环境,并且是第一次,将跳过备份&#x27;) cmdunzip() &#125; &#125; else &#123; console.log(&#x27;当前为测试环境,无需备份,直接解压上传压缩包&#x27;) cmdunzip() &#125; &#125; else if (res.stderr) &#123; console.log(&#x27;查询指定目录失败&#x27;) &#125; else &#123; console.log(&#x27;ssh链接发生了错误&#x27;) &#125; &#125;)&#125;/** * 备份项目 */function backupData() &#123; ssh .execCommand(`mv $&#123;config.objname&#125; backup/$&#123;config.objname&#125;_backup$&#123;new Date().getTime()&#125;`, &#123; cwd: config.uploadDir, &#125;) .then((res) =&gt; &#123; if (res.stderr) &#123; console.log(&#x27;备份发生错误&#x27;, res.stderr) &#125; else &#123; console.log(&#x27;完成备份,解压最新代码&#x27;) cmdunzip() &#125; &#125;) .catch((err) =&gt; &#123; console.log(&#x27;备份发生未知链接错误&#x27;, err) &#125;)&#125;/** * 解压最新代码zip */function cmdunzip() &#123; // 解压程序 ssh .execCommand( `rm -rf $&#123;config.objname&#125; &amp;&amp; unzip -o -d $&#123;config.uploadDir&#125;/$&#123;config.objname&#125; $&#123;config.objname&#125;.zip &amp;&amp; rm -f $&#123;config.objname&#125;.zip`, &#123; cwd: config.uploadDir, &#125; ) .then(() =&gt; &#123; console.log(`项目包完成解压,$&#123;config.objname&#125;项目部署成功了!`) console.log(`项目更新时长$&#123;(new Date().getTime() - startTime.getTime()) / 1000&#125;s`) return deletelocalFile().then(() =&gt; &#123; console.log(&#x27;本地缓存zip清除完毕&#x27;) &#125;) &#125;) .then(() =&gt; &#123; ssh .execCommand(`rm -rf $&#123;config.objname&#125;/static/.DS_Store`, &#123; cwd: config.uploadDir, &#125;) .then(() =&gt; &#123; console.log(&#x27;线上项目.DS_Store删除完成&#x27;) ssh.dispose() process.exit(0) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125;) .catch((err) =&gt; &#123; console.log(&#x27;解压出现错误&#x27;, err) &#125;)&#125;/** *删除本地生成的压缩包 */function deletelocalFile() &#123; return new Promise((resolve, reject) =&gt; &#123; fs.unlink(`$&#123;path.join(__dirname, &#x27;../&#x27;)&#125;$&#123;config.buildPath&#125;/$&#123;config.objname&#125;.zip`, (err) =&gt; &#123; if (err) &#123; reject(err) throw err &#125; else &#123; resolve() &#125; &#125;) &#125;)&#125; 配置文件upload.config.js 123456789101112131415161718192021222324// 打包核心配置文件let Available = [&#x27;dist-a&#x27;, &#x27;dist-b&#x27;] // dist-a 环境a代码包 dist-b 环境b代码包 npm run upload dist-a/** * 获取更新配置 * @param &#123;String&#125; objName 当前更新名称 * @returns */module.exports = (objName) =&gt; &#123; if (!Available.includes(objName)) &#123; console.log(&#x27;当前项目不存在您输入的更新命令,请检查更新名称&#x27;) process.exit(0) &#125; return &#123; host: &#x27;xx.xx.xx.xx&#x27;, // 服务器地址 username: &#x27;root&#x27;, password: &#x27;xxxxxxxxxx&#x27;, buildPath: &#x27;&#x27;, // 本地打包项目地址(多层路径用这个) buildobj: &#x27;dist&#x27;, // 本地打包文件名称 uploadDir: &#x27;/xx/xx/xx&#x27;, // 服务端项目地址 objname: objName, // 打包项目名称 backObject: &#x27;objName&#x27;, // 备份的文件夹名称 buildScript: &#x27;npm run build&#x27; // 更新命令 &#125;&#125; 触发命令最后在package.json增加一行命令，运行前面的脚本文件 1234&quot;scripts&quot;: &#123; // ...... &quot;upload&quot;: &quot;node build/upload.js&quot; &#125;, 依赖版本​ 因为更新脚本是在项目里面的，所以需要额外安装依赖 推荐版本号 123&quot;node-ssh&quot;: &quot;^12.0.0&quot;,&quot;inquirer&quot;: &quot;^7.3.3&quot;,&quot;archiver&quot;: &quot;^3.1.1&quot;, 实际使用1npm run upload xxxx // 线上代码文件夹名称 upload 命令后面的字符串就是服务器上的文件夹名称，这里为了防止更新命名敲错了，需要首先在upload.config.js中进行更新白名单声明，如果配置都正确的情况下，你就可以看到，这就代表成功了~ 最后​ 脚本文件还存在很高的上限，可以优化一下备份部分的备份代码生成规则，再增加一个回滚代码的脚本，就可以实现线上的无感知回滚了 ​ 如果使用中遇到了什么问题，请到QQ群 530496237，一起吹吹水","categories":[{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"}]},{"title":"一些算法题","slug":"一些题目","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:35:23.778Z","comments":true,"path":"2021/03/22/一些题目/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/","excerpt":"","text":"题目 两个数组的交集思路： 在一个while循环中不断寻找两个链表的最小值，将其加入结果链表，同时该数据指针向后一位，结果链表也许要向后一位，假如while循环完成还存在某一个未处理的链表数据，直接加入到结果链表 https://leetcode-cn.com/problems/merge-two-sorted-lists/ 时间复杂度：O(n) 空间复杂度：O(1) 123456789101112131415161718192021222324252627282930/** * @param &#123;ListNode&#125; list1 * @param &#123;ListNode&#125; list2 * @return &#123;ListNode&#125; */var mergeTwoLists = function (list1, list2) &#123; let res = new ListNode(0) // 结果 let p0 = res; let p1 = list1 // 指针 let p2 = list2 // 指针 while (p1 &amp;&amp; p2) &#123; // 找到小的值,将其被指向p0,同时概念表后移一位 if (p1.val &lt; p2.val) &#123; p0.next = p1 p1 = p1.next &#125; else &#123; p0.next = p2 p2 = p2.next &#125; // 每次p0都会增加指向,,所以需要每次都手动指向最后一位 p0 = p0.next &#125; // p1或者p2其中一个还存在值,则全部消化掉 if (p1) &#123; p0.next = p1 &#125; else if (p2) &#123; p0.next = p2 &#125; return res.next&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://vkcyan.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树","slug":"二叉树","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:29:32.224Z","comments":true,"path":"2021/03/22/二叉树/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"一种分层数据的抽象模型，例如dom，菜单，树形控件，多层联动选择器 JavaScript中没有树，但是可以用Object和Array构建树 常见操作 深度&#x2F;广度有限遍历，先中后序遍历 二叉树: 树中的每个节点最多只能两个子节点，在JavaScript 中使用Object进行模拟 深度优先遍历含义： 尽可能深的搜索树的分支 12345// 深度优先遍历function inter1(tree) &#123; console.log(tree.value); tree.child.map(e =&gt; inter(e)) // 递归调用&#125; 广度优先遍历含义： 先访问离根节点最近的节点 12345678910111213// 广度优先遍历function inter2(tree) &#123; const q = [tree] // 使用队列存储广度数据 while (q.length &gt; 0) &#123; let c = q.shift() // 每次取队列最后一个 console.log(c.value); c.child.forEach(e =&gt; &#123; q.push(e) // 再次将下一层数据加入队列 &#125;) &#125;&#125;inter2(tree) 先序遍历二叉树定义：先根节点，后左子树，再右子树 123456789// 先序遍历function preorder(root) &#123; if (!root) &#123; return &#125; console.log(root.key); // 首先访问 preorder(root.left) preorder(root.right)&#125; 中序遍历二叉树定义：先左子树，后根节点，再右子树 123456789// 中序遍历function inorder(root) &#123; if (!root) &#123; return &#125; inorder(root.left) console.log(root.key); inorder(root.right)&#125; 后序遍历二叉树定义：先左子树，后右子树，再根节点 123456789// 后序遍历function postorder(root) &#123; if (!root) &#123; return &#125; postorder(root.left) postorder(root.right) console.log(root.key);&#125; 先序遍历二叉树（非递归）1234567891011121314// 先序遍历function preorder(root) &#123; if (!root) return const task = [root] while (task.length) &#123; const n = task.pop() console.log(n.key); if (n.right) task.push(n.right) if (n.left) task.push(n.left) // pop拿最后面的,数组需要保证后进先出,所以left放后面,这样每次循环都会优先使用left,直到left用完,就会用right,当前层级全部用完就会到更加深处或者右边的二叉树 &#125;&#125;preorder(bt) 中序遍历二叉树（非递归）123456789101112131415161718192021function inorder(root) &#123; if (!root) return const task = [] let p = root while (task.length || p) &#123; while (p) &#123; task.push(p) p = p.left &#125; const n = task.pop() console.log(n.key); p = n.right &#125;&#125;inorder(bt)// 首先找到最右边的全部节点,在从最左边开始递归// 在每次将右节点放入下一次循环,因为当前一定是中节点// 右节点完成后找上的中节点,中节点完成后找下右节点,完成二叉树的从左到右的覆盖// task存储所有左节点,当前阶段存在右节点的情况下,数组最后一位是右节点,下次一定会被抛出// p存储下一个右节点,开始下级树的查询 后序遍历二叉树（非递归）12345678910111213141516171819// 后序遍历(非递归)function postorder(root) &#123; if (!root) return const task = [root] const outputTask = [] while (task.length) &#123; const n = task.pop() outputTask.push(n.key) if (n.left) task.push(n.left) if (n.right) task.push(n.right) &#125; while (outputTask.length) &#123; let n = outputTask.pop() console.log(n); &#125;&#125;// 后序的顺序是 先右 再左 再中 首先倒叙先序遍历,获取先中 再左 再右// 最后倒序输出postorder(bt) 题目 二叉树的最大深度https://www.youtube.com/watch?v=H8SjbVxGB1c&amp;list=PLwIrqQCQ5pQmjH6YyFvH2A9FYL6bBB4Ra 时间复杂度：O(n) 空间复杂度：O(n) 思路：使用深度优先遍历（先序）,记录最大递归数量，最后返回 12345678910111213141516171819202122/** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function (root) &#123; let res = 0 /** * * @param &#123;*&#125; n 树 * @param &#123;*&#125; l 层级 */ const dfs = (n, l) =&gt; &#123; if (!n) return if (!n.left &amp;&amp; !n.right) &#123; res = Math.max(res, l) &#125; dfs(n.left, l + 1) dfs(n.right, l + 1) &#125; dfs(root, 1) return res&#125;; 题目 二叉树的最小深度时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历，同时记录当前层级，当遇到没有叶子节点，则说明找到最小深度，最后返回 12345678910111213141516171819/** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var minDepth = function (root) &#123; if (!root) return 0; let task = [ [root, 1] ] while (task.length) &#123; let [n, l] = task.shift() if (!n.left &amp;&amp; !n.right) &#123; return l &#125; if (n.right) task.push([n.right, l + 1]) if (n.left) task.push([n.left, l + 1]) &#125;&#125;; 题目 二叉树的层序遍历（广度遍历解法）https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历二叉树，同时记录当前层级，以层级为数组下标，完成层序遍历结果记录 12345678910111213141516171819202122/** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function (root) &#123; if (!root) return [] let task = [ [root, 0] ] let res = [] while (task.length) &#123; let [n, level] = task.shift() if (!res[level]) &#123; res.push([n.val]) &#125; else &#123; res[level].push(n.val) &#125; if (n.left) task.push([n.left, level + 1]) if (n.right) task.push([n.right, level + 1]) &#125; return res&#125;; 题目 二叉树的层序遍历（新陈代谢+广度遍历解法）https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：广度遍历二叉树，在遍历中，每次都将本层级全部遍历完成，再进行下一个层级的遍历，这样在同一个循环里面把当前数据都放入遍历结果的最后，循环累加完成结果记录 123456789101112131415161718192021/** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function (root) &#123; if (!root) return [] const q = [root] const res = [] while (q.length) &#123; let len = q.length res.push([]) // 每次while之前都把上一层的全部提出,下一层的全部记录下来 while (len--) &#123; const n = q.shift() res[res.length - 1].push(n.val) if (n.left) q.push(n.left) if (n.right) q.push(n.right) &#125; &#125; return res&#125;; 题目 二叉树的中序遍历(递归)https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function (root) &#123; const res = [] const rec = (n) =&gt; &#123; if (!n) return; rec(n.left) res.push(n.val) rec(n.right) &#125; rec(root) return res&#125;; 题目 二叉树的中序遍历(非递归)https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function (root) &#123; const res = [] const task = [] // 遍历数据 let p = root // 指针 while (task.length || p) &#123; // 找到所有左子树 while (p) &#123; task.push(p) p = p.left &#125; // 获取最后一个节点 初始化的时候都是左子树 后面可能为右子树 const n = task.pop() res.push(n.val) p = n.right &#125; return res&#125;; 题目 路径总和https://leetcode-cn.com/problems/path-sum/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：使用深度遍历所有节点的值，在这个过程中不断累加，直到遇到最底部节点，对比与目标是否一致，如果一致则说明有，没有则继续找 12345678910111213141516171819/** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;boolean&#125; */var hasPathSum = function (root, targetSum) &#123; if (!root) return false; let res = false const dfs = (n, s) =&gt; &#123; // console.log(n.val); if (!n.left &amp;&amp; !n.right &amp;&amp; targetSum == s) &#123; res = true &#125; if (n.left) dfs(n.left, s + n.left.val) if (n.right) dfs(n.right, s + n.right.val) &#125; dfs(root, root.val) return false&#125;; 深度优先遍历json的全部节点1234567891011121314151617const json = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;, d: [1, 2]&#125;function dfs(json, path) &#123; console.log(json, path); Object.keys(json).map(e =&gt; &#123; dfs(json[e], path.concat(e)) &#125;)&#125;dfs(json, [])","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图","slug":"图","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:30:58.074Z","comments":true,"path":"2021/03/22/图/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E5%9B%BE/","excerpt":"","text":"深度优先遍历12345678910111213141516171819const graph = &#123; 0: [1, 2], 1: [2], 2: [0, 3], 3: [3]&#125;let visited = new Set() // 存储已经被访问数据const dfs = (n) =&gt; &#123; console.log(n) visited.add(n) graph[n].forEach(e =&gt; &#123; if (!visited.has(e)) &#123; dfs(e) // 未访问数据继续递归 &#125; &#125;)&#125;dfs(2) // 确定起点 广度优先遍历12345678910111213let visited = new Set() // 存储已经被访问过的数据visited.add(2) // 增加起点值let q = [2] // 设定起点while (q.length) &#123; let n = q.shift() // 弹出开头的 console.log(n); graph[n].map(e =&gt; &#123; if (!visited.has(e)) &#123; // 不存在才遍历节点 q.push(e) visited.add(e) &#125; &#125;)&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"字典","slug":"字典","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:31:40.870Z","comments":true,"path":"2021/03/22/字典/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E5%AD%97%E5%85%B8/","excerpt":"","text":"与集合类似，字段也是一种存储唯一值的数据结构吗，但是他是以键值对的形式来存储 ES6中增加了字段，也就是Map 123456789let a = new Map([ // 默认值 [&#x27;a&#x27;, &#x27;aa&#x27;]])a.set(&#x27;b&#x27;, &#x27;bb&#x27;) // 加入值a.delete(&#x27;b&#x27;, &#x27;bb&#x27;) // 删除a.set(&#x27;a&#x27;, &#x27;aaa&#x27;) // 替换值console.log(a.get(&#x27;a&#x27;), a.get(&#x27;b&#x27;)); // 读取值 题目 两个数组的交集时间复杂度：O(n) 空间复杂度：O(n) 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; // 集合的方式 // return [...new Set(nums1.filter(e =&gt; nums2.includes(e)))] // 字典的方式 const map = new Map(); nums1.forEach(e =&gt; &#123; map.set(e, true) &#125;) const res = [] nums2.map(e =&gt; &#123; if (map.get(e)) &#123; res.push(e) map.delete(e) &#125; &#125;) return res&#125;; 题目 有效的括号时间复杂度：O(n) 空间复杂度：O(n) 12345678910111213141516171819202122232425/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function (s) &#123; const stack = [] var map = new Map([ [&#x27;(&#x27;, &#x27;)&#x27;], [&#x27;&#123;&#x27;, &#x27;&#125;&#x27;], [&#x27;[&#x27;, &#x27;]&#x27;], ]) for (let i = 0; i &lt; s.length; i++) &#123; if (map.has(s[i])) &#123; stack.push(s[i]) &#125; else &#123; if (map.get(stack[stack.length - 1]) === s[i]) &#123; stack.pop() &#125; else &#123; return false &#125; &#125; &#125; return stack.length === 0&#125;; 题目 两数之和时间复杂度：O(n) 空间复杂度：O(n) 思路： 循环中每次判断map中，是否存在匹配项，如果没有，加入到map中，等到被匹配，如果匹配到了，直接返回被匹配到的与当前元素 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123; let map = new Map() for (let i = 0; i &lt; nums.length; i++) &#123; let e = nums[i] let n = target - e if (map.has(n)) &#123; return [map.get(n), i] &#125; else &#123; map.set(e, i) &#125; &#125;&#125;; 题目 无重复字符的最长子串时间复杂度：O(n) 空间复杂度：O(n) 思路：使用双指针 + 字典的方式实现，就像剪切视频时候的滑动窗口一张 右边指针不断向前，每次向前的时候，判断当前窗口中是否存在已有元素，如果存在，就将左边指针调整到存在的问题 同时每次都判断滑动窗口的长度，最终获取到最长子串 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function (s) &#123; let res = 0 // 最长长度 let a = 0 // 滑动窗口起点 const map = new Map() // 存储字符的字典 for (let b = 0; b &lt; s.length; b++) &#123; const e = s[b]; if (map.has(e) &amp;&amp; map.get(e) &gt;= a) &#123; // 如果存在重复元素 // 如果是abba 这样的情况,需要防止滑动窗口起始点变小,已经在滑动窗口外面了,不应当考虑 a = map.get(e) + 1 // 滑动窗口左边前进一位 &#125; map.set(e, b) // 存储当前值的最后的下标 用于下次计算起始点 res = Math.max(res, b - a + 1) // 当前长度与已知最大长度 &#125; return res&#125; 题目 最小覆盖子串（困难）https://leetcode-cn.com/problems/minimum-window-substring/ 时间复杂度：O(n2) 空间复杂度：O(n) 思路: 采用字典 + 双指针滑动窗口来实现最小覆盖子串的查找，因为题目不限制子串被覆盖的顺序，所以首先将子串通过Map结构转化为 数值:数量（abc &#x3D;&gt; {‘a’ &#x3D;&gt; 1,’b’ &#x3D;&gt; 1,’c’ &#x3D;&gt; 1 }） ​ 完成了Map的构建后，开始滑动右指针，知道map中数据都为0，代表当前滑动窗口覆盖了最小子串，这时候再开始左指针的滑动，知道左指针当前值在Map中，代表已经无法覆盖最小子串，此时左指针停止，再次开始滑动右指针，再次进入循环 ​ 最后在每次滑动左边指针的时候，截取当前的最小覆盖子串，最后得到最小覆盖子串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;string&#125; */ var minWindow = function (s, t) &#123; // 最小子串大于字符串s，毕竟不存在最小子串，直接返回空 if(t.length &gt; s.length) &#123; return &#x27;&#x27; &#125; let start = 0 // 指针开头 let end = 0 // 指针结尾 let result = &#x27;&#x27; // 存储最小覆盖子串 const need = new Map() // 存储最小子串数据 for (let i = 0; i &lt; t.length; i++) &#123; const e = t[i]; need.set(e, need.has(e) ? need.get(e) + 1 : 1) &#125; // need 为 &quot;ABC&quot; =&gt; &#123;&#x27;A&#x27; =&gt; 1,&#x27;B&#x27; =&gt; 1,&#x27;C&#x27; =&gt; 1 &#125; let needType = need.size // 最小子串的长度,用于记录滑动窗户口还未包含几位数 // 先走后指针 while (end &lt; s.length) &#123; const c = s[end] // 滑动窗口右边向前 if (need.has(c)) &#123; // 判断当前元素是否在map中 need.set(c, need.get(c) - 1) // 如果在map中,其值减1 if (need.get(c) == 0) &#123; // 如果当前值,在map中为0了,说明当前滑动窗口包含了当前值的所有数量 // 所以对记录map数量的数值再减1 needType -= 1 &#125; &#125; // 如果needType为0了,说明次数滑动窗口已经包含所有子串 while (needType === 0) &#123; // 获取当前子串 let carry = s.substring(start, end + 1) // 对比存储子串与当前子串,获取最小的 if (result == &#x27;&#x27; || result.length &gt; carry.length) &#123; result = carry &#125; const c2 = s[start] if (need.has(c2)) &#123; // 判断当前元素是否在map中,在,这说明某个值移出了,此时已经不是最小子串,因此map中的当前值,+1 // 因为去除了存在的值,当前子串已经不符合标准,needType记录值+1 // 左指针停止,开始右指针行动,知道它再次覆盖了子串 need.set(c2, need.get(c2) + 1) if (need.get(c2) === 1) &#123; needType += 1 &#125; &#125; start += 1 // 左指针前进 &#125; end += 1 // 右指针前进 &#125; return result&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"排序算法","slug":"排序算法","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:30:20.272Z","comments":true,"path":"2021/03/22/排序算法/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序先找最大，从右到左 时间复杂度：O(n2) 空间复杂度：O(n) 思路：内层循环通过依次比较，将最大值放到最后面，在此基础上增加外部循环，每次外部循环都会排除已经完成排序的下标，再算出最大值，并放到排除已经排序的数组最后 1234567891011121314151617181920/** * 冒泡排序 * @param &#123;Array&#125; arr * @returns */function bubbleSort(arr) &#123; for (let j = 0; j &lt; arr.length - 1; j++) &#123; // 为什么循环体减1,因为循环体里面是当前的比较后一个,不减1,就会溢出 // 减去j是为了减少无意义的循环次数 for (let i = 0; i &lt; arr.length - 1 - j; i++) &#123; // 比较当前的与后一个大小,前面的大则换位子 if (arr[i] &gt; arr[i + 1]) &#123; let temp = arr[i] arr[i] = arr[i + 1] arr[i + 1] = temp &#125; &#125; &#125; return arr&#125; 选择排序先找最小，从左到右 时间复杂度：O(n2) 空间复杂度：O(n) 思路：内层循环每次找到最小的下标并放到数组最前面，再此基础上增加外部循环，外部循环每次以循环下标为坐标，寻找最小值换位到坐标中，一次完成排序 123456789101112131415161718192021/** * 选择排序 * @returns */function selectionSort() &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; let indexMin = i for (let j = i; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[indexMin]) &#123; indexMin = j &#125; &#125; if (indexMin != i) &#123; // 最小值就是自己,不需要交换 let temp = arr[i] arr[i] = arr[indexMin] arr[indexMin] = temp &#125; &#125; return arr&#125; 插入排序从第二开始，依次从右到左开始比较最小值 时间复杂度：O(n2) 空间复杂度：O(n) 思路：从第二位开始，和前面的进行比较，如果前面的大于后面，则后面的等于前面的，继续向前找，如果找到了前面的小于后面都，则停止查找，覆盖该下标，如果到最开始都没有找到最小的，则将第一位变成比较值 123456789101112131415161718192021222324/** * 插入排序 * @param &#123;*&#125; arr * @returns */function inSetrSort(arr) &#123; // 从第二位开始 for (let i = 1; i &lt; arr.length; i++) &#123; let j = i let temp = arr[j] while (j &gt; 0) &#123; if (temp &gt; arr[j - 1]) &#123; // 如果当前值大于前一个值,直接弹出,并且得知插入位置 break &#125; // 如果当前值小于前一个值,当前值就等于前一个字 arr[j] = arr[j - 1] j-- &#125; // 在弹出的下标填入缓存的值 arr[j] = temp &#125; return arr&#125; 归并排序难度较大，后续再看 快速排序难度较大，后续再看 顺序搜索在目标函数中寻找目标值，找不到则返回-1 时间复杂度：O(n) 123function searchSort(list, carry) &#123; return list.findIndex(e =&gt; e == carry)&#125; 二分搜索针对有序数组的单项查找方法，找到会返回下标，未找到则返回-1，他的性能要高于顺序搜索，每次搜索都会将现有数组批成两半 时间复杂度：O(logN) 1234567891011121314151617181920let bin = [1, 2, 3, 4, 5, 6, 7, 8, 9]function binarySearch(list, carry) &#123; let low = 0 let high = list.length - 1 while (low &lt;= high) &#123; const mid = Math.floor((low + high) / 2) const ele = list[mid] if (carry &gt; ele) &#123; low = mid + 1 &#125; else if (carry &lt; ele) &#123; high = mid - 1 &#125; else if (carry == ele) &#123; return mid &#125; &#125; return -1&#125;console.log(binarySearch(bin, 1));","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://vkcyan.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈","slug":"栈","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:31:29.618Z","comments":true,"path":"2021/03/22/栈/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E6%A0%88/","excerpt":"","text":"一个后进先出的数据结构,例如蜂窝煤，先放进去的蜂窝煤是被后拿出来的，后放进去的先拿出来，放进去（push）拿出来（pop） JavaScript虽然没有栈，但是可以通过array进行实现 123456const stack = []stack.push(1)stack.push(2)const item1 = stack.pop()const item2 = stack.pop() 题目 有效括号https://leetcode-cn.com/problems/valid-parentheses/ 思路：使用栈的特性实现 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var obj = &#123; &#x27;(&#x27;: &#x27;)&#x27;, &#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;[&#x27;: &#x27;]&#x27;&#125;var isValid = function (s) &#123; if (s.length % 2 === 1) &#123; return false &#125; const stack = [] for (let i = 0; i &lt; s.length; i++) &#123; if (obj[s[i]]) &#123; stack.push(s[i]) &#125; else &#123; if (obj[stack[stack.length - 1]] === s[i]) &#123; stack.pop() &#125; else &#123; return false &#125; &#125; &#125; return stack.length === 0&#125;; 函数调用堆栈","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"链表","slug":"链表","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:29:59.298Z","comments":true,"path":"2021/03/22/链表/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表数组：增加或者删除非首尾元素时，需要移动元素 链表：增加或者删除非首尾元素时，不需要移动元素，只需要修改其next的指向即可 注： JavaScript 没有链表结构，所以我们需要用Object来模拟链表 题目 删除链表中的节点https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 时间复杂度：O(1) 空间复杂度：O(1) 12345678/** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function (node) &#123; node.val = node.next.val // 将自己变成别人 node.next = node.next.next // 干掉别人，达到自己消失的目的&#125;; 题目 反转链表https://leetcode-cn.com/problems/reverse-linked-list/ 时间复杂度：O(n) 空间复杂度：O(1) &#x2F;&#x2F; p2里面都是p1的，所以不是新内存，temp因为是单个值，不是数组与矩阵，所以是O(1) 思路：每次循环的时候首先保存之后的链表，再讲当前链表指向新的链表，最后循环”之后的链表“，进而实现 123456[1,2,3,4,5] =&gt; [][2,3,4,5] =&gt; [1][3,4,5] =&gt; [1,2][4,5] =&gt; [1,2,3][5] =&gt; [1,2,3,4][] =&gt; [1,2,3,4,5] 写法1 双指针123456789101112131415/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; let p1 = head // 链表 let p2 = null while (p1) &#123; const temp = p1.next // 首先保存当前的下一个指针 p1.next = p2 // 将当前指针指向新链表 p2 = p1 // 替换之前的链表 [] =&gt; [1] =&gt; [2,1] =&gt; [3,2,1] p1 = temp // 为了下次循环,将下一个链表给p1(本次循环的已经被弹出) [1,2,3] =&gt; [2,3] =&gt; [3] &#125; return p2 // 返回反转后的链表&#125;; 写法2 递归123456789101112131415161718/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; // 递归写法 return reverse(null, head)&#125;;function reverse(now, old) &#123; if (!old) &#123; // 老数据没了,递归反转完成 return now &#125; let temp = old.next // 首先保存链表(除了自己) old.next = now // 将当前指针指向新链表 return reverse(old, temp) // 将2个链表再执行一遍&#125; 题目 两数相加https://leetcode-cn.com/problems/add-two-numbers/ 时间复杂度：O(n) 空间复杂度：O(n) 思路：同时循环两个链表，在将数据放入一个新的链表中，对十位数需要进行额外的处理 12345678910111213141516171819202122232425262728/** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function (l1, l2) &#123; let all = new ListNode(0) // 新建空链表 let three = all // 向新链表追加元素是需要指针,直接用all,链表头就没了 let carry = 0 // 记录超出的十位数 while (l1 || l2) &#123; // 同时循环2个链表 let val = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry // 同位数相加,并且加上上一位的超出的十位数 carry = Math.floor(val / 10) // 获取超出的十位数 three.next = new ListNode(val % 10) // 记录当前的余数 three = three.next // 指向下一个链表 if (l1) &#123; // 2个链表长度不一致,需要判断 l1 = l1.next &#125; if (l2) &#123; l2 = l2.next &#125; &#125; // 最后一位可能存在余数 if (carry) &#123; three.next = new ListNode(carry) three = three.next &#125; return all.next&#125;; 题目 删除排序链表中的重复元素https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 时间复杂度：O(n) 空间复杂度：O(1) 思路：遇到同样的，删除自己，没遇到，指针向后一位 1234567891011121314151617/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var deleteDuplicates = function (head) &#123; let all = head // 当前指针 while (all &amp;&amp; all.next) &#123; if (all.val == all.next.val) &#123; // 和下个一个节点一致,删除本阶段 all.next = all.next.next &#125; else &#123; // 没有重复的,指针到下一个 all = all.next &#125; &#125; return head&#125; 题目 环形链表https://leetcode-cn.com/problems/linked-list-cycle/ 题目解析: 给定一个特殊的链表，链表的最后一位再次指向链表中的某一个，这样会形成一个环，pos参数是未知的，通过算法判断该链表是否有环 写法1 特殊值法时间复杂度:O(n) 空间复杂度：O(1) 特殊值一定要保证不能在链表中出现 12345678910111213141516171819202122/** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; let all = head; while(all) &#123; // 定一个特殊值，将遇到的每一项都变成这个特殊值 // 如果有遇到了，就说明是存在环 if(all.val == &#x27;123456789&#x27;) &#123; all = null return true &#125; else &#123; all.val = &#x27;123456789&#x27; all = all.next &#125; &#125; // 如果一次都没遇到这说明没有环 return false&#125;; 写法2 快慢指针 为什么快指针与慢指针一定会相遇? 一旦快指针进入环中，每次都离慢指针进一步，因为到了追上的时候，要么相隔1步，下一步相遇，要么相隔2步，下下次一定相遇 快指针与慢指针相遇的时候，慢指针是否绕环超过了一圈 不会，假设环长为N，环外长度为n，N一定大于n；并且根据第一题可知每次快指针都距离慢指针进一步，所以N与n最终会距离n，所以N&gt;n 时间复杂度:O(n) 空间复杂度：O(1) 12345678910111213141516/** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; let p1 = head let p2 = head while(p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123; p1 = p1.next p2 = p2.next.next if(p1 === p2) &#123; return true &#125; &#125; return false&#125;; JavaScript原型链123obj -&gt; Object.prototype -&gt; null // 对象func -&gt; Function.prototype -&gt; Object.prototype -&gt; null // 方法arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null // 数组 如果A沿着原型链能找到B.protype，那么 A instanceof B一定为true 如果A对象上面没有找到X属性，那么就会沿着原型链找到X属性 例如：Object.prototype.x &#x3D; ‘x’,那么函数func.x也会为x,因为Function.prototype指向Object.prototype instanceof如何实现？（遍历原型链） 遍历链表，寻找是否存在一致的 12345678910function instanceOf(params, type) &#123; let p = params while (p) &#123; if (p === type.prototype) &#123; return true &#125; p = p.__proto__ &#125; return false&#125; 应用 使用链表获取json的值 在知道全部键的情况下，或者说知道json中数据的的某个值，可以使用链表，嵌套for过于暴力 123456789101112131415const json = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;&#125;const path = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]let p = jsonpath.map(e =&gt; &#123; p = p[e]&#125;)console.log(p); 总结 链表中的元素不是连续的，而是通过next指针连接的 JavaScript没有链表，但是Object可有模拟链表 常用操作：遍历链表，修改链表next JavaScript的原型链也是链表，使用__proto__进行连接","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"队列","slug":"队列","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:29:20.293Z","comments":true,"path":"2021/03/22/队列/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E9%98%9F%E5%88%97/","excerpt":"","text":"一个先进先出的数据结构，先放进去的后拿出来，先进先出，保持有序 JavaScript中虽然没有队列但是可以通过array进行实现 123456const stack = []stack.push(1)stack.push(2)const item1 = stack.shift()const item2 = stack.shift() 题目 最近请求次数https://leetcode-cn.com/problems/number-of-recent-calls/ 思路： 使用栈实现 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415var RecentCounter = function () &#123; this.q = []&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function (t) &#123; this.q.push(t) while (this.q[0] + 3000 &lt; t) &#123; this.q.shift() &#125; return this.q.length&#125;; 事件循环于任务队列 ​ 如果执行事件的过程中，如果遇到了异步任务，比如dom操作，ajax，setTimeout，就会将事件交给webApi执行， 不会加入任务队列 ​ 直到异步任务结束，回调函数加入任务队列，如果回调函数里面还有异步任务，就继续做放入wenAPI里面做事件循环","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"集合","slug":"集合","date":"2021-03-21T16:00:00.000Z","updated":"2022-05-23T08:29:44.105Z","comments":true,"path":"2021/03/22/集合/","link":"","permalink":"https://vkcyan.github.io/2021/03/22/%E9%9B%86%E5%90%88/","excerpt":"","text":"一种无序且唯一的数据结构 ES6增加了集合，Set 常用操作：去重 判断是否在集合中，求交集，差集 123456789101112// 去重const arr = [1,2,3,4,4,4,4]const arr2 = [...new Set(arr)]// 判断是否在集合中const set = new Set(arr)const has = set.has(2)// 求交集const set1 = new Set([1,2,3,4])const set2 = new Set([3,4,5,6])const set3 = new Set([...set1].filter(e =&gt; set2.has(e))) // 将其中一个变成数组，另一个has，最终结果转为Set 题目 两个数组的交集https://leetcode-cn.com/problems/intersection-of-two-arrays/ 时间复杂度：O(n^2) 空间复杂度：O(1) 12345678/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; return [...new Set(nums1.filter(e =&gt; nums2.includes(e)))]&#125;; JavaScript中Set的一些操作1234567891011121314151617181920212223242526let my = new Set()my.add(1) // 正常加入my.add(2) // 正常加入my.add(2) // set保证不会重复,依旧只有一个2my.add(&#x27;313&#x27;) // 正常加入let o = &#123; a: 1&#125;my.add(o) // 正常加入my.add(&#123; // 正常加入 a: 1&#125;)const has1 = my.has(&#123; a: 1&#125;) // 返回false 引用类型不在内存的同一个地方const has2 = my.has(o) // 返回true console.log(has1);my.delete(1) // 正常删除for (const item of my) &#123; // 迭代函数 这个不使用my 使用my.values my.keys 都可以 都是一样的 console.log(item);&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"类目","slug":"类目","permalink":"https://vkcyan.github.io/categories/%E7%B1%BB%E7%9B%AE/"},{"name":"JavaScript-2022","slug":"JavaScript-2022","permalink":"https://vkcyan.github.io/categories/JavaScript-2022/"},{"name":"杂谈","slug":"杂谈","permalink":"https://vkcyan.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"日常开发","slug":"日常开发","permalink":"https://vkcyan.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/categories/JavaScript/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"https://vkcyan.github.io/categories/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"},{"name":"随想集","slug":"随想集","permalink":"https://vkcyan.github.io/categories/%E9%9A%8F%E6%83%B3%E9%9B%86/"},{"name":"产品经理","slug":"产品经理","permalink":"https://vkcyan.github.io/categories/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"},{"name":"移动端","slug":"移动端","permalink":"https://vkcyan.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"JavaScript-2021","slug":"JavaScript-2021","permalink":"https://vkcyan.github.io/categories/JavaScript-2021/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://vkcyan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://vkcyan.github.io/tags/%E6%A0%87%E7%AD%BE/"},{"name":"Hexo","slug":"Hexo","permalink":"https://vkcyan.github.io/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://vkcyan.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"价值观","slug":"价值观","permalink":"https://vkcyan.github.io/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"},{"name":"移动端","slug":"移动端","permalink":"https://vkcyan.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"兼容性","slug":"兼容性","permalink":"https://vkcyan.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"设计模式","slug":"设计模式","permalink":"https://vkcyan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"无障碍","slug":"无障碍","permalink":"https://vkcyan.github.io/tags/%E6%97%A0%E9%9A%9C%E7%A2%8D/"},{"name":"随选朗读","slug":"随选朗读","permalink":"https://vkcyan.github.io/tags/%E9%9A%8F%E9%80%89%E6%9C%97%E8%AF%BB/"},{"name":"童年","slug":"童年","permalink":"https://vkcyan.github.io/tags/%E7%AB%A5%E5%B9%B4/"},{"name":"随想","slug":"随想","permalink":"https://vkcyan.github.io/tags/%E9%9A%8F%E6%83%B3/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://vkcyan.github.io/tags/JavaScript/"},{"name":"低代码","slug":"低代码","permalink":"https://vkcyan.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"h5装修","slug":"h5装修","permalink":"https://vkcyan.github.io/tags/h5%E8%A3%85%E4%BF%AE/"},{"name":"Vue3","slug":"Vue3","permalink":"https://vkcyan.github.io/tags/Vue3/"},{"name":"关于C端","slug":"关于C端","permalink":"https://vkcyan.github.io/tags/%E5%85%B3%E4%BA%8EC%E7%AB%AF/"},{"name":"产品日常","slug":"产品日常","permalink":"https://vkcyan.github.io/tags/%E4%BA%A7%E5%93%81%E6%97%A5%E5%B8%B8/"},{"name":"vue3","slug":"vue3","permalink":"https://vkcyan.github.io/tags/vue3/"},{"name":"webpack5","slug":"webpack5","permalink":"https://vkcyan.github.io/tags/webpack5/"},{"name":"响应式","slug":"响应式","permalink":"https://vkcyan.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"vw","slug":"vw","permalink":"https://vkcyan.github.io/tags/vw/"},{"name":"NPDP","slug":"NPDP","permalink":"https://vkcyan.github.io/tags/NPDP/"},{"name":"算法","slug":"算法","permalink":"https://vkcyan.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://vkcyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}