<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vkcya Blog</title>
  
  
  <link href="https://bluedancers.github.io/atom.xml" rel="self"/>
  
  <link href="https://bluedancers.github.io/"/>
  <updated>2023-11-27T03:15:31.259Z</updated>
  <id>https://bluedancers.github.io/</id>
  
  <author>
    <name>bluedancers</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正确的理解技术，可以让我们走的更远</title>
    <link href="https://bluedancers.github.io/2023/11/25/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C/"/>
    <id>https://bluedancers.github.io/2023/11/25/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C/</id>
    <published>2023-11-24T16:00:00.000Z</published>
    <updated>2023-11-27T03:15:31.259Z</updated>
    
    <content type="html"><![CDATA[<p>​我们小时候都听过这样的一个故事，</p><p>​为什么大家都说35岁是技术岗的危机，甚至现在还出现了更加提前的趋势，30岁危机就已经出现。在本文开始之前，我也先丢几个问题给大家，一起思考一下以下现象的原因是什么？</p><ul><li>软件开发是否是劳动密集型行业？</li><li>为什么在中国，为何倾向于更加年轻的程序员，多年经验的程序员反而越发艰难？</li><li>当程序员们意识到危机的时候，他们遇到了什么挑战？</li><li>如何应对程序员的”35岁危机”？</li></ul><p>​接下来我来谈一谈我这6年对技术的理解的变化，以及学习与适应变化的过程，从中我们一起寻找上述问题的答案。</p><p>​</p><h2 id="技术是代码（0-3年）"><a href="#技术是代码（0-3年）" class="headerlink" title="技术是代码（0-3年）"></a>技术是代码（0-3年）</h2><blockquote><p>那时候我就像是一个在技术的门外不断窥探的孩子，迷茫、思索，不断寻找属于我的自己的打开技术大门的钥匙。</p></blockquote><p>​当我在大学中刚开始接触代码的时候，我和大多数人一样苦于如何完成老师的课后作业，回想起来，我对技术这个词的理解非常直观，<strong>技术就是代码</strong>，要如何做好一名合格的技术呢？多多学习与理解代码。实话说，谈不上有写代码的天赋，大学中学的第一个语言课是C语言，学的也比较糟糕，后来慢慢培养了一点技术思维，学java的时候又败给了面向对象。</p><p>​我时常为自己的天赋平庸而烦恼。如果技术就是代码，那时候我的技术能力简直就是灾难。</p><p>​上帝还是给了我机会，偶然之间让我接触到了JavaScript，这并不是学校授课的语言，以面向过程的的JavaScript（ES5）中，我找到了突破点，顺着这条藤蔓，我找到了适合我的对技术的打开方式，技术思维逐渐被打开，以前不理解种种逻辑，面向对象、指针，也很自然的就理解了。</p><p>​再后来参加全国比赛，凭借兴趣与努力不断学习，逐渐成为我们计院的top，这才算走上了代码这条路。</p><p>​在工作的前2年，我始终都有一个明确的理念，<strong>技术 &#x3D; 代码</strong>，要想技术进步，像成为更加厉害的程序员，就要拼命写代码，所以我继续坚持知行合一，延续了在学校比赛时期的作息时间，工作时间外，晚上也继续学习技术，我非常积极的接触所有前端范畴的技术的上的工作，主动挑战任何技术难点，我始终坚信，我代码写的好不好，是评价我技术的唯一标准。</p><p>​就这样，在我写代码的前3年我几乎把前端范畴中能接触的所有技术，都学习了一遍，而对于重要的技术，也会重点学习与了解，通常会想方设法的了解实现原理；同时坚持费曼学习法，保持输出的习惯，这些年我的juejin博客的阅读量也还不错，大部分文章的内容也还说得过去。</p><p>​在头三年，我的收入和大家对我的认同都肉眼可见的不断增加了，但是我内心的疑惑却越来越大。</p><p>​有一天晚上我在公司无所事事，学习ng，在学习的过程中，我就开始思考起来了，学习ng对我而言真的有价值吗？</p><p>​公司不可能用ng的技术栈，不好招人、国内生态差、文档不友好，那在学习ng的过程中我能了解到什么？ng的一些编程思想，企业级的项目架构；可是我没有应用场景，怎么能有深刻的理解？自那之后我在学习技术的时候我都会开始思考，我花这么多时间去学习这些我用不到的技术，我又不可能用上所有我学到的技术，随着知识慢慢被遗忘或者过期，机会成本是不是太高了？</p><p>​我们时常说，技术为业务服务，若是学习的技术并没有在实际业务中发挥作用，没有让开发效率更高，没有让软件的速度更快，那岂不就是没用的技术。后来我转变了思路，我觉得不在走马观花的学习，我决定打技术的纵深。</p><p>​后来我看了axios、promise、vue2.x、vuex的源码，非常遗憾，这给我了当头一击，源码的复杂程度超乎我的现象，首先是个人完全不具备独立阅读源码的能力，在阅读的过程中，我需要搭配别人的博客，以及源码解读视频才能理解其核心逻辑，在那一段时间，逐渐开始明白了，去追求成为顶尖的开发者是不现实的，并不是说退缩了，而是认清现实后的最优选择。</p><p>​另一方面我还是要为阅读源码正名，这个确实有用，这就像数学公式一样，不理解原理就只能背诵，照搬硬套，但了解原理后，就能解释很多为什么，开发的能力得到很大的加强。</p><p>​那段时间和我老板谈论了很多，老板通过各种例子向我说明技术本身是没有价值的，是业务体现了技术的价值，那时候我对这句话依旧是半知半解，但是我还是找到了一条路，就是<strong>既然技术的最终呈现方式是业务，我直接关注业务不就好了？</strong></p><h2 id="技术是需求（3-5）"><a href="#技术是需求（3-5）" class="headerlink" title="技术是需求（3-5）"></a>技术是需求（3-5）</h2><p>​业务的落地由多个角色协作完成，后端、ui、运营、产品、项目经理，因为大学期间学习了经济学相关知识，并且对此一直很感兴趣，我选择了与前端最贴近的产品角色。同时再公司，我也走向了基层管理岗位，前端组长。</p><p>​也就是说在这个阶段，我不仅需要关注技术，还需要关注需求、管理，我对此非常庆幸，因为我找到了下一个增长的切入点。</p><p>​如何平衡 技术与其他工作？</p><p>​如何学习产品相关知识？</p><p>​</p><h2 id="技术是产品（5-？）"><a href="#技术是产品（5-？）" class="headerlink" title="技术是产品（5-？）"></a>技术是产品（5-？）</h2><h2 id="技术是？"><a href="#技术是？" class="headerlink" title="技术是？"></a>技术是？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	我们小时候都听过这样的一个故事，&lt;/p&gt;
&lt;p&gt;​	为什么大家都说35岁是技术岗的危机，甚至现在还出现了更加提前的趋势，30岁危机就已经出现。在本文开始之前，我也先丢几个问题给大家，一起思考一下以下现象的原因是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件开发是否是劳动密集型行</summary>
      
    
    
    
    <category term="关于程序员" scheme="https://bluedancers.github.io/categories/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
    <category term="记录" scheme="https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(3) - 从游戏名词到电商营销，我们一起来聊聊“秒杀”</title>
    <link href="https://bluedancers.github.io/2023/10/30/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%883%EF%BC%89%20-%20%E4%BB%8E%E6%B8%B8%E6%88%8F%E5%90%8D%E8%AF%8D%E5%88%B0%E7%94%B5%E5%95%86%E8%90%A5%E9%94%80%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%81%8A%E8%81%8A%E7%A7%92%E6%9D%80/"/>
    <id>https://bluedancers.github.io/2023/10/30/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%883%EF%BC%89%20-%20%E4%BB%8E%E6%B8%B8%E6%88%8F%E5%90%8D%E8%AF%8D%E5%88%B0%E7%94%B5%E5%95%86%E8%90%A5%E9%94%80%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%81%8A%E8%81%8A%E7%A7%92%E6%9D%80/</id>
    <published>2023-10-29T16:00:00.000Z</published>
    <updated>2023-11-27T03:13:59.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史上的“秒杀”"><a href="#历史上的“秒杀”" class="headerlink" title="历史上的“秒杀”"></a>历史上的“秒杀”</h2><p>​在1980美国的11月24号，这一天是美国最重要的传统节日<strong>感恩节</strong>，我们的主角小帅一家聚会到深夜才结束，但是他们并没有休息，反而穿着厚厚的大衣，前往附近早已停止营业的沃尔玛。</p><p>​但是当小帅抵达沃尔玛的时候，门前却排上了长长的队伍，超市关门了反而门前开始排队了？</p><p>​因为明天就是<strong>黑色星期五</strong>！</p><blockquote><p>感恩节后的黑色星期五标志着圣诞购物季的开始，美国人民通常会利用这一天购买圣诞礼物或者需要的商品。</p></blockquote><p>​小帅早早来的原因是他在11月22号沃尔玛的宣传单上看到的<strong>限时限量优惠！</strong>，只要<strong>1元就可以获得一个崭新的柯比吸尘器</strong>，但是限量500个；虽然现在寒风凛冽，但是捡漏的快乐还是让小帅充满干劲，美国的11月还谈不上太冷，就这样等到11月25号的凌晨5点，沃尔玛开门了！</p><p><img src="http://qiliu.vkcyan.top/FpsVAIISf_iWj4CwNxJfNxR-7MGF.png"></p><p>​排在前面的人都是冲着限时限量商品去的，都一个劲往里挤，事后发现大门都被挤坏了。</p><p>​尽管沃尔玛出动了大量安保人员维持秩序，但是还是出现了小范围踩踏事件，我们主角小帅非常幸运的挤在队伍的前列，在丧尸一般的人潮中成功抢到了仅售1元的限量商品柯比吸尘器，当然小帅不会立刻结账走人，他还会在沃尔玛购买圣诞节礼物、自己需要的东西。</p><p>​最后付款离场，小帅心满意足回家。</p><p>​<strong>但是感恩节之后，沃尔玛决定明年不再做限时限量优惠活动了。</strong></p><h2 id="线下商超为何对“秒杀”又爱又恨？"><a href="#线下商超为何对“秒杀”又爱又恨？" class="headerlink" title="线下商超为何对“秒杀”又爱又恨？"></a>线下商超为何对“秒杀”又爱又恨？</h2><p>我们一般认为，秒杀活动存在3个主要特征，<strong>限时、限量、高值低价</strong>。</p><p>线下秒杀在大多数情况下，都会获取预期效果，并且可以达到增加销售额、增加客流量的核心目的，具体来说作用如下</p><ul><li>通过制造热点吸引潜在用户、老用户、引导到店消费。</li><li>被吸引到的用户多半会购买一些产品，增加商超的销售额</li><li>秒杀活动会增加品牌、商超自身的知名度</li></ul><p>这么看挺不错的啊，能抓到老鼠就是好猫，能完成目标就是好活动，那何来的恨呢？</p><p>虽然秒杀能带来一些用户，但是也许要付出很多显性与隐性的成本。</p><ul><li>线下商超的目标是提供广泛而优质的服务，有可预期的周边几公里顾客，并不是很需要通过秒杀低价这种”激进“的营销策略来获取用户的青睐。</li><li>由于价格便宜并且限量，而黑色星期五本身就存在庞大的人流量，会出现人员拥挤与混乱的情况，不稳定因素大大增加。</li><li>秒杀活动会导致顾客之间发生冲突与纠纷的概率大幅增加，有损商超的的形象与品牌建设。</li></ul><p>比如这样</p><p><img src="http://qiliu.vkcyan.top/FnOB7X8l9_5k8IXVfQSWV5CuNIS8.png"></p><p>还有这样</p><p><img src="http://qiliu.vkcyan.top/FtY-pyoXDvjRGseKD3awOzUA41uf.png"></p><p>而黑色星期五的人流量是这样</p><p><img src="http://qiliu.vkcyan.top/FgToytXjQTy1M3qmyZsk3mt2nqCH.png"></p><p>​</p><p>​总的来说就是<strong>线下秒杀是一把双刃剑</strong>，<strong>相对来说雨露均沾式的优惠更加适合线下商超的价值定位</strong>；商超会根据自己的营销目的，选择不同的促销方式去吸引客户。</p><p>​也正是以上的一些原因，在线下商超出现之前，秒杀一直不是非常主流的营销方式，比我们之前聊的优惠券差远了。</p><h2 id="互联网时代，”秒杀“为什么破圈了？"><a href="#互联网时代，”秒杀“为什么破圈了？" class="headerlink" title="互联网时代，”秒杀“为什么破圈了？"></a>互联网时代，”秒杀“为什么破圈了？</h2><p>​1989年发生了一件影响人类历史进程的事情：由美国国家科学基金会推动的商业互联网正式成立，互联网开始走向大众。</p><p>​亚马逊为代表的电子商务公司开始兴起。2004年亚马逊推出了一项叫做<strong>Gold Box</strong>的业务，专门提供各种产品的打折促销和限时特惠。</p><p>​该功能一上线，取得了非常好的的效果，手机上点点就可以花少量的钱购买想要的产品，消费者对此类限时限量优惠的商品自然是很有兴趣，线上秒杀也开始被更多人注意到，<strong>Gold Box</strong>类型的营销方式开始电子商务领域被使用。</p><p>​我们考虑一下线上秒杀相对于线下秒杀有什么优势？解决了以前的什么问题？为什么线下不温不火的秒杀业务，到了线上就成了常见的营销方式？</p><p>​我们先分析一下线下秒杀的痛点到底是什么。</p><p>​<strong>用户参与秒杀的成本高</strong></p><p>​对于用户而言，提前一晚上到超市门口排队，抢到了还好，要是没抢到直接破防，这要是有啥烦心事，做出过激举动，身边人都遭殃。</p><p>​<strong>对于大型商超来说，成本可能大于收益</strong></p><p>​面对线下秒杀这样的活动，一方面商家需要增加额外的人力，另一方面还存在不可控的风险，比如损伤商超形象、影响顾客消费，等等一系列问题，除了新店开业需要快速拉新，稳定期间的经营者一定会慎重选择该营销策略。</p><p>​而且大型线下商超是存在<strong>区域性</strong>，比如在你家距离2公里处有一个沃尔玛，距离第二的超市可能就是5公里以上，你几乎不可能来回多跑6公里去距离更远的超市。而站在商超的视角看，除了特殊的开业阶段，应该多做老客户的维护，培养用户习惯。</p><p>​而互联网的出现，几乎弥补了以上所有痛点。</p><p>​<strong>用户参与门槛极低</strong></p><p>​在手机上就可以秒杀抢购，足不出户，就算抢不到，无非就是吐槽有内幕，付出的成本微乎其微。</p><p>​<strong>对于电子商务来说，收益大概率大于成本</strong></p><p>​相较于线下秒杀，线上开展这样的活动，主要成本在研发，用的辐射的人越多<strong>边际会成本越低</strong>，只要提前考虑到可能的意外情况，加上优质的运营方案，几乎不存在风险。</p><p>​另外，不同于线下商超固定的辐射圈，电子商务<strong>不存在物理空间的限制</strong>，这就意味着理论上网络上的任何一个人都是潜在用户，这样的前提下，平台的增长潜力是极大的，上升期也是极长的，秒杀这样吸引眼球的活动就成了一个非常不错的选择。</p><p>​<strong>那线上秒杀有什么缺点呢？</strong></p><p>​存在技术难度，瞬间巨量的访问，会直接让服务器宕机，相信经历过早期国内双11的用户都深有体会，而伴随秒杀业务的火热，一系列的技术方案都火起来了，所以技术难度也随着生态的完善而降低。</p><p>​亚马逊的秒杀业务在2000年左右开始发展壮大，除了日常折扣和限时促销的<strong>Gold Box</strong>之外，还细分出了<strong>Lightning Deals（闪电交易）、Deal OF The Day（团购）、7-day Deals（7天优惠）</strong>，等等针对不同类型商品的秒杀活动，直到现在，相关业务依旧是亚马逊促销策略中重要的一环。</p><p>​相比于线下秒杀，线上秒杀只能说是：<strong>优雅，实在是太优雅了！</strong></p><p><img src="http://qiliu.vkcyan.top/FmWevXBSpQZGxXVCFA7xhqEY_oBR.png"></p><p>​</p><h2 id="国内为什么叫“秒杀”？"><a href="#国内为什么叫“秒杀”？" class="headerlink" title="国内为什么叫“秒杀”？"></a>国内为什么叫“秒杀”？</h2><p>​不知道大家注意到没有，我们上面谈论了很多秒杀，都是打引号的，国外这种模式不叫秒杀，电商领域的”秒杀“是一个本土词汇。</p><p>​<strong>以前的人怎么想到这个名字的？</strong>，为啥不叫限时抢购？</p><p>​秒杀这个词在电商之前高频出现在竞技、游戏中，在国内电商兴起的同时，网游也在蓬勃发展，众多RPG游戏进入中国市场，比如大名鼎鼎的《红月》；大概就是看起来像<strong>是兄弟就来砍我、一刀999</strong>的游戏。</p><p><img src="http://qiliu.vkcyan.top/FheXDA7WVgXxyPH_MIaJVsvxBCm4.png"></p><p>​这个游戏可以升级到1000级，每次升级会给技能点，有些玩家将这些技能点全部加到攻击上，几百级之后，就会出现极其脆弱的身板 + 极其变态的攻击力，要么自己秒死，要么对方秒死，玩的就是心跳。</p><p>​秒杀一词也慢慢在社区流行起来，而玩游戏的多半是年轻人，这部分年轻人与电商领域从业者产生交叉，电商从业者目睹限时限价低价商品在电商平台瞬间抢购一空，发出了惊呼：”<strong>一下子就没了，就秒了！</strong>“。</p><p>​这时候人们转念一想，抢购没有体现极致的速度与紧迫感，哎！<strong>秒杀</strong>这个词很不错，商品直接售空，与游戏中的血条消失场景非常类似。</p><p>​有了这样的先例后，<strong>9.9秒杀、限时秒杀，京东秒杀、秒杀专区、老板娘生日，全场秒杀</strong>….在电商领域犹如雨后春笋般出现，直到现在几乎成了电商平台的专用名词。</p><p>​</p><h2 id="从专业角度看，人们为何喜爱秒杀"><a href="#从专业角度看，人们为何喜爱秒杀" class="headerlink" title="从专业角度看，人们为何喜爱秒杀"></a>从专业角度看，人们为何喜爱秒杀</h2><p>​可能会有小伙伴说了，这个问题很简单，因为大家都喜欢物超所值！其实不仅仅是简单的价格对比，限时限量抢购活动能够被人类选择，是有他的底层逻辑的。</p><p>​<strong>收益不最大化（商家）</strong>：在秒杀的场景下，用户支付比心里预期更低的价格就可以获得商品，用户会自发性的通过已知渠道进入秒杀活动中，而目标用户的参与动机，与需要支付的金额数量成反比，对于商家来说，秒杀场景下收益肯定不最大化的，这也是秒杀的显性成本。</p><img src="http://qiliu.vkcyan.top/FuriXSVGpvjd68sn5RaNT3-gr6Xo.png" style="zoom:33%;" /><p>​<strong>厌恶损失</strong>：根据科学验证，失去的痛苦是的得到的快乐的2倍以上，丢掉100元的痛苦远高于捡到100元的快乐，人们聪明的脑瓜自然能推理出，如果不通过此刻稀缺的秒杀活动购买到商品，后续多支付的部分金额，就是我的损失，则会进一步强化用户参与秒杀的动机</p><p>​<strong>稀缺效应</strong>：秒杀的特征，都是在加强稀缺这一点，限时、限量、高值低价，用户对稀缺的感知直线上升，从而增加购买的兴奋度与成就感。</p><p>​<strong>从众效应</strong>：我们想象一个场景，你的面前有2家超市，一家门可罗雀，一家人人潮汹涌，你会选择哪一家店？我相信绝大多数人都会无意识的认为，人多的肯定好，其实秒杀的场景也是这样，只是换了舞台，从线下变成了互联网上，如果秒杀活动可以在一个圈子中被炫耀、宣传，人们就会被这种“火热场景”所“迷惑”。</p><h2 id="秒杀的目是什么？"><a href="#秒杀的目是什么？" class="headerlink" title="秒杀的目是什么？"></a>秒杀的目是什么？</h2><p>​聊了这么多，我们还是要回到最关键的问题上。</p><p>​为什么要秒杀，我们的目的是啥？线上秒杀与几十年前的线下秒杀还是一个东西吗？</p><p>​我们先看线下商超做秒杀的目的是什么？</p><p>​<strong>用限时限量低价把用户吸引过来，然后为用户提供消费空间，并让更多用户了解与记住产品。</strong></p><p>​几十年前线下秒杀受到现实世界的限制，无法发挥全部实力，而有了互联网加持之后，弥补了现实世界的缺陷，<strong>秒杀进化为完全体状态</strong>，其核心目的没有根本变化；</p><p>​很多新人产品只理解了前半句话，把用户吸引过来，让用户参与”秒杀“，人气确实吸引过来了，但是人家只秒杀，花钱赚吆喝，就是不挣钱，甚至羊毛党越来越多。</p><p>​线上商城不像线下商超，用户来线下商超参与秒杀活动，来都来了，大概率会消费，线上则不是这样，无论用户是否”秒杀“成功，没兴趣了会直接右划走人，这就达不到开展秒杀活动的目的了。</p><p>​所以线上秒杀的运营目的并非秒杀活动进行状态，而是<strong>秒杀活动开始前后的活动运营，以及产品的曝光与留存</strong>。</p><p>​<strong>等待秒杀的用户运营</strong></p><p>​店铺付出较高成本开展秒杀活动，吸引来的新老用户都是极其宝贵的，如何引导这些用户转化为店铺的忠实用户，如何引导用户增强与店铺的粘性都是极其重要的，在这段时间可以做的事情很多，社交互动、相关营销活动曝光、强化品牌价值等等；只要能加强与用户的粘性，用户强化用户认知的目的，营销方案的形态都是可以畅想的。</p><p>​<strong>秒杀之后的用户运营</strong></p><p>​秒杀之后有些用户抢到了，有些用户没抢到，抢到的用户必然会增加对店铺的信任，我们再引导用户多下单，并在下单过程中继续曝光产品能力，比如签到、会员、让用户发自内心的认可产品；</p><p>​而没抢到的用户呢？我们也不能白白浪费宝贵的流量，时刻记住我们秒杀的目的。</p><p>​猜测一下”秒杀“失败用户的心理，可能还对抢到抱有一丝希望，是否还有下一波?是否可以捡漏？这时候我们是否可以提示用户，没抢到没关系，预约下一次的秒杀，还有机会抢！或者贴出其他相对优惠的非秒杀的商品，来安慰用户；总之就是拉升用户的心情曲线，给予用户继续操作的空间，也是将用户留存下来。</p><p>​所以秒杀并不是简单的低价抢购，短期吸引巨量人气的活动，因为如果没有合理的运营策略，最后陷入只能花钱赚吆喝的虚假繁荣之中。</p><h2 id="一定是秒杀吗"><a href="#一定是秒杀吗" class="headerlink" title="一定是秒杀吗?"></a>一定是秒杀吗?</h2><p>​我们纵观人类发展史，无论是工业革命时代的路边小卖部，还是信息化时代的全球电商平台，总有时代的先驱者找到了当下时代的技术与底层逻辑的结合，归根结底其实研究的还是是<strong>人与组织、交易</strong>。</p><p>​互联网秒杀此类业务模式的出现是在特定历史阶段的产物，而我们真正要关注的是此类活动的底层逻辑以及我们的营销目的，最终以什么样的形态展示到用户面前，一定不是永恒不变的，<strong>秒杀是手段，不是目的</strong>。而在高速发展的当下，已经有了相对于传统秒杀更加有效的活动模式，以及电商突破物理限制后，能够触达的新业态。</p><p>​<strong>万变不离其宗</strong>，了解消费者，了解底层逻辑，与自身资源有机结合，形成可落地的面向用户的活动形式，最后落地的一定是秒杀吗？我想一定不是的。</p><p>​谢谢朋友们的观看，我是懂点技术的saas电商产品经理狗阿木，如果您觉得我的文章对您有帮助，记得点赞关注~</p><p>​</p><p>参考资料</p><p><a href="https://www.163.com/dy/article/GJ7AQT7E0526D7OK.html">曾将中文带火的韩国网游，却被自己搞凉，15年后又想复活捞一笔？</a></p><p><a href="https://www.itsiwei.com/2434.html">“秒杀起源”，电商年代告诉你什么是真正的秒杀</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;历史上的“秒杀”&quot;&gt;&lt;a href=&quot;#历史上的“秒杀”&quot; class=&quot;headerlink&quot; title=&quot;历史上的“秒杀”&quot;&gt;&lt;/a&gt;历史上的“秒杀”&lt;/h2&gt;&lt;p&gt;​	在1980美国的11月24号，这一天是美国最重要的传统节日&lt;strong&gt;感恩节&lt;/st</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="秒杀" scheme="https://bluedancers.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(2) - 细致解读,Saas商城必备的优惠券产品设计攻略</title>
    <link href="https://bluedancers.github.io/2023/10/20/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89%20-%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91/"/>
    <id>https://bluedancers.github.io/2023/10/20/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89%20-%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91/</id>
    <published>2023-10-19T16:00:00.000Z</published>
    <updated>2023-11-27T03:12:56.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​在上一篇文章中，我们了解了优惠券的起源，以及随着互联网的出现，优惠券的能力进一步被挖掘的发展历程；今天直接上干货，聊一聊<strong>Saas商城系统的优惠券产品逻辑究竟要如何设计</strong>。</p><h2 id="优惠券的框架设计"><a href="#优惠券的框架设计" class="headerlink" title="优惠券的框架设计"></a>优惠券的框架设计</h2><p>优惠券的生命周期如下</p><p><img src="http://qiliu.vkcyan.top/FtAcMuNyjljceuzGB871e9Zp3Xra.png"></p><p>我们的优惠券设计的目的，也就是解决生命周期每个环节的问题。</p><ol><li>店铺如何发布优惠券？</li><li>店铺中的用户如何领取到优惠券？</li><li>领取到优惠券的用户如何使用优惠券？</li><li>店铺通过那些维度去复盘优惠券的效果？</li></ol><p>​其中的问题1、2是放在一起考虑的，发布优惠券的时候，我们不仅需要考虑优惠券的基本信息，也需要<strong>提前思考优惠券通过什么渠道发放到目标用户手中</strong>。</p><p>​我们首先聚焦于发布优惠券的产品逻辑。</p><h2 id="发放优惠券"><a href="#发放优惠券" class="headerlink" title="发放优惠券"></a>发放优惠券</h2><p>发布优惠券中我们可以将其分为2个大类，<strong>基础设置</strong>与<strong>发放规则</strong>。</p><p>​<strong>基础设置</strong>包含优惠券名称、优惠券类型、发放数量，等的优惠券的基本信息，这样的<strong>基本信息在任何商城几乎都是通用的。</strong></p><p>​<strong>发放规则</strong>是发放渠道、定向发放、发布平台、领取限制，等等平台独特的，<strong>配合运营而存在的设置。</strong></p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>  <img src="http://qiliu.vkcyan.top/FtT9pjaAgxFwEuuCX-Omr6HCu-4l.png"></p><p>​这部分产品逻辑无论哪一家的saas都是大同小异的，都是对<strong>现实优惠券的抽象</strong>。</p><p>​有的saas系统中，将优惠券的设置单独抽出来，叫做<strong>优惠券模板</strong>，其产品流程为，首先发布优惠券模板，然后发布优惠券的时候再选择模板，随后设置发放规则，才算发放成功，比如微盟；</p><p>​绝大部分saas都没有这样做的必要，因为如果不是极其复杂的产品，过于细化产品逻辑，反而增加了技术、运营的使用难度。</p><h4 id="券名称（用户见）-券名称（店铺见）"><a href="#券名称（用户见）-券名称（店铺见）" class="headerlink" title="券名称（用户见） + 券名称（店铺见）"></a>券名称（用户见） + 券名称（店铺见）</h4><p>​券名称不仅需要设置用户可见的优惠券名称，还需要设置后台独有的优惠券名称</p><p>​为什么存在这样一个字段呢？</p><p>​因为<strong>同名称 + 规格的优惠券可能被发布在不同的渠道</strong>，如果不存在字段在后台进行区分，店铺运营人员就无法通过用户见的优惠券名称快速区分同名优惠券的具体渠道；</p><p>​<strong>为了满足运营人员快速区分渠道的目的，系统内部就需要针对优惠券增加一个内部可见的名字</strong></p><p>​也许有小伙伴会说，将不同的渠道信息写到优惠券备注里面不就好了，这样确实可以，但是优惠券备注字段一般是不支持搜索的，这就需要运营人员手动筛选，所以店铺见的券名称字段是非常有必要的。</p><p>​<strong>这2个字段在优惠券列表页面都需要支持搜索。</strong></p><h4 id="优惠券类型"><a href="#优惠券类型" class="headerlink" title="优惠券类型"></a>优惠券类型</h4><p>​尽管优惠金额千变万化，我们始终可以用满减券、折扣券这2个抽象纬度进行归纳；当然虽然场景的精细化，还可以衍生出更加细分的优惠券类型，我们先说通用的。</p><p>​折扣券除了设置<strong>具体折扣</strong>之外，一般还要设置<strong>门槛</strong>与<strong>优惠上限</strong>，我们归纳一下，一般这样设置</p><ul><li><strong>优惠内容</strong><ul><li>满xx元，打xx折</li><li>无门槛，打xx折</li></ul></li><li><strong>优惠上限</strong><ul><li>无优惠上限</li><li>最多优惠xx元</li></ul></li></ul><p>满减券的逻辑和折扣券类似，不过满减券已经设置了具体的优惠金额，所以不再需要设置优惠上限，一般存在以下设置</p><ul><li><strong>优惠内容</strong></li><li>满xx元，减xx元</li><li>无门槛，减xx元</li></ul><p>​以上2种类型几乎包含了<strong>通用saas商城90%以上的应用场景</strong>，所以如果不是非常重视用户运营，或者行业需要，增加额外的优惠券类型是不划算的。</p><p>​趣味性的包含<strong>随机金额券</strong>，则需要设置随机区间、<strong>商品兑换券</strong>，需要设置指定商品、<strong>买一送一券</strong>、<strong>赠品券</strong>，此类优惠券使用频率与场景相对低频，所有在开发优先级上，需要慎重考虑。</p><h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><p>​回想一下，我们拿到的线下优惠券，是不是基本都会指定单品或者指定类目，这样指定优惠范围的逻辑在saas商城系统的发布优惠券中是不可或缺的，一般应用范围存在以下几种纬度。</p><p><strong>指定商品、指定类目、指定供货商、全场通用</strong></p><p>注意一点，这里的指定都是可以指定多个的，并非只能指定一个，比如指定多个商品、指定多个类目。</p><p>另外就是关于全场通用，这个选项saas商城谨慎添加，因为该应用范围存在以下特点</p><ol><li>应用范围太大</li><li>同时使用频率不高</li><li>全场通用券容易被撸羊毛，偏离效果预期</li><li>一旦运营人员点错，后果不堪设想</li></ol><p>​所以如果全场通用类型优惠券在业务上不是必要的，则不进行添加。</p><h4 id="发放数量"><a href="#发放数量" class="headerlink" title="发放数量"></a>发放数量</h4><p>​这就是指优惠券具体的发放数量。</p><p>​要注意的是，发放数量在编辑的时候，一般只能添加，不允许减少，这是因为减少优惠券可能导致已领取的优惠券数量超出实际库存，也会对系统的稳定性造成风险。</p><h4 id="有效期与活动时间"><a href="#有效期与活动时间" class="headerlink" title="有效期与活动时间"></a>有效期与活动时间</h4><p>​在店铺后台发券的时候可以指定优惠券可使用时间，一般存在2种类型</p><ul><li><strong>用券时间</strong><ul><li>指定用券时间范围，比如指定xxxx - xxxx时间段可用</li><li>指定领券后有效期，比如领券后x天内有效</li></ul></li><li><strong>活动时间</strong><ul><li>执行之间端，优惠券是</li></ul></li></ul><p>​用券时间的限制，大家都比较好理解，存在时间限制的券，会增加用户的使用动机，存在有效期的优惠券也降低了程序的运行负担。</p><p>​而活动时间，我调研多数竞品看是不存在的，而我站在店铺运营者的角度来看，觉得这个字段是有存在的必要的。</p><p>​我们可以想象一个场景，在春节节假日期间运营需要发布了一张全场优惠券，用户领券后，30天内可用，春节之后无法领券。如果不存在活动时间，运营人员就需要在春节节假日结束的时候手动关闭优惠券，或者活动入口。</p><p>​这样的事情，完全可以交给程序完成，就是增加活动时间的概念。</p><p>​还有一点需要注意的是，当活动时间小于优惠券的使用时间的时候，优惠券不会随着活动时间的过期而过期，而是按照自己的使用有效期规则。</p><p>​到此为止，我们的发布优惠券的基础模块就完成了，这一部分的产品设计是比较简单的，大部分的产品逻辑都是类似的，无论是参考竞品，还是自行设计，最终都会走向类似的终点，将尽力聚焦于商家运营需求，或者用户需求才是重点；</p><h3 id="基础设置的示例图"><a href="#基础设置的示例图" class="headerlink" title="基础设置的示例图"></a>基础设置的示例图</h3><p><img src="http://qiliu.vkcyan.top/FvGjr5XHiv-c4_YuTqAV4SZkHHNo.png"></p><p>​完成了如何发布优惠券，下一步，我们就要看看用户如何获得优惠券。</p><h3 id="发放规则"><a href="#发放规则" class="headerlink" title="发放规则"></a>发放规则</h3><p><img src="http://qiliu.vkcyan.top/FjIjbcXN74Jae5Ahy4rT7aKB0Mgj.png"></p><h4 id="发放渠道（重点）"><a href="#发放渠道（重点）" class="headerlink" title="发放渠道（重点）"></a>发放渠道（重点）</h4><p>​我们可以想象一下，在我们的日常生活中，有多少种途径可以完成领券动作</p><ul><li>在商品详情页领券。</li><li>在社群中的优惠券链接完成领券。</li><li>在线下海报完成领券。</li><li>通过特定的卡密兑换优惠券。</li><li>在签到、抽奖活动中获取优惠券。</li><li>….</li></ul><p>​我们可以想到很多很多领券的途径，在我们发布优惠券的时候，需要控制优惠券可以在什么渠道被领取，如果没有渠道的概念，原本打算发给社群的优惠券，在商城类就可以领取，券就会被截胡了；后期的数据统计也无法细分查看不同渠道的转化率。</p><p>​另外优惠券有了渠道的区分，即使是同样规格的优惠券，在后期的优惠券数据统计上，也可以<strong>看到不同渠道的效果如何</strong>，总之，优惠券渠道的区分对于店铺运营来说都有很重要的意义。</p><p>​一般存在什么样的发放渠道呢？</p><h5 id="商城渠道"><a href="#商城渠道" class="headerlink" title="商城渠道"></a>商城渠道</h5><p>​用户可在商城内的优惠券集合页面、可用商品的商品详情页面领取优惠券</p><h5 id="手工渠道"><a href="#手工渠道" class="headerlink" title="手工渠道"></a>手工渠道</h5><p>​一般用于客服为用户补发优惠券，用户无法手动领取。</p><h5 id="外部渠道"><a href="#外部渠道" class="headerlink" title="外部渠道"></a>外部渠道</h5><p>​运营可以<strong>导出可兑换优惠券的券码</strong>，并分配给第三方，第三方的用户通过兑换、购买等等方式获取到指定券码，最后按照活动提示，回到商城中，将兑换码兑换成可使用的优惠券；一般用于异业合作。</p><blockquote><p>以上3个渠道为基本渠道，几乎每个saas商城都存在的，而下面的渠道则和具体的业务绑定，属于个性化的渠道</p></blockquote><h5 id="券包渠道"><a href="#券包渠道" class="headerlink" title="券包渠道"></a>券包渠道</h5><p>​券包渠道优惠券无法直接被用户领取，而是需要运营人员在后台的券包管理模块，选择多个该渠道的优惠券，发布成一个券包，用户再通过指定渠道、或者首页弹窗，领取券包，自动获取券包中的所有优惠券。</p><h5 id="抽奖渠道"><a href="#抽奖渠道" class="headerlink" title="抽奖渠道"></a>抽奖渠道</h5><p>​发布在抽奖渠道的优惠券，可以在发布抽奖活动的配置中，配置指定优惠券，用户即可通过抽奖获得该优惠券。</p><h5 id="签到渠道"><a href="#签到渠道" class="headerlink" title="签到渠道"></a>签到渠道</h5><p>​发布在签到渠道的优惠券，可以在发布签到活动的配置中，配置指定优惠券，用户即可通过指定的签到天数获取该优惠券。</p><h5 id="标签渠道"><a href="#标签渠道" class="headerlink" title="标签渠道"></a>标签渠道</h5><p>​发布在标签渠道的优惠券，可以在标签管理中配置指定优惠券，用户达成某种条件，自动获得标签的时候，也就会自动获取优惠券。</p><p>​自动标签可以有效的完成用户精细化运营的需求，我文中所写的方式是，先发券，再去标签管理中进行绑定，<strong>如果精细化运营要求比较高，可以在发布优惠券的时候就指定标签，这样操作上更加直观</strong>。</p><p>​关于 券包、抽奖、签到、标签与活动运营存在强关联的优惠券渠道，如果对运营不存在精细化的需求，可以不在进行划分，统称为<strong>自动渠道</strong>。</p><p>​细分的渠道虽然可以让系统更加稳健，让后期的统计更加简单直观，但是也不是没有缺点，增加了实际运营的理解难度，也增加了操作步骤，所以<strong>到底是精细化还是简单直观，需要根据自己的产品特性进行判断</strong>。</p><h4 id="领取限制"><a href="#领取限制" class="headerlink" title="领取限制"></a>领取限制</h4><p>​券的数量是有限的，一个用户可消费的量也是有限的，如果不对券的领取加一限制，会造成券的浪费，也会造成潜在订单的流失，所以发放优惠券的领取限制是很有必要的</p><p>​领取限制一般存在以下几种</p><ul><li>不限次数</li><li>每人限制x次</li><li>每人每天限制x次</li><li>每人每月限制x次</li></ul><p>​领取限制并非一成不变的，究竟是什么样的领取限制，在设计产品的时候，我们需要根据服务对象的需求来决定。</p><h4 id="领取与使用平台"><a href="#领取与使用平台" class="headerlink" title="领取与使用平台"></a>领取与使用平台</h4><p>​很多saas商城不仅支持微信小程序，可能还支持h5、微信公众号、xx小程序，等等。</p><p>​首先，不同平台的运营规则是不一样的，比如虚拟类商品就不允许在小程序中进行售卖，那么虚拟类商品的优惠券就不可以在微信小程序中被领取与使用；或者某些运营需求，我们希望用户在指定渠道领取与使用，这些运营需求的实现都需要再发布优惠券的时候限制领取与使用平台。</p><h4 id="是否加入微信券包"><a href="#是否加入微信券包" class="headerlink" title="是否加入微信券包"></a>是否加入微信券包</h4><p>​如果saas商城支持微信公众号、微信小程序，我们的ToC的商城用到微信的鉴权能力，技术上就没有阻碍了。</p><p>​开启该功能后，用户在商城中完成领券的时候，我们也可以将券<strong>加入到用户的微信券包</strong>，加入微信券包的券存在过期提醒，可以快过期的时候<strong>二次唤醒用户</strong>，也可以通过优惠券直达商城，是不错的功能。</p><p>​不过要注意的是，加入微信券包的券，尽量是高价值的，低价值的优惠券无法引起用户的兴趣，快过期了再提示用户使用，会加剧用户的反感，甚至导致用户的投诉，所以该功能也需要慎重使用。</p><p><img src="http://qiliu.vkcyan.top/FoD4PbIDLgrVTZs-O8FHiRC1742Z.png"></p><h2 id="外部优惠券的发放逻辑"><a href="#外部优惠券的发放逻辑" class="headerlink" title="外部优惠券的发放逻辑"></a>外部优惠券的发放逻辑</h2><p>​在上述优惠券发放渠道中，存在一个比较特殊的优惠券渠道，就是我们的外部渠道，外部渠道的券，是我们发放给第三方产品，或者公开区域，用户无法在站内获取的优惠券。</p><p>​因为站内无法获取，则需要我们导出券码，让用户可通过站外渠道进行领取，<strong>所有我们的后台需要支持导出优惠券的功能</strong>。</p><p>​为了更好的运营效果，优惠券也不是一股脑全部导出的，因为可能存在多个外部渠道，A渠道需要1000张，b渠道需要2000张，不能让运营人员去手动拆分做这种工作，所以<strong>我们需要先生成指定渠道，再导出优惠券。</strong></p><p>​外部优惠券在优惠券列表表格中会多出2个按钮，第一个是<strong>生成</strong>，第二个是<strong>导出</strong>。</p><p>​假设我发布了10000张优惠券，分别导出给A、B、C渠道，则发布完成后，点击生成，生成的时候填写<strong>生成数量、导出渠道</strong>，完成指定渠道的外部优惠券的生成，B、C同理。</p><p>​外部优惠券生成完成后，再点击导出，<strong>再选择上一步声明的指定渠道</strong>，即可导出指定渠道的所有优惠券兑换码，同时还可以在导出时设置券码状态，未领取、未使用、已使用或者全部，针对性导出。</p><p>​最后，我们将导出的csv文件，给到第三方的外部渠即可。</p><p>​到此为止，我们发放优惠券的全部功能就梳理完成了。</p><h2 id="用户使用优惠券"><a href="#用户使用优惠券" class="headerlink" title="用户使用优惠券"></a>用户使用优惠券</h2><p>​在C端用户使用优惠券的逻辑就非常简单了，为了更好的用户体验，领券页面到下单的产品路径一定是越短越好，一般存在如下特征</p><ul><li>商城内存在一个“我的优惠券”页面，我的优惠券页面需要有<strong>券码兑换功能</strong>，方便用户兑换发放出去的外部优惠券</li><li>如果优惠券是指定单商品，点击使用优惠券，则直接进入指定单商品，如果是多商品可用，则进入一个可用商品集合页面，<strong>确保最短产品路径</strong>。</li><li>在最终下单环节，自动帮助用户选择最便宜的优惠券，同时为用户提供切换可用优惠券的产品功能。</li></ul><p>关于ToC的产品逻辑可参考竞品非常多，也不是本文的重点，所以这里就不做过多赘述了。</p><h2 id="优惠券效果复盘"><a href="#优惠券效果复盘" class="headerlink" title="优惠券效果复盘"></a>优惠券效果复盘</h2><p>​每当我们的优惠券活动结束后，并且用户的券已经全部被使用，或者失效，我们便可以根据优惠券的多维数据建立漏斗模型。</p><p>​<strong>发券数量 - 领券数量 - 使用数量</strong></p><p>​另外还有<strong>优惠券成本、优惠券支付金额、优惠券新老用户数</strong>，等等偏向于业务维度的数据统计。</p><p>​假设数据分析发现，大量用户没有领券，我们则需要反思我们渠道是否存在问题，导致优惠券的曝光不足。</p><p>​亦或者领取到使用的转化低于预期，我们则需要考虑，领券用户是否对商品不感兴趣，或者券的价值过小，最终导致用户领券，但没有足够的下单动机。</p><p>​总之，在领券与使用2个环节的转化漏斗结合用户画像，以及渠道的，等相关影响因素，可以分析出一些宝贵的结论，再反哺下一次的优惠券营销活动。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​优惠券作为saas电商系统最常见的营销活动，在用户的拉新、促活、转化，等多个维度都可以发挥作用，是作用极大的，贯穿整个系统的功能，所以各位产品，一定要思考用户的需求，慎重做产品决策，构建出操作便捷、功能强大的优惠券模块。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	在上一篇文章中，我们了解了优惠券的起源，以及随着互联网的出现，优惠券的能力进一步被挖掘的发展历程；今天直接上干货，聊一聊&lt;strong&gt;</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="优惠券" scheme="https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>runtime运行时</title>
    <link href="https://bluedancers.github.io/2023/09/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/runtime%E7%9B%B8%E5%85%B3/"/>
    <id>https://bluedancers.github.io/2023/09/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/runtime%E7%9B%B8%E5%85%B3/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-11-27T02:44:34.885Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟dom存在2个非常核心的概念</p><ol><li>挂载：mount</li><li>更新：patch</li></ol><p>h函数作用，生成vnode</p><p>render函数的作用，解析vnode并生成真实dom</p><h1 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h1><p>源码地址在：<strong>packages&#x2F;runtime-core&#x2F;src&#x2F;h.ts</strong></p><p>首先进入<strong>h</strong>函数</p><p>h函数存在3个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type：当前节点类型</span><br><span class="line"></span><br><span class="line">propsOrChildren：props或者children</span><br><span class="line"></span><br><span class="line">children：子节点</span><br></pre></td></tr></table></figure><p>该函数的作用就是处理好以上三个函数的传参的多种情况。</p><p>然后再将处理好的<strong>type，props，children</strong>传入到<strong>createVNode</strong>函数中</p><p>createVNode最终会执行_createVNode函数，只不过开发环境会做一些额外的处理</p><p>对于初始化的组件来说，_createVNode的主要目的就是给当前组件增加组件类型标识shapeFlag</p><p>然后进入createBaseVNode，在该出构建了完成的VNode，并根据children的字段，重新计算shapeFlag，最终返回vnode</p><p>小结：<strong>h - createVNode - _createVNode - createBaseVNode</strong></p><ol><li>h函数 处理入参，使其标准化的进入到vnode创建流程</li><li>根据type类型预先赋值shapeFlag，并增强处理class与style</li><li>构建VNode基础数据</li><li>根据children的类型，再次刷新ShapeFalg，完成对组件类型的全部标识。</li></ol><p>h函数最终就是要生成可用于render函数渲染的vnode数据</p><h1 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h1><p>在h函数中处理过去的vnode，将会在render函数中被渲染为真实dom</p><p>render的核心代码在runtime-core中进行实现，核心代码与平台式无关的，runtime-dom中存放所有dom渲染相关的代码</p><p>在导出render之前，首先会将dom相关方法放入render函数，我们使用的render其实已经被处理过了</p><p>代码执行流程大概如下</p><p>render：传入vnode与挂载阶段</p><p>patch：判断阶段类型，进入对应渲染函数</p><p>processElement：文本组件进入这里，首先判断是更新还是新增</p><p>mountElement：新增文本组件进入该函数 （创建节点 填充数据 设置props 插入dom）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚拟dom存在2个非常核心的概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;挂载：mount&lt;/li&gt;
&lt;li&gt;更新：patch&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;h函数作用，生成vnode&lt;/p&gt;
&lt;p&gt;render函数的作用，解析vnode并生成真实dom&lt;/p&gt;
&lt;h1 id=&quot;h函数&quot;&gt;</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(1) - 人人都爱用的优惠券，背后逻辑竟然这么复杂？</title>
    <link href="https://bluedancers.github.io/2023/09/29/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%881%EF%BC%89%20-%20%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%88%B1%E7%94%A8%E7%9A%84%E4%BC%98%E6%83%A0%E5%88%B8%EF%BC%8C%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F/"/>
    <id>https://bluedancers.github.io/2023/09/29/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%881%EF%BC%89%20-%20%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%88%B1%E7%94%A8%E7%9A%84%E4%BC%98%E6%83%A0%E5%88%B8%EF%BC%8C%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-11-27T03:03:54.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="带着问题思考"><a href="#带着问题思考" class="headerlink" title="带着问题思考"></a>带着问题思考</h2><ol><li>为什么淘宝要把优惠券规则设计的那么复杂？</li><li>为什么不直接降低价格，而是使用优惠券才可以优惠?</li><li>商家发放优惠券的目的究竟是什么？</li><li>为什么公司就算被消费者唾弃，也要大数据杀熟。</li></ol><p><strong>看完这篇文章，你将理解以上这些令人费解的事情。</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​最近负责的Saas商城系统中的优惠券模块开始重构，借此机会作者也打算深入学习与理解优惠券，了解优惠券的前世今生，为后续的产品功能设计环节做好知识储备，避免浅尝辄止的借鉴竞品。</p><p>​让我们搭乘时光机，先回到工业革命时代，看看优惠券是如何“诞生”与“破圈”的，成为人们生活中的一部分。</p><h2 id="时间的齿轮开始转动"><a href="#时间的齿轮开始转动" class="headerlink" title="时间的齿轮开始转动"></a>时间的齿轮开始转动</h2><blockquote><p>​根据广告学中目前公认的说法，全世界首张优惠券是美国著名广告文案撰写人<strong>克劳德.霍普金斯</strong>发明的，他为一款炼乳产品在报纸上设计了一张优惠券，消费者撕下报纸的优惠券，再凭借优惠券去购物便可以享受到优惠。</p></blockquote><p>​19世纪中后期，美国工业革命走向巅峰，随着工业化的兴起与城市化的快速发展，商店、百货公司的数量开始高速增加，购物流程上已经开始现代化，从早期的顾客将想要的商品告知店员，店员将商品从货架拿到顾客手中，演变成了<strong>自助选购模式</strong>。</p><p>​商店数量的增加以及早期供应链的完善，产品与服务开始同质化，竞争也随之变得越发激烈，百货公司与百货公司、品牌与品牌之间逐渐开始相互内卷；</p><p>​在19世纪后期，广告成本非常低廉，主要有以下原因</p><ol><li>由于科技水平的限制，广告多为报纸、海报，广告覆盖与传播的范围有限</li><li>19世纪后期并不是信息过载的时代，竞争不算激烈，消费者对广告的接受度较高。</li><li>电子印刷术进入普及阶段，同时简单的文字与配图被被用户广泛接受，制作成本低。</li><li>没有广告法的限制，进一步降低广告的制作成本</li></ol><p>​而一部分人已经看到了营销对产品的巨大影响，大批企业开始肆无忌惮的投放广告，巨幅墙体海报、有轨电车海报、报纸、促销宣传单，广告开始越来越多的，以各种各样的形式出现在大家的生活中，还有公开分发优惠券以及在用户消费后赠送固定折扣券的行为；</p><p>​不过19世纪末期，整个市场仍处于增量阶段，所以那时宣传依旧具有良好的效果，优惠券这样的营销方式还没有引起大家足够的注意。</p><p>​到这里，我们没法不谈谈这个世界上最伟大的公司之一Coca Cola，根据互联网现存资料的主流声音，优惠券模式通过可口可乐完成被更多人所了解。</p><p>​同样在19世纪末期，可口可乐的营销负责人非常相信广告曝光的巨大价值，他采用各种平面海报、免费饮品券的方式，来开展可口可乐的营销工作，后续靠产品的上瘾性形成复购（上瘾是因为那时候的可口可乐里面含有可卡因）。</p><p>​<strong>当时谁也没想到，那时候不受待见的免费饮品券综合下来竟然是效果最好的</strong>，因为早期彭伯顿（coca cola创始人）认为免费券不挣钱了，因为可口可乐的上瘾性，用户侧反映出极高复购率，<strong>让彭伯顿不禁相信，专业的事情还是应该专业的人来做</strong>。</p><p>​<strong>于是免费饮品券开始被大力使用，甚至通过邮寄的方式直接送到你家门口</strong>，优惠券玩法第一次出圈，当然可口可乐的成功是非常复杂的，优惠券仅仅是一段小小的佳话。</p><p>​非常幸运的是，这样的一张优惠券，目前在互联网上依旧可以找到</p><img src="http://qiliu.vkcyan.top/FutIDma1qVyyN0KukUeRmIJOv4AM.png" style="zoom:90%;" /><p>this card entitles you to one glass of free coca cola at the fountain of any dispense of genuine coca cola</p><p>图片的中文是：<strong>这张卡可以让您在任何出售真正可口可乐的饮料机处免费领取一杯可口可乐。</strong></p><p>我们来简单分析一下，coca cola免费饮品券发挥的作用是什么，或者说传统优惠券有何作用？</p><ol><li>极大降低用户的首次消费门槛，用户面对折扣与免费的优惠，倾向于立即行动，可快速刺激销量。</li><li>创新与新颖性，免费优惠券是新颖的概念，用户收到免费优惠券后，会存在兴趣与好奇心。</li></ol><p>其实除此之外，传统优惠券还有以下作用</p><ol><li>增加品牌忠诚度，用户通过优惠券获取额外的价值的时候，会对品牌产生积极的情感。</li><li>清除库存与滞销商品，通过该优惠券的方式来达到快速周转的目的。</li></ol><p>​<strong>总的来说，传统优惠券就一个点：无套路！真的优惠了！</strong></p><p>​虽然初代优惠券的方式很原始，但是<strong>已经符合大部分人对优惠券的认知了</strong>，而在美国19世纪前中期的大萧条阶段，消费者为了省钱，经常会收集各种优惠券，优惠券进一步受到用户的青睐。</p><p>​在后来的几十年中，互联网时代来临之前，优惠券早已被大众广泛接受，不过其核心玩法和概念没有变化，只不过是表现形式上会变的更加新颖，<strong>产品描述、售价</strong>依旧是重点、如果是免费的会写一个大大的<strong>FREE</strong>。</p><h2 id="在互联网时代优惠券发生变化了吗？"><a href="#在互联网时代优惠券发生变化了吗？" class="headerlink" title="在互联网时代优惠券发生变化了吗？"></a>在互联网时代优惠券发生变化了吗？</h2><p>​当我们了解了优惠券的历史后，现在让我们搭乘时光机器回到互联网时代，看看100多年后的出现的电子优惠券有何变化。</p><p>​<strong>先说结论：互联网的电子优惠券玩法相对传统优惠券是颠覆式的改变</strong></p><p>​到底改变了什么？我先卖个关子，这100年间发生了太多改变人类事情，所以在讲电子优惠券之前，我们首先了解一些极其重要又简单的经济学概念。</p><h3 id="需要提前了解的经济学概念"><a href="#需要提前了解的经济学概念" class="headerlink" title="需要提前了解的经济学概念"></a>需要提前了解的经济学概念</h3><h4 id="差别定价"><a href="#差别定价" class="headerlink" title="差别定价"></a>差别定价</h4><p>​差别定价又被称为价格歧视，<strong>表示生产者针对相同生产成本的产品，以不同的价格售予不同的买家</strong>，这并非是一个贬义词，只是商家为了利益最大化的一种方式。</p><p>  简单来说就是有钱多花点，没钱少花钱。</p><h4 id="消费者剩余"><a href="#消费者剩余" class="headerlink" title="消费者剩余"></a>消费者剩余</h4><p><strong>消费者剩余  &#x3D; 用户可接受最高价 - 实际售卖价</strong></p><p>比如一个手机，张三本来打算5000块钱买，但是这时候突然拿到了一个500块优惠券，张三最终以4500块就买下了的手机。</p><p>此时，<strong>消费者剩余就是5000 - 4500 &#x3D; 500</strong>，而商家的成本是3500，<strong>生产者剩余为4500 - 3500 &#x3D; 1000</strong>，虽然商家挣了1000块，但是他原本是可以挣消费者1500块，所以消费者剩余越大，商家越不赚钱。</p><img src="http://qiliu.vkcyan.top/Fnsl689q92YLLHdYEENXToxFQlSP.png" style="zoom:33%;" /><h4 id="利润最大化"><a href="#利润最大化" class="headerlink" title="利润最大化"></a>利润最大化</h4><p>​我们还是看上面的案例，张三可接受的最高价是5000元，实际消费了4500元，消费者剩余是500元，理想情况下，商家希望用户都通过<strong>可接受最高价进行购买</strong>，这样的情况下商家利润最大，消费者也依旧愿意购买。</p><p>​而针对这个5000的手机，张三消费能力强，5000块愿意购买，李四消费能力弱，最多愿意4500元购买，王五是个学生，最多愿意4000元购买，那么最理想的情况则是，大家分别按照自己的能接受的最高价进行购买。</p><p>​张三消费5000、李四消费4500、王五消费4000，张三、李四、王五的消费者剩余均为0，这样的情况下，<strong>商家看起似乎打折少挣钱了，实际上却是最挣钱的状态，也就是利润最大化。</strong></p><h3 id="线下优惠券的局限性"><a href="#线下优惠券的局限性" class="headerlink" title="线下优惠券的局限性"></a>线下优惠券的局限性</h3><p>​在互联网到来的前夕，企业就已经在讨论如何利用优惠券实现收益最大化。大家都发现了一个非常难以解决的问题，<strong>精准投放无法实现</strong>。</p><p>​比如同样在纽约的张三与李四，张三相对富裕，而李四是一个穷苦大学生，他们都喜欢吃肯德基的单人套餐。</p><p>​假设肯德基的单人套餐原价是30元，张三没有觉得原价贵，无论是否有券，他都会直接买，而李四不是，只有在打折到8折及以下的时候，他才会有消费动机。</p><p>​最后让我们假设，肯德基的单人套餐综合成本是15元</p><p>​<strong>在不发券的情况下</strong>，张三30元购买，消费者剩余是0，商家实现了收益最大化，但是李四不会买，没有收益；</p><p>​<strong>在发券的情况下</strong>，张三与李四都会获取优惠券，假设是8折券，此时张三和李四都会去消费了，张三平时30元也会买，但是现在他只需要花24元，而李四呢，8折优惠券达到了他可下单的最高价，他使用8折券进行下单了；</p><p>​现在在让我们看一下发券场景下，张三与李四的消费者剩余</p><p>​张三可接受最高价30，实际消费 24，商品成本价15，消费者剩余6元，没有实现收益最大化</p><p>​李四可接受最高价24，实际消费 24，商品成本价15，消费者剩余0元，实现了收益最大化</p><p>​虽然少挣了张三的钱，但是多获得了李四的钱，似乎比不发券的效果好；但是这依旧不是理想的效果，因为张三还存在消费者剩余。</p><p>​但是券也不能一直发，长时间这样会降低品牌形象，影响消费者对品牌的信心，并提升用户对价格的敏感度，造成不可逆的严重影响，到那时候再想提价就极其困难了。</p><p>​<strong>最理想的结果应该是让大家都按照自己可接受最高价购买，用户愿意购买，商家收益最大化</strong></p><p>​张三消费能力强，不应该给他发券，他使用原价30元进行消费，消费者剩余为0</p><p>​李四消费能力弱，从高折扣券陆续发到低折扣券，不断试探用户可接受的最高价，直到消费者剩余为0</p><p>​只有这样，商家才能实现收益最大化。</p><p>​但是线下优惠券由于投放不精准问题，是无法达到理想效果的，所以商家极难实现收益最大化。但是互联网的出现改变了这一切。</p><h3 id="线上优惠券的出现"><a href="#线上优惠券的出现" class="headerlink" title="线上优惠券的出现"></a>线上优惠券的出现</h3><p>​我们的主角终于要登场了，时间来到了21世纪初期，并将视野聚焦到我们身边的国家，日本。</p><p>​日本的移动互联网的发展在当时是全球领先的，2010年3G网络几乎就达到了100%的覆盖率，在这样的背景下，<strong>日本麦当劳找到了优惠券投放不精准的解法</strong>。</p><p>​日本麦当劳此前一直想尽量收集消费者信息，比如用户的性别、年龄，来为用户提供更加精准的优惠券，具体做法就是需要用户自行填写个人信息，但是收效甚微。</p><p>​但是如果大家都通过线上进行消费呢？通过交易系统的将可以准确的采集到每个人的消费信息，并记录在数据库。</p><p>​<strong>基于用户数据 + 用户信息挖掘系统，分析用户的消费频次、消费门店、消费金额、购买品种，便可以猜测出用户的消费水平与消费习惯，进而通过电子优惠券的方式实现精准营销</strong></p><ul><li>对于经常购买汉堡的用户，发放小食优惠券，增加用户消费上限</li><li>对于一段时间未关顾的用户发放以前经常购买产品的优惠券</li><li>对于价格敏感型用户，这发放更加大幅的优惠券刺激用户的消费</li></ul><p>​<strong>线上优惠券的出现完全改写了传统优惠券的定义，从商家决定优惠券是什么，变成由用户自己的消费习惯决定优惠券是什么</strong>，完全脱离了以前的单纯的打折促销的作用。</p><p>​而是经过数据分析、精准营销，再通过电子优惠券的方式，实现了不同用户的相同产品的差别定价，更大限度的实现消费者满意，商家利润最大化的理想状态。</p><p>​电子优惠券带着他无法取代的优势开始被大众所熟知，用户分群、基于用户的消费习惯动态给予优惠券的精准营销逻辑开始进入大家的生活，优惠券进入了全新的时代；</p><p>​那么问题来了，新时代的优惠券还可以为大家省钱吗？</p><p>​</p><h3 id="优惠券真的是为了给大家省钱吗？"><a href="#优惠券真的是为了给大家省钱吗？" class="headerlink" title="优惠券真的是为了给大家省钱吗？"></a>优惠券真的是为了给大家省钱吗？</h3><p>​电子优惠券的出现确实让消费者省钱了，但是商家也挣钱了，这看似不合理，<strong>买家更省钱，卖家更挣钱，钱还能凭空变出来不成？</strong></p><p>​只有一种可能，省钱的消费者和不省钱的消费者不是一拨人，而电子优惠券做到了用户分群。</p><p>​让我们看看这几年的双十一购物节，淘宝令人诟病的复杂优惠券机制，站在用户视角，一定是让大部分人不耐烦的，直接把优惠给我不就行了吗？站在淘宝的视角，给用户优惠，但是不能无脑给，给的同时要实现收益最大化，想要收益最大化就需要<strong>让尽可能多的人使用可接受的最高价下单</strong>，大家在淘宝花时间玩游戏也好，活跃也好，如果感觉价格合适了，一般就不存在足够的动机继续下去，于是为了商家、平台的利益最大化，淘宝设定了一套复杂的优惠机制，让消费者利用时间与精力换取优惠。</p><p>​当价格高于心理可接受的最高价的时候，时间与精力的价值小于优惠的价值，用户会自发性的参与活动，获取优惠。</p><p>​当价格低于心理可接受最高价的时候，用户则没有足够的动机继续参与活动获取优惠，而是进入下单流程。</p><p>​<strong>通过这样一个付出成本获取优惠的机制，实现了针对不同用户的动态优惠，完成了用户分层与针对每个用户的区别定价；最终不同消费能力的用户都认为省钱了，同时消费者剩余为0，商家+平台利润最大化状态。</strong></p><img src="http://qiliu.vkcyan.top/FmmnhC5ER69UigqsnSeWXFyVSE92.png" style="zoom:50%;" /><p>相比较与传统优惠券，电子优惠券有一些非常突出的优点</p><ul><li>电子优惠券实现了动态定价，让商品覆盖到了更多的维度，同时更大限度的实现了消费者剩余为0。</li><li>价格标高 + 复杂的优惠券规则，实现对用户的分层，动态实现利润最大化，这个本质上是<strong>优惠券 + 大数据 &#x3D; 卡用户心里最高价</strong>。</li></ul><h3 id="传统优惠券与现代优惠券"><a href="#传统优惠券与现代优惠券" class="headerlink" title="传统优惠券与现代优惠券"></a>传统优惠券与现代优惠券</h3><p>​当我们用传统的优惠券思维，去理解电子优惠券的时候，一切似乎都不合理，而看懂了基于互联网的优惠券的逻辑，我们才能解释现代世界中发生很多事情。</p><ul><li><p>为什么会存在大数据杀熟？</p></li><li><p>为什么不直接降价而是让用户通过优惠券的方式来购买？</p></li><li><p>为什么商家千方百计的想获取你的信息？</p></li><li><p>为什么现如今数据是极其宝贵的资源？</p></li></ul><p>​商家、平台在满足用户需求的情况下，都是为了收益最大化而努力，凭借消费者的用户信息、用户标签、消费习惯，等等信息，实现收益最大化；</p><p>​<strong>通过以上案例与分析，我们可以发现电子优惠券和传统优惠券早已经不是一种东西，虽然他们都叫优惠券</strong>，电子优惠券虽然很厉害，但是也存在很强的开发成本与技术壁垒，传统优惠券虽然能力有限，但是使用门槛很低，成本更低。所以也不能片面说电子优惠券就是好，传统优惠券就是差，<strong>思考自己拥有的资源与需求，理性判断最合适的产品方案</strong>即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​本来只是想回顾一下优惠券的历史，结果一不小心就写了一篇5000字的文章，无论是消费者还是商家，理解优惠券的规则都可以帮助大家更好的理解这个世界发生的事情。</p><p>​下一篇文章，我们将进入实战篇，谈谈<strong>营销工具 - 优惠券的产品设计逻辑</strong>。</p><p>​</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.foodtalks.cn/news/5374">2万字深度拆解可口可乐百年营销史：如何从冷启动到风靡全世界？</a></p><p><a href="https://mp.weixin.qq.com/s/u2nLG2dk3-BxqX8zVhg2mA">我无比怀念肯德基和麦当劳的纸质优惠券</a></p><p><a href="https://weibo.com/1721030600/zmFhXbyAy">艾瑞咨询</a></p><p><a href="http://tech.sina.com.cn/t/2008-05-10/03432187170.shtml">日本3G市场</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;带着问题思考&quot;&gt;&lt;a href=&quot;#带着问题思考&quot; class=&quot;headerlink&quot; title=&quot;带着问题思考&quot;&gt;&lt;/a&gt;带着问题思考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为什么淘宝要把优惠券规则设计的那么复杂？&lt;/li&gt;
&lt;li&gt;为什么不直接降低价格，而是使用优惠券</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="优惠券" scheme="https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>从读《微信背后的产品观》到思考前端工程师的“35岁”</title>
    <link href="https://bluedancers.github.io/2023/08/10/%E9%98%85%E8%AF%BB/%E4%BB%8E%E8%AF%BB%E3%80%8A%E5%BE%AE%E4%BF%A1%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E3%80%8B%E5%88%B0%E6%80%9D%E8%80%83%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E2%80%9C35%E5%B2%81%E2%80%9D/"/>
    <id>https://bluedancers.github.io/2023/08/10/%E9%98%85%E8%AF%BB/%E4%BB%8E%E8%AF%BB%E3%80%8A%E5%BE%AE%E4%BF%A1%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E3%80%8B%E5%88%B0%E6%80%9D%E8%80%83%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E2%80%9C35%E5%B2%81%E2%80%9D/</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2023-11-27T02:43:09.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://qiliu.vkcyan.top/FkbBqDq59Gu7Pjwi9xwN4P1Dz7fM.png"></p><p>​我是一名前端开发者，同时兼任pm职责，近半年在公司负责升级一直在开发与运营的一个B端的Saas商城系统；</p><p>​在对需求剖析、需求抽象、每个字段含义的推敲的时候，我越发对微信这样简洁、自然的产品产生兴趣与共鸣。</p><p>​也会情不自禁的赞叹微信清晰明了、谨慎内敛的结构化产品思路。</p><p>​虽然微信这么多年上线了如此多功能与特性，但是产品简洁而克制的灵魂从来没有改变，哪怕对于60岁的人来说，也几乎不存在用不好微信的情况。</p><p>​而我做为微信的使用者，广义技术上的开发者，无论是产品还是技术维度，都让我越加佩服与引起共鸣(恶心的小程序开发除外)。</p><p>​昨天终于行动了起来，把这本知名的<strong>《微信背后的产品观》</strong>找出来并读了起来，与其叫一本书，不如说是一个演讲的记录，很短，大约2小时就读完了，主要内容是2012年微信4.0发布时候，张小龙长达8个多小时的公开演讲的内容；</p><p>​不同于其他产品经理的书籍，他们会告诉你各种方法论、科学分析方法，张小龙截然相反的采用了一种极其浪漫的方式去看待产品，去理解所谓的用户需求，我认为这种产品思路的领先是微信这么多年在社交领域立于不败之地的根本。</p><p>​虽然在最后，张小龙看似补刀似的说：<strong>我所说的，都是错的</strong>；但是这恰恰就是他的产品理念，所谓产品没有任何科学方法，完全来自于对人，对人类群体的理解，对自己的拷问与质疑。</p><p>​我也斗胆推荐大家看看这本书，很快就能看完，人类之所以存在信息差，就是因<strong>为不知道</strong>，或许看完这本书，你会打开新的思路，某些问题也能豁然开朗。</p><p>​借此机会，我也想与大家分享一下，这几年我<strong>作为一名前端开发者的迷茫与努力</strong>。</p><h2 id="业务前端开发者的困境"><a href="#业务前端开发者的困境" class="headerlink" title="业务前端开发者的困境"></a>业务前端开发者的困境</h2><blockquote><p>我只是一名普通学历，普通的业务前端开发者，所以以下仅是我的个人感觉，不代表所有前端开发者。</p></blockquote><p>​目前在一个小型互联网公司的saas电商部门下，主要职责是前端开发组长，我们公司的主营业务不是saas电商，所以这几年算不上受到到很强的市场冲击，平时会管理几人的小团队，我18年毕业至今，一直在这家公司。</p><p>​而我大学毕业之后一直从事前端开发方向，在我工作1-3年的阶段，我都保持着对技术的热情，主要是因为尝到了学习技术的甜头，那时候我坚定的认为下一个阶段是<strong>全栈</strong>，在工作之余我花费了大量的精力学习技术；但是后面我就发现了一个很现实的问题，公司需要大家更好分工协作，所以高级别的项目后端是绝对轮不到一个前端去开发开发；并不是说能力不行，而是人的精力有限，前后端都干，还要管团队，是忙不过来的。</p><p>​在这样的环境下，关于全栈技术的学习，我也越发疑虑，逐渐走到了大多数业务前端开发者的临界点。</p><ul><li>业务前端的35岁危机在普通人身上是存在的，我们的年纪、精力、外部压力都不允许你永远征战一线，并始终保持高竞争力。</li><li>业务前端的上限很低，大多数努力的前端开发者可以在3 - 5年内触摸到业务前端的上限，职位也就是前端组长。</li><li>技术纵深是很好的选择，但是受限于综合实力（英语、计算机基础、天分），普通人可以达到的纵深远比想象的要浅。</li><li>技术学会了，但是用不上，也会慢慢被遗忘；demo级别的应用无法让开发者对某一项技术有深刻理解。</li><li>在业务开发场景下的前端，永远是<strong>没有灵魂的大头兵</strong>，上限低就意味着待遇相对较低、可替代性相对较强。</li><li>代码写的越多，与人交流的机会越少，对于几十年的人生而言，这是一件很没安全的事情。</li></ul><p>​总结一下，就是因为兴趣而走的前端技术路径开始越来越窄，前路开始越来越看不清，时间推着我向前，这不禁让我低头沉思，下一步究竟要怎么走？</p><h2 id="说回产品"><a href="#说回产品" class="headerlink" title="说回产品"></a>说回产品</h2><blockquote><p>到目前为止我也依旧不确定前路怎么走，接下来的一些结论，只是我的一些探索。</p></blockquote><p>​在大学后期，我隐约感觉技术路线并非我所擅长的时候，我有目的的学习了微观经济学、企业管理、竞争战略相关的知识，从而间接接触到了互联网产品，也就是pm。</p><p>​我很快就感受到了pm的魅力：<strong>创造</strong>，我恰好是一个喜欢新鲜事物的人，在技术上总喜欢优化、迭代、升级，亲手构建出优美并且有价值的产品极具满足感，而前端开发者与用户的距离比任何一个岗位都要近，甚至可以说：前端开发者决定了用户体验。</p><p>​如果一个人同时具备前端开发 + 产品的能力是不是还不错？</p><ul><li>消除技术与产品的认知壁垒，后续我们做到了，在我们公司，产品和技术从来不吵架</li><li>如果有能力决定产品走向，开发者就可以是一名有灵魂的大头兵，甚至晋升军衔。</li></ul><p>也就是说，我逐渐不再下探技术，而是<strong>走向用户</strong>。</p><p>​走向用户，并不意味着开发者要放弃对技术的学习，技术很重要，技术能力依旧是核心竞争力，而是随着我对技术的理解逐渐深入，开始越发清晰的了解到，究竟什么样的能力是前端开发者最需要的，什么样的能力边际收益是最高的。</p><img src="http://qiliu.vkcyan.top/Fj5ClfMkacFzfRYeT1ie06gkYNn8.png" style="zoom:30%;" /><p>​在我从事前端开发第2年至今，我一直都有在产品这方面作出努力与尝试。</p><p>​关于这几年产品的结果，大概可以用这句话来形容：</p><p>​100个想法中，80个想法死在在调研与分析阶段，15个想法死在在demo阶段，最后落地5个想法，其中4个反响平平，只有1个还算成功。</p><p>​虽然绝大部分都是失败，但是站在此刻回头来看，这几年的产品的学习将我的思维高度提升了很多，综合能力也提升了很多，因为很多想法初期是没有团队介入的，凡事都需要亲力亲为，需要思考需求、写最小demo、UI设计、沟通，而上线后，有需要又要为产品负责，就需要进行数据分析，线上数据的观察，等等….，这其实比写代码累多了。</p><p>​这些进步不像程序的学习有一个可量化的指标，这样的软实力很多的是一种感觉，虽然依旧是时而迷茫，但是也偶尔会有一些收获。</p><p>​虽然我做的产品决策越来越多，公司与同事给予的信任也越来越多，所以在产品上的舞台也是越来越大，而看了《微信背后的产品观》，里面的想法非常符合我对产品的理解，当然我的理解是相对浅显与张小龙没法比的，不过张小龙对产品的理念，以及他对需求的理解，这样一套浪漫的方法论，真的非常有魅力，这也是为什么，我看完最后决定写这篇文章。</p><h2 id="跨越“技术”思维"><a href="#跨越“技术”思维" class="headerlink" title="跨越“技术”思维"></a>跨越“技术”思维</h2><p>​这几年，我的老板经常会找我聊天，因为我和他提过对产品很有兴趣，在前两年，他反复和我提一句话<strong>技术为业务服务</strong>，我当时觉得我理解这句话了。</p><p>​我想，这不是废话，写代码最终都是为了公司的项目，为了更好更快的完成公司需求，我要狠狠的学习技术。</p><p>​之后来随着我写的代码越来越多，我对这句话逐渐有了新的理解。</p><p>​之前过于执着于<strong>技术</strong>，总是站在写代码的角度去理解，而这句话的侧重点是<strong>业务</strong>，或者我们换个词<strong>交付</strong>。</p><p>​并不是技术推动交付，而是在推动交付的因素中，技术是其中之一，我们可以衍生出很多类似的话；设计为业务服务、产品为业务服务….</p><p>​所以<strong>技术的目的并非技术，而是交付价值。</strong></p><p>​<strong>人们总是不自知的放大自己在团队中的价值</strong>，这样只会蒙蔽大家的视野，走到更高处，对很多事物将会有不一样的理解。</p><p><img src="http://qiliu.vkcyan.top/Fh1A7U86ZW-_I64VW8gr-hmg2Zd8.png"></p><p>低纬度的技术思维，走向高纬度的业务（交付）思维。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​其实我本来只是觉得读了还不错的一本书，不复盘、不留下点什么反思会达不到学习的目的，写着写着就想到了自己的职业，想到了这几年的经历；</p><p>​总结性的话不说太多，希望可以帮助到屏幕前你，我们共同成长，共同进步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://qiliu.vkcyan.top/FkbBqDq59Gu7Pjwi9xwN4P1Dz7fM.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	我是一名前端开发者，同时兼任pm职责，近半年在公司负责升级一直在开发与运营的一个B端的Saas商城系统；&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="书摘" scheme="https://bluedancers.github.io/categories/%E4%B9%A6%E6%91%98/"/>
    
    
    <category term="产品" scheme="https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
    <category term="张小龙" scheme="https://bluedancers.github.io/tags/%E5%BC%A0%E5%B0%8F%E9%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>这是我写过的最简单的Vue3中后台动态路由 + 侧边栏渲染方案</title>
    <link href="https://bluedancers.github.io/2023/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BF%99%E6%98%AF%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Vue3%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%20+%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/"/>
    <id>https://bluedancers.github.io/2023/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BF%99%E6%98%AF%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Vue3%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%20+%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/</id>
    <published>2023-06-14T16:00:00.000Z</published>
    <updated>2023-11-27T03:16:52.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​在3年前发布了一篇<a href="https://juejin.cn/post/6844903816593145864">vue2后台管理系统动态路由方案</a>，时至今日，<strong>vue2</strong>已经升级到了<strong>vue3</strong>，动态路由的实现方案也同步做出了一些升级迭代，帮助开发者们更高效的完成业务需求，然后摸鱼🐟。</p><p>​本次逻辑的升级，主要聚焦于2点</p><ol><li><p><strong>更加简单的实现逻辑</strong></p></li><li><p><strong>更加便捷的路由配置</strong></p></li></ol><h2 id="之前的动态路由方案"><a href="#之前的动态路由方案" class="headerlink" title="之前的动态路由方案"></a>之前的动态路由方案</h2><ul><li><p>前端只存储基础的路由（<strong>登录、首页、404</strong>）</p></li><li><p>根据不同的登录角色，返回其对应的可访问路由树</p></li><li><p>从服务端获取路由树（<strong>JSON</strong>）并递归处理成<strong>vue-router</strong>可使用的数据结构，并通过<strong>addRouters</strong>拼接到基础路由树，完成动态路由</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>相当安全，项目里面只有基础路由，业务路由全部来自接口</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>代码中只保存了基础路由，<strong>业务路由的全部字段需要前端开发人员手动录入到超级管理系统之中，维护业务路由非常繁琐。</strong></li><li>客户端逻辑相对复杂，<strong>addRouters</strong>的逻辑必须在路由钩子<strong>beforeRouter</strong>中完成，这部分逻辑比较烧脑。</li></ul><p>有没有一种办法，可以<strong>既保留动态路由的特性，也保证代码逻辑的简单性，同时将路由配置回归前端项目呢？</strong></p><h2 id="转变解决思路"><a href="#转变解决思路" class="headerlink" title="转变解决思路"></a>转变解决思路</h2><p>​通过以上分析，我们首先可以明确一点，动态路由的配置数据还是<strong>需要放在前端项目</strong>中，而不是将路由的配置录入到系统中。所以，我们可以简化系统后台的权限配置，由之前的超多字段简化为两个字段 <strong>路由名称、路由标识，仅服务于为角色勾选路由，路由配置交还给前端项目</strong>。</p><p>​<strong>路由的树形结构还是需要录入到系统中</strong>，因为我们还需要<strong>保留动态路由的核心逻辑</strong>，给（角色&#x2F;用户）勾选指定路由。</p><img src="http://qiliu.vkcyan.top/Fmtj-mmyZ6NTcHap9GnkgQ6_YXSE.png" style="zoom:50%;" /><p>​<strong>Vue2</strong>版本，我们通过<strong>addRouters为项目路由树“做加法”实现动态路由</strong>。</p><p>​<strong>Vue3</strong>版本，我们则为项目路由树手动<strong>“做减法”实现动态路由</strong>。</p><h2 id="做“减法”实现动态路由"><a href="#做“减法”实现动态路由" class="headerlink" title="做“减法”实现动态路由"></a>做“减法”实现动态路由</h2><p>首先依旧将我们的全部路由分成2部分，<strong>基础路由数组，动态路由数组</strong></p><p>基础路由：无论什么角色都可以访问的路由（登录后的公共页面，比如工作台，没有可以为空）</p><p>动态路由：拥有权限的角色才可进行访问的路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础业务路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">baseRouter</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态业务路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">asyncRouter</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 这一层的路由除了dashboard，其他都是业务无关的路由，比如登录 注册 404 500，不属于动态路由</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/login/index.vue&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;baseDashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;根路径&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">component</span>: layout,</span><br><span class="line">      <span class="attr">children</span>: [...baseRouter, ...asyncRouter], <span class="comment">// 全部注册到vue-router中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们直接将全部路由都注册到<strong>Vue</strong>中，如果不存在鉴权，此时任意角色都可以访问所有页面。</p><p>为了实现动态路由的需求，我们只要解决两个问题</p><ol><li><strong>如何实现路由拦截，拦截不允许被访问的页面。</strong></li><li><strong>如何做减法，筛选出指定的权限树，用于侧边菜单栏的展示。</strong></li></ol><h3 id="如何实现路由拦截"><a href="#如何实现路由拦截" class="headerlink" title="如何实现路由拦截"></a>如何实现路由拦截</h3><p>在用户登录的时候，我们会调用服务端的**<code>获取当前用户权限</code>**接口，获取到当前用户的权限数据</p><p>无论后端给我们返回的什么样的接口，嵌套也好、一维数组也罢，我们都将其处理成一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;index&quot;</span>, <span class="string">&quot;dashboard&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;goods&quot;</span>, <span class="string">&quot;goodsList&quot;</span>, <span class="string">&quot;goodsClass&quot;</span>]</span><br></pre></td></tr></table></figure><p>并将这样的一维数组，保存到我们全局状态库<strong>pinia</strong>中，我们假设变量名称为<strong>authList</strong>。</p><p>然后我们再增加路由钩子的逻辑，每次跳转之前，都判断<strong>next</strong>的页面<strong>name</strong>在<strong>authList</strong>中是否存在，如果不存在，则直接<strong>404</strong>，如果存在，则<strong>允许访问</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> auth = <span class="title function_">useAuthStore</span>()</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// 登录后逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (auth.<span class="property">isLogin</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断权限是否通过</span></span><br><span class="line">    <span class="keyword">if</span> (auth.<span class="property">asyncRouter</span>.<span class="title function_">includes</span>(<span class="title class_">String</span>(to.<span class="property">name</span>))) &#123;</span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未登录逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>经过beforeEach的逻辑之后，我们现在就已经实现了基本的鉴权，不允许访问的页面，都将404</strong>。</p><h3 id="递归筛选出菜单树"><a href="#递归筛选出菜单树" class="headerlink" title="递归筛选出菜单树"></a>递归筛选出菜单树</h3><p>​接下来，我们考虑第二个问题，用户登录之后，自身权限获取完毕，用户进入到管理系统内部，右侧显示功能侧边栏，<strong>我们不能将不属于该用户的动态路由都显示出来</strong>，所以我们需要根据服务端返回的权限数据，实现项目中的动态路由<strong>asyncRouter</strong>的筛选。</p><p>​因为我们路由层级理论上是无限的，所以这里使用<strong>递归</strong>进行实现比较合理。</p><img src="http://qiliu.vkcyan.top/Fjpi98MtbL0irT1Va_-kNy2BXSfw.png" style="zoom:50%;" /><p>实现思路如下</p><ol><li>递归遍历<strong>asyncRouter</strong>路由树，如果路由的<strong>name</strong>在权限数组内，并且该菜单可显示，则继续递归<strong>children</strong>，如果没有<strong>children</strong>则不做处理</li><li>如果路由的<strong>name</strong>不在权限数组中，则将其<strong>splice</strong>，也就是<strong>做减法</strong>，并且循环下标后退一位，防止跳过下一个。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取可访问路由树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">tree</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">loopRouter</span>(<span class="params">tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = tree.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = tree[i]</span><br><span class="line">    <span class="keyword">if</span> (asyncRouter.<span class="title function_">includes</span>(item.<span class="property">name</span>!) &amp;&amp; item.<span class="property">meta</span>!.<span class="property">showMenu</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">children</span>) &#123;</span><br><span class="line">        item.<span class="property">children</span> = <span class="title function_">loopRouter</span>(item.<span class="property">children</span>!, asyncRouter)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tree.<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">      len = tree.<span class="property">length</span> <span class="comment">// 刷新循环长度</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; tree.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除后,数组长度-1,数组的下一位前进了一位,所以一旦splice掉不存在的权限,便需要i--,否则会跳过下一位</span></span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上代码后，我们的路由树便会过滤掉那些不允许被访问的路由</p><p>接下来，我们便可以进行菜单的渲染工作了，前端基操我就不做过多赘述了，大家可以看看我精心为大家准备的<a href="https://github.com/BlueDancers/vue3-dynamic-routing-admin">源码案例</a>。</p><p>到此为止，我们的动态路由就实现了，是不是非常简单~</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>有经验的小伙伴会问，用户登录后，刷新页面再访问的时候，我们如何处理权限呢？</p><p>在我看来这有2个方案</p><p><strong>方案1（相对简单）</strong>：使用<strong>pinia</strong>的持久化插件<strong>pinia-plugin-persistedstate</strong>来持久化我们存储<strong>pinia</strong>的权限数据，无论用户如何刷新，我们的权限数据都一直有效，这样的实现非常简单，但是存在一定的安全隐患，就是心怀不轨的某些人，知道了不允许访问的菜单路由名称之后，可以通过手动修改当前页面的<strong>localStorage</strong>实现权限的突破。</p><p><strong>方案2（更加安全）</strong>：在<strong>pinia</strong>中创建一个变量<strong>isRouterInit</strong>标识权限是否已经被初始化，如果没获取过权限数据，则为<strong>false</strong>，如果获取过则为<strong>true</strong>；每次<strong>beforeEach</strong>的时候，登录情况下都判断该值是否为<strong>false</strong>，如果为<strong>false</strong>，则请求当前角色的权限数据，并在请求完毕后，再进行相关路由拦截逻辑，并将变量<strong>isRouterInit</strong>改为<strong>true</strong>，表明权限已经被初始化。</p><p>​以上2种方案都可以用，如果安全性要求不是特别高，建议方案1，如果对安全性、实时性要求比较高，则建议方案2。</p><p><img src="http://qiliu.vkcyan.top/Fq4pwPLiWUPmGhd34tSFDfd8x4Ag.png"></p><h2 id="菜单的排序问题"><a href="#菜单的排序问题" class="headerlink" title="菜单的排序问题"></a>菜单的排序问题</h2><p>​经过实操的小伙伴还会发现一个问题，在项目中的路由排序也许是个麻烦事。</p><p>​可能角色A说：我要<strong>acb</strong>，角色b说：我要<strong>bac</strong>，但是我们路由表放在项目中，其排序是固定不变的，有什么办法可以实现项目左侧路由树按照后台返回的权限字段数据进行渲染呢？</p><p>​其实这个问题很简单，我们针对递归后的动态路由的结果，加一个<strong>sort</strong>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取可访问路由树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">tree</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">loopRouter</span>(<span class="params">tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="comment">// 将菜单按照当前拥有权限asyncRouter的顺序排序</span></span><br><span class="line">  <span class="keyword">return</span> tree.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> asyncRouter.<span class="title function_">indexOf</span>(a.<span class="property">name</span>) - asyncRouter.<span class="title function_">indexOf</span>(b.<span class="property">name</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样项目的右侧菜单树就会按照我们后端返回的顺序进行排序了。</p><h2 id="不需要的路由可以删除吗？"><a href="#不需要的路由可以删除吗？" class="headerlink" title="不需要的路由可以删除吗？"></a>不需要的路由可以删除吗？</h2><p>​vue3提供了动态路由的相关<a href="https://router.vuejs.org/zh/guide/advanced/dynamic-routing.html">API</a>，其中有一个<strong>removeRoute</strong>，可以删除不需要的路由，那么，我们在根据登录角色动态删除剔除不需要在侧边栏显示的路由的时候，是否也同步将不需要的路由进行删除呢？</p><p>​关于这个问题，我的建议是，不建议删除，首先我们的路由模块均为异步加载的，是否删除一定不会访问的路由，都不会影响项目的加载。而一旦真的删除了，用户在推出登录切换账号的时候，一定要<strong>重载当前页面</strong>，因为我们不知道用户下一次登录的角色是什么，会不会用到已经被删除的路由。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​B端项目通过动态路由实现角色鉴权，已经是一个非常成熟的方案，无论是使用<strong>“加法方案”</strong>实现，还是使用<strong>“减法方案”</strong>，都是可行的，理论上都是对权限的一次递归筛选。</p><p>​大家主要根据项目规模、要求合理选择最适合的方案，在安全、便捷、开发难度、稳定性，等多角度做好权衡利弊。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	在3年前发布了一篇&lt;a href=&quot;https://juejin.cn/post/6844903816593145864&quot;&gt;vue2后台</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="动态路由 - vue3" scheme="https://bluedancers.github.io/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 笛卡尔积算法构建SKU最佳实践！看完不会来打我</title>
    <link href="https://bluedancers.github.io/2023/06/03/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BASKU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%81%E7%9C%8B%E5%AE%8C%E4%B8%8D%E4%BC%9A%E6%9D%A5%E6%89%93%E6%88%91/"/>
    <id>https://bluedancers.github.io/2023/06/03/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BASKU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%81%E7%9C%8B%E5%AE%8C%E4%B8%8D%E4%BC%9A%E6%9D%A5%E6%89%93%E6%88%91/</id>
    <published>2023-06-02T16:00:00.000Z</published>
    <updated>2023-11-27T02:38:00.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​商城一直都是平台研发类的高频项目，也存在诸多含金量与难度非常大的功能点，比如<strong>购物车模块、支付模块、装修模块、商品模块</strong>、以及很多与业务相关的模块，主导此类复杂需求的开发与落地不仅可以<strong>升职加薪</strong>，也是面试中的<strong>展示肌肉</strong>的时刻，</p><p>​所以今天，我和大家分享一个在正式项目中沉淀出来的<strong>Vue3版发布商品 - 构建sku的思路以及具体实现方案</strong>；附带源码与案例，点赞收藏不迷路，接下来进入正文~</p><p>源码：<a href="https://github.com/BlueDancers/vue3-sku-demo/blob/main/src/views/goods/add/index.vue">https://github.com/BlueDancers/vue3-sku-demo/blob/main/src/views/goods/add/index.vue</a></p><p>案例：<a href="https://bluedancers.github.io/vue3-sku-demo">https://bluedancers.github.io/vue3-sku-demo</a></p><h2 id="什么是SKU"><a href="#什么是SKU" class="headerlink" title="什么是SKU"></a>什么是SKU</h2><p>​在开始正文之前，首先要做一次扫盲，那就是我们说的电商项目中的SKU，究竟是什么？</p><p>​SKU的全称是<strong>Stock Keeping Units</strong>，我们可以理解为<strong>商家用于管理商品库存和销售的一种方式</strong>。</p><p>​每个 SKU 对应着一个若干<strong>属性</strong>的组合，例如一个商品存在<strong>颜色、尺寸、款式</strong>等属性。商家可以根据商品的不同属性设置不同的 SKU，并对每个 SKU 进行价格、库存若干信息的管理。</p><p>​举个例子，假设商家有一件衬衫商品，有<strong>红色、蓝色</strong>两种颜色、<strong>S、M、L</strong> 三种尺码可选。那么该商品便存在 <strong>6 个 SKU</strong> ，分别为：</p><ul><li>红色 S 号</li><li>红色 M 号</li><li>红色 L 号</li><li>蓝色 S 号</li><li>蓝色 M 号</li><li>蓝色 L 号</li></ul><p>在这里我们就要明确一下概念了，<strong>颜色、尺码</strong>都是我们的商品属性中的<strong>销售属性</strong>，而生成的 <strong>红色 S 号 红色 M 号 等等</strong> 就是我们的<strong>SKU</strong>。</p><p>再让我们在看看某宝的SKU选择弹窗</p><img src="http://qiliu.vkcyan.top/FnoRiGevwfyWw1iDnZu5FD_mNrQi.png" style="zoom:33%;" /><p>​这个商品的<strong>销售属性</strong>：尺码（6个） 颜色分类（6个），那么通过销售属性，最终将会生成<strong>6*6&#x3D;36个SKU</strong>，而用户选择任意尺码 + 颜色分类的搭配都可以匹配到具体的价格与库存等信息。</p><p>​以上提到的功能点，就设计到电商后台的商品模块的SKU构建知识点，接下来让我们看看，如何使用Vue3构建SKU。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="构建销售属性"><a href="#构建销售属性" class="headerlink" title="构建销售属性"></a>构建销售属性</h3><p>​通过上面的案例，我们得知了SKU并非凭空捏造出来的，而是由<strong>销售属性</strong>动态生成。</p><p>​那么根据某宝的SKU信息，我们反向推导一下，他的销售属性的数据结构可能是这样</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果，不考虑SKU的图片，我们的每个销售属性的数据结构都这样，存在一个销售属性的名称，以及若干个属性值。</p><p>​我们继续观察某宝，发现无论如何修改尺码，白色的图片都是同一张，不会随着尺码的变化而变化，因此我们可以推断出，<strong>sku的图片是由着销售属性进行设置的</strong>；</p><p>​另外还要注意一个细节，一个商品无论存在多少个销售属性，最终只能为其中一个销售属性设定图片，所以我们优化一下我们的销售属性数据结构，增加销售属性图片的字段。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">isAddImage</span>: <span class="built_in">boolean</span> <span class="comment">// 是否上传图片（最多只能打开一个）</span></span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">    thumbnailUrl?: <span class="built_in">string</span> <span class="comment">// 属性图片</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​于是，我们便可以得出我们案例的数据结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> skuAttrItemType = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;尺码&#x27;</span>,</span><br><span class="line">    <span class="attr">isAddImage</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">values</span>: [</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;S&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;M&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;颜色分类&#x27;</span>,</span><br><span class="line">    <span class="attr">isAddImage</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">values</span>: [</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;白色&#x27;</span>, <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;黑色&#x27;</span>, <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​这样的数据结构便满足了我们客户端渲染商品SKU，用户可以将不同的尺码与颜色分类进行搭配，但是我们目前仅能实现SKU的选择，还无法满足用户选择任意尺码 + 颜色分类的搭配后，立刻得知价格的场景。</p><p>这也是我们下一步需要解决的问题，就是基于销售属性构建商品SKU。</p><h3 id="使用笛卡尔积算法实现商品SKU的构建"><a href="#使用笛卡尔积算法实现商品SKU的构建" class="headerlink" title="使用笛卡尔积算法实现商品SKU的构建"></a>使用笛卡尔积算法实现商品SKU的构建</h3><p>基于以上销售属性，我们的目标是构建一个如下的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>SKU的生成是存在明确的运算规则的，<strong>销售属性的属性名称的数量的乘积等于SKU的数量</strong>。</p><p>比如我们上线的销售属性是 两个尺码 两个颜色分类，则生成的SKU数量2 * 2 &#x3D; 4个</p><p>假如我们存在三个尺码 三个颜色分类，则生成的SKU数量3 * 3 &#x3D; 9个</p><p>假如我们再多一个销售属性 两个尺码 三个颜色 四个风格，则生成的SKU数量为 2 * 3 * 4 &#x3D; 24个</p><p>​我们程序如何实现以上逻辑呢？大部分小伙伴面对这样的诉求的第一反应应该都是递归，因为销售属性的数量是未知的，写死循环实现是不现实的，不过在SKU生成上，我们一般使用更加简单的<strong>笛卡尔积算法</strong>。</p><p>​<strong>笛卡尔积：笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积，又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 。</strong></p><img src="http://qiliu.vkcyan.top/Fmr0wr2qWAEvldYISLN3RLzcK6zt.png" style="zoom:30%;" /><p>接下来，我们就来实现这一部分的逻辑</p><p>sku的生成是实时的，销售属性的变化会引发sku的变化，所以我们需要监听销售属性的变化，这里我们通过watch进行实现</p><blockquote><p>笛卡尔积本身不复杂，熟练了解reduce即可，如果有点忘记了，请去<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">MDN</a>复习一下~</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">isAddImage</span>: <span class="built_in">boolean</span> 是否上传图片（限制最多只能打开一个）</span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">    thumbnailUrl?: <span class="built_in">string</span> <span class="comment">// 属性图片</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听销售属性的变化,并构建sku</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> skuAttributes.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">generateSku</span>(<span class="title function_">deepClone</span>(value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新销售属性构建sku</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">skuAttribute</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateSku</span>(<span class="params">skuAttribute: skuAttrItemType[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">attrValue</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  skuAttribute.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> attrValue.<span class="title function_">push</span>(item.<span class="property">values</span>)) <span class="comment">// 获取所有属性名称 =&gt; [[&#x27;S&#x27;,&#x27;M&#x27;], [&#x27;白&#x27;,&#x27;黑&#x27;]]</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始构建sku </span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">skus</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  <span class="comment">// 笛卡尔积算法（注意，我们的reduce没有指定第二个参数，则第一次循环中，col是数组第一位，set是数组第二位）</span></span><br><span class="line">  skus = attrValue.<span class="title function_">reduce</span>(<span class="function">(<span class="params">col: <span class="built_in">any</span>[], set</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">res</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">    <span class="comment">// 对于每个属性值集合，依次与当前已有的结果集做笛卡尔积</span></span><br><span class="line">    col.<span class="title function_">forEach</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">// 将两个属性值合并为一个字符串，并存入结果集中</span></span><br><span class="line">        <span class="keyword">let</span> t = c.<span class="property">attributeValue</span> + <span class="string">&#x27;,&#x27;</span> + s.<span class="property">attributeValue</span></span><br><span class="line">         <span class="comment">// 寻找销售属性指定的图片</span></span><br><span class="line">        res.<span class="title function_">push</span>(&#123; <span class="attr">attributeValue</span>: t, <span class="attr">thumbnailUrl</span>: c.<span class="property">thumbnailUrl</span> || s.<span class="property">thumbnailUrl</span> || <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">// 将笛卡尔积后的结果集返回，作为下一轮的结果集</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="comment">// 将结果存储起来</span></span><br><span class="line">  stockKeepUnits.<span class="property">value</span> = skus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上的代码，我们变化销售属性，就会得出以下的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这便实现了我们的sku算法，无论是多么复杂的销售属性，都可以通过该函数，输出符合预期的SKU。</p><p>这时候有同学要说了，哎，我SKU的价格，库存等等属性呢？</p><p>这还不简单？赋值之前再循环一遍，增加字段即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">skus.<span class="title function_">map</span>(<span class="function">(<span class="params">e: skuType</span>) =&gt;</span> &#123;</span><br><span class="line">  e.<span class="property">price</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 价格</span></span><br><span class="line">  e.<span class="property">marketPrice</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 市场价</span></span><br><span class="line">  e.<span class="property">stock</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 库存</span></span><br><span class="line">  e.<span class="property">specificationBarCode</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 销售规格</span></span><br><span class="line">  <span class="keyword">return</span> e</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 将结果存储起来</span></span><br><span class="line">stockKeepUnits.<span class="property">value</span> = skus</span><br></pre></td></tr></table></figure><p>最终我们得到了这样的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>数据准备妥当后，接下来我们就可以渲染表格了，这都是前端基操，我就不做过多赘述，有兴趣的朋友，可以看看<a href="https://github.com/BlueDancers/vue3-sku-demo">源码</a>以及我精心为大家准备的案例。</p><h3 id="实现SKU数据缓存"><a href="#实现SKU数据缓存" class="headerlink" title="实现SKU数据缓存"></a>实现SKU数据缓存</h3><p>如果大家仔细想以上代码，会发现一个问题</p><p>​假设，运营人员在发布商品的时候漏填了一个销售属性，尺码L，但是这时候运营已经填写好了SKU表格中的信息，如果这时候运营想增加字段，根据我们上面的代码，会触发skuAttributes.value的watch，进而运行generateSku，<strong>开始重新构建SKU，导致运营人员之前的数据全部被重置了</strong>。</p><img src="http://qiliu.vkcyan.top/FtwTwzykFR8qzHJwZFVsHIA2XYug.png" style="zoom:50%;" /><p>​而以上提到的场景是项目实际运营期间非常常见的场景，那么有没有办法，可以实现SKU的变动，不影响已经填写好的SKU呢。</p><p>​实现起来其实也很简单，那就是，我们保存每一次生成的SKU的副本，然后在下一次SKU重新构建的时候，对比副本，再回填信息。</p><p>思路如下：</p><ol><li>实时保存SKU的副本</li><li>SKU重新构建的时候对比副本</li><li>销售规格一致的SKU回填副本数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">afterSku</span>: skuType[] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听sku本身的变化,并将当前sku进行备份</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> stockKeepUnits.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    afterSku = <span class="title function_">deepClone</span>(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新销售属性构建sku</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">skuAttribute</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateSku</span>(<span class="params">skuAttribute: skuAttrItemType[]</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line"> <span class="comment">// 增加,回显相关字段</span></span><br><span class="line">  skus.<span class="title function_">map</span>(<span class="function">(<span class="params">e: skuType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找销售规格一致的副本数据</span></span><br><span class="line">    <span class="keyword">let</span> old = afterSku.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">attributeValue</span> == e.<span class="property">attributeValue</span>)</span><br><span class="line">    e.<span class="property">id</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">id</span></span><br><span class="line">    e.<span class="property">price</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">price</span></span><br><span class="line">    e.<span class="property">marketPrice</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">marketPrice</span></span><br><span class="line">    e.<span class="property">stock</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">stock</span></span><br><span class="line">    e.<span class="property">specificationBarCode</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">specificationBarCode</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">  &#125;)</span><br><span class="line">  stockKeepUnits.<span class="property">value</span> = skus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以是其他回填规则，比如按照下标的方式回填，这就看具体业务的要求了，基于副本我们便完成了SKU的变动后数据的缓存功能。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们vue3版本的商城项目的SKU核心实现到此就全部结束了，如果你想了解全部代码，请点击<a href="https://github.com/BlueDancers/vue3-sku-demo">这里</a>，如果你想测试案例，请点击这里</p><p>作为一名Vue3开发者，你可能对这个专栏感兴趣</p><p><a href="https://juejin.cn/column/7124246398278565895">Pinia 源码分析专栏</a></p><p><a href="https://juejin.cn/column/7199826518570172472">Vue3 硬核源码解析系列</a></p><p><a href="https://juejin.cn/post/7052952117425733663">写给前端nginx教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	商城一直都是平台研发类的高频项目，也存在诸多含金量与难度非常大的功能点，比如&lt;strong&gt;购物车模块、支付模块、装修模块、商品模块&lt;/</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="vue3" scheme="https://bluedancers.github.io/tags/vue3/"/>
    
    <category term="sku" scheme="https://bluedancers.github.io/tags/sku/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（7）watch源码解析.md</title>
    <link href="https://bluedancers.github.io/2023/05/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/05/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-17T16:00:00.000Z</published>
    <updated>2023-11-27T02:40:13.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​原本打算本章讲讲<strong>computed</strong>，但是<strong>computed</strong>的源码相当复杂，使用文章的形式说清楚，难度真的很大，所以暂时跳过<strong>computed</strong>，先说说<strong>watch</strong>。</p><p>​<strong>watch</strong>即为监听的意思：<strong>监听响应式数据，每当状态发生变化，就会触发回调函数</strong>。</p><p>​如果大家对之前的源码分析有所理解的话，我相信大家可以猜到watch实现原理，<strong>一定是初始化的时候进行依赖收集，依赖项发生变化的时候依赖触发</strong>。</p><p>​如果能领悟到这一层，那么对vue3的核心实现你已经有所理解啦。</p><p>​接下来就让我们走进watch的世界，让我们看看，vue3是如何实现他的吧。</p><p>首先还是放出watch的逻辑图，watch的逻辑相对简单，因为对于watch而言，响应式是其一部分逻辑。</p><p><img src="https://www.vkcyan.top/FmR0g8twA5yVrokQ-uXkSNKqD5Cn.png"></p><h2 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h2><p>在我刚刚使用Vue3 watch的时候，经常出现以下让我无法解释的情况。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactive的案例</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span> &#125;)</span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">name</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三&#x27;</span>, value))<span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">name</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第四&#x27;</span>, value))<span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span> <span class="comment">// 修改reactive 期望触发watch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ref案例</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">ref</span>(<span class="string">&#x27;卖鱼强&#x27;</span>)</span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个watch&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">value</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个watch&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三次watch&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">value</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第四次watch&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">value</span> = <span class="string">&#x27;狂飙强&#x27;</span> <span class="comment">// 修改reactive 期望触发watch</span></span><br></pre></td></tr></table></figure><p>以上案例，我相信大部分写vue的同学，都很难在第一时间准确判断其watch是否有效无效，接下来就让我们一起从源码中寻找答案。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>watch</strong>的源码并不在<strong>reactivity</strong>中，而是在<strong>runtime-core</strong>中</p><blockquote><p>关于这一点我会谈谈我的想法，讨论一下为什么不在<strong>reactivity</strong>中，而在<strong>runtime-core</strong>中。</p></blockquote><h3 id="watch初始化"><a href="#watch初始化" class="headerlink" title="watch初始化"></a>watch初始化</h3><p>当我们使用<strong>watch</strong>的时候，其执行的具体源码位置为<code>packages/runtime-core/src/apiWatch.ts</code> <strong>line131</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;T = <span class="built_in">any</span>, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span>&gt;(</span><br><span class="line">  <span class="attr">source</span>: T | <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">cb</span>: <span class="built_in">any</span>,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span></span><br><span class="line">): <span class="title class_">WatchStopHandle</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(source <span class="keyword">as</span> <span class="built_in">any</span>, cb, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WatchOptions</span> &#123;</span><br><span class="line">  immediate?: <span class="built_in">boolean</span></span><br><span class="line">  deep?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以了解到，<strong>watch</strong>是存在三个参数的</p><ol><li><strong>source</strong> ：监听项</li><li><strong>cb</strong>：watch的回调函数</li><li><strong>options</strong>： 关于watch的设置，内部存在2个参数<ol><li><strong>immediate</strong>  首次是否运行</li><li><strong>deep</strong>  是否深度监听</li></ol></li></ol><p>这些消息和我们通过Vue文档了解到的信息完全一致，最终我们会发现，其实际返回了一个<strong>doWatch</strong>函数，并将<strong>watch</strong>的三个参数传递了进去。</p><p><strong>doWatch内部的逻辑就是watch实现的核心逻辑了</strong>，我们从三个阶段分析<strong>doWatch</strong>的代码。</p><p><strong>第一阶段：处理source，监听项分析</strong></p><p><strong>第二阶段：构建响应式模块，完成依赖收集</strong></p><p><strong>第三阶段：明确依赖触发方式</strong></p><h2 id="第一阶段：处理source，监听项分析"><a href="#第一阶段：处理source，监听项分析" class="headerlink" title="第一阶段：处理source，监听项分析"></a>第一阶段：处理source，监听项分析</h2><p>我们在使用<strong>watch</strong>的时候，第一个参数，也就是被监听项，是可以传入很多类型的，<strong>ref reactive function array</strong>，在<strong>doWatch</strong>函数中，我们可以看到，针对不同类型与属性的<strong>source</strong>，都做了个性化的依赖处理。</p><p>接下来就让我们看看，<strong>doWatch</strong>都是如何处理这些变量的吧。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote><p>后续getter函数一旦执行，将会访问ref，<strong>触发 ref本身的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// 如果当前source的值是ref, 则处理为() =&gt; source.value</span></span><br><span class="line">  <span class="comment">// 这里注意const num = ref(1) num是ref，num.value并不是ref而是基础类型</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.<span class="property">value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><blockquote><p>后续getter函数一旦执行，将会访问reactive，<strong>触发 ReactiveEffect 完成依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// 如果是reactive则,直接处理成() =&gt; source</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> source</span><br><span class="line">  <span class="comment">// 同时将deep赋值为true 因为reactive为object，一般为多层嵌套，需要深度递归</span></span><br><span class="line">  deep = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><blockquote><p> 后续getter函数一旦执行，将会运行fn，访问函数返回值，如果fn返回的是ref 或者reactive 就会<strong>触发相应的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// callWithErrorHandling函数比较复杂，这里就不做展示了</span></span><br><span class="line">  <span class="comment">// 函数效果为：返回 () =&gt; fn()</span></span><br><span class="line">  <span class="comment">// 后续getter</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> <span class="title function_">callWithErrorHandling</span>(source, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><blockquote><p> 后续getter函数一旦执行，将会访问getter中的所有的访问值，如果fn返回的是ref 或者reactive 就会<strong>触发相应的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isArray</span>(source)) &#123;</span><br><span class="line">  isMultiSource = <span class="literal">true</span> <span class="comment">// 标识为多个监听项</span></span><br><span class="line">  <span class="comment">// array类型的source，可能包含ref reactive Function 所以都需要进行处理</span></span><br><span class="line">  <span class="comment">// 其中reactive比较复杂，需要通过traverse函数，递归触发所有依赖项，也可以说array类型的source，默认deep参数就是true</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> </span><br><span class="line">    source.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isRef</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="property">value</span> <span class="comment">// </span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">traverse</span>(s)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callWithErrorHandling</span>(s, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">callWithErrorHandling</span>(<span class="params">fn,instance,<span class="keyword">type</span>,</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未知类型"><a href="#未知类型" class="headerlink" title="未知类型"></a>未知类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">NOOP</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">getter = <span class="variable constant_">NOOP</span> <span class="comment">// 如果watch的第一个参数不是以上类型，这起getter函数为空</span></span><br></pre></td></tr></table></figure><p>以上就是<strong>watch</strong>针对所有类型的<strong>source</strong>的处理。</p><p>我们可以发现其实就做了一件事，就是将其包装为<strong>getter</strong>函数，<strong>getter</strong>函数一旦运行，便可以触发相关<strong>依赖收集</strong>。</p><p>完成第一阶段的分析，其实我们文章开头提出的问题已经有了明确答案，我们回过头来继续看看</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// user是reactive，将会被处理为（）=&gt; user，同时deep参数默认设置为true，reactive中的所有依赖都将会触发依赖收集，watch有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">name</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// name是reactive内的基础对象，将会被识别为未知类型，所以watch无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 函数返回，并未访问proxy的属性，无法完成依赖收集，所以watch无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">name</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 函数返回 而user.name是proxy下的属性，将会触发依赖收集，所以watch有效</span></span><br></pre></td></tr></table></figure><p>以上就是<strong>reactive + watch</strong>不同使用方式的效果解读。</p><p>有兴趣的小伙伴可以试试解读一下<strong>ref + watch</strong>的结果。</p><p>如果真的记不住，我们就记住下面的这句话：<strong>watch 监听对象本身，使用对象的形式；watch监听对象内部属性，使用函数形式。</strong></p><h2 id="第二阶段：构建响应式模块，完成依赖收集"><a href="#第二阶段：构建响应式模块，完成依赖收集" class="headerlink" title="第二阶段：构建响应式模块，完成依赖收集"></a>第二阶段：构建响应式模块，完成依赖收集</h2><blockquote><p>这上小节，我们完成<strong>getter</strong>函数的构建，这一步我们需要进行依赖触发，与依赖收集，使<strong>watch</strong>的监听功能正式生效。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">  <span class="comment">// 如果deep为true, 则将getter函数再通过traverse进一步处理，使其可以被深度监听</span></span><br><span class="line">  <span class="comment">// traverse的作用前面说过，目的就是递归触发对象所有属性的get。</span></span><br><span class="line">  <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">  getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(<span class="title function_">baseGetter</span>()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化oldValue，如果source是数组isMultiSource为true，否则为false</span></span><br><span class="line"><span class="keyword">let</span> oldValue = isMultiSource ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch的核心实现，注意一下，此刻我们还没有执行</span></span><br><span class="line"><span class="comment">// 内部逻辑非常复杂，我们这里简化处理</span></span><br><span class="line"><span class="comment">// 简单来说就是每次watch的属性或者字段发生变化，都会触发该方法，可以触发的原因是我们getter函数完成了依赖收集的必要逻辑</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">job</span>: <span class="title class_">SchedulerJob</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>() <span class="comment">// 获取被监听项的最新值</span></span><br><span class="line">  <span class="comment">// 如果deep为true 或者新旧值不一致, 则会执行watch的cb，也就是我们需要触发的函数</span></span><br><span class="line">  <span class="keyword">if</span> (deep || <span class="title function_">hasChange</span>(newValue, oldValue)) &#123;</span><br><span class="line">    <span class="title function_">cb</span>(newValue, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">scheduler</span>: <span class="title class_">EffectScheduler</span></span><br><span class="line"><span class="comment">// flush：回调的刷新时机 </span></span><br><span class="line"><span class="comment">// queuePreFlushCb  queuePostRenderEffect 后续再说，我们先假设flush就是async</span></span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">  scheduler = job</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class="property">suspense</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePreFlushCb</span>(job) <span class="comment">// queuePreFlushCb 暂时先忽略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter是第一步处理的，可以访问到响应式字段的函数</span></span><br><span class="line"><span class="comment">// scheduler是watch监听字段发生变化，实际需要执行的回调函数，我们可以理解为scheduler = job = getter</span></span><br><span class="line"><span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, scheduler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cb) &#123;</span><br><span class="line">  <span class="comment">// 如果immediate为true,则代表默认watch初始化阶段自动执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">    <span class="comment">// job中的effect.run运行，完成依赖收集，建立其了变量与cb函数之间的联系。</span></span><br><span class="line">    <span class="comment">// 同时也执行了cb函数，首次watchcb被执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果immediate为false，则直接运行effect.run()，完成依赖收集，建立其了变量与cb函数之间的联系。</span></span><br><span class="line">    oldValue = effect.<span class="title function_">run</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回了effect的stop函数，则意味着，watch api存在返回值，只需要执行一下返回值 就会结束掉watch的监听</span></span><br><span class="line">  effect.<span class="title function_">stop</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​到此为止，我们可以明确了解到，在<strong>Vue</strong>的初始化阶段，<strong>watch</strong>其内部通过<strong>ReactiveEffect</strong>，以及<strong>effect.run()<strong>的触发，完成了</strong>watch</strong>需要监听的变量与触发函数的绑定，<strong>ReactiveEffect</strong>逻辑在<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>可以了解其具体实现。</p><p>​<strong>也就是相当于说，watch内部通过手动访问source，触发source的get事件</strong>，<strong>source</strong>依赖一旦触发，就会开始依赖收集，就会<strong>收集到watch的第二个参数cb</strong>，经进而完成<strong>watch</strong>的依赖收集；<strong>只要source发生改变，一定会触发cb函数。</strong></p><p>​其实到这里<strong>watch</strong>的核心源码就已经结束了，依赖已经完成收集；</p><p>​当被监听变量或者属性发生变化的时候，<strong>cb</strong>函数一定会执行，但是<strong>watch</strong>的执行时机是非常有讲究的；</p><p>​<strong>所以接下来就要讲讲watch第三个参数的flush，该字段就是控制cb函数的执行时机。</strong></p><h2 id="第三阶段：依赖触发"><a href="#第三阶段：依赖触发" class="headerlink" title="第三阶段：依赖触发"></a>第三阶段：依赖触发</h2><p>当我们<strong>watch</strong>监听的字段发生变化的时候，<strong>watch</strong>的第二个参数，<strong>cb</strong>会被触发，但是并不是监听字段发生变化的下一步就立刻触发。</p><p>这里我们回顾一下<strong>watch</strong>源码中变量<strong>scheduler</strong>的相关逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">  scheduler = job</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePreFlushCb</span>(job)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 为了便于理解，暂时认为__FEATURE_SUSPENSE__为false，此处一定等于queuePostFlushCb</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> queuePostRenderEffect = __FEATURE_SUSPENSE__</span><br><span class="line">  ? queueEffectWithSuspense</span><br><span class="line">  : queuePostFlushCb</span><br></pre></td></tr></table></figure><p>我们可以看到，<strong>flush</strong>参数不同的时候<strong>scheduler</strong>的值也是不同的</p><p>如果我们指定了<strong>flush</strong>是<strong>sync</strong>，则<strong>source</strong>发生变化下一个同步任务就是执行<strong>watch</strong>的<strong>cb</strong>函数，</p><p>如果我们不进行指定，默认将是<strong>pre</strong>，则会触发<strong>queuePreFlushCb(job)</strong></p><p>如果指定为<strong>post</strong>，则会触发<strong>queuePostFlushCb(job)</strong></p><p>根据文档我们可以了解到当<strong>flush</strong>为<strong>pre</strong>的时候，<strong>watch</strong>第二个参数<strong>cb</strong>，将会在<strong>Vue</strong>组件更新之前被调用，<strong>post</strong>则会让<strong>cb</strong>函数在<strong>Vue</strong>组件更新之后被调用</p><p>接下来就让我们看看<strong>queuePreFlushCb</strong>与<strong>queuePostFlushCb</strong>内部是如何实现的吧！</p><h3 id="queuePreFlushCb与queuePostFlushCb"><a href="#queuePreFlushCb与queuePostFlushCb" class="headerlink" title="queuePreFlushCb与queuePostFlushCb"></a>queuePreFlushCb与queuePostFlushCb</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedPromise =  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line"><span class="keyword">let</span> currentFlushPromise = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">pendingPreFlushCbs</span>: <span class="title class_">SchedulerJob</span>[] = []</span><br><span class="line"><span class="keyword">let</span> <span class="attr">activePreFlushCbs</span>: <span class="title class_">SchedulerJob</span>[] | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> preFlushIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cb传入到queueCb中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePreFlushCb</span>(<span class="params">cb: SchedulerJob</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行方法附带一些关于pre队列的全局变量</span></span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cb传入到queueCb中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePostFlushCb</span>(<span class="params">cb: SchedulerJobs</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行方法附带一些关于post队列的全局变量</span></span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将cb加入到全局变量pendingPreFlushCbs或者pendingPostFlushCbs中，我们可以理解为缓存了cb函数，并执行了queueFlush</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueCb</span>(<span class="params"></span></span><br><span class="line"><span class="params">  cb: SchedulerJobs,</span></span><br><span class="line"><span class="params">  activeQueue: SchedulerJob[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  pendingQueue: SchedulerJob[],</span></span><br><span class="line"><span class="params">  index: number</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  pendingQueue.<span class="title function_">push</span>(cb)</span><br><span class="line">  <span class="title function_">queueFlush</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数最终将缓存的cb函数访问到Promise的.then中，resolvedPromise已经是resolve状态，则意味着，将会在下一次微任务的时候触发flushJobs</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若干时间后watch被触发，然后一轮事件循环结束，开始触发flushJobs</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  isFlushPending = <span class="literal">false</span></span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">      <span class="keyword">if</span> (job &amp;&amp; job.<span class="property">active</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title function_">flushPostFlushCbs</span>(seen)</span><br><span class="line">    isFlushing = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次触发之前存储的所有cb函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushPreFlushCbs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pendingPreFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> activePreFlushCbs = [...<span class="keyword">new</span> <span class="title class_">Set</span>(pendingPreFlushCbs)]</span><br><span class="line">    </span><br><span class="line">    pendingPreFlushCbs.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; activePreFlushCbs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      activePreFlushCbs[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次触发之前存储的所有cb函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushPostFlushCbs</span>(<span class="params">seen?: CountMap</span>) &#123;</span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>()</span><br><span class="line">  <span class="keyword">if</span> (pendingPostFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> deduped = [...<span class="keyword">new</span> <span class="title class_">Set</span>(pendingPostFlushCbs)]</span><br><span class="line">    pendingPostFlushCbs.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    activePostFlushCbs = deduped</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (postFlushIndex = <span class="number">0</span>; postFlushIndex &lt; activePostFlushCbs.<span class="property">length</span>; postFlushIndex++) &#123;</span><br><span class="line">      activePostFlushCbs[postFlushIndex]()</span><br><span class="line">    &#125;</span><br><span class="line">    activePostFlushCbs = <span class="literal">null</span></span><br><span class="line">    postFlushIndex = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码看起来似乎比较复杂，但是执行的逻辑其实非常简单，<strong>Vue3的更新队列存在三种分别是pre，queue，post，这三个队列按照顺序执行相应代码</strong></p><ol><li>执行<strong>pre</strong>队列中的代码</li><li>执行<strong>queue</strong>队列中的代码，（<strong>queue为组件update的相关逻辑</strong>）</li><li>执行<strong>post</strong>队列中的代码</li></ol><p>这里对照<strong>vue3</strong>文档，我们可以发现，我们的分析是符合文档描述的。</p><blockquote><p>因为涉及到<strong>vue3</strong>的更新队列，这并非<strong>watch</strong>关联的知识，为了方便源码阅读，可以假设<strong>watch</strong>的<strong>flush</strong>的参数为<strong>async</strong>，这样是最好理解的。</p></blockquote><p>到此为止，我们的<strong>watch</strong>核心源码分析就全部完毕了。</p><h2 id="关于ref的一些问题"><a href="#关于ref的一些问题" class="headerlink" title="关于ref的一些问题"></a>关于ref的一些问题</h2><h3 id="watch的源码为什么在runtime-core中？"><a href="#watch的源码为什么在runtime-core中？" class="headerlink" title="watch的源码为什么在runtime-core中？"></a>watch的源码为什么在runtime-core中？</h3><p>关于这一点我是这么理解的，watch不仅仅是一个响应式组件，他涉及到了组件的生命周期，更新渲染等等逻辑，放在runtime中更好与组件系统进行集成，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​通过以上源码分析我们可以发现，watch的响应式原理相对来说是比较简单的，完全依赖我们的之前说过的ReactiveEffect，所以如果小伙伴了解reactive的源码，相信看watch的源码的响应式部分是非常轻松的</p><p>​相对于其他api，watch的响应式实现具备一下2个特点</p><ol><li>watch的依赖收集是<strong>被动触发</strong>的</li><li>watch的依赖触发，实际上是调度器scheduler，然后通过不同的flush，达到控制执行顺序、规则的目的。</li></ol><p>​watch的源码分析就到这里，我们下期再见吧~👋🏻</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:151</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（6） 100行代码 实现mini版ref</title>
    <link href="https://bluedancers.github.io/2023/03/22/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/"/>
    <id>https://bluedancers.github.io/2023/03/22/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/</id>
    <published>2023-03-21T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:55.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>​在上一节，我们完成了<strong>vue3</strong>的<strong>ref</strong>核心源码解读，其实<strong>基础类型的ref的核心逻辑还是非常简单的</strong>，所以在我们的简易版源码环节，我们直接切入基础类型，复杂类型仅做支持，不做讲解。</p><blockquote><p>注：单基础类型场景的ref源码，几乎可以说是整个vue3源码中最简单的一部分，所以这一节的学习难度是最小的</p></blockquote><p><a href="https://github.com/BlueDancers/vue3-mini/tree/ref">mini版vue3仓库地址</a>，还请大家不要吝啬star，下次不迷路~</p><p><strong>仅保留最核心逻辑，极大减低阅读难度，80行代码实现vue3 ref</strong>，让我们直接进入源码实现环节！</p><h2 id="逻辑图（基础类型）"><a href="#逻辑图（基础类型）" class="headerlink" title="逻辑图（基础类型）"></a>逻辑图（基础类型）</h2><blockquote><p>完整版ref逻辑图，请看 Vue3硬核源码解析系列（5） ref源码解析</p></blockquote><p><img src="https://www.vkcyan.top/FjE3zqx5l7zpmv0is0_Fusim1mhf.png"></p><h2 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h2><blockquote><p>如同逻辑图所示，我们简易版源码的具体实现也从 <strong>初始化 依赖收集 依赖触发</strong>三个角度来进行实现</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>ref</strong>的初始化非常简单，逻辑流程如下</p><ol><li>判断传入对象是否已经是<strong>ref</strong>，如果是，这直接返回，如果不是，则继续运行代码</li><li><strong>ref</strong>的本质就是一个<strong>Class RefImpl</strong></li><li>初始化<strong>RefImpl</strong>的时候，将ref的参数保存到<code>_value</code>，同时将参数的原始值保存到<code>_rawValue</code></li><li>通过<strong>get value</strong>，实现<strong>ref.value</strong>的访问</li><li>使用<strong>set value</strong>，实现<strong>ref.value &#x3D; xx</strong>的更新逻辑</li></ol><p>确定实现逻辑的同时，我们也仿照vue3的源码结构开始输出吧~</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue: <span class="built_in">unknown</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否已经是ref,如果是直接返回其本身</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ref本质上就是RefImpl的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T <span class="comment">// ref每次读取与返回的属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T <span class="comment">// ref中value的原始属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">dep</span>: <span class="title class_">Dep</span> | <span class="literal">undefined</span> <span class="comment">// 当前ref相关effect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">__v_isRef</span>: <span class="built_in">boolean</span> = <span class="literal">true</span> <span class="comment">// 标记__v_isRef为true,以后将无法在通过isRef()的判断</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = value     <span class="comment">// 赋值原始值</span></span><br><span class="line">    <span class="comment">// ref API中 __v_isShallow,一定为false （__v_isShallow 表示是否浅层代理）</span></span><br><span class="line">    <span class="comment">// value是基础类型,则toReactive返回原值，value是复杂类型,则toReactive会将其处理成为reactive(proxy)再返回,这就意味着,此时的value是一个proxy</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现ref.value能力</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 配合effect阶段保存的activeEffect,将依赖收集到this.dep中（依赖收集）</span></span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 返回最新value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现ref.value = xx能力</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前set的value是否存在变化, 有变化则进入if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChange</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="comment">// 保存最新的参数原始值，便于下次hasChange判断</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">      <span class="comment">// 如果value是基础类型, 则toReactive返回value本身，否则返回通过toReactive生成的proxy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="comment">// 触发get阶段收集在this.dep中的依赖（依赖触发）</span></span><br><span class="line">      <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><blockquote><p>ref &#x3D; Class RefImpl</p></blockquote><p>​经过我们上一章的<strong>ref</strong>源码分析我们可以了解到，<strong>ref</strong>的依赖收集，并不是依赖<strong>WeakMap</strong>进行完成，而是其自行完成依赖收集，收集在自身<strong>class</strong>的<strong>dep</strong>中，逻辑大概是这样的</p><ol><li>每次触发<strong>ref</strong>的<strong>get</strong>的时候，都会执行一次<strong>trackRefValue</strong>（trackRefValue的作用是完成依赖收集）</li><li>每次执行<strong>effect</strong>的时候，都会将<strong>effect</strong>本身保存到变量<strong>activeEffect</strong>中（具体请看<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>）</li><li>如果<strong>RefImpl</strong>的<strong>dep</strong>不存在，则说明是第一次进行依赖收集，将通过<strong>createDep</strong>将<strong>RefImpl.dep</strong>赋值为<strong>Set</strong></li><li>将<strong>activeEffect</strong>，也就是当前正在运行的<strong>effect</strong>，<strong>push</strong>到<strong>RefImpl</strong>的<strong>dep</strong>中，<strong>ref</strong>完成依赖收集</li></ol><p>明确了逻辑之后，我们依旧结合vue3的源码结构，来完成ref依赖收集的代码输出。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref 依赖收集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref: RefImpl</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断当前是否存在需要收集的依赖</span></span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 判断RefImpl的实例中的dep是否被初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (!ref.<span class="property">dep</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有, 则赋值为Set</span></span><br><span class="line">      ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前effect收集到当前RefImpl实例的dep中, 完成依赖收集</span></span><br><span class="line">    <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">dep</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p>若干时间后，<strong>ref</strong>的<strong>value</strong>被更新，触发<strong>RefImpl</strong>的<strong>set value</strong>，在更新<strong>value</strong>的同时，也会执行其内部的<strong>triggerRefValue</strong>，开始依赖触发逻辑</p><ol><li>获取到当前ref，也就是class <strong>RefImpl</strong>本身的<strong>dep</strong></li><li>循环<strong>dep</strong>中存储的所有<strong>effect</strong>，并执行其<strong>fn</strong>，完成依赖触发。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref 依赖触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefImpl</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前当前RefImpl实例中是否存在收集的依赖</span></span><br><span class="line">  <span class="keyword">if</span> (ref.<span class="property">dep</span>) &#123;</span><br><span class="line">    <span class="comment">// 触发依赖</span></span><br><span class="line">    <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理所有待触发依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="comment">// const effects = isArray(dep) ? dep : [...dep]</span></span><br><span class="line">  <span class="keyword">const</span> effects = [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发执行依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们的<strong>ref</strong>就具备响应式的能力了，是不是很简单~</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​这时候肯定有同学要说了，<strong>你这ref不保熟啊</strong>，仅支持基础类型，不支持复杂类型啊，这不是阉割版ref吗？</p><p>​这里必须澄清一下，虽然简易版ref 100行代码不到，但是他是支持复杂类型的响应式的，因为复杂类型的响应式是依赖<strong>reactive</strong>进行完成的，不过<strong>reactive</strong>的源码解读，并不是本文的重点，所以，这里就跳过了，有兴趣的同学，请看这里<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>，了解<strong>reactive</strong>的响应式实现，再看<a href="https://juejin.cn/post/7212910997778350136">Vue3硬核源码解析系列（5）ref源码解析</a>，了解复杂类型场景下的源码执行逻辑吧。</p><p>​最后，建议大家<a href="https://github.com/BlueDancers/vue3-mini/tree/ref">clone</a>源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，在简历上留下浓墨重彩的一笔~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;​	在上一节，我们完成了&lt;strong&gt;vue3&lt;/strong&gt;的&lt;strong&gt;ref&lt;/strong&gt;核心源码解读，其</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>chatGPT一些学习记录</title>
    <link href="https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-03-20T16:00:00.000Z</published>
    <updated>2023-03-22T03:17:16.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最早"><a href="#最早" class="headerlink" title="最早"></a>最早</h2><p>​自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段文本做到深入的理解与分析，并生成高质量的语言表达。</p><p>​那他究竟是什么原理呢？</p><p>​从一段文本中，随机扣掉一部分字，然后模型不断学习此处到底应该填写什么，<strong>所谓学习与训练就是从大量的数据中学习理解复杂的上下文关系。</strong></p><p>​注：学习 无监督学习 训练 有监督学习</p><p>​bert的出现推动了自然语言处理领域的发展，在bert出现之前，我们都是基于规则与浅层神经网络（关键字理解）去解决，bert的出现使得深度学习在自然语言处理上得到了更加广泛的使用。</p><p>​在bert出现之前，openid就出版了GPT1，GPT1也是基于Transformers进行实现，但是gpt没有走双向Transformers的方向，而是走类似单字接龙的方向，由长文单字接龙的自回归所生成，不过GPT1并没有出现bert的惊人效果，所以早期的GPT没啥热度。</p><h2 id="GPT2-GPT3"><a href="#GPT2-GPT3" class="headerlink" title="GPT2 GPT3"></a>GPT2 GPT3</h2><p>​基于bert的成就，大家都看到深度学习在语言模型上的可行性，于是大家都开始各种预训练模型，完形填空，判断题，改错题，GPT2、3也确实是这个思路，开始提升训练数据量，这个成果我们称之为开卷有益（无监督学习）。</p><p>​让chatGPT对海量互联网文本做单字接龙，以扩充模型的词汇量、语言只是、世界的信息与知识。是chatGPT从哑巴鹦鹉变成了脑容量超大的懂王鹦鹉，这个和人类的学习其实很相似，小孩刚刚来到这个解释，就是不断的输入信息。</p><p>​经过巨量的数据训练之后，我们下一步就需要情景学习（<strong>in-context learning</strong>），这两个阶段是NLP模型的基础工作流程，简单来说，就是让chatGPT对优质对话范例做单字接龙，以规范回答的对话模式和对话内容。是chatGPT变成懂规矩的博学鹦鹉，这里的场景标记几个就够了，机器一旦学会了规范，便可以应对此类所有问题。</p><h2 id="关于强化学习（RL）"><a href="#关于强化学习（RL）" class="headerlink" title="关于强化学习（RL）"></a>关于强化学习（RL）</h2><p>​几年前，alpha go击败了柯洁，几乎说明了，经过强化学习，机器可以做到近乎人类极限的程度，但是这样的场景有一个前提，一个非常明确的奖惩机制，alpha go并不理解围棋规则，但是他可以接收到成功、失败的反馈，模型会根据反馈不断调整策略，已达到更多次成功的目的。</p><p>​我们可以看到alpha go的强化学习规则书相对简单的，因为目标明确，而在NLP领域强化学习却很难实现。</p><p>​因为NLP是语言，语言是没有固定的对错，这就意味着无法设定奖惩机制，除非人工来做反馈。</p><p>​openid还就这么干了，这被称之为 <strong>RLHF（Reinforcement Learning from Human Feedback）</strong></p><p>​openid公司找了40家外包公司，不断帮助gpt筛选什么是好的，什么是坏的，通过这种方式构建了一个奖励（reward）模型。</p><p>​这样训练是为了让他学会举一反三的规律，开始出现类似人类的价值价值观与思考模式。</p><p>​于是gpt通过这样奖励模型，开始感知到真实世界，开始了与真实世界的拟合。甚至可以说奖励模型就是gpt的母体，他对人类的理解不取决于世界，而是取决于模型。</p><p>​这样引导学习的方式，在超大模型上出现惊人的效果，gpt在巨量的数据与规范 + 手动标注引导下，变成了看起来有心智的超级人工智能，甚至出现了理解、例子、思维链的能力。</p><p>​这样的方式也是存在缺点的，比如缺点是可能混淆记忆，无法直接查看个更新所学，并且高度依赖学习材料</p><img src="https://www.vkcyan.top/FgOCZQEw2fTJZsn40Q_b5KP5EvZy.png" style="zoom:50%;" /><h2 id="GPT对现今社会的可能影响"><a href="#GPT对现今社会的可能影响" class="headerlink" title="GPT对现今社会的可能影响"></a>GPT对现今社会的可能影响</h2><p>​chatGPT是里程碑的产品，就像流浪地球里面的行星发动机，刚开始大家都都不知道其潜力，经过验证后，地球上迅速出现了几万座行星发动机，并完成了最后的流浪地球，chatGPT这样大语言模型就像最开始几座行星发动机 ，最终也将会形成改变我们生活的推力</p><p>​合理的使用大预言模型，就可以让一个普通人快速准确的触及各行各业的平均知识， 以及具体解法</p><p>​所以我们可以畅想，未来我们也许不在需要学习如何打架，只需要对gpt发号施令，让机器去具体的做事即可</p><p>​除了chatGPT本身具备对人类的能力输出，chatGPT具备我们人类不具备的一点，那就是他可以在语言中学会世界知识。</p><p>​人脑是有限的，寿命是有限，个体死亡，一切都会消失，直到语言的发明，打通了过去与未来，知识以文字作为载体传承至今，一直以来我们通过纸质、或者其他物理形式进行存储，其效率是有限的，直到计算机的出现，我们开始用电子文档替代纸质， 信息传递的效率飞速提升，但是同时也带来了信息处理的巨大成本。</p><p>​所以人工智能领域的自然语言技术应运而生（NLP），其目标就是让机器理解人类的语言，协助人类处理工作，这是人工智能领域非常重要的发展方向，虽然这些年发展缓慢，但是依旧被很多公司加以厚望，因为机器不需要作息，没有情绪，效率极高，可以为企业节省大量的成本。</p><h2 id="与行业结合的可能性"><a href="#与行业结合的可能性" class="headerlink" title="与行业结合的可能性"></a>与行业结合的可能性</h2><ul><li>搜索引擎，帮助用户更加精准的筛选信息</li><li>笔记工作结合，辅助阅读与写作</li><li>办公软件结合，辅助文字处理，数据分析，演示制作</li><li>教育培训结合，指定学习计划，寻找学习资料</li><li>开发工具结合，辅助编写业务代码，调试纠错</li><li>客服系统结合，全天候问答，</li><li>视频会议结合，会议记录，总结，谈话查找</li><li>审核机制结合，少选评论，统计舆论，给出提醒</li><li>行业顾问，提供法律，医疗，健身等等建议</li><li>社交媒体结合，帮助寻找兴趣相投的用户与话题</li><li>与视频音乐结合，个性化推荐视频、音乐、小说、动漫</li><li>游戏剧情结合，让NPC给玩家带来更加灵活的对话体验</li></ul><h2 id="GPT具备对文字行业巨大的改造潜力"><a href="#GPT具备对文字行业巨大的改造潜力" class="headerlink" title="GPT具备对文字行业巨大的改造潜力"></a>GPT具备对文字行业巨大的改造潜力</h2><ul><li>学术界 创造知识</li><li>教育行业 传承知识</li><li>新闻行业 传播知识</li></ul><p>​还有对传统教育行业的巨大挑战，不是GPT可以给学生写作业，而是对现有的人才教育模式存在很大的冲击。</p><p>​按照现在的教育模式（应试教育，传授既有知识）出来的学生，还能应对未来的5-10年的社会需求吗？</p><p>​其实现在已经不太符合了，因为社会变化太快了，以前人们可以通过学习的知识终生受益，现在能满足毕业后5年其实都比较难了，因为知识过时的太快了，人们就需要不断学习新的知识。</p><p>​正因如此，随着互联网时代的到来，终生学习的理念开始被人们推崇，同时教育模式也开始以【培养学习能力与创造能力】为主了，只有这样才能适应不断变化的时代。</p><pre><code> 试想一下你学习了20年，掌握了一些知识，但是GPT却可以瞬间替代你完成你的能力，怎么办？以后人人都有一个熟读人类既有知识的超级大脑，市场不会因为学校的禁用，而集体不使用。</code></pre><p>​任何事物都存在两面性，好的一面是，GPT将方便人来对既有知识进行集成，推进教育去培养高层次人才</p><h2 id="GPT对网络安全的巨大挑战"><a href="#GPT对网络安全的巨大挑战" class="headerlink" title="GPT对网络安全的巨大挑战"></a>GPT对网络安全的巨大挑战</h2><p>​因为GPT的第一阶段，需要大量录入信息，这其中的信息难免会存在一个坏的信息，亦或者军事机密等等信息，所以国家与国家之间很难愿意共享数据，这也意味着，在不就得将来每个有实力的国家都会自己研发大语言模型</p><p>​同时在应用层面，大预言模型将会像口语、文字、电脑、互联网对社会进行再一次改造。</p><h2 id="社会影响"><a href="#社会影响" class="headerlink" title="社会影响"></a>社会影响</h2><p>​只有会工具的人取代不会使用工具的人，没有工具取代人的说法，所以真正需要害怕的是，我们成为无法成为使用工具的人，时代的车轮势不可挡，抵触新工具就意味着落后，学20年干一辈子的时代已经逐渐远去，我们身处加速时期，必须学会终生学习</p><p>​GPT正在改变人类群体应用知识的方式与继承知识的方式，甚至未来可能会形成人机合作的科研，改变人类创造知识的方式，甚至步入下一个文明形态。</p><p>​每个人的学习能力与理解能力，将是驾驭这项技术的瓶颈，也意味着是否可以充分发挥这一技术的优势，</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>bert（Bidirectional Encoder Representations from Transformers 双向编码变换器）</strong></p><p>​BERT 基于 Transformers 模型架构，使用双向编码器来训练深度双向表示，并在多项自然语言处理任务上实现了最先进的性能</p><p><strong>浅层神经网络（Shallow Neural Network）</strong></p><p>​浅层神经网络是一种神经网络，它只有一层或几层隐层，通常用于浅层特征学习和分类任务。与深层神经网络相比，浅层神经网络的参数量少，计算速度较快，但也可能会受到学习能力和表示能力的限制。</p><p><strong>【UL】无监督学习（Unsupervised Learning）</strong></p><p>​无监督学习是一种机器学习的范畴，其目的是在没有明确的标签或目标函数的情况下，从数据中发现隐藏的结构和规律。在无监督学习中，模型需要从数据中学习如何将数据分组、降维、聚类等。</p><p><strong>【SL】有监督学习（Supervised Learning）</strong></p><p>​有监督学习是一种机器学习的范畴，其目的是在有标签的训练数据上学习一个模型，使其能够预测新的数据。在有监督学习中，模型需要学习如何将输入映射到输出，并根据标签调整模型参数以提高预测性能。（特定的任务上进行微调，例如情感分析、文本分类、命名实体识别）</p><p><strong>【RL】情景学习（Reinforcement Learning）</strong></p><p>​情景学习是一种机器学习的范畴，其目的是通过试错来学习如何在特定的情景下做出正确的决策。在情景学习中，模型需要学习如何在不断尝试和反馈的过程中最大化累计奖励。</p><p><strong>【NLP】自然语言处理技术（Natural Language Processing）</strong></p><p>​自然语言处理技术是一种人工智能技术，旨在让计算机能够理解和生成自然语言。NLP 技术可以应用于文本分类、情感分析、机器翻译、问答系统等领域。</p><p><strong>【LLM】大语言模型（Large Language Model）</strong></p><p>​大语言模型是一种基于神经网络的自然语言处理模型，它可以处理大量的文本数据，并学习语言的语法和语义。目前的大语言模型通常使用预训练加微调的方式进行训练，并在各种自然语言处理任务中取得了很好的表现。</p><p><strong>【MLLM】多模态大语言模型（Multi modal Large Language Model）</strong></p><p>​多模态大语言模型是一种结合了自然语言处理和计算机视觉等多种模态的模型，旨在解决多模态数据的处理和理解问题。与传统的大语言模型不同，多模态大语言模型可以同时处理文字、图片、声音等不同类型的数据，并学习它们之间的交互和关联，从而提高自然语言处理和视觉任务的性能。</p><p><strong>RLHF（Reinforcement Learning from Human Feedback 从人类反馈中强化学习）</strong></p><p>​这是一种机器学习的方法，旨在通过与人类交互来提高强化学习算法的性能。在 RLHF 中，算法会在执行任务的过程中接收人类反馈，并将其作为一种奖励信号来调整自己的策略。与传统的强化学习不同，RLHF 可以在学习过程中快速地获得关于任务的准确信息，并且更容易被应用于实际场景中，如自动驾驶、机器人控制等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最早&quot;&gt;&lt;a href=&quot;#最早&quot; class=&quot;headerlink&quot; title=&quot;最早&quot;&gt;&lt;/a&gt;最早&lt;/h2&gt;&lt;p&gt;​	自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段</summary>
      
    
    
    
    <category term="日常" scheme="https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/tags/chatGPT/"/>
    
  </entry>
  
  <entry>
    <title>（3.1）vue3 手摸手实现mini版reactive.md</title>
    <link href="https://bluedancers.github.io/2023/03/13/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/"/>
    <id>https://bluedancers.github.io/2023/03/13/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/</id>
    <published>2023-03-12T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:41.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>​在上一节，我们完成了<strong>vue3</strong>的<strong>reactive</strong>的核心源码解读，总的来说还是非常复杂，文章的表现能力有限，我想可能有很多同学无法完全理解其精髓，所以在本节，我将带领大家完成mini版本源码的输出。</p><p>​<strong>仅保留最核心逻辑，极大减低阅读难度，200行代码实现reactive + effect</strong>，话不多说，我们直接开始！</p><p><a href="https://github.com/BlueDancers/vue3-mini/tree/reactive">简易版vue3仓库地址</a>，<strong>还请大家不要吝啬star，留个标记，下次迷路~</strong></p><h2 id="逻辑图"><a href="#逻辑图" class="headerlink" title="逻辑图"></a>逻辑图</h2><p><img src="https://www.vkcyan.top/FmPJt0I04Cs834SauJHg3WgJgy5O.png"></p><h2 id="逻辑流程"><a href="#逻辑流程" class="headerlink" title="逻辑流程"></a>逻辑流程</h2><h3 id="reative初始化"><a href="#reative初始化" class="headerlink" title="reative初始化"></a>reative初始化</h3><p>​将<strong>reactive</strong>处理为<strong>proxy</strong>，同时预先声明<strong>set</strong> <strong>get</strong>方法，赋值、取值均通过<strong>Reflect</strong>完成，<strong>get</strong>中存在<strong>track</strong>（依赖收集），<strong>set</strong>中存在<strong>trigger</strong>（依赖触发），完成<strong>reactive</strong>的初始化。</p><h3 id="effect初始化（依赖收集）"><a href="#effect初始化（依赖收集）" class="headerlink" title="effect初始化（依赖收集）"></a>effect初始化（依赖收集）</h3><blockquote><p>cb  &#x3D; callback &#x3D; 回调函数 effect(() &#x3D;&gt; {})   &#x2F;&#x2F; () &#x3D;&gt; {} 就是cb</p></blockquote><p>​初始化<strong>effect</strong>函数，通过一个类<strong>ReactiveEffect</strong>运行其<strong>cb</strong>，同时将当前<strong>cb</strong>存储到公共变量，<strong>cb</strong>中读取了<strong>reactive</strong>的属性，进而触发<strong>proxy</strong>的<strong>get</strong>，同时完成<strong>track</strong>（依赖收集），让<strong>reative</strong>收集到存储在公共变量中的<strong>effect</strong>的<strong>cb</strong>，至此完成依赖收集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重点：reactive - key - effect // 依赖收集完成后，将会形成这样的从上到下的可追溯关系</span><br></pre></td></tr></table></figure><h3 id="reactive改变（依赖触发）"><a href="#reactive改变（依赖触发）" class="headerlink" title="reactive改变（依赖触发）"></a>reactive改变（依赖触发）</h3><p>​若干时间后，<strong>reactive</strong>属性发生变化，触发<strong>reactive</strong>属性的赋值操作，进而触发<strong>proxy</strong>的<strong>set</strong>事件，同时完成trigger（依赖触发），根据指定的<strong>reative + key</strong>，找到特定<strong>effect</strong>运行，完成依赖触发，形成响应式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重点：reactive + key 找到指定effect，进而完成触发</span><br></pre></td></tr></table></figure><h2 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h2><h3 id="proxy处理"><a href="#proxy处理" class="headerlink" title="proxy处理"></a>proxy处理</h3><p>​经过真实的源码分析之后，我们都知道<strong>reactive</strong>实际上就是<strong>proxy</strong>，我们仿照源码的格式，将<strong>reactive</strong>经过<strong>proxy</strong>处理后返回就好了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存proxy</span></span><br><span class="line"><span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">object</span>, <span class="built_in">any</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(target, mutableHandlers, reactiveMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理被代理对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;<span class="built_in">object</span>&gt;,</span></span><br><span class="line"><span class="params">  proxyMap: <span class="built_in">WeakMap</span>&lt;<span class="built_in">object</span>, <span class="built_in">any</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果已经被代理过,这直接返回结果</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, baseHandlers)</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-set函数编写"><a href="#get-set函数编写" class="headerlink" title="get set函数编写"></a>get set函数编写</h3><p>​以上代码我们完成了变量的<strong>proxy</strong>处理，为了完成后续的响应式，我们需要预先声明好<strong>get set</strong>函数，我们依旧仿照源码格式，并只保留核心逻辑，<strong>get</strong>阶段返回结果，并触发<strong>（依赖收集）track</strong>，<strong>set</strong>阶段通过<strong>Reflect</strong>完成赋值，并触发<strong>（依赖触发）trigger</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> get = <span class="title function_">createGetter</span>()</span><br><span class="line"><span class="keyword">const</span> set = <span class="title function_">createSetter</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    <span class="comment">// 核心逻辑: 依赖收集</span></span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, newValue: <span class="built_in">unknown</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    <span class="comment">// 核心逻辑: 依赖触发</span></span><br><span class="line">    <span class="title function_">trigger</span>(target, key, newValue)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="effect实现"><a href="#effect实现" class="headerlink" title="effect实现"></a>effect实现</h3><p><strong>effect</strong>的核心的实现，就是在运行<strong>effect</strong>的时候<strong>保存当前的this</strong>，以便于后续流程中的<strong>依赖收集</strong>，所以其核心代码非常简单，保证一下2点即可。</p><ul><li>运行effect本身</li><li>保存effect的fn到activeEffect即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> effect&lt;T = any&gt;(<span class="attr">fn</span>: <span class="function">() =&gt;</span> T) &#123;</span><br><span class="line">  <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn)</span><br><span class="line">  _effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">activeEffect</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span>&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public fn: () =&gt; T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集（track）"><a href="#依赖收集（track）" class="headerlink" title="依赖收集（track）"></a>依赖收集（track）</h3><p>按照时序，<strong>effect</strong>函数初始化阶段会执行，<strong>effect</strong>函数本身也会被保存到<strong>activeEffect</strong>中，同时触发<strong>effect</strong>中的<strong>reactive</strong>中的<strong>get</strong>事件，进而触发<strong>track</strong>，我们在<strong>track</strong>中完成 <strong>reactive- key - effect之间关系的构建</strong>，确保以后可以在<strong>set</strong>阶段找到<strong>指定的effet的fn</strong>即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="title function_">createDep</span>()</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">trackEffects</span>(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖触发（trigger）"><a href="#依赖触发（trigger）" class="headerlink" title="依赖触发（trigger）"></a>依赖触发（trigger）</h3><p>若干时间后，<strong>reative</strong>中的某个属性发生了变化，也就会发生<strong>set</strong>事件，这时候其实就很简单了，我们只需要通过<strong>reactive - key</strong>找到对应的<strong>effect的fn</strong>，然后执行即可。</p><p><strong>这就形成了我们看到的“响应式”</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, newValue: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dep</span>: <span class="title class_">Dep</span> | <span class="literal">undefined</span> = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">triggerEffects</span>(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  effect.<span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​到此为止，我们简易版的<strong>reactive + effect</strong>的全部源码就完成了，虽然<strong>vue3</strong>的源码很复杂，但是我们抽丝剥茧，仅保留核心逻辑，大幅降低<strong>vue3</strong>源码阅读的难度，让绝大多数的前端开发者都可以读懂核心实现~</p><p>​最后，建议大家<a href="https://github.com/BlueDancers/vue3-mini/tree/reactive">clone</a>源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，然后在简历上留下浓墨重彩的一笔~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;​	在上一节，我们完成了&lt;strong&gt;vue3&lt;/strong&gt;的&lt;strong&gt;reactive&lt;/strong&gt;的核心</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>（7）vue3 runtime-dom源码解析</title>
    <link href="https://bluedancers.github.io/2023/02/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%887%EF%BC%89vue3%20runtime-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/02/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%887%EF%BC%89vue3%20runtime-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-17T16:00:00.000Z</published>
    <updated>2023-11-27T02:38:45.025Z</updated>
    
    <content type="html"><![CDATA[<p>html叫做DOM节点数</p><p>vdom是正式dom的JavaScript数据结构的描述</p><p>在运行时runtime中，渲染器rerender会遍历整个虚拟dom树，并根据此结构构建正式dom树，这个过程我们称之为mount</p><p>当vnode发生变化的时候，，我们会对比旧的vnode与新的vnode，找出他们的区别，并应用于真实dom上，这个过程我们称之为patch。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;html叫做DOM节点数&lt;/p&gt;
&lt;p&gt;vdom是正式dom的JavaScript数据结构的描述&lt;/p&gt;
&lt;p&gt;在运行时runtime中，渲染器rerender会遍历整个虚拟dom树，并根据此结构构建正式dom树，这个过程我们称之为mount&lt;/p&gt;
&lt;p&gt;当vnode发生</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）</title>
    <link href="https://bluedancers.github.io/2023/02/17/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/webpack%E3%80%81vite%E5%9C%A8proxy%E4%B8%AD%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEheaders/"/>
    <id>https://bluedancers.github.io/2023/02/17/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/webpack%E3%80%81vite%E5%9C%A8proxy%E4%B8%AD%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEheaders/</id>
    <published>2023-02-16T16:00:00.000Z</published>
    <updated>2023-02-18T08:16:39.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）"><a href="#通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）" class="headerlink" title="通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）"></a>通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都知道，利用<strong>webpack、vite</strong>的<strong>proxy</strong>可以解决开发环境的跨域问题。</p><p>但是在真实开发场景下，我们可能不仅要面对跨域问题，还有可能面对<strong>动态header</strong>的情况。</p><p>让我们来看如下案例</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>强盛集团开发了一套<strong>多店铺的H5商城系统</strong>，此时小安 小龙 小虎，都想利用这个系统开一个线上商城，我们如何区分他们的店铺呢？</p><p>聪明的同学肯定已经想到了答案，用二级域名进行区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小安 -&gt; xa.shop.com</span><br><span class="line">小龙 -&gt; xl.shop.com</span><br><span class="line">小虎 -&gt; xh.shop.com</span><br></pre></td></tr></table></figure><p>接下来让我们把视角聚焦到强盛集团的技术部门。</p><p>面对这样的多店铺商城系统，开发环境肯定无法用ip直接访问了，因为ip无法识别具体是什么店铺。</p><p>这个问题其实也很好解决，修改本地host即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 xa.shop.com</span><br><span class="line">127.0.0.1 xl.shop.com</span><br><span class="line">127.0.0.1 xh.shop.com</span><br></pre></td></tr></table></figure><p>假设我们开发环境的端口是8082，我们想在开发环境访问小安的店铺，则通过<code>xa.shop.com:8082</code>进行访问。</p><p>​直到某一天，安全部门发现了沙海集团的的scrf恶意攻击，决定限制该产品请求发起方的<strong>Origin Header</strong>与<strong>Referer Header</strong>，并且限制了必须是80端口。</p><blockquote><p>这两个请求头的含义是标记来源域名，可以起到防止scrf攻击的目的。</p></blockquote><p>​此时前端开发就麻烦了，因为在开发环境，我们的<strong>Origin Header</strong>与<strong>Referer Header</strong>都是<strong>x.shop.com:8082</strong>，这会被服务端识别为不合法的请求来源，同时因为浏览器安全限制，前端是不具备直接修改<strong>referer</strong>头的能力， 除非将项目端口号改为80端口，但是这并不是一个好办法。</p><p><strong>如果你是强盛集团的前端开发，你会怎么解决以上问题呢？</strong></p><h2 id="后端高某强提供的思路"><a href="#后端高某强提供的思路" class="headerlink" title="后端高某强提供的思路"></a>后端高某强提供的思路</h2><p>​后端开发高某强这时候提供了一个想法，通过本地nginx代理8082端口就好了呀。</p><ol><li>在开发机器本地启动一个<strong>nginx</strong></li><li>通过<strong>nginx</strong>将<strong>x.shop.com</strong>指向<strong>127.0.0.1:8082</strong></li><li>同时配合<strong>host</strong>的修改，实现开发环境去端口的诉求。</li></ol><p>后续，我尝试了这个方案，确实是可以实现的，也在团队中推广并使用了一段时间；</p><p>但是长期使用下就暴露了一些问题</p><ol><li>每次新增一个站点，都需要同时增加host、nginx中的配置，流程复杂。</li><li>并不是每个前端都了解nginx，初级开发非常容易出问题，增加团队内耗。</li></ol><h2 id="proxy解决方案"><a href="#proxy解决方案" class="headerlink" title="proxy解决方案"></a>proxy解决方案</h2><h3 id="Vite解决方案"><a href="#Vite解决方案" class="headerlink" title="Vite解决方案"></a>Vite解决方案</h3><p>​直到某一天，我在<strong>vite</strong>的文档中突然发现一个细节，<strong>server.proxy</strong>的实现依赖<a href="https://github.com/http-party/node-http-proxy">node-http-proxy</a>，而这个库具备<strong>设置请求头的能力</strong></p><p><img src="https://www.vkcyan.top/Fl8GqobFWoDlUT-UZTrUN43npq1H.png"></p><p>​如果是这样，我是否可以在开发环境通过proxy代理请求接口，同时覆写<strong>Origin Header</strong>与<strong>Referer Header</strong>的方式来解决我们遇到的多域名+端口限制问题呢？进而在开发环境规避掉nginx。</p><p>​通过<strong>vite</strong>的问题可以了解到参数<strong>configure</strong>可以编写<strong>http-proxy</strong>相关逻辑，再结合<strong>http-proxy</strong>文档，我们便可以完成相关代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;/client&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;https://api.xxxx.com&#x27;</span>, <span class="comment">// 需要代理的地址</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">true</span>, <span class="comment">// 如果是https接口，需要配置这个参数</span></span><br><span class="line">      <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/client/</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      <span class="attr">configure</span>: <span class="function">(<span class="params">proxy</span>) =&gt;</span> &#123;</span><br><span class="line">        proxy.<span class="title function_">on</span>(<span class="string">&#x27;proxyReq&#x27;</span>, <span class="function">(<span class="params">proxyReq, req, res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// req是当前真实请求的地址 开发环境为：a.shop.com:8082</span></span><br><span class="line">          <span class="keyword">let</span> host = req.<span class="property">headers</span>.<span class="property">host</span>!.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>] <span class="comment">// a.shop.com 动态获取当前请求地址，并去除端口</span></span><br><span class="line">          proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;referer&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>)</span><br><span class="line">          proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;origin&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="comment">// .....</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​测试结果符合预期，<strong>web</strong>端请求被<strong>proxy</strong>代理，并在代理请求中完成了端口的去除，符合了服务端对<strong>Origin Header</strong>与<strong>Referer Header</strong>的要求。</p><h3 id="Webpack解决方案"><a href="#Webpack解决方案" class="headerlink" title="Webpack解决方案"></a>Webpack解决方案</h3><p>​<strong>vite</strong>测试成功后，我们便开始对<strong>webpack</strong>的<strong>vue2.x</strong>项目<strong>proxy</strong>动态<strong>headers</strong>进行评估；通过<strong>webpack4</strong>的文档，我们可以了解到<strong>webpack4</strong>的<strong>proxy</strong>是基于<a href="https://github.com/chimurai/http-proxy-middleware">http-proxy-middleware</a> 进行实现。</p><p>​接下来我们也顺利在<strong>http-proxy-middleware</strong>文档中找到相关配置</p><p><img src="https://www.vkcyan.top/Fh7xKiiJnus0ciu_JRlUfqO7Wyk9.png"></p><p>我们基于<strong>webpack</strong>与<strong>http-proxy-middleware</strong>的文档，就可以很顺利的做产出了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;/client&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;https://api.xxxx.com&#x27;</span>, <span class="comment">// 需要代理的地址</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">true</span>, <span class="comment">// 如果是https接口，需要配置这个参数</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/client&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">onProxyReq</span>: <span class="function">(<span class="params">proxyReq, req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> host = req.<span class="property">headers</span>.<span class="property">host</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;referer&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>) <span class="comment">//添加请求头</span></span><br><span class="line">        proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;origin&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>) <span class="comment">//添加请求头</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​项目配置完成后，我们便可以在开发环境利用proxy的动态headers完成<strong>a.shop.com:8082</strong>正常访问线上端口了，只需要在本地配置host即可。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>高某强了解到前端部门使用<strong>proxy + 动态headers方案</strong>后，连连称赞，表示请我去他家吃鱼。</p><p>如果你也遇到了类似的问题，快来试试proxy的解决方案吧~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）&quot;&gt;&lt;a href=&quot;#通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="日常开发" scheme="https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="关于proxy" scheme="https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8Eproxy/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（5）ref源码解析</title>
    <link href="https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%20ref%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%20ref%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-02T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:46.861Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​本文是<a href="https://juejin.cn/column/7199826518570172472"><strong>Vue3硬核源码解析系列</strong></a>的第五篇文章，在之前文章中，我们了解到了<strong>reactive effect</strong>的源码实现原理，并抽丝剥茧输出了<a href="https://juejin.cn/post/7209967260898033722">mini版本的reactive + effect</a>，带领大家充分理解<strong>reactive</strong>的实现原理，同时我们也发现了<strong>reactive</strong>在使用上的一些局限性，比如无法代理基础类型。</p><p>​正因为此，<strong>Vue3</strong>提供了另一个API <strong>ref</strong>，面对<strong>proxy</strong>无法代理基础类型数据的问题，<strong>ref</strong>又是如何实现其响应式的呢，本文将带领大家一起走进vue3源码世界，看看<strong>ref</strong>的实现原理</p><h2 id="逻辑图"><a href="#逻辑图" class="headerlink" title="逻辑图"></a>逻辑图</h2><p>因为<strong>ref</strong>既可以传入<strong>基础类型</strong>，也可以传入<strong>复杂类型</strong>，所以其实现逻辑要比<strong>reactive</strong>更加复杂，并且依赖<strong>reactive</strong>。</p><p><img src="https://www.vkcyan.top/FkmdQj_dyMoiD6Rg7PaH-Lf7FdHO.png"></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>如果关于class get set已经很了解，请跳过前置知识</p></blockquote><p>为了降低大家理解<strong>ref</strong>源码的难度，我们在正式阅读源码之前，先学习一下JavaScript的 <strong>class</strong>以及修饰符<strong>get set</strong>相关知识点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  _value = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value的get行为触发&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value的set行为触发&#x27;</span>, val)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Obj</span>()</span><br></pre></td></tr></table></figure><p>get： 被get修饰的方法，允许通过<strong>属性读取</strong>的方式，触发方法</p><p>set： 被set修饰的方法，允许通过<strong>属性赋值</strong>的方式，触发方法</p><p>当访问<code>obj.value</code>的时候，会执行被<strong>get</strong>修饰的<strong>value()<strong>，打印log，并得到返回值</strong>‘张三’</strong></p><p>当我们执行<code>obj.value = ’李四‘</code>，进行赋值的时候，将会执行被<strong>set</strong>修饰的**value()**方法，打印log，并完成变量_value的赋值</p><p>​看到这里，大家是否有点似曾相识的感觉，<strong>访问与赋值触发get set</strong>，和<strong>proxy</strong>代理的对象的<strong>get set</strong>很相似，大家能理解到这一点就足够了。</p><p>​因为ref可以代理<strong>简单类型</strong>，同时也可以代理<strong>复杂类型</strong>，并且这两种情况下的响应式实现逻辑是完全不同的。</p><p>​所以接下来，我们从这两个角度分别解读ref的源码实现，以及其核心逻辑。</p><p>​首先我们看相对简单的基础类型场景，从源码的角度去了解ref是如何实现响应式的。</p><h2 id="基础类型场景"><a href="#基础类型场景" class="headerlink" title="基础类型场景"></a>基础类型场景</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ref, effect &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;卖鱼强&#x27;</span>)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = name.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  name.<span class="property">value</span> = <span class="string">&#x27;狂飙强&#x27;</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>​上述代码现象：</p><ol><li><p>页面初始化的时候显示“卖鱼强”</p></li><li><p>2s之后，<strong>name</strong>发生改变，变成了“狂飙强”。</p></li></ol><p>通过<strong>现象</strong>与我们之前分析<strong>reactive</strong>的经验，这个我们可以将<strong>ref</strong>的实现分为三大模块</p><ol><li><strong>初始化</strong></li><li><strong>读取</strong>（依赖收集）</li><li><strong>赋值</strong>（依赖触发）</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>packages/reactivity/src/ref.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ref 实际上就是createRef</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue: <span class="built_in">unknown</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果已经是ref，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ref API 参数shallow 为 false 含义是 代理是否是浅层的,浅层则只会代理第一层数据</span></span><br><span class="line">  <span class="comment">// ref 就是RefImpl的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T <span class="comment">// 被代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T <span class="comment">// 原始对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span> <span class="comment">// Dep是reative阶段声明的Set, 内部存放的是ReactiveEffect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span> <span class="comment">// 将RefImpl实例默认为true, 未来的isRef判断就一定为true</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123; </span><br><span class="line">    <span class="comment">// 寻找原始类型，如果是基础类型不会做任何处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = <span class="title function_">toRaw</span>(value) </span><br><span class="line">    <span class="comment">// 如果value是基础类型，toReactive内部不会做任何处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    newVal = <span class="title function_">toRaw</span>(newVal)</span><br><span class="line">    <span class="comment">// 判断新旧值是否一致，不一致进入if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="comment">// 每次value的值发生修改的时候，都保存一下原始对象</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">     <span class="comment">// 如果value是基础类型 toReactive不会做任何处理</span></span><br><span class="line">     <span class="comment">// 如果value是复杂类型，则重新进行proxy处理</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 依赖触发，后面单独说</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码分析，我们可以发现，<strong>ref</strong>的本质就是<strong>new RefImpl</strong></p><p>我们ref传入的参数 原始对象被保存到_rawValue，同时将参数（“卖鱼强”）保存到-value中，便于后续的get set</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>调用<code>name.value</code>的时候，会触发<strong>RefImpl</strong>的**get value()**，方法内部返回最新的_value，完成读取。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// trackRefValue(this) // 依赖收集，后面单独说</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p><code>name.value</code>发生赋值的时候，会触发<strong>RefImpl</strong>的**set value()**方法，方法内部进行_value的赋值，完成数据更新。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断新旧值是否一致，不一致进入if</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果value是基础类型 toReactive不会做任何处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triggerRefValue(this)// 依赖触发，后面单独说</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，<strong>ref</strong>的基础逻辑就完成，我们已经具备给<strong>ref</strong>赋值、读取的能力。</p><p>但是还不具备响应式的能力，接下来就让我们看看，ref的响应式系统是如何实现的。</p><h3 id="依赖收集（trackRefValue）"><a href="#依赖收集（trackRefValue）" class="headerlink" title="依赖收集（trackRefValue）"></a>依赖收集（trackRefValue）</h3><p>​根据我们解读<strong>reactive</strong>的源码经验，我们可以猜到，<strong>ref</strong>一定是在<strong>get</strong>中完成依赖收集的，事实也是如此。</p><p>​而第一次<strong>ref</strong>的<strong>get</strong>是何时触发的呢？</p><p>​答案是初始化时期的<strong>effect</strong>，<strong>effect</strong>触发后，内部<strong>fn</strong>被保存到<strong>activeEffect</strong>中，并触发<strong>fn</strong>，<strong>fn</strong>访问了<code>name.value</code>，触发了<strong>ref</strong>的<strong>get</strong>行为，所以接下来我们前往<strong>RefImpl</strong>的<strong>get</strong>中，看看<strong>ref</strong>是如何完成依赖收集的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖收集函数 将当前RefImpl实例传入方法</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref</span>) &#123;</span><br><span class="line">  <span class="comment">// shouldTrack一定为true，activeEffect在effect执行阶段保存了fn，所以一定存在</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="comment">// createDep我们在reactive中见过，含义为创建一个Set</span></span><br><span class="line">    <span class="comment">// 所以这个实际函数是给RefImpl实例的dep赋值为Set，然后在传入trackEffects方法</span></span><br><span class="line">  <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep,</span>) &#123;</span><br><span class="line">  <span class="comment">// 将当前activeEffect，也就是effect的fn，保存到当前RefImpl实例的dep中，effect成功被ref依赖收集到实例的dep中</span></span><br><span class="line"> dep.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上源码，我们可以发现，他们都公用了<strong>activeEffect</strong>部分的逻辑，但是<strong>ref</strong>收集依赖的方式与<strong>reactive</strong>是存在一些差别的</p><ul><li><strong>reactive</strong>的依赖收集通过<strong>WeakMap</strong>完成，实现<strong>属性、变量与effect fn</strong>的绑定关系</li><li><strong>ref</strong>则通过自身实例内部的<strong>dep</strong>变量来保存所有相关的<strong>effect fn</strong></li></ul><h3 id="依赖触发（triggerRefValue）"><a href="#依赖触发（triggerRefValue）" class="headerlink" title="依赖触发（triggerRefValue）"></a>依赖触发（triggerRefValue）</h3><p>若干时间后，<code>name.value</code>的值被修改，触发<strong>RefImpl</strong>的<strong>set value</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断传入值是否与原始值不一致</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">    <span class="comment">// 完成赋值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">    <span class="comment">// 依赖触发</span></span><br><span class="line">    <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ref.<span class="property">dep</span>) &#123; <span class="comment">// dep为依赖收集阶段收集到的依赖，内部为effect的fn</span></span><br><span class="line">    <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = <span class="title function_">isArray</span>(dep) ? dep : [...dep] <span class="comment">// 转为数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="comment">// 进入依赖触发函数</span></span><br><span class="line">      <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  <span class="comment">// 依次通过run触发被收集的effect的fn，至此完成依赖触发工作</span></span><br><span class="line">  effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖触发的逻辑就非常简单了，<strong>set value</strong>的同时，获取当前<strong>ref</strong>的<strong>dep</strong>，并遍历<strong>dep</strong>中的依赖，依次执行，完成依赖触发。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​到此为止，我们基础类型场景的<strong>ref</strong>源码解读就结束了，我们简单做一下总结，</p><p>​相比较于<strong>reactive</strong>，该场景下的逻辑要稍微简单一点，相关依赖<strong>（effect fn）</strong>被实例本身的<strong>dep</strong>管理，没有构建复杂的<strong>WeakMap</strong>对象。</p><p><strong>ref</strong>与<strong>reactive</strong>的收集与触发的逻辑也不相同</p><ul><li>ref实际上是一个<strong>class</strong> <strong>RefImpl</strong>的实例</li><li>数据响应并不是通过<strong>proxy</strong>实现，而是通过<strong>class</strong> 的<strong>get</strong> <strong>set</strong>修饰符实现</li><li>依赖收集、触发并不是通过<strong>WeakMap</strong>实现，而是通过<strong>RefImpl</strong>实例中的变量<strong>dep</strong>实现</li></ul><h2 id="复杂类型场景"><a href="#复杂类型场景" class="headerlink" title="复杂类型场景"></a>复杂类型场景</h2><p>​大家都知道<strong>ref</strong>不仅可以实现基础类型的响应式，还可以实现复杂类型的响应式，我们可以说<strong>ref</strong>是<strong>reactive</strong>的超集，那<strong>ref</strong>是如何实现既支持基础类型也支持复杂类型的呢？</p><p>​接下来就让我们看看复杂类型场景下的<strong>ref</strong>是如何完成响应式的吧。</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ref, effect &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = obj.<span class="property">value</span>.<span class="property">name</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span></span><br><span class="line">&#125;, <span class="number">4000</span>)</span><br></pre></td></tr></table></figure><h3 id="Ref初始化"><a href="#Ref初始化" class="headerlink" title="Ref初始化"></a>Ref初始化</h3><p>首先依旧是进入<strong>ref</strong>函数中，开始<strong>new RefImpl</strong>，前面流程完全一致，所以直接我们进入<strong>RefImpl</strong>内部</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T <span class="comment">// 被代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span> <span class="comment">// Dep是reative阶段声明的Set,内部存放的是ReactiveEffect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span> <span class="comment">// 将RefImpl的实例全部置为true,下次isRef判断就会为true</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = <span class="title function_">toRaw</span>(value) <span class="comment">// toRaw 获取原始数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(value) <span class="comment">// 跳转到toReactive函数中 并且最终会获取到一个proxy对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toReactive = &lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>&gt;(<span class="attr">value</span>: T): <span class="function"><span class="params">T</span> =&gt;</span></span><br><span class="line">  <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value <span class="comment">// value为object，进入reactive(value)逻辑 最终返回一个proxy的对象</span></span><br></pre></td></tr></table></figure><p>​在<strong>constructor</strong>逻辑中，我们可以看到<strong>this._value &#x3D; toReactive(value)<strong>，而</strong>toReactive</strong>函数中，会首先识别<strong>value</strong>类型，如果不是<strong>object</strong>，原路返回，如果是<strong>object</strong>，将会被<strong>reactive</strong>函数处理，所以在该场景下，<strong>value</strong>将被<strong>reactive</strong>函数处理成<strong>proxy</strong>对象。</p><p>​也就是说，此时<strong>ref</strong>内部的**_value<strong>实际上成了</strong>reactive**类型。</p><h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><p>​初始化阶段，<strong>effect</strong>触发的时候，将会读取<strong>obj.value.name</strong>，，首先会访问量<strong>obj.value</strong>，触发<strong>ref</strong>的<strong>get</strong>方法。</p><p>​<strong>obj.value</strong>获取完成后，继续去获取<strong>obj.value.name</strong>，而<strong>name</strong>已经在初始化阶段，被<strong>toReactive</strong>处理成了<strong>proxy</strong>，所以接下来，会再触发<strong>reactive</strong>的<strong>get</strong>，来获取<code>name</code></p><p>​也就是说，读取阶段，实际上触发了2次<strong>get</strong>，一次是<strong>ref</strong>的<strong>get value</strong>，一次是<strong>proxy</strong>的<strong>get</strong>，进而完成了变量的读取。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// trackRefValue(this) // 依赖收集，后面单独说</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span> <span class="comment">// 获取到proxy类型的&#123;name: &#x27;张三&#x27;&#125;，进而再次触发proxy的get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h3><p>若干时间后，<strong>obj.value.name</strong>发生<strong>set</strong>行为，首先依旧会触发<strong>ref</strong>的<strong>get</strong>，获取<code>obj.value</code>，然后再触发<strong>reactive</strong>的<strong>set</strong>方法，完成<strong>name</strong>的赋值。</p><p>整个赋值过程，实际上分别触发了ref的<strong>get value</strong>，和proxy的<strong>set</strong>，进而完成变量的赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ref 本身的set在value为object，并且没有直接修改ref.value的情况下，不会被触发</span></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们了解了ref在处理复杂对象时候的读取与赋值的逻辑。</p><p>读取：<strong>先触发ref的get，再触发proxy的get</strong></p><p>赋值：<strong>先触发ref的get，再触发proxy的set</strong></p><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>依赖收集是在<strong>get</strong>阶段进行完成，而通过上面的分析我们可以了解到，<strong>ref</strong>的<strong>get</strong>实际上其内部是两次<strong>get</strong>事件，所以我们分开来看。</p><h4 id="ref的依赖收集（trackRefValue）"><a href="#ref的依赖收集（trackRefValue）" class="headerlink" title="ref的依赖收集（trackRefValue）"></a>ref的依赖收集（trackRefValue）</h4><p>effect初始化阶段执行的时候，会读取<code>obj.value.name</code>，首先会触发<strong>ref</strong>的<strong>get</strong>方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖收集函数 将当前ref本身传入方法</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ref</strong>的<strong>get</strong>方法触发了<strong>trackRefValue</strong>，会在当前<strong>ref</strong>的<strong>dep</strong>中收集到<strong>effect</strong>，此处逻辑与<strong>ref</strong>为基础类型的逻辑一致。</p><h4 id="proxy的依赖收集（track）"><a href="#proxy的依赖收集（track）" class="headerlink" title="proxy的依赖收集（track）"></a>proxy的依赖收集（track）</h4><p>​<strong>ref</strong>的的<strong>get</strong>完成后，紧接着触发了<strong>reactive</strong>的<strong>get</strong>，然后<strong>get</strong>内部通过<strong>WeakMap</strong>再次完成依赖收集（相关逻辑参考<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>）。</p><p>​我们会发现，在该阶段，我们内部实际上<strong>触发了2次依赖收集</strong>，<strong>effect fn</strong>被<strong>ref</strong>收集的同时，也被<strong>proxy</strong>收集了。</p><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p>因为ref内部是一个对象，所以赋值也存在多种方式，这依赖触发存在多种方式</p><h4 id="对象属性触发依赖"><a href="#对象属性触发依赖" class="headerlink" title="对象属性触发依赖"></a>对象属性触发依赖</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span></span><br></pre></td></tr></table></figure><p>这种<strong>不会破坏RefImpl初始化阶段其内部构建的proxy</strong>，仅修改已有<strong>proxy</strong>内部变量的值。</p><p>首先触发的是<strong>obj.value</strong>的<strong>get</strong>行为（此时没有<strong>effet</strong>在执行，不会发生依赖收集）。然后<strong>ref</strong>的<strong>get</strong>函数返回<strong>proxy</strong>对象 <code>&#123;name:&#39;卖鱼强&#39;&#125; </code>，紧接着触发<strong>proxy</strong>的<strong>set</strong>，并完成依赖触发（proxy的依赖触发请看这里<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>）。</p><h4 id="对象触发依赖"><a href="#对象触发依赖" class="headerlink" title="对象触发依赖"></a>对象触发依赖</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">value</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;狂飙强&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式首先触发<strong>obj.value</strong>的<strong>set</strong>行为，同时替换掉ref的值，<strong>注意这会破坏RefImpl初始化构建的_value的proxy</strong>，进而导致<strong>WeakMap</strong>中已有的<strong>依赖关系断裂</strong></p><p>然后执行<strong>triggerRefValue</strong>，触发，ref本身在get阶段收集了相关effect fn，。</p><p>effect fn被触发后，再次触发<strong>ref的get</strong>，<strong>proxy的get</strong>，并帮助<strong>proxy</strong>又重建了与<strong>effect fn</strong>之间的依赖关系。</p><p>这就是为什么存在依赖收集2次的原因。</p><p>到此为止，我们的<strong>ref</strong>核心源码分析就全部完毕了。</p><h2 id="关于ref的一些问题"><a href="#关于ref的一些问题" class="headerlink" title="关于ref的一些问题"></a>关于ref的一些问题</h2><p><strong>Q：为啥一定要.value，不能干掉吗？</strong></p><p>A：非常遗憾，value是去不掉的，因为ref依赖class get set 进行实现，在当前实现的场景下，可以简写为v，但是无法去除</p><p><strong>Q：我是不是可以完全使用ref，不用reactive？</strong></p><p>A：是的，可以完全使用ref，因为ref会根据你传入的类型，自动识别内部是否需要使用reactive，但是读过源码的同学知道ref在处理响应式系统中，存在重复收集依赖的场景，如果你有极致的性能要求，建议复杂类型依旧使用reactive完成，业务开发场景则无所谓。</p><p>如果还有其他问题，请评论区提问~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​通过对ref源码的阅读，我们可以察觉到，如果仅仅聚焦基础类型的ref，其实底层实现还是比较简单的，所以建议有兴趣的同学渐进式的阅读源码，先完成基础类型场景的源码解读，再进行复杂类型的源码解读，这样事半功倍~</p><p>​如果有任何问题，请评论区留言~</p><p>​下一个阶段，我将手摸手带大家完成<strong>mini版本vue3 ref API</strong>，帮助大家深入理解<strong>ref</strong>~</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:151</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue - 源码解读" scheme="https://bluedancers.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（7）有点难的computed源码解析</title>
    <link href="https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89computed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89computed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-02T16:00:00.000Z</published>
    <updated>2023-11-27T02:40:03.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写过vue的同学，写过<strong>computed</strong>的都知道，<strong>computed</strong>会在依赖属性发生变化的时候自动更新结果。</p><p>他有一个重要的特点：<strong>计算值是可缓存的，只有依赖项发生变化的时候，才会重新计算</strong></p><p>而通过之前的文章，我们已经了解了<strong>reactive</strong>，<strong>ref</strong>的实现原理，相信大家已经对<strong>vue3</strong>响应式机制有所了解，今天我们就来了解一下<strong>computed</strong>是如何实现的。</p><blockquote><p>注：computed的源码难度相当大，我会尽力描述清楚其实现原理，如有不足之处，还请见谅</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> showName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;我叫&#x27;</span> + obj.<span class="property">name</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = showName.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>​以上代码运行后，我们可以看到如下现象</p><ul><li>页面显示：<strong>我叫张三</strong></li><li>2s后，页面显示<strong>我叫李四</strong></li></ul><p>按照我们之前源码分析的思路，我们依旧从以下三个角度入口</p><ul><li><strong>初始化</strong></li><li><strong>读取（依赖收集）</strong></li><li><strong>赋值（依赖触发）</strong></li></ul><p>接下来就让我们走进computed的源码世界吧~</p><h2 id="computed初始化"><a href="#computed初始化" class="headerlink" title="computed初始化"></a>computed初始化</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> computed&lt;T&gt;(getterOrOptions) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter;</span><br><span class="line">  <span class="keyword">let</span> setter;</span><br><span class="line">  <span class="comment">// 传入的是否是一个方法</span></span><br><span class="line">  <span class="keyword">const</span> onlyGetter = <span class="title function_">isFunction</span>(getterOrOptions)</span><br><span class="line">  <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">    <span class="comment">// 如果是方法, 则直接赋值到getter, 同时屏蔽setter行为</span></span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    <span class="comment">// dev环境下 set函数给予提示</span></span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="variable constant_">NOOP</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是方法,则认为是对象,将对象中的get set分别赋值到getter setter中</span></span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span></span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cRef = <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR)</span><br><span class="line">  <span class="keyword">return</span> cRef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​入口函数的逻辑还是非常简单的，如果传入的是一个匿名函数，这处理为<strong>getter</strong>，如果传入的是对象，这赋值<strong>getter</strong> <strong>setter</strong>，这部分逻辑符合我们对这个API的使用习惯，也解释了computed为何是这样的传参方式。</p><p>​抹平两种传参方式的差异后，<strong>new ComputedRefImpl</strong>，并返回，所以<strong>computed &#x3D; new ComputedRefImpl</strong> ，我们接下来就进入该<strong>Class</strong>中看看吧。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性的响应式也是通过class get set去实现的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span> <span class="comment">// 依赖收集处(effect)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> _value!: T  <span class="comment">// 存储计算属性结果的值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">effect</span>: <span class="title class_">ReactiveEffect</span>&lt;T&gt; <span class="comment">// 存储依赖</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span> <span class="comment">// 所有的计算属性也会被识别为ref</span></span><br><span class="line">  <span class="keyword">public</span> _dirty = <span class="literal">true</span> <span class="comment">// 判断是否需要重新计算</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    getter: ComputedGetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _setter: ComputedSetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    isReadonly: <span class="built_in">boolean</span>, <span class="comment">// 是否只读,如果存在setter,则为false</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 将计算属性的识别为effect，初始化一个ReactiveEffect</span></span><br><span class="line">    <span class="comment">// 初始化阶段仅仅声明 但是却没有触发</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 脏变量（_dirty）的本质就是判断什么时候去触发依赖</span></span><br><span class="line">      <span class="comment">// 脏变量为false的时候才会触发  </span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 触发依赖</span></span><br><span class="line">        <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">computed</span> = <span class="variable language_">this</span> <span class="comment">// 赋值ReactiveEffect中的computed为当前this</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue: T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在<strong>ComputedRefImpl</strong>初始化阶段，我们看到了非常熟悉的api，<strong>ReactiveEffect</strong>，在我们的前面的reactive，ref源码分析中，我们使用这个api来完成关键步骤<strong>依赖收集</strong>，不过这里有些区别，传入了第二个参数，一个匿名函数，目前还无法体现其作用，我们后面再说</p><p>​总的来说，<strong>ComputedRefImpl</strong>初始化阶段，生成了一个<strong>ReactiveEffect</strong>并保存到当前类的<strong>effect</strong>变量中。</p><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>按照我们实例代码，首次访问<strong>effect</strong>初次执行的时候，我们会触发<code>showName.value</code>的<strong>get</strong>，也就是说，会触发<strong>ComputedRefImpl</strong>的<strong>get</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被读取的时候触发</span></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖收集</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// 判断是否需要更新，如果需要则进入函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果更新过，这下一次就不需要更新了，</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// effect的run执行，也就是执行computed的fn，将会得到一次计算属性的结果</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="title function_">run</span>()! </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回computed的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="comment">// 首次computed内部的dep是不存在的，会通过createDep生成一个Set</span></span><br><span class="line">  <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="comment">// 将activeEffect，此时是effect的fn，收集到computed的dep中</span></span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当我们触发<strong>computed</strong>的<strong>get</strong>的时候，首先会触发<strong>trackRefValue</strong>，将当前<strong>activeEffect</strong>收集到ComputedRefImpl的<strong>dep</strong>中，这正是依赖收集，这里effect被收集到了computed的dep中，<strong>建立起了computed与其被依赖项（effect）的联系</strong>。</p><p>​然后判断**_dirty<strong>是否为</strong>true<strong>，默认是</strong>true<strong>，所以进入判断中，首先将</strong>_dirty<strong>改为</strong>false<strong>，下一次则不会进入判断，直接返回</strong>computed**之前的结果，之后再执行computed初始化阶段声明的ReactiveEffect，也就是我们computed本身的effect。</p><p>​<strong>computed</strong>的<strong>effect.run</strong>一旦触发，全局<strong>activeEffect</strong>将会被替换为当前computed的 <strong>effect的fn</strong> ，并且触发<strong>computed</strong>依赖项<strong>obj.name</strong>的<strong>get</strong>，进而触发<strong>proxy</strong>的依赖收集，于是<strong>obj.name</strong>成功收集到了<strong>computed</strong>内部的<strong>effect</strong>，<strong>proxy与computed建立了联系</strong>，同时返回了最新的computed结果。</p><p>​<strong>computed的get行为触发的时候，我们发现computed收集了effect，reactive收集了computed，三者之间建立起了联系。</strong></p><img src="http://www.vkcyan.top/FulT2b9ii1-iTvws8zj2z8vEn0Hn.png" style="zoom:33%;" /><h3 id="关于-dirty"><a href="#关于-dirty" class="headerlink" title="关于_dirty"></a>关于_dirty</h3><p>​现在我要个大家着重讲一下ComputedRefImpl中的这个参数，_dirty是实现计算属性缓存性的关键所在，</p><p>我们假设一下，没有缓存性的computed，是什么样的运行逻辑</p><p>计算属性依赖了变量abc，并返回abc的总和，每个获取计算属性的时候，我都需要计算一次abc的总和，即使abc这三个值没有发生任何变化，就是这样的</p><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p><strong>2s</strong>后，我们触发了<strong>obj.name</strong>的<strong>set</strong>，所以首先触发<strong>obj.name</strong>的依赖触发，此时我们将可以通过WeakMap会找到之前收集到<strong>computed</strong>，我们直接进入依赖触发的逻辑。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span><br><span class="line"><span class="params">  key?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  newValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">deps</span>: (<span class="title class_">Dep</span> | <span class="literal">undefined</span>)[] = []</span><br><span class="line">  deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(key))</span><br><span class="line">  <span class="title function_">triggerEffects</span>(deps[<span class="number">0</span>]) <span class="comment">// 找到了之前收集到的computed中的effect</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照常理来说，我们找到指定依赖之后，就是触发依赖，但是计算属性有所不同，因为计算属性存在“调度器”</span></span><br><span class="line"><span class="comment">// 还记得computed初始化阶段，new ReactiveEffect传递的第二个参数吗?</span></span><br><span class="line"><span class="comment">// 该参数将会被保存到ReactiveEffect的scheduler(调度器)中</span></span><br><span class="line"><span class="comment">// 所以此时的ReactiveEffect中，fn是computed的匿名函数，scheduler是computed初始化阶段new ReactiveEffect的第二个参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep | ReactiveEffect[]</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = <span class="title function_">isArray</span>(dep) ? dep : [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line"><span class="comment">// 调度器的优先级大于run，所以此时会执行调度器逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (effect.<span class="property">scheduler</span>) &#123;</span><br><span class="line">    effect.<span class="title function_">scheduler</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    effect.<span class="title function_">run</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度器代码</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 还记得我们get之后将dirty改为false吗？</span></span><br><span class="line">  <span class="comment">// 此时computed的依赖发生变化，将_dirty改为true，表示下次重新计算</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 触发当前computed中收集了相关effect（依赖触发）</span></span><br><span class="line">    <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;, newVal?: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 公共依赖触发逻辑</span></span><br><span class="line">  <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// computed的dep中收集的effect触发，再次触发computed的get</span></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖项发生变化的时候activeEffect不存在，所以此处收集不到任何依赖</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// 刚才依赖项发生了变化，所以dirty为true，表示本次需要更新计算属性的结果</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算后dirty改为false 除非依赖项发生变化，否则将不会再重新计算。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 重新计算 computed的结果</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="title function_">run</span>()! </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​计算属性的触发逻辑还是非常复杂的，首先<strong>proxy</strong>的set，触发<strong>computed</strong>的<strong>scheduler（调度器）</strong>，<strong>scheduler</strong>通过<strong>computed</strong>的<strong>dep</strong>找到相关<strong>effect</strong>，<strong>effect的fn</strong>执行又会触发<strong>computed</strong>的<strong>get</strong>，<strong>并与首次完成computed的计算，同时缓存最新的computed的结果</strong>，进而再完成effect的全部逻辑。</p><img src="https://www.vkcyan.top/Fu-QElucOgKlCPvYBJuMIQst0Fuo.png" style="zoom:33%;" /><h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><h3 id="依赖收集阶段"><a href="#依赖收集阶段" class="headerlink" title="依赖收集阶段"></a>依赖收集阶段</h3><ol><li><strong>computed</strong>初始化阶段，通过<strong>ReactiveEffect</strong>进行初始化，并且生成<strong>scheduler（调度器）</strong></li><li><strong>effect</strong>初始化，触发<strong>computed</strong>的<strong>get</strong>，将当前<strong>activeEffect（effect）</strong>收集到<strong>computed</strong>的<strong>dep</strong>中<strong>（computed将effect收集）</strong></li><li>执行<strong>computed</strong>自身逻辑，刷新全局<strong>activeEffect</strong></li><li>进而触发<strong>proxy</strong>的<strong>get</strong>事件触发，将当前<strong>activeEffect（computed）</strong>收集到<strong>WeakMap</strong>中<strong>（proxy将computed收集）</strong></li><li><strong>proxy</strong>的返回值返回<strong>computed</strong>，完成<strong>computed</strong>的计算逻辑</li><li>获取到<strong>computed</strong>结果，完成<strong>effect</strong></li></ol><h3 id="依赖触发阶段"><a href="#依赖触发阶段" class="headerlink" title="依赖触发阶段"></a>依赖触发阶段</h3><ol><li>触发<strong>proxy</strong>的<strong>set</strong>，<strong>set</strong>行为中触发依赖，触发之前保存的<strong>computed</strong>的<strong>调度器scheduler</strong>（proxy找到computed）</li><li><strong>调度器scheduler</strong>触发，<strong>dirty</strong>改为<strong>true</strong>，同时触发<strong>computed</strong>中保存的依赖，其中都是相关<strong>effec</strong>的<strong>fn</strong>。（computed找到effect）</li><li><strong>effect</strong>触发，<strong>fn</strong>执行，触发<strong>computed</strong>的<strong>get</strong>行为</li><li><strong>dirty</strong>为<strong>true</strong>，首次进行计算属性的重新计算（除非依赖项改变，否则下次不会重新计算），返回最新的<strong>computed</strong>结果，</li><li><strong>effect</strong>执行完成</li></ol><h2 id="回答一些问题"><a href="#回答一些问题" class="headerlink" title="回答一些问题"></a>回答一些问题</h2><h4 id="computed如何实现高性能缓存的？"><a href="#computed如何实现高性能缓存的？" class="headerlink" title="computed如何实现高性能缓存的？"></a>computed如何实现高性能缓存的？</h4><p>​通过<strong>调度器scheduler</strong> + <strong>脏值检查_dirty</strong>，实现依赖项不变化，不进行重新计算，依赖项变化后仅执行一次的逻辑，进而实现高性能缓存。</p><h4 id="为什么访问computed需要-value"><a href="#为什么访问computed需要-value" class="headerlink" title="为什么访问computed需要.value"></a>为什么访问computed需要.value</h4><p>​因为我们访问<strong>computed</strong>实际上是访问<strong>ComputedRefImpl</strong>这个<strong>Class</strong>的实例，他的内部通过<strong>get value</strong>返回被访问值，所以我们必须通过**.value**来访问</p><h4 id="简述computed的实现原理？"><a href="#简述computed的实现原理？" class="headerlink" title="简述computed的实现原理？"></a>简述computed的实现原理？</h4><blockquote><p>vue的响应式api都可以从依赖收集 依赖触发2个角度出发阐述其原理实现</p></blockquote><p>依赖收集阶段：computed通过首次get的完成相关effect的依赖收集，首次计算的时候proxy完成computed的依赖收集。</p><p>依赖触发阶段：computed的依赖项发生变化后，会通过proxy找到computed的调度器 scheduler，触发所有effect，effct中再出发computed的get，首次get将进行一次结果运算（后续不在运算，除非computed依赖项发生变化），effect触发完成</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​到此为止，我们<strong>computed</strong>的核心源码就解读完毕了，虽然总体依旧可以从<strong>依赖收集</strong>和<strong>依赖触发</strong>两个角度去理解实现原理，但是新增加的<strong>scheduler（调度器）</strong>与**_dirty（脏值检查）**机制，让逻辑复杂了很多。</p><p>​大家在理解computed源码的时候，一定要多走几遍流程，多捋几遍逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写过vue的同学，写过&lt;strong&gt;computed&lt;/strong&gt;的都知道，&lt;strong&gt;computed&lt;/strong&gt;会在依赖</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>（3）vue3 reactive源码解析</title>
    <link href="https://bluedancers.github.io/2023/02/01/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20reactive%20+%20effect%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/02/01/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20reactive%20+%20effect%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-01-31T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:34.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>​本文是<strong>vue3源码解析系列</strong>的第三篇文档，在前两篇文章中，我们了解了vue3源码的运行、调试，以及阅读前的一些前置知识点，从本节开始，我们就可以正式的开始<strong>vue3</strong>的源码阅读了。</p><p>​我们首先阅读的模块是@vue&#x2F;reactivity 中的<strong>reactive</strong>以及相关<strong>api</strong>，<strong>effect</strong>的源代码。</p><p>在正文开始之前，我先将本节的简化版源码放出来，有兴趣的同学可以clone到本地，一边debug，一边阅读文章，这样效果更佳~</p><p><a href="https://github.com/BlueDancers/vue3-mini/tree/reactive">https://github.com/BlueDancers/vue3-mini/tree/reactive</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>reactive</strong>的含义如其名称，通过<strong>reactive</strong>创建的对象都是具备响应式的。即<strong>reactive</strong>对象的改变会造成<strong>副作用</strong>。</p><p>于是我们引出<strong>副作用API（effect）</strong>，如果<strong>effect</strong>内部依赖了<strong>reactive</strong>，<strong>则reactive的改变会重新触发effect</strong>。</p><p>现在让我们走进案例与源码，看看究竟是如何实现响应式的。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> &#123; reactive, effect &#125; = <span class="title class_">Vue</span></span><br><span class="line"> <span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span>,</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = obj.<span class="property">name</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>以上测试案例，我们涉及到了三个重要的阶段</p><ol><li>reactive初始化</li><li>effect初始化</li><li>reactive发生修改</li></ol><p>最后形成了effect的自动触发，我们就从以上三个角度去切入源码实现。</p><h2 id="reactive初始化"><a href="#reactive初始化" class="headerlink" title="reactive初始化"></a>reactive初始化</h2><blockquote><p>为了方便阅读与理解，以下仅贴出核心源码</p></blockquote><p><code>packages/reactivity/src/reactive.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target, <span class="comment">// reactive里面的值</span></span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否已经被代理过了，如果是，则获取缓存中的值，并直接返回</span></span><br><span class="line">  <span class="comment">// 我们这里第一次指定，必然是不存在的，所以跳过这个</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对reactive中的变量进行代理，我们这里的target类型是obejct，targetType为common，所以接下来进入baseHandlers逻辑</span></span><br><span class="line">  <span class="comment">// 而baseHandlers从reactive被当做参数传递过来的，实际执行的是mutableHandlers</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    baseHandlers</span><br><span class="line">  )</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive中变量类型为object场景下，proxy的监听逻辑会走到这里</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  get, </span><br><span class="line">  set,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过源码 我们可以看得出来，使用<strong>reactive</strong>，内部实际执行的是<strong>createReactiveObject</strong>，函数就是新建了<strong>proxy</strong>，并最终返回。</p><p>​不过要注意一点的是，经过<strong>reactive</strong>处理过的对象，都会以<strong>target</strong>为<strong>WeakMap</strong>键，<strong>proxy</strong>为值，进行一次缓存，这样同一个值再次进行<strong>reactive</strong>的时候就会读取缓存中的值。</p><img src="https://www.vkcyan.top/Fo-SnMAmNY3ZCNiZ_GONRZTFVefm.png" style="zoom:50%;" /><p>​接下来，让我们进入初始化阶段的<strong>mutableHandlers</strong>，也就是<strong>proxy</strong>中核心的<strong>get set</strong>函数，看看内部做了些什么。</p><h3 id="初始化读取（get）"><a href="#初始化读取（get）" class="headerlink" title="初始化读取（get）"></a>初始化读取（get）</h3><p>当触发<strong>obj.name</strong>的读取行为的时候，就会触发代理对象的<strong>get</strong>函数</p><p><code>packages/reactivity/src/baseHandlers.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> get = <span class="title function_">createGetter</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver) <span class="comment">// 读取被代理对象</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 核心逻辑(track)：依赖收集，后续单独看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前值是reactive则递归proxy处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get内部的逻辑很简单，通过<strong>Reflect</strong>完成被代理对象的读取操作。</p><p>如果被读取对象的属性是<strong>object</strong>则会再次进入<strong>reactive</strong>逻辑中进行<strong>proxy</strong>处理，确保嵌套对象的响应式。</p><blockquote><p>也许有的人会说了proxy不是自身就实现了对象的拦截了吗？为什么我们还是要递归处理嵌套obj呢？</p><p>这里我给大家解释一下，proxy确实会拦截到所有操作，但是他也只能拦截当前层级的。</p><p>如果没有递归处理， obj.name.abc &#x3D; 123的时候，只会触发obj.name的get事件，但是不会触发obj.name.abc的set事件。</p></blockquote><h3 id="初始化修改（set）"><a href="#初始化修改（set）" class="headerlink" title="初始化修改（set）"></a>初始化修改（set）</h3><p>当触发<code>obj.name</code>的修改行为，将会触发代理对象的<strong>set</strong>函数</p><p><code>packages/reactivity/src/baseHandlers.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="title function_">createSetter</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改被代理数据，完成数据更新</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心逻辑(trigger)：依赖触发，后续单独看</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>Reflect</strong>完成被代理对象值的更新，最后返回本次Reflect.set的结果，完成逻辑。</p><p>总体就是对proxy的简单利用，还是很简单的嘛</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​以上代码是去除所有边界判断，以及响应式逻辑后，reactive的核心代码；我们可以发现，其实就是<strong>proxy + Reflect</strong>的基础使用。</p><p>​目前数据已经具备响应式，但是数据变化后，引用数据的<strong>effect</strong>如何实现自动执行呢？接下来我们就去看看effect初始化的时候究竟做了什么。</p><h2 id="effect初始化"><a href="#effect初始化" class="headerlink" title="effect初始化"></a>effect初始化</h2><h3 id="读取-依赖收集（track）"><a href="#读取-依赖收集（track）" class="headerlink" title="读取 - 依赖收集（track）"></a>读取 - 依赖收集（track）</h3><p>​我们回到测试demo中，根据我们使用<strong>vue3</strong>的预期，在初始化完成后，<strong>effect</strong>会触发一次，若干时间后，<strong>setTimeout</strong>内<strong>set</strong>触发，依赖<code>obj.name</code>的 <strong>effect</strong>的函数还会被触发一次，这又是如何实现的呢？</p><p>​这里我要提到Vue3中第一个非常非常非常重要的概念，<strong>依赖收集（track）</strong>，整个reactivity都利用到了这个概念。</p><p>​接下来，我们就要通过源码去了解，<strong>effect</strong>的初始化的时候，到底发生了什么，Vue3在此阶段是如何完成<strong>依赖收集</strong>的。</p><p><code>packages/reactivity/src/effect.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前被执行的effect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">activeEffect</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn) <span class="comment">// 首先执行new ReactiveEffect，所以我们跳转到ReactiveEffect中</span></span><br><span class="line">  _effect.<span class="title function_">run</span>() <span class="comment">// 并立刻执行了run方法，run方法内实际执行的就是effect内部函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span> &#123;</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    public fn: () =&gt; T, <span class="comment">// 这里的fn就是effect内部的匿名函数</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = <span class="variable language_">this</span> <span class="comment">// 将effect对象，也就是new ReactiveEffect的结果，保存到activeEffect</span></span><br><span class="line">      shouldTrack = <span class="literal">true</span> <span class="comment">// 表示开始依赖收集</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>() <span class="comment">// 这里的fn，实际上就是effect内部的匿名函数 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>vue3的依赖收集几乎都是通过ReactiveEffect进行完成的，简单来说就是ReactiveEffect.run一旦运行后，就会将当前正在运行的匿名函数保存到内存中，以便于proxy get事件触发的时候，收集保存在内存中的匿名函数，进而完成依赖收集。</p></blockquote><p>​effect方法内部，首先<strong>new ReactiveEffect</strong> 最终执行了一次<strong>fn</strong>，但是在执行之前，将activeEffect赋值为this，<strong>将自身保存到了公共变量activeEffect之中</strong>。</p><p>让我们来看看此时运行的fn是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = obj.<span class="property">name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​匿名函数的内部读取了<strong>obj.name</strong>，<strong>触发了被代理对象obj的get方法</strong>.</p><p>​所以接下来我们回到get方法中，查看之前忽略的依赖收集逻辑。</p><p><code>packages/reactivity/src/baseHandlers.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: string | symbol, receiver: object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver) <span class="comment">// 读取被代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123; <span class="comment">// obj为可读代码 所以isReadony一定为false 进入if中</span></span><br><span class="line">      <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖收集</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, type, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123; <span class="comment">// 在effect中执行run方法的时候，我们确保了shouldTrack为true activeEffect 存在值，所以进入判断</span></span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target) <span class="comment">// targetMap是一个全局变量，实际上是一个new WeakMap 首次depsMap肯定是不存在的</span></span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      <span class="comment">// 这里的target为被代理对象，&#123;name: &#x27;张三&#x27;&#125;，该值做为key，Map作为value</span></span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key) <span class="comment">// 当前key为name 首次也是不存在的</span></span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      <span class="comment">// depsMap是一个Map结构，key是name value是createDep()的返回值，我们进入createDep</span></span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将dep作为参数传递到trackEffects中，此时的dep为Set</span></span><br><span class="line">    <span class="title function_">trackEffects</span>(dep, <span class="literal">undefined</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createDep</span> = (<span class="params">effects?</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Set</span>(effects) <span class="comment">// 实际上就是生成了Set结构（Set我们简单理解为元素不可重复的数组）</span></span><br><span class="line">  dep.<span class="property">w</span> = <span class="number">0</span></span><br><span class="line">  dep.<span class="property">n</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  dep: Dep,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 一系列边界判断，合法的情况下shouldTrack为true</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrack) &#123;</span><br><span class="line">    dep.<span class="title function_">add</span>(activeEffect!) </span><br><span class="line">    <span class="comment">// 将全局变量activeEffect（包含effect的匿名函数）加入到dep（Set）中</span></span><br><span class="line">    <span class="comment">// 到这里 我们将响应式数据与effect函数建立起了联系 标志着我们完成了依赖收集</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>effect</strong>内部的<strong>fn</strong>被触发，<strong>fn</strong>执行中触发了<strong>obj</strong>的<strong>get</strong>，<strong>get</strong>内部触发了<strong>依赖收集（track）</strong>，<strong>track</strong>内部通过构建<strong>targetMap</strong>，来维护<strong>变量</strong>与<strong>effect</strong>之间的关系，进而实现所谓的<strong>依赖收集</strong>。</p><p>​我们来梳理一下他的数据结构</p><ul><li><p><strong>WeakMap</strong></p><ul><li><strong>key：被代理对象（{name:’张三’}）</strong></li><li><strong>value：Map对象</strong><ul><li><strong>key：响应式对象的指定属性（name）</strong></li><li><strong>value：指定对象的指定属性的使用函数（effect的匿名函数）</strong></li></ul></li></ul><p><img src="https://www.vkcyan.top/Fq7ZRGhuv98fGixwhk7L8UMWEiRr.png"></p></li></ul><p>在<strong>WeakMap</strong>中，我们不仅仅收集了<strong>effect</strong>的匿名函数，还将<strong>effect</strong>与<strong>effect中具体读取的变量建立起了联系</strong>。</p><p>在未来的依赖触发逻辑中，weakMap将会发挥巨大作用。</p><p>到此为止，<strong>effect</strong>内的匿名函数执行完毕，同时我们也完成了重要的<strong>依赖收集</strong>。</p><h2 id="修改-依赖触发（trigger）"><a href="#修改-依赖触发（trigger）" class="headerlink" title="修改 - 依赖触发（trigger）"></a>修改 - 依赖触发（trigger）</h2><p>继续回到demo中，2s后，<strong>obj.name</strong>赋值为<strong>狂飙强</strong>，此时的现象是<strong>effect</strong>中的函数自动执行了，这又是如何实现的呢？</p><p>此处首先一定是触发了代理对象<strong>obj.name</strong>的<strong>set</strong>，所以我们由此处开始分析。</p><p><code>packages/reactivity/src/baseHandlers.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>): boolean &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver) <span class="comment">// 完成被代理对象的赋值操作</span></span><br><span class="line"><span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, type, key?, newValue?, oldValue?, oldTarget?</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过全局变量targetMap（weakMap）获取value</span></span><br><span class="line">  <span class="comment">// 在依赖收集阶段我们收集到了当前target，所以这时候 depsMap存在值 值为Map Map的key为name 值为Set Set内部是effect的fn</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  </span><br><span class="line"> <span class="title function_">triggerEffects</span>(depsMap.<span class="title function_">get</span>(key))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep, debuggerEventExtraInfo?</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = <span class="title function_">isArray</span>(dep) ? dep : [...dep] <span class="comment">// 将set处理为数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  effect: ReactiveEffect, <span class="comment">// 每一个effect都是ReactiveEffect，内部的fn都是effect的fn</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 此时的activeEffect为undefined，一定进入if中</span></span><br><span class="line">  <span class="keyword">if</span> (effect !== activeEffect || effect.<span class="property">allowRecurse</span>) &#123;</span><br><span class="line"> effect.<span class="title function_">run</span>() <span class="comment">// effect的run方法就是effect的fn，完成执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上代码，我们可以了解到，<strong>obj.name</strong>的改变在触发了<strong>proxy</strong>的<strong>set</strong>方法的同时，也触发了<strong>依赖触发（trigger）</strong>。</p><p><strong>trigger</strong>中，我们首先通过**{name: ‘狂飙强’}<strong>，找到了</strong>Map<strong>，再通过</strong>name<strong>找到</strong>Set<strong>，最终找到对应的</strong>effect<strong>的</strong>fn**，并进行匿名函数的执行，于是我们便看到了effect函数自动触发。</p><p>到此为止完成了整个响应式过程。</p><h2 id="reactive源码总结"><a href="#reactive源码总结" class="headerlink" title="reactive源码总结"></a>reactive源码总结</h2><p>我们简单总结一下，reactive中<strong>依赖收集</strong>与<strong>依赖触发</strong>的过程</p><ol><li>通过<strong>proxy</strong>处理<strong>reactive</strong>包裹的对象，被返回<strong>proxy</strong>代理对象</li><li><strong>effect</strong>初始化，生成了类<strong>ReactiveEffect</strong>，并执行了其<strong>run</strong>方法</li><li><strong>run</strong>方法执行后，当前<strong>effect的fn函数本身</strong>被保存到了<strong>activeEffect(公共变量)<strong>，随后执行了</strong>effect的fn</strong></li><li><strong>effect的fn</strong>触发，函数内使用到了<strong>obj.name</strong>，触发了代理对象的<strong>get</strong></li><li><strong>get</strong>方法内部触发了<strong>依赖收集（track）</strong>，配合保存到局部的<strong>activeEffect</strong>，最终通过<strong>WeakMap</strong>，建立了<strong>effect的fn</strong>与当前<strong>get的属性</strong>的联系，完成了依赖收集。</li><li>若干时间后，<strong>obj.name &#x3D; ‘狂飙强’<strong>，触发</strong>proxy</strong>的<strong>set</strong>，同时触发了<strong>依赖触发（trigger）</strong></li><li><strong>trigger</strong>内部通过<strong>当前代理对象</strong>以及<strong>具体修改的属性</strong>，在依赖收集阶段保存的<strong>WeakMap</strong>中，找到所有需要触发的<strong>effect的fn</strong>。</li><li>触发<strong>effect的fn函数</strong>，完成响应式。</li></ol><p>最后反映在我们眼前，就是<strong>obj.name</strong>改变的同时，所有使用到<strong>obj.name</strong>的<strong>effet</strong>都被自动触发其匿名函数，完成响应式。</p><h2 id="关于vue3-reactive的面试题"><a href="#关于vue3-reactive的面试题" class="headerlink" title="关于vue3 reactive的面试题"></a>关于vue3 reactive的面试题</h2><h4 id="为什么Vue3的响应式使用WeakMap实现？"><a href="#为什么Vue3的响应式使用WeakMap实现？" class="headerlink" title="为什么Vue3的响应式使用WeakMap实现？"></a>为什么Vue3的响应式使用WeakMap实现？</h4><p>​还记得我们前一篇文章谈到的<strong>WeakMap</strong>吗，一旦被代理对象被置为null，<strong>weakMap</strong>中该<strong>key</strong>将会被垃圾回收，达到性能最大化的目的</p><h4 id="简述Vue3的响应式的核心实现逻辑？"><a href="#简述Vue3的响应式的核心实现逻辑？" class="headerlink" title="简述Vue3的响应式的核心实现逻辑？"></a>简述Vue3的响应式的核心实现逻辑？</h4><p>​通过proxy递归代理对象，然后在get中完成依赖收集，在set中完成依赖触发</p><h4 id="Vue3的reactive为什么不能代理简单类型？"><a href="#Vue3的reactive为什么不能代理简单类型？" class="headerlink" title="Vue3的reactive为什么不能代理简单类型？"></a>Vue3的reactive为什么不能代理简单类型？</h4><p>​reactive底层依赖proxy，但是proxy只能代理对象，无法代理基础类型。</p><h4 id="为什么reactive解构会失去响应式？"><a href="#为什么reactive解构会失去响应式？" class="headerlink" title="为什么reactive解构会失去响应式？"></a>为什么reactive解构会失去响应式？</h4><p>​这里要明确一点，只有解构出来的变量是基础类型的时候，才会失去响应式，失去响应式的主要原因是基础类型无法被proxy代理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​到此为止，我们的vue3中的响应式模块的第一个API，reactive源码解读就完成了；</p><p>​总的来说逻辑还是比较复杂的，尽管我已经很努力的去反复修改与简化，但是还是能可以感觉到，有些东西很难用文字讲清楚。</p><p>​也不知道是否可以帮助到正在阅读文章的你，如果你觉得还不错的话，还麻烦你动动小手点个赞，关注专栏，这是我输出优质文章最大的动力。</p><p>​如果有小伙伴存在视频教程诉求的话，请评论区告诉我，我会评估出几期视频的必要性~</p><p>​下一站，我们将前往ref。</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;​	本文是&lt;strong&gt;vue3源码解析系列&lt;/strong&gt;的第三篇文档，在前两篇文章中，我们了解了vue3源码的运行、</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>（2）Object.defineProperty vs proxy</title>
    <link href="https://bluedancers.github.io/2023/01/30/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89Object.defineProperty%20VS%20proxy/"/>
    <id>https://bluedancers.github.io/2023/01/30/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89Object.defineProperty%20VS%20proxy/</id>
    <published>2023-01-29T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:24.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>本文是<strong>vue3源码解析系列</strong>的第二篇文章，这一章我们主要学习<strong>vue3</strong>源码中涉及到的一些核心<strong>api</strong>。</p><p>后续的源码解读是非常复杂的，所以相关基础知识一定要牢固哦~</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大部分使用过<strong>vue3</strong>的同学都知道，<strong>vue3</strong>的底层的响应式实现由<strong>Object.defineProperty</strong>更换成了<strong>Proxy</strong>。</p><p><strong>为什么vue3要更换呢？proxy相对于前者又有何优势呢？</strong></p><p>接下来让我们通过案例去一探究竟吧！</p><p>​</p><h2 id="当响应式不存在"><a href="#当响应式不存在" class="headerlink" title="当响应式不存在"></a>当响应式不存在</h2><p>我们先看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shoes = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> total = shoes.<span class="property">num</span> * shoes.<span class="property">price</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">shoes.<span class="property">num</span> = <span class="number">5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>第二次打印依旧是<strong>30</strong>，虽然我们的<strong>num</strong>发生了变化，但是下一次获取<strong>total</strong>的值依旧是之前的值，因为<strong>total</strong>已经被运算过了。</p><p>那应该怎么做，才能实时的获取到当前最新的<strong>total</strong>呢？</p><p>也很简单，我们每次获取之间，<strong>手动重新计算</strong>一次就好了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shoes = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  total = shoes.<span class="property">num</span> * shoes.<span class="property">price</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>() <span class="comment">// 重新计算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">shoes.<span class="property">num</span> = <span class="number">5</span></span><br><span class="line"><span class="title function_">effect</span>() <span class="comment">// 重新计算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total) <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>​我们增加<strong>effect</strong>方法来手动触发依赖，这样我们实现了需求。</p><p>​但是这样手动触发的方式，在真实业务中过于繁琐，难以维护，本质上依旧是命令式思维。</p><p>​<strong>如何实现值的修改，后续逻辑的自动执行呢？</strong></p><h2 id="vue2的解决方案"><a href="#vue2的解决方案" class="headerlink" title="vue2的解决方案"></a>vue2的解决方案</h2><p>通过<strong>Object.defineProperty</strong>来对字段进行代理，<strong>通过set，get方法，完成逻辑的自动触发</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> shoes = &#123;</span><br><span class="line">  <span class="attr">num</span>: num,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始计算&#x27;</span>, shoes)</span><br><span class="line">  total = shoes.<span class="property">num</span> * shoes.<span class="property">price</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理的值无法不可再get中使用了 因为会触发ett的死循环</span></span><br><span class="line"><span class="comment">// 所以,必须增加一个变量来做被代理的值,所以我们监听shoes.num的get set内部实际修改和读取的都是num</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(shoes, <span class="string">&#x27;num&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    num = newVal</span><br><span class="line">    <span class="title function_">effect</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​我们再以上代码，再次修改shoes.num，将触发代理中的set，进而触发effect，实现依赖的自动触发，vue2的底层也正是如此实现的，这样看起来我们的需求已经解决了，那为何vue3有放弃了<strong>Object.defineProperty</strong>呢？</p><p>​接下来我们就要聊聊他的缺陷。</p><h2 id="Object-defineProperty的缺陷"><a href="#Object-defineProperty的缺陷" class="headerlink" title="Object.defineProperty的缺陷"></a>Object.defineProperty的缺陷</h2><p>该API确实满足了我们上面提到的案例，但是他在一些场景也存在很多问题。</p><p>比如大家一定都遇到过的问题</p><ol><li>object中新增字段 没有响应性</li><li>array中指定下标的方式增加字段 没有响应性的</li></ol><p>为什么会这样呢？vue的官方解释是</p><p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。</p><p>尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p><p><strong>那JavaScript到底限制了什么呢？</strong></p><p>​<strong>object.defineProperty</strong>只能监听到指定对象的<strong>指定属性的get set</strong>，这些工作其实是vue初始化阶段完成，所以指定对象的指定元素发生变化的时候，我们可以监听到变化，vue中也确实是这么表现的；</p><p>​但是如果，我们在指定对象上面新增属性，<strong>object.defineProPerty</strong>是无法监听到的，无法监听则无法处理被新增的字段，自然字段就不具备响应式；</p><p>​在vue2中，如果想解决以上问题，需要使用<strong>Vue.$set</strong>进行手动增加响应式字段，解决无法监听到字段新增的问题。</p><h2 id="vue3的解决方案"><a href="#vue3的解决方案" class="headerlink" title="vue3的解决方案"></a>vue3的解决方案</h2><p><strong>vue3</strong>中改用了<strong>proxy</strong>，为什么响应式核心api做了修改，<strong>proxy</strong>是什么？我们先实现一个类似<strong>vue2</strong>的案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shoes = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shoesProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(shoes, &#123;</span><br><span class="line">  <span class="comment">// target 被代理对象 key 本次修改的对象中的键 newValue 修改后的值 receiver 代理对象</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发了写入事件&#x27;</span>)</span><br><span class="line">    shoes[key] = newValue</span><br><span class="line">    <span class="title function_">effect</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// target 被代理对象 key 本次读取的值 receiver 代理对象</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">tartget, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发了获取事件&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> shoes[key]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始计算&#x27;</span>, shoes)</span><br><span class="line">  <span class="comment">// 如果使用被代理对象本身shoes,这不会触发</span></span><br><span class="line">  <span class="comment">// 如果使用代理对象shoesProxy,则这里会触发proxy的get事件</span></span><br><span class="line">  total = shoes.<span class="property">num</span> * shoes.<span class="property">price</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以看到一些差别</p><p><strong>object.defineproperty</strong></p><ul><li><p>代理的并非对象本身，而是对象中的属性</p></li><li><p>只能监听到对象被代理的指定属性，无法监听到对象本身的修改</p></li><li><p>修改对象属性的时候，是对原对象进行修改的，原有属性，则需要第三方的值来充当代理对象</p></li></ul><p><strong>proxy</strong></p><ul><li>proxy针对对象本身进行代理</li><li>代理对象属性的变化都可以被代理到</li><li>修改对象属性的时候，我们针对代理对象进行修改</li></ul><p>无论是逻辑的可读性，还是API能力上，<strong>proxy</strong>都比<strong>object.defineProPerty</strong>要强很多，这也是vue3选择proxy的原因。</p><h2 id="proxy的好兄弟Reflect"><a href="#proxy的好兄弟Reflect" class="headerlink" title="proxy的好兄弟Reflect"></a>proxy的好兄弟Reflect</h2><p>​在<strong>vue3</strong>的源码中的**@vue&#x2F;reactivity<strong>中，</strong>我们会经常看到在proxy的set、get中存在Reflect的身影<strong>，但是从我们上面对</strong>proxy<strong>的使用来看，赋值 读取都实现了，为什么</strong>vue3<strong>中使用了</strong>Reflect**呢？</p><p>首先我们了解一下<strong>Reflect</strong>是干嘛的</p><p>官方解释：<strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。</p><p>似乎比较难理解，我们举个例子吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">num</span>:<span class="number">10</span> &#125;</span><br><span class="line">obj.<span class="property">num</span> <span class="comment">// 10</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj,<span class="string">&#x27;num&#x27;</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>这么来看，似乎这个api很普通啊，反而把简单的读取值写复杂了。</p><p>这时候我们就要提一下Reflect.get 的第三个参数了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propertyKey, receiver]) <span class="comment">// receiver 如果target对象中指定了propertyKey，receiver则为getter调用时的this值。</span></span><br></pre></td></tr></table></figure><p>这次我们知道了，第三个参数receiver具有强制修改this指向的能力，接下来我们来看一个场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;12岁&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">useinfo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;属性被读取&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dataProxy.<span class="property">useinfo</span>)</span><br></pre></td></tr></table></figure><p>打印情况如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性被读取</span><br><span class="line">张三12岁</span><br></pre></td></tr></table></figure><p>​<strong>dataProxy.useinfo</strong>的get输出的值是正常的，但是get只被触发了一次，这是不正常的；</p><p>​因为useinfo里面还读取了被代理对象<strong>data</strong>的<strong>name</strong>、<strong>age</strong>，理想情况应当是<strong>get</strong>被触发三次。</p><p>​为什么会出现这样的情况呢，这是因为调用<strong>userinfo</strong>的时候，<strong>this指向了data，实际执行的是data.userinfo，此时的this指向data，而不是dataProxy</strong>，此时get自然是监听不到name、age的get了。</p><p>​这时候我们就用到了Reflect的第三个参数，<strong>来重置get set的this指向</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;属性被读取&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver) <span class="comment">// this强制指向了receiver</span></span><br><span class="line">    <span class="comment">// return target[key]</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印情况如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">属性被读取</span><br><span class="line">属性被读取</span><br><span class="line">属性被读取</span><br><span class="line">张三12岁</span><br></pre></td></tr></table></figure><p>现在打印就正常了，<strong>get</strong>被执行的3次，此时的<strong>this</strong>指向了<strong>dataProxy</strong>，<strong>Reflect</strong>很好的解决了以上的this指向问题。</p><p>​通过以上案例，我们可以看到使用<strong>target[key]<strong>有些情况下是不符预期的，比如案例中的被代理对象this指向问题，而使用</strong>Reflect</strong>则可以更加稳定的解决这些问题，在vue3源码中也确实是这么用的。</p><h2 id="补充章节（WeakMap）"><a href="#补充章节（WeakMap）" class="headerlink" title="补充章节（WeakMap）"></a>补充章节（WeakMap）</h2><p>​通过以上文章，我们了解到了<strong>object.defineproperty</strong>相较于<strong>proxy</strong>的劣势，以及搭配<strong>proxy</strong>同时出现的<strong>Reflect</strong>的原因，这是<strong>vue3</strong>最核心的<strong>api</strong>。</p><p>​但是仅仅知道理解<strong>proxy+reflect</strong>，还不太够，为了尽量轻松的阅读<strong>Vue3</strong>源码，我们还要学习一个<strong>原生API</strong>，那就是<strong>WeakMap</strong>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap MDN中文文档地址</a></p><p>​<strong>weakMap</strong>和<strong>map</strong>一样都是<strong>key value</strong>格式，但是他们还是存在一些差别。</p><ul><li><strong>weakMap</strong>的<strong>key</strong>必须是对象，并且是<strong>弱引用</strong>关系</li><li><strong>Map</strong>的<strong>key</strong>可以是任何值（基础类型+对象），但是key所引用的对象是<strong>强引用</strong>关系</li></ul><p>​通过查阅MDN我们可以发现，<strong>weakMap</strong>可以实现的功能，<strong>Map</strong>也是可以实现的，那为什么<strong>Vue3</strong>内部使用了<strong>WeakMap</strong>呢，问题就在<strong>引用关系</strong>上</p><p><strong>强引用：不会因为引用被清除而失效</strong></p><p><strong>弱引用：会因为引用被清除而自动被垃圾回收</strong></p><p>概念似乎还无法体现其实际作用，我们通过以下案例即可明白</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">obj = <span class="literal">null</span> <span class="comment">// obj的引用类型被垃圾回收</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// map中key obj依旧存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">map.<span class="title function_">set</span>(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">obj = <span class="literal">null</span> <span class="comment">// obj的引用类型被垃圾回收</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// weakMap中key为obj的键值对已经不存在</span></span><br></pre></td></tr></table></figure><p>通过以上案例我们可以了解到</p><ul><li>弱引用在<strong>对象与key共存</strong>场景存在优势，<strong>作为key的对象被销毁的同时，WeakMap中的key value也自动销毁了</strong>。</li><li>弱引用也解释了为什么<strong>weakMap</strong>的<strong>key</strong>不能是基础类型，因为基础类型存在栈内存中，不存在弱引用关系；</li></ul><p>在vue3的依赖收集阶段，源码中用到了WeakMap，具体什么作用？我们下一节进行解答。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​通过本篇文章，我们认识到了<strong>object.defineproperty</strong>相较于<strong>proxy</strong>的劣势，以及搭配<strong>proxy</strong>同时出现的<strong>Reflect</strong>的原因，还有一个<strong>Map</strong>的原生的<strong>API</strong>，<strong>WeakMap</strong>的作用。</p><p>​接下来我们就可以正式走进<strong>vue3</strong>源码的世界~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;本文是&lt;strong&gt;vue3源码解析系列&lt;/strong&gt;的第二篇文章，这一章我们主要学习&lt;strong&gt;vue3&lt;/st</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>（1.1）搭建属于自己的vue3</title>
    <link href="https://bluedancers.github.io/2023/01/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>https://bluedancers.github.io/2023/01/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</id>
    <published>2023-01-28T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:16.228Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​我们本次源码的目的是最终完成一个简化版的vue3，我们将他称为vue3-mini，本节我们就开始项目的搭建工作。</p><h3 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><h3 id="引入ts"><a href="#引入ts" class="headerlink" title="引入ts"></a>引入ts</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -init</span><br></pre></td></tr></table></figure><p>tsconfig.json范本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 编辑器配置 </span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 根目录</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 严格模式标志</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 指定类型脚本如何从给定的模块说明符查找文件。</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// https://www.typescriptlang.org/tsconfig#esModuleInterop </span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// JS 语言版本</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许未读取局部变量</span></span><br><span class="line">    <span class="attr">&quot;noUnusedLocals&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许未读取的参数</span></span><br><span class="line">    <span class="attr">&quot;noUnusedParameters&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许解析 json</span></span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 支持语法迭代:https://www.typescriptlang.org/tsconfig#downlevelIteration </span></span><br><span class="line">    <span class="attr">&quot;downlevelIteration&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许使用隐式的 any 类型(这样有助于我们简化 ts 的复杂度，从而更加专注于逻辑本身 </span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 模块化</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 转换为 JavaScript 时从 TypeScript 文件中删除所有注释。</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 禁用 sourceMap</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// https://www.typescriptlang.org/tsconfig#lib</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;dom&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 设置路径映射</span></span><br><span class="line">    <span class="comment">// 设置后ts在打包过程中也会自动完成路径映射,需要其他地方再次设置</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@vue/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;packages/*/src&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;packages/*/src&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="引入代码格式化"><a href="#引入代码格式化" class="headerlink" title="引入代码格式化"></a>引入代码格式化</h3><p>vscode下载插件prettier</p><p>创建文件.prettierrc.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">singleQuote</span>: <span class="literal">true</span>, <span class="comment">// 单引号</span></span><br><span class="line">  <span class="attr">trailingComma</span>: <span class="string">&#x27;es5&#x27;</span>, <span class="comment">// 对象属性最后有 &quot;,&quot;</span></span><br><span class="line">  <span class="attr">semi</span>: <span class="literal">false</span>, <span class="comment">// 是否需要分号</span></span><br><span class="line">  <span class="attr">printWidth</span>: <span class="number">110</span>, <span class="comment">// 一行最多120</span></span><br><span class="line">  <span class="attr">jsxSingleQuote</span>: <span class="literal">true</span>, <span class="comment">// jsx使用单引号</span></span><br><span class="line">  <span class="attr">tabWidth</span>: <span class="number">2</span>, <span class="comment">// 一个tab代表几个空格数，默认就是2</span></span><br><span class="line">  <span class="attr">useTabs</span>: <span class="literal">false</span>, <span class="comment">// 不使用缩进符，而使用空格</span></span><br><span class="line">  <span class="attr">jsxBracketSameLine</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建文件.prettierignore</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Ignore artifacts:</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line">coverage</span><br><span class="line">common</span><br><span class="line">tsconfig.json</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>后续的代码格式化工具上选择prettier即可</p><p>我们这里不使用eslint，不做非常强制的代码校验</p><h3 id="创建相关文件"><a href="#创建相关文件" class="headerlink" title="创建相关文件"></a>创建相关文件</h3><p>按照vue3源码中的结构进行创建，暂时只创建packages文件夹</p><h3 id="引入打包工具"><a href="#引入打包工具" class="headerlink" title="引入打包工具"></a>引入打包工具</h3><p>全局安装rollup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global rollup</span><br></pre></td></tr></table></figure><p>项目创建rollup配置文件rollup.config.js</p><blockquote><p>output中的name暂时不生效</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span></span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-typescript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认导出一个数组,数组中,每个对象都是独立导出项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;packages/vue/src/index.ts&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: [</span><br><span class="line">      <span class="comment">// 导出iife的包(自动执行 适用于script标签)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;iife&#x27;</span>,</span><br><span class="line">        <span class="attr">sourcemap</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">file</span>: <span class="string">&#x27;./packages/vue/dist/vue.js&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span>, <span class="comment">// 指定打包后的全局变量名（如果被打包代码，没有任何导出，将不存在导出名称）</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="comment">// 让rollup 支持打包ts代码,并可以指定ts代码打包过程中的相关配置</span></span><br><span class="line">      <span class="title function_">typescript</span>(&#123;</span><br><span class="line">        <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 与webpack不同的是,rollup并不知道如何寻找路径以外的依赖,比如node_module中的</span></span><br><span class="line">      <span class="comment">// 帮助程序可以在项目依赖中找到对应文件</span></span><br><span class="line">      <span class="title function_">resolve</span>(),</span><br><span class="line">      <span class="comment">// rollup默认仅支持es6的模块,但是还存在很多基于commonjs的npm模块,这就需要改插件来完成读取工作</span></span><br><span class="line">      <span class="title function_">commonjs</span>(),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>package.json中增加打包命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: <span class="string">&quot;rollup -c&quot;</span></span><br></pre></td></tr></table></figure><p>执行打包命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>然后我们在<code>packages/vue/src/index.ts</code>编写测试代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isArray &#125; from &#x27;@vue/shared&#x27; // ts部分我们配置了paths选项</span><br><span class="line"></span><br><span class="line">console.log(isArray([]))</span><br></pre></td></tr></table></figure><p>不出意外的话，这里肯定是正常打包了，并且会生成sourceMap文件。</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>package的script中增加一个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;rollup -c -w&quot;</span><br></pre></td></tr></table></figure><p>至此，基础的vue3框架环境我们就搭建完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;​	我们本次源码的目的是最终完成一个简化版的vue3，我们将他称为vue3-mini，本节我们就开始项目的搭建工作。&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>（1）vue3 源码解读前的准备工作</title>
    <link href="https://bluedancers.github.io/2023/01/28/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%881%EF%BC%89vue3%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>https://bluedancers.github.io/2023/01/28/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%881%EF%BC%89vue3%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</id>
    <published>2023-01-27T16:00:00.000Z</published>
    <updated>2023-11-27T02:38:37.875Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​在22年下半年就有想阅读vue3源码的想法了，但是因为很多不可抗力原因，一直在不断拖延。</p><p>​23年年初下定决心，一定要在半年内完成vue3的核心源码的解读，所有源码的阅读记录我都讲输出到本专栏中，目测可能有10片以上的文章，在输出中，我会尽力保证文字的简单易懂；</p><p>​话不多说，我们直接开始吧！</p><h3 id="下载vue3源码"><a href="#下载vue3源码" class="headerlink" title="下载vue3源码"></a>下载vue3源码</h3><p>仓库地址：<a href="https://github.com/vuejs/core">https://github.com/vuejs/core</a></p><p>本专栏版本为3.2.37，地址：<a href="https://github.com/vuejs/core/releases/tag/v3.2.37">https://github.com/vuejs/core/releases/tag/v3.2.37</a></p><p>克隆仓库地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vuejs/core</span><br></pre></td></tr></table></figure><h3 id="打包与运行vue3源码"><a href="#打包与运行vue3源码" class="headerlink" title="打包与运行vue3源码"></a>打包与运行vue3源码</h3><p><strong>vue3</strong>采用<strong>monorepo</strong>进行包管理，而<strong>monorepo</strong>由<strong>pnpm</strong>提供，所以需要一定要预先安装<strong>pnpm</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><p><strong>pnpm</strong>安装完成后，开始安装<strong>vue3</strong>的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install</span><br></pre></td></tr></table></figure><p>依赖安装完成后，开始<strong>vue3</strong>源码的打包工作，该步骤可能花费较长时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>​打包完成后，将会在<code>packages/vue/dist</code>，路径下生成打包后的vue3的代码，接下来我们去<code>packages/vue/examples</code>官方提供的案例中运行打包后代码，在目标html文件通过<strong>vscode启动live server</strong>，即可完成vue3示例的运行。</p><h3 id="打包vue3源码可能遇到的问题"><a href="#打包vue3源码可能遇到的问题" class="headerlink" title="打包vue3源码可能遇到的问题"></a>打包vue3源码可能遇到的问题</h3><h4 id="Error-Command-failed-with-exit-code-128-git-rev-parse-HEAD"><a href="#Error-Command-failed-with-exit-code-128-git-rev-parse-HEAD" class="headerlink" title="Error: Command failed with exit code 128: git rev-parse HEAD"></a>Error: Command failed with exit code 128: git rev-parse HEAD</h4><p>运行<code>build</code>之后，出现以上错误，原因是因为<strong>build</strong>的过程中，会读取了当前<strong>git</strong>的<strong>commit id</strong>，如果当前目录下没有**.git**文件，相关逻辑就会出错，所以需要注释掉<code>scripts/build.js</code>中以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line34 const commit = execa.sync(&#x27;git&#x27;, [&#x27;rev-parse&#x27;, &#x27;HEAD&#x27;]).stdout.slice(0, 7)</span><br><span class="line">line97 `COMMIT:$&#123;commit&#125;`</span><br></pre></td></tr></table></figure><p><strong>跳过获取commitID相关逻辑代码，即可正确打包。</strong></p><h4 id="vue3示例中源码未支持SourceMap"><a href="#vue3示例中源码未支持SourceMap" class="headerlink" title="vue3示例中源码未支持SourceMap"></a>vue3示例中源码未支持SourceMap</h4><p>当我们完成上文的打包后，我们运行一个<strong>example</strong>，运行后就会发现一个问题，我们使用Vue3源码是打包后的代码，没有sourceMap，这样是无法调试源码的。</p><p><strong>vue3</strong>源码内提供了打开<strong>sourceMap</strong>的能力，修改打包命令<code>package.json</code>中的line7，即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node scripts/build.js -s</span><br></pre></td></tr></table></figure><p>为什么这个改动呢？我们还要从<code>rollup.config.js</code>入手</p><p>在<code>rollup.config.js</code>的<strong>line94</strong> 我们可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output.sourcemap = !!process.env.SOURCE_MAP // 反向取反，获取其对应的boolean类型的值</span><br></pre></td></tr></table></figure><p>要开启sourcemap首先需要修改process.env.SOURCE_MAP，而这个值来源于<code>scripts/build</code></p><p><code>scripts/build.js</code>中的<strong>line103</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceMap ? `SOURCE_MAP:true` : ``</span><br></pre></td></tr></table></figure><p>而这里的sourceMap来源于命令行后缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const args = require(&#x27;minimist&#x27;)(process.argv.slice(2))</span><br><span class="line">const sourceMap = args.sourcemap || args.s</span><br></pre></td></tr></table></figure><p><strong>所以我们只需要在脚本命令后增加<code>-s</code>即可开启sourcemap。</strong></p><p>至此为止，我们便可以在vue源码环境中进行阅读与调试了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;​	在22年下半年就有想阅读vue3源码的想法了，但是因为很多不可抗力原因，一直在不断拖延。&lt;/p&gt;
&lt;p&gt;​	23年年初下定决心，一定要在</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
</feed>
