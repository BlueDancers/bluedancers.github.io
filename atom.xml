<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vkcya Blog</title>
  
  
  <link href="https://bluedancers.github.io/atom.xml" rel="self"/>
  
  <link href="https://bluedancers.github.io/"/>
  <updated>2024-01-04T07:17:07.354Z</updated>
  <id>https://bluedancers.github.io/</id>
  
  <author>
    <name>bluedancers</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《如何避免孤独终老》读书笔记</title>
    <link href="https://bluedancers.github.io/2024/01/04/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AD%A4%E7%8B%AC%E7%BB%88%E8%80%81/"/>
    <id>https://bluedancers.github.io/2024/01/04/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AD%A4%E7%8B%AC%E7%BB%88%E8%80%81/</id>
    <published>2024-01-03T16:00:00.000Z</published>
    <updated>2024-01-04T07:17:07.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="为什么现在谈恋爱比以前更难了"><a href="#为什么现在谈恋爱比以前更难了" class="headerlink" title="为什么现在谈恋爱比以前更难了"></a>为什么现在谈恋爱比以前更难了</h3><ul><li>我们的身份开始完全由自己决定，而不是上一辈安排</li><li>互联网的出现，大大增加了人与人交流的机会，也有了太多选择，这反而导致我们难以选择。</li><li>我们都渴望确定性，选择太多导致了大家都不稳定，这不利于感情的建立</li><li>社交媒体造成了攀比与绝望，信息的茧房与误导性，会导致人们错误的认知</li><li>亲密关系中，我们缺少扮演，我们的上一代自由恋爱不多，很多都是为了生存，我们不知道如何成为亲密的人之间是什么样子的。</li><li>在亲密关系中，需要考虑的太多，因为这个世界太自由了</li><li>为了做出正确的选择，我们压力都很大</li></ul><h3 id="婚恋倾向"><a href="#婚恋倾向" class="headerlink" title="婚恋倾向"></a>婚恋倾向</h3><h4 id="浪漫主义倾向"><a href="#浪漫主义倾向" class="headerlink" title="浪漫主义倾向"></a>浪漫主义倾向</h4><ul><li>期待找到灵魂伴侣</li><li>对另一半过于具体与不缺实际的幻想</li><li>相信爱情是充满故事性的</li><li>对爱情抱有不切实际的幻想</li></ul><h4 id="完美主义倾向"><a href="#完美主义倾向" class="headerlink" title="完美主义倾向"></a>完美主义倾向</h4><ul><li>不远降低自己的标准</li><li>过于理性的去看待爱情，喜欢对比与研究</li><li>对对方抱有不缺实际的幻想</li></ul><h4 id="自我怀疑倾向"><a href="#自我怀疑倾向" class="headerlink" title="自我怀疑倾向"></a>自我怀疑倾向</h4><ul><li>自己没有成为理想的自己</li><li>自己还有很多不足</li><li>对自己抱有不切实际的幻想</li></ul><h4 id="浪漫主义倾向的解决办法"><a href="#浪漫主义倾向的解决办法" class="headerlink" title="浪漫主义倾向的解决办法"></a>浪漫主义倾向的解决办法</h4><ul><li>放弃幻想，任何人都有他的缺点，白马王子也会早上口臭，大家都是普通人类</li><li>从此以后过上幸福的生活，是一个错误的幻想</li><li>爱情的邂逅需要自己主动去寻找，电视剧里面都是骗人的</li><li>亲密关系从来没有一帆风顺，都需要人们去可以维护的</li><li>敞开心扉，接受一份与你想象的完全不同的爱情</li><li>并不是降低标准，而是白马王子是不存在的</li></ul><h4 id="完美主义倾向的解决办法"><a href="#完美主义倾向的解决办法" class="headerlink" title="完美主义倾向的解决办法"></a>完美主义倾向的解决办法</h4><ul><li>不仅害怕错过，也害怕选错</li><li>我们的大脑会自己说服自己，自身合理化</li><li>知足常乐者并不是要求低，而是找到了期望的之后，就不在考虑其他选项</li><li>如果一个人的婚姻时间是18-40，按照37%法则，那么在26岁的时候，就可以结合之前的经验做出判断了，当我们有足够的数据，则不需要做更多的研究了</li><li>送给自己一份知足常乐的礼物吧！</li></ul><h4 id="自我怀疑倾向的解决办法"><a href="#自我怀疑倾向的解决办法" class="headerlink" title="自我怀疑倾向的解决办法"></a>自我怀疑倾向的解决办法</h4><ul><li>自我苛求者被恐惧束缚了手脚</li><li>不进行行动的自我怀疑成本极高，也会失去学习的机会</li><li>每个人都会犯错，最好现在就犯错</li><li>设定明确的目标，比如一个月最少认识一位异性</li><li>做自己拉拉队长，对自己进行鼓励</li></ul><p>一旦决定某件事，你的大脑就会开始不断的合理化。</p><h3 id="依恋类型"><a href="#依恋类型" class="headerlink" title="依恋类型"></a>依恋类型</h3><ul><li>焦虑型</li><li>安全型</li><li>回避型</li></ul><h4 id="体现在婴儿身上"><a href="#体现在婴儿身上" class="headerlink" title="体现在婴儿身上"></a>体现在婴儿身上</h4><ul><li>焦虑型是妈妈离开后会哭泣，回来后，会停止哭泣，但是随后又会愤怒，再次哭泣</li><li>安全型是妈妈离开后会哭泣，回来就会停止哭泣，安心玩耍</li><li>回避型是妈妈离开后，反应很淡，虽然心跳会加速，但是不会进行表现</li></ul><h4 id="体现在成年人身上"><a href="#体现在成年人身上" class="headerlink" title="体现在成年人身上"></a>体现在成年人身上</h4><h5 id="焦虑型"><a href="#焦虑型" class="headerlink" title="焦虑型"></a>焦虑型</h5><ul><li>一刻不停的想念自己的伴侣</li><li>会对感情抱有不安全感，阶段性怀疑，它还爱我吗</li><li>可能会做出一些过激行为</li></ul><h5 id="回避型"><a href="#回避型" class="headerlink" title="回避型"></a>回避型</h5><ul><li>觉得不能依赖他人</li><li>总是避免和人走的太近，对亲密关系有点抵触</li><li>总是会仔细琢磨另一半不好的地方，然后设法离开，幻想单身或者换个人更好</li></ul><p>自我评价一下自己，50%的安全、35%的焦虑，15%的回避</p><h3 id="寻找终生伴侣而不是舞伴"><a href="#寻找终生伴侣而不是舞伴" class="headerlink" title="寻找终生伴侣而不是舞伴"></a>寻找终生伴侣而不是舞伴</h3><ul><li>出去约会到底是为了短暂的快乐，还是长久的亲密关系？</li><li>在爱情上，我们容易过于重视当前的感觉，而忽略了未来的价值，我们实际寻找的是终生伴侣</li><li>有意识的摆脱寻找舞伴的思维</li></ul><h4 id="没那么重要"><a href="#没那么重要" class="headerlink" title="没那么重要"></a>没那么重要</h4><p>人们总是会将正在思考的事情认为成更加重要，也就是聚焦错觉</p><h5 id="金钱"><a href="#金钱" class="headerlink" title="金钱"></a>金钱</h5><ul><li>从金钱中获得的快乐不取决于金钱的多少，而是取决于你周围人多有钱</li><li>在亲密关系中考虑这个没错，但是财富不是最重要的</li></ul><h5 id="长相"><a href="#长相" class="headerlink" title="长相"></a>长相</h5><ul><li>人们看重长相有历史上的进化原因，在现代社会的加持下，这不是大问题</li><li>当你习惯了他的长相，或者随着时间的推移，迷恋都会随之消失</li><li>不要将长相放在其他更加重要的事情前面</li></ul><h5 id="相似的性格"><a href="#相似的性格" class="headerlink" title="相似的性格"></a>相似的性格</h5><ul><li>你真的愿意和自己谈恋爱吗</li><li>科学研究证明，相似的性格并不意味着亲密关系一定会成功</li><li>可以试试互补的人，未来会更加有趣</li></ul><h5 id="共同的爱好"><a href="#共同的爱好" class="headerlink" title="共同的爱好"></a>共同的爱好</h5><ul><li>没必要一定共同爱好，只要给彼此留出足够的空间与自由</li><li>各自探索，对一个未来更好</li></ul><h4 id="更加重要的"><a href="#更加重要的" class="headerlink" title="更加重要的"></a>更加重要的</h4><h5 id="情绪稳定，心地善良"><a href="#情绪稳定，心地善良" class="headerlink" title="情绪稳定，心地善良"></a>情绪稳定，心地善良</h5><ul><li>夫妻情绪都稳定，婚姻美满的概念就会大大提升</li><li>心地善良的人会最好的伴侣，愿意成为另一半的后盾</li></ul><h5 id="忠诚"><a href="#忠诚" class="headerlink" title="忠诚"></a>忠诚</h5><ul><li>人生不仅仅是共享荣华富贵，也是共担患难</li></ul><h5 id="成长型心态"><a href="#成长型心态" class="headerlink" title="成长型心态"></a>成长型心态</h5><ul><li>成长型心态相信，可以通过后天提升自己的智力与技能</li><li>一个成长型心态的人更会认真努力</li></ul><h5 id="能否激发出你好的一面"><a href="#能否激发出你好的一面" class="headerlink" title="能否激发出你好的一面"></a>能否激发出你好的一面</h5><ul><li>要一起变得越来越好，而不是数落与打击</li><li>和他理解的开始，是否会觉得无聊，泄气，还是快乐，充满渴望</li></ul><h5 id="懂得合理争吵"><a href="#懂得合理争吵" class="headerlink" title="懂得合理争吵"></a>懂得合理争吵</h5><ul><li>吵架不是坏事，不要将不满憋在心里</li><li>需要人认识到亲密关系中大约有69%的事情是无法解决的</li><li>理性表达、采取行动、多加欣赏</li><li>目标是合理争吵，而不是避免争吵</li></ul><h5 id="很一起做出艰难决定的人"><a href="#很一起做出艰难决定的人" class="headerlink" title="很一起做出艰难决定的人"></a>很一起做出艰难决定的人</h5><ul><li>面对困境，能否一起做出合理的解决方案</li><li>是否一个乐于领导，一个乐于服从</li><li>事情出现了差错，你是否会责怪另一半</li></ul><p><strong>一段亲密关系成功的关键：一个人的情绪是否稳定，是否善良、忠诚，以及和这个人在一起的时候，我们感觉如何。</strong></p><p><strong>把舞伴留在舞台，寻找长期伴侣吧！</strong></p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="你其实并不知道自己想要什么"><a href="#你其实并不知道自己想要什么" class="headerlink" title="你其实并不知道自己想要什么"></a>你其实并不知道自己想要什么</h3><h4 id="社交媒体上"><a href="#社交媒体上" class="headerlink" title="社交媒体上"></a>社交媒体上</h4><h5 id="你并不知道自己想要什么"><a href="#你并不知道自己想要什么" class="headerlink" title="你并不知道自己想要什么"></a>你并不知道自己想要什么</h5><ul><li>我们过于关注可量化的数字，但是这个常常不是重点</li><li>我们错误的使用自己想要的数据把潜在对象过滤掉了</li><li>交友软件催生了 购物式恋爱，而不是显示生活的渐进式恋爱，将活生生的人变成了被搜索到商品</li><li>交友软件太多的选择，反而让我们约会这件事变得更加困难</li><li>放开交友软件中的过滤条件</li><li>寻找接受对方的理由，而不是寻找缺点，很多人比档案里面表现的要有趣的多</li></ul><h5 id="如何利用社交媒体"><a href="#如何利用社交媒体" class="headerlink" title="如何利用社交媒体"></a>如何利用社交媒体</h5><ul><li>挑选几张好照片</li><li>抓拍的照片比摆拍的更好</li><li>要准确、实际的描述自己，而不是理想中的自己</li><li>要写的具体，别人才有兴趣和你交谈，具体喜欢什么电影，具体爱做什么菜</li><li>关注自己喜欢什么，而不是不喜欢什么</li><li>构思一个巧妙的开场白</li><li>尽快进入正题，也就是面对面交流，因为聊的太多，反而不是好事情</li></ul><h3 id="现实生活中"><a href="#现实生活中" class="headerlink" title="现实生活中"></a>现实生活中</h3><h4 id="参加活动"><a href="#参加活动" class="headerlink" title="参加活动"></a>参加活动</h4><ul><li>多多参加社交活动，朋友需要自己主动去寻找</li><li>可以参考活动决策矩阵<ul><li>和他人互动多机会有多大</li><li>玩的开心的机会有多大</li></ul></li></ul><h4 id="朋友与家人的介绍"><a href="#朋友与家人的介绍" class="headerlink" title="朋友与家人的介绍"></a>朋友与家人的介绍</h4><ul><li>开口让别人给你介绍对象，并告诉他们你要找人生伴侣而不是舞伴</li><li>同时给你的好朋友发几张照片</li><li>要接受朋友们的安排，这都是他费心介绍的</li><li>给朋友反馈</li><li>为这件事提供奖励</li></ul><h4 id="考虑已经认识的人"><a href="#考虑已经认识的人" class="headerlink" title="考虑已经认识的人"></a>考虑已经认识的人</h4><h4 id="出门在外，勇敢的介绍自己"><a href="#出门在外，勇敢的介绍自己" class="headerlink" title="出门在外，勇敢的介绍自己"></a>出门在外，勇敢的介绍自己</h4><ul><li>主动才有缘份，注意分寸就行</li></ul><h3 id="如何更好的约会"><a href="#如何更好的约会" class="headerlink" title="如何更好的约会"></a>如何更好的约会</h3><ul><li><p>约会的环境很重要，人们是非常受环境影响的</p></li><li><p>避免评估式约会，应该体验式约会，多问自己感觉如何，而不是看条件</p></li><li><p>学会不是工作，不是求职</p></li><li><p>首次约会的目的并不是结婚，而是是否可以引起对方的好奇心</p></li><li><p>约会的心态很重要，消极的心态带来消极的结果，积极的心态带来积极的结果，期待会带来快乐</p><ul><li>约会前和最好朋友聊聊天，让自己充满自信也更加更讨喜</li><li>约会前听听喜剧，保持好心情</li><li>做一些简单运动，释放内啡肽</li><li>洗个香香的热水澡</li></ul></li></ul><h3 id="不要迷恋一见钟情"><a href="#不要迷恋一见钟情" class="headerlink" title="不要迷恋一见钟情"></a>不要迷恋一见钟情</h3><ul><li>一见钟情往往会蒙蔽我们的双眼，一见钟情不代表两个人就合适</li><li>一见钟情不是好事，这只能证明一个人有迷人或者自恋</li><li>一见钟情，不代表感情就可以很好维持，可能只是站在一见钟情的份子上，不断坚持</li></ul><p>然后这辈子都不去辜负这梦幻一般的相逢</p><p>不要因为好像找到了正确的人，而沿着错误的道路一直走下去。</p><h3 id="开始第二次约会"><a href="#开始第二次约会" class="headerlink" title="开始第二次约会"></a>开始第二次约会</h3><ul><li><p>不想被别人评价，就不要去评价别人</p></li><li><p>负面偏见，人们总是更加容易记住危险的，批评的话与人，我们要认清这一点</p></li><li><p>归因错误，这个迟到，就是不守信用，说话大声就还是脾气暴躁，这都是客观的评判，别被自己误解了</p></li><li><p>去寻找积极的一面，比如看到别人的善良、体贴、聪明</p></li><li><p>默认选项的重要性，默认自己会开始第二次约会，别给自己思考的机会</p></li><li><p>识别什么是小毛病什么是大毛病，小毛病别可以容忍，大毛病无法容忍</p><ul><li>小毛病， 这个人不是一米八、这个人不够英俊</li><li>大毛病，消费观不合、对未来的期待不合</li></ul></li><li><p>如果要拒绝别人，请不要玩失踪</p><ul><li>玩消失会让玩消失的人感觉难受，还不如直接表达自己的感受</li><li>根据自我知觉理论，人们不告而别后，会想：我做了一个不好的事情，我大概是个滚蛋</li><li>当人们玩消失的时候，他们认为自己走了一条轻松的路，但是他们错了，如果我们选择善良、坦率、礼貌的方式，我们更加能够获得正面回应</li></ul></li></ul><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><h3 id="主动决策，而不是顺其自然"><a href="#主动决策，而不是顺其自然" class="headerlink" title="主动决策，而不是顺其自然"></a>主动决策，而不是顺其自然</h3><ul><li>主动决策的关系要比顺其自然的关系更加具备信任感</li><li>主动明确关系，哪怕得到是不好的回答</li><li>同居更加容易让人们因为惯性走到一起，所以要认真对待这件事</li></ul><h3 id="既不要说走就走，也不患得患失"><a href="#既不要说走就走，也不患得患失" class="headerlink" title="既不要说走就走，也不患得患失"></a>既不要说走就走，也不患得患失</h3><h4 id="说走就走型"><a href="#说走就走型" class="headerlink" title="说走就走型"></a>说走就走型</h4><ul><li>不给感情发展的机会，过早的选择离开</li><li>通常是个完美主义者，追求或者相信自己可以找到更好的</li><li>不仅影响被甩的人，也影响自己，没有机会学习如何成为一个长期的好伴侣</li><li>说走就走永远都是原地踏步的循环，没人希望这样。</li><li>多多发现对方的长处，而不是盯着缺点一直想</li></ul><h4 id="患得患失型"><a href="#患得患失型" class="headerlink" title="患得患失型"></a>患得患失型</h4><ul><li>感情已经破裂，但是仍然不愿离开</li><li>我应该听从内心的声音和她分手吗，我会不会错过一段美好的姻缘？</li><li>因为沉没成本的执念，我在她身上花费了太多时间，现在退出太亏了</li><li>因为厌恶损失的影响，我们总是把损失看得比收益更加重要</li><li>我们对失去伴侣充满恐惧，胜过我们对新的约会的对象的兴趣</li><li>分手不是闸道，而是一个丁字路口，我们总是要做出选择，而不是停滞不前</li><li>我应该如何做出决定<ul><li>想象一下如果你的伴侣是衣柜一面的一件衣服，你认为是哪一种？</li><li>不好的表现是不是暂时的，还是长期这样</li><li>是否尝试修复你们的关系</li><li>你对长期伴侣的期望是什么样，是否实际？</li><li>在这段感情中，你做到最好的自己了吗？</li></ul></li><li>征求朋友与家人的意见</li></ul><h3 id="定制一个分手计划"><a href="#定制一个分手计划" class="headerlink" title="定制一个分手计划"></a>定制一个分手计划</h3><p>​及时决定分手的人，实际做起来都非常困难，人们害怕艰难的谈话，害怕伤害对方，害怕一个人独处，通常会花几个月，几年的时间去畏缩、迟疑，也许我们需要一个分手计划。</p><ul><li>记下你分手的原因<ul><li>喜欢攀比，看到别的男朋友好就会给我压力。</li><li>过于算计，一点亏吃不得。</li><li>太多要求让我倍感压力。</li><li>与我的长期目标不一致，不想结婚，不想生孩子，不想承担家庭的责任。</li><li>大家的脾气都非常尖锐，我们没有做到相互理解与尊重彼此。</li><li>我们总是吵架，这人我们都很糟糕，我不喜欢我们的表现。</li><li>我做出了挽回感情的努力，我相信现阶段结束是最好的选择。</li></ul></li><li>定制分手计划<ul><li>写下目标、定制计划会让实现目标的可能性高出33%</li><li>选择一个安静的地方，让大家好好交流</li><li>选择一个合适的时间，分手是引爆对方生活的炸弹，如果后面它有要紧的事情，别毁了它的计划。</li><li>提前思考谈话的目的，核心信息，语气，开场白，内容，对方可能的反应，如何结束对话</li></ul></li><li>和朋友建立一个问责体系<ul><li>找你的朋友确认一个目标，以及期限。</li></ul></li><li>我们去谈话，不是干其他的事情<ul><li>我们可能会谈话情绪的波动做出一些不该做的事情，参考尤利西斯契约，不要改变航向。</li></ul></li><li>为自己制定一个分手后的短期计划<ul><li>考虑好分手后你要做什么</li><li>朋友、家人、美食、电影</li><li>避免孤独与不安</li></ul></li><li>和前任签订分手协议</li><li>改变习惯，避免再次陷入这段感情<ul><li>分手后，生活中会有很多空洞</li><li>换个人来替换和对象经常做的事情吧，一个强有力的策略就是用新的活动、人代替她</li></ul></li><li>不要在分手后，做一个黏黏糊糊的老好人<ul><li>即使一切都在预料之中，对个人而言也不是一件容易的事情</li><li>分手后的一段时间，心情会做过山车，从极度放松到极度后悔，我会孤独终老吗，我为什么要这么做</li><li>可能会感到内疚，因为你伤害了在乎你的人</li><li>做老好人，很多是为了自己，而不是在帮助对方，给对方精简，</li></ul></li></ul><p>​如果我们曾经努力过，但仍然无法解决问题，有觉得彼此的伤害难以忘记，那或许分手是当前最好的选择，尽管还有感情存在，但长期的矛盾和伤害会削弱彼此的幸福感与成长空间，</p><p>​说实话，我依旧对你还有感情，我也很喜欢我们在一起的很多时光，但是我并不开心，我们都知道我们的感情出了问题，我们也都努力过尝试改善，但是我们一直都没有做出有效的改变；</p><p>​这很难说出口，因为我不想伤害你，非常感激我们在一起的时光。</p><h3 id="把分手看做收获而不是损失"><a href="#把分手看做收获而不是损失" class="headerlink" title="把分手看做收获而不是损失"></a>把分手看做收获而不是损失</h3><h4 id="如何克服分手后的心碎"><a href="#如何克服分手后的心碎" class="headerlink" title="如何克服分手后的心碎"></a>如何克服分手后的心碎</h4><ul><li>要想走出分手，关键是找对描述事物的框架</li><li>分手之所以痛苦，是因为大脑对损失非常敏感，分手是绝大的损失，你个伴侣曾经一起构想的未来就此终结，让你悲伤的不仅仅是不堪回首的过往、面目全非的现在、还有再无可能的未来，因为厌恶损失，我们总是尽量避免分手。</li><li>一切都都会过去，你的感觉都是暂时的，你终将走出这个阶段</li></ul><h4 id="关注分手的积极方面"><a href="#关注分手的积极方面" class="headerlink" title="关注分手的积极方面"></a>关注分手的积极方面</h4><ul><li>大脑会帮你合理化，尽量去想一些积极方面的事情</li><li>告诉大脑你渴望的东西，为什么这次分手很好</li></ul><h4 id="关注亲密关系中消极的部分"><a href="#关注亲密关系中消极的部分" class="headerlink" title="关注亲密关系中消极的部分"></a>关注亲密关系中消极的部分</h4><ul><li>思考已经结束的这段感情中不好的地方</li><li>不和谐的地方</li><li>让你讨厌的事情</li></ul><h4 id="重新发现自己"><a href="#重新发现自己" class="headerlink" title="重新发现自己"></a>重新发现自己</h4><ul><li>你恢复了单身，会成为什么样的人呢</li><li>做一些你们在一起的时候，你想做却没能做的事情</li><li>太多独处意味着对自我价值的怀疑，勇敢的出去走走</li></ul><h4 id="吸取分手的教训"><a href="#吸取分手的教训" class="headerlink" title="吸取分手的教训"></a>吸取分手的教训</h4><ul><li>把分手看成一个学习的机会，反思这段感情学到了什么，没做好什么</li></ul><p>试着不把分手看做失败，看成一个机会，促使你在未来做出更好决定。让你的思想升级一下，从时间能治愈一切创伤，变成意义能治愈一切创伤。</p><h4 id="需要思考的问题"><a href="#需要思考的问题" class="headerlink" title="需要思考的问题"></a>需要思考的问题</h4><ul><li>在上一段感情中，你的地位是什么？</li><li>在下一段感情中你希望扮演什么角色？</li><li>认真反思后，你认为一段长期亲密关系中，什么最重要</li><li>你是否在这一次关系中没有考虑到某件事</li><li>你希望在下一段关系中，首先从对方身上寻找什么特质？</li><li>在这段感情里面你学到了什么？</li><li>从分手中你学到了什么？</li><li>在这段感情之前的你和现在的你有什么不同？</li><li>这段经历对你的生活带来了什么改变？</li></ul><p>与其让自己被打碎，不如主动打碎自己的枷锁，哪些裂痕、不完美，会让你变的更加坚强。</p><h3 id="喜结连理之前要做的事情"><a href="#喜结连理之前要做的事情" class="headerlink" title="喜结连理之前要做的事情"></a>喜结连理之前要做的事情</h3><ul><li>婚姻对人生的幸福、自己的身心健康、寿命、财富、子女的幸福都存在巨大的影响，所以要慎重对待</li><li>彼此相爱并不够可能会让彼此产生“错误共识效应”，认为对方在生活中和自己想要的东西一样，直到婚后才发现，并不一样</li><li>首先问自己若干问题</li><li>问我们过去、现在、未来的若干问题</li></ul><h3 id="目标明确的爱情"><a href="#目标明确的爱情" class="headerlink" title="目标明确的爱情"></a>目标明确的爱情</h3><ul><li>随着婚姻时间的增加，满意度一定是逐渐降低的</li><li>现代社会，幸福婚姻的趋势在不断下降</li><li>爱情是需要我们认真经营，并不是说要做到最好，最恩爱的，而是营造可以适应变化的亲密关系</li><li>建立一个亲密关系的契约，它帮助伴侣们为他们的亲密关系设定一个共同的愿景，在编写亲密关系契约的时候，并不是抱怨对方的缺点，也不是提出要求，而是价值观上的一致：我们承诺支付对方的梦想，并为实现这些梦想做出必要的牺牲。</li><li>选择主动决策，而不是任凭感情自然发展，这更有助于亲密关系的实现</li><li>契约中要进行例行检查，契约保证你们发展在一个方向，而检查则确保始终沿着正确的轨道前进，这要可以在问题爆发之前，对亲密关系进行调整，一起谈谈身上正在发生的事情，我的生活变成了什么样子？</li><li>牢固亲密关系不会凭空出现，需要你尽心尽力的做出正确的选择</li></ul><p><strong>不论怎样，生活都是一次探索之旅，而不是意外事件，主动设计自己的生活，对自己负责，对自己诚实，知道自己是谁，想要什么，最重要的是，必要的时做出改变。你不必按照别人的想法生活，你要按照自己的想法生活。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一部分&quot;&gt;&lt;a href=&quot;#第一部分&quot; class=&quot;headerlink&quot; title=&quot;第一部分&quot;&gt;&lt;/a&gt;第一部分&lt;/h2&gt;&lt;h3 id=&quot;为什么现在谈恋爱比以前更难了&quot;&gt;&lt;a href=&quot;#为什么现在谈恋爱比以前更难了&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="恋爱" scheme="https://bluedancers.github.io/tags/%E6%81%8B%E7%88%B1/"/>
    
  </entry>
  
  <entry>
    <title>（23年12月）chatGPT绑虚拟卡并开通plus会员</title>
    <link href="https://bluedancers.github.io/2023/12/12/chatGPT/chatGPT%20plus%E5%BC%80%E9%80%9A%E6%8C%87%E5%8D%97/"/>
    <id>https://bluedancers.github.io/2023/12/12/chatGPT/chatGPT%20plus%E5%BC%80%E9%80%9A%E6%8C%87%E5%8D%97/</id>
    <published>2023-12-11T16:00:00.000Z</published>
    <updated>2024-01-04T07:14:06.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="看完这篇文章你将学会"><a href="#看完这篇文章你将学会" class="headerlink" title="看完这篇文章你将学会"></a>看完这篇文章你将学会</h2><ul><li>购买加密货币，包括BTC、ETH、USDT</li><li>注册虚拟银行卡，并充值美元</li><li>开通chatGPT PLUS会员</li></ul><h2 id="绑卡的好处"><a href="#绑卡的好处" class="headerlink" title="绑卡的好处"></a>绑卡的好处</h2><ul><li>可以使用gpt 4的api能力</li><li>gpt 3.5的api请求速率从每分钟3次到每分钟3500次，避免429状态码</li><li>可以进一步<strong>开通Plus会员</strong></li></ul><h2 id="平台简介"><a href="#平台简介" class="headerlink" title="平台简介"></a>平台简介</h2><p><strong>DuPay</strong></p><p>​前身为<strong>depay</strong>，可开通虚拟银行卡进行全球通用支付，并可使用加密货币进行充值。</p><p><strong>欧易OXK</strong></p><p>​加密货币交易所，可以购买绝大部分的加密货币，类似平台还是币安。个人推荐使用欧易，国内使用更加方便。</p><h3 id="如何下载相关APP"><a href="#如何下载相关APP" class="headerlink" title="如何下载相关APP"></a>如何下载相关APP</h3><p>​功能上APP相对网站更加齐全，体验感更好，所以推荐使用APP去完成相关操作，IOS的用户需要<strong>美区APPID</strong>才能下载，android手机可根据官方提供的下载地址，或者第三方资源完成下载与安装。</p><p>​亲测使用环节均不需要梯子。</p><h2 id="关于货币流转"><a href="#关于货币流转" class="headerlink" title="关于货币流转"></a>关于货币流转</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><blockquote><p>为了方便理解，下文使用中文进行描述</p></blockquote><p>USDT：中文名称为<strong>泰达币</strong>，价值与美元挂钩，一个USDT相当于一美元</p><p>USD：美元</p><h3 id="流转过程"><a href="#流转过程" class="headerlink" title="流转过程"></a>流转过程</h3><blockquote><p>为什么流程这么复杂？depay不接受人民币，仅支持泰达币的方式进行充值，或者内部转账</p></blockquote><p><strong>人民币 - 泰达币 - 美元</strong></p><ul><li>在欧易中完成<strong>人民币转化为泰达币</strong></li><li>在dupay中获取加密钱包地址，将欧易中的泰达币<strong>充值到dupay</strong>（每次大约2泰达币的手续费）</li><li>花费20泰达币完成虚拟卡的申请，或者50泰达币，取决于购买者的需求</li><li>将大约30泰达币转化为30美元，并充值到虚拟卡中</li><li>在openAI侧进行消费</li></ul><h3 id="大概费用"><a href="#大概费用" class="headerlink" title="大概费用"></a>大概费用</h3><p>开卡费<strong>20泰达币</strong>，后续每月卡费0.5泰达币（或者使用50泰达币，获得无需开卡费的虚拟银行卡）</p><p><strong>虚拟卡充值单次最少30美元</strong></p><p>各个流程的手续费累计在一起大约消耗2-3美元</p><p>所以建议一次性充值大约56-60泰达币，也就是<strong>430元人民币</strong>，<strong>注意每次充值都需要手续费，所以尽量一次充值到位</strong></p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="http://qiliu.vkcyan.top/FlGpff7vZHI3Is5Wyl7z1Eg8u0K6.png"></p><h3 id="注册DuPay"><a href="#注册DuPay" class="headerlink" title="注册DuPay"></a>注册DuPay</h3><p><a href="https://dupay.one/">https://dupay.one/</a></p><ul><li>建议通过手机号完成注册（使用的时候不要挂梯子，否则会注册失败）</li><li>根据要求完成实名认证</li></ul><h3 id="注册欧易OXK"><a href="#注册欧易OXK" class="headerlink" title="注册欧易OXK"></a>注册欧易OXK</h3><p> <a href="https://www.okx.com/cn">https://www.okx.com/cn</a></p><ul><li>根据网站要求完成手机号的注册</li><li>根据要求完成实名认证</li><li>使用人民币购买泰达币</li></ul><p><img src="http://qiliu.vkcyan.top/FshK_VQQMZgLEur12CXruuzUQhYY.png"></p><p>购买后存在一定的T+N的安全保护，大约<strong>1-3天</strong>后才可以进行后续的操作。这里就只能等待了</p><h3 id="充值到DuPay"><a href="#充值到DuPay" class="headerlink" title="充值到DuPay"></a>充值到DuPay</h3><p>欧易那边的T+N的安全保护结束后，我们就可以把泰达币充值到DuPay中了</p><p><img src="http://qiliu.vkcyan.top/Frz4IcRFfNSxkhrASZznJs52AkUU.png"></p><ul><li>DuPay中点击钱包 - 充币，获取到钱包地址</li><li>欧易中点击资产 - 提币，提取数字货币，选择USDT，在选择链上提币。</li><li>填写正确的钱包地址，与提币网络即可完成充值</li></ul><p><strong>注意：每次充值都会两头收取手续费，大约2泰达币，所以尽量一次充值到位</strong></p><h3 id="开卡-存款"><a href="#开卡-存款" class="headerlink" title="开卡+存款"></a>开卡+存款</h3><p>​泰达币充值到账之后，我们就可以开卡了，现在已经没有免费卡了，横向对比，应该只有这个20泰达币的高级卡是性价比最高了。</p><p><img src="http://qiliu.vkcyan.top/FjCd0xMFBS7RaT7lv61JLUCpdd3Q.png"></p><p>支付20泰达币之后，开通成功。</p><p>接下来我们在钱包中将剩下的<strong>泰达币转化为美元</strong>，再点击首页的充值，<strong>这里需要注意一定要准备30美元以上，这是DuPay的充值限制</strong></p><p><img src="http://qiliu.vkcyan.top/FhqVrzpV-aWUdrvd0JAc7IgUvvWS.png"></p><p>完成以上步骤后，我们就成功完成了开卡与充值；接下里让我们到openAI侧进行绑卡操作。</p><h3 id="openAI侧绑卡"><a href="#openAI侧绑卡" class="headerlink" title="openAI侧绑卡"></a>openAI侧绑卡</h3><p>登录进入自己的账号，并选择个人的</p><p><img src="http://qiliu.vkcyan.top/FhTN2n8SkaX-DUtlNWf7_EXwG6p2.png"></p><p>先使用<a href="https://www.dizhishengcheng.com/">https://www.dizhishengcheng.com/</a> 生成美国人虚构信息。</p><p>建议使用免税州的信息，免税州包括阿拉斯加州（Alaska）、特拉华州（Delaware）、蒙大拿州（Montana）、新罕布什尔州（New Hampshire）和俄勒冈州（Oregon）。</p><p><img src="http://qiliu.vkcyan.top/FoT2slhfpX0ZJpzV2DuPxFQZfsQo.png"></p><p>信息全部输入成功，点击continue即可，在这个环节我没有遇到被银行卡被拒绝的情况。</p><p>后续流程会建议你设置自动充值计划，这个按照自己的需要进行配置。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>​绑卡成功后，即可直接购买plus会员；就算不进行购买，chatgpt3.5的api也享受每分钟3500次请求的速率限制，还是非常不错的。</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;看完这篇文章你将学会&quot;&gt;&lt;a href=&quot;#看完这篇文章你将学会&quot; class=&quot;headerlink&quot; title=&quot;看完这篇文章你将学会&quot;&gt;&lt;/a&gt;看完这篇文章你将学会&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;购买加密货币，包括BTC、ETH、USDT&lt;/li&gt;
&lt;li&gt;注</summary>
      
    
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/categories/chatGPT/"/>
    
    
    <category term="chatgpt PLUS" scheme="https://bluedancers.github.io/tags/chatgpt-PLUS/"/>
    
    <category term="虚拟币" scheme="https://bluedancers.github.io/tags/%E8%99%9A%E6%8B%9F%E5%B8%81/"/>
    
    <category term="depay" scheme="https://bluedancers.github.io/tags/depay/"/>
    
    <category term="dupay" scheme="https://bluedancers.github.io/tags/dupay/"/>
    
  </entry>
  
  <entry>
    <title>chatgpt的calling Funtion让贾维斯不再遥远</title>
    <link href="https://bluedancers.github.io/2023/12/12/chatGPT/chatgpt%E7%9A%84calling%20Funtion%E8%AE%A9%E8%B4%BE%E7%BB%B4%E6%96%AF%E4%B8%8D%E5%86%8D%E9%81%A5%E8%BF%9C/"/>
    <id>https://bluedancers.github.io/2023/12/12/chatGPT/chatgpt%E7%9A%84calling%20Funtion%E8%AE%A9%E8%B4%BE%E7%BB%B4%E6%96%AF%E4%B8%8D%E5%86%8D%E9%81%A5%E8%BF%9C/</id>
    <published>2023-12-11T16:00:00.000Z</published>
    <updated>2024-01-04T07:15:07.042Z</updated>
    
    <content type="html"><![CDATA[<p>后续编写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;后续编写&lt;/p&gt;
</summary>
      
    
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/categories/chatGPT/"/>
    
    
    <category term="calling Funtion" scheme="https://bluedancers.github.io/tags/calling-Funtion/"/>
    
  </entry>
  
  <entry>
    <title>搭建一个企业内部的实用AI</title>
    <link href="https://bluedancers.github.io/2023/12/12/chatGPT/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%94%A8AI/"/>
    <id>https://bluedancers.github.io/2023/12/12/chatGPT/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%94%A8AI/</id>
    <published>2023-12-11T16:00:00.000Z</published>
    <updated>2024-01-04T07:15:41.718Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章</p><p><a href="https://longbig.github.io/2023/02/19/ChatGPT%E6%8E%A5%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%90%E4%B8%BA%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/">https://longbig.github.io/2023/02/19/ChatGPT%E6%8E%A5%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%90%E4%B8%BA%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/</a></p><p><a href="https://dingyx99.me/post/wechat-work-nodejs/">https://dingyx99.me/post/wechat-work-nodejs/</a></p><p><a href="https://juejin.cn/post/7133543712977584142">https://juejin.cn/post/7133543712977584142</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://longbig.github.io/2023/02/19/ChatGPT%E6%8E%A5%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%90%E4%B8%BA</summary>
      
    
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/categories/chatGPT/"/>
    
    
    <category term="ai机器人" scheme="https://bluedancers.github.io/tags/ai%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>正确的理解技术，可以让我们走的更远</title>
    <link href="https://bluedancers.github.io/2023/11/25/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C/"/>
    <id>https://bluedancers.github.io/2023/11/25/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C/</id>
    <published>2023-11-24T16:00:00.000Z</published>
    <updated>2023-11-29T09:35:34.578Z</updated>
    
    <content type="html"><![CDATA[<p>​我们小时候都听过这样的一个故事，</p><p>​为什么大家都说35岁是技术岗的危机，甚至现在还出现了更加提前的趋势，30岁危机就已经出现。在本文开始之前，我也先丢几个问题给大家，一起思考一下以下现象的原因是什么？</p><ul><li>软件开发是否是劳动密集型行业？</li><li>为什么在中国，为何倾向于更加年轻的程序员，多年经验的程序员反而越发艰难？</li><li>当程序员们意识到危机的时候，他们遇到了什么挑战？</li><li>如何应对程序员的”35岁危机”？</li></ul><p>​接下来我来谈一谈我这6年对技术的理解的变化，以及学习与适应变化的过程，从中我们一起寻找上述问题的答案。</p><p>​</p><h2 id="技术是代码（0-3年）"><a href="#技术是代码（0-3年）" class="headerlink" title="技术是代码（0-3年）"></a>技术是代码（0-3年）</h2><blockquote><p>那时候我就像是一个在技术的门外不断窥探的孩子，迷茫、思索，不断寻找属于我的自己的打开技术大门的钥匙。</p></blockquote><p>​当我在大学中刚开始接触代码的时候，我和大多数人一样苦于如何完成老师的课后作业，回想起来，我对技术这个词的理解非常直观，<strong>技术就是代码</strong>，要如何做好一名合格的技术呢？多多学习与理解代码。实话说，谈不上有写代码的天赋，大学中学的第一个语言课是C语言，学的也比较糟糕，后来慢慢培养了一点技术思维，学java的时候又败给了面向对象。</p><p>​我时常为自己的天赋平庸而烦恼。如果技术就是代码，那时候我的技术能力简直就是灾难。</p><p>​上帝还是给了我机会，偶然之间让我接触到了JavaScript，这并不是学校授课的语言，但是这确实一个令人着迷的语言，在面向过程的的JavaScript（ES5）中，我找到了突破点，顺着这条藤蔓，我找到了适合我的对技术的打开方式，技术思维逐渐被打开，以前不理解种种逻辑，面向对象、指针，也很自然的就理解了。</p><p>​再后来参加全国比赛，凭借兴趣与努力不断学习，逐渐成为我们计院的top，这才算走上了编程这条路。</p><p>​在我那短暂而又高强度的学习编程的经历中，我始终都有一个明确的理念，<strong>技术 &#x3D; 代码</strong>，要想编程能力进步，想成为更加厉害的程序员，就要拼命写代码，所以我知行合一，延续了在学校比赛时期的作息时间，工作时间外，晚上也继续学习技术，我非常积极的接触所有前端范畴的技术的上的工作，主动挑战任何技术难点，因为我坚信，代码写的好不好，是评价技术的唯一标准。</p><p>​就这样，在我写代码的前3年我几乎把前端范畴中能接触的所有技术，都学习了一遍，而对于重要的技术，也会重点学习与了解，通常会想方设法的了解实现原理；同时坚持费曼学习法，保持输出的习惯，这些年我的juejin博客的阅读量也还不错，大部分文章的内容也还说得过去。</p><p>​所以在我迈入职场的头几年，我的收入和社会认同感都有肉眼可见的增加，这些成果一方面激励我继续努力，但是另一方面我内心的疑惑也越来越大。</p><h3 id="对技术的疑虑"><a href="#对技术的疑虑" class="headerlink" title="对技术的疑虑"></a>对技术的疑虑</h3><p>​某一天晚上我在公司无所事事，学习ng，在学习的过程中，我突然开始思考起来，学习ng对我而言真的有用吗？</p><p>​公司不可能用ng的技术栈，不好招人、国内生态差、文档不友好，那在学习ng的过程中我能了解到什么？ng的一些编程思想，企业级的项目架构；可是我没有应用场景，怎么能有深刻的理解？最多只能扩大自己的知识面。自那之后我在学习新技术的时候我都会开始思考，我花这么多时间去学习这些我很难用到的技术，再随着知识慢慢被遗忘或者过期，是不是已经产生不了什么效果呢？</p><p>​我们时常说，技术为业务服务，若是学习的技术并没有在实际业务中发挥作用，没有让开发效率更高、没有让软件的速度更快、没有让团队成员开发体验更好，那岂不就是没用的技术。</p><p>​所以我转变了思路，决定不在走马观花式的学习，要打技术纵深，看axios、promise、vue2.x、vuex的底层实现，然而源码的复杂程度超乎我的现象，首先我个人不具备独立阅读源码的能力，在阅读的过程中，我需要搭配别人的博客，以及源码解读视频才能理解其核心逻辑，在这个过程中我充分认识到了一点就是这些人的水平，我一辈子都达不到。</p><p>​不过另一方面我还是要为阅读源码正名，这个确实有用，这就像数学公式一样，不理解原理就只能背诵，照搬硬套，但了解原理后，就能解释很多为什么，开发的能力得到很大的加强。</p><h3 id="对没有结果的疑虑"><a href="#对没有结果的疑虑" class="headerlink" title="对没有结果的疑虑"></a>对没有结果的疑虑</h3><p>​在我工作的前三年，我做过很多产品和需求、开源，有些是公司的，有些私人的，但是绝大部分都是失败，投入了很多精力，没有产生任何价值，我非常幼稚的认为技术是非常重要的一环，但是反复的失败，让我非常茫然，也让我逐渐意识到技术能决定的事情，并不多，也意识到做出一款被大家接受的产品是一件极难的事情，</p><p>​那段时间和我的领导聊了很多，这里我尊称一句<strong>w老师</strong>，w老师通过各种例子慢慢纠正我的对技术片面的理解，反复和我论述<strong>技术为业务服务</strong>，那时候我对这句话依旧是半知半解，我想技术当然是为了业务服务，技术好才能完成各种各样复杂的业务，这人我一度想不明白，w老师想和我表达什么，但是这还是埋下了一颗种子，为了我的下一个阶段做好了准备。</p><p>所以后面，我想明白了一些道理，也看到了我对技术理解上的局限性</p><ul><li><strong>技术只是工具，本身没有价值，有价值的是技术形成的产品。</strong></li><li><strong>程序员不仅需要怎么做，更需要知道为什么要做。</strong></li></ul><h3 id="对0-3年的建议"><a href="#对0-3年的建议" class="headerlink" title="对0-3年的建议"></a>对0-3年的建议</h3><p>从我的精力看，我觉得从小白 - 初级前端开发者 - 前端组长，3年时间足矣，需要做到以下几点</p><ul><li><strong>学习技术的第一源动力是出于兴趣、与技术的喜爱，而不是为了获得一份工作或者高薪资</strong></li><li><strong>打好计算机基础，良好的编程基础是程序员头三年高速进步的前提。</strong></li><li><strong>要多写代码，量变才能产生质变，尽快成长为前端团队中的顶梁柱是这个阶段的核心目标。</strong></li><li><strong>重视业务，千万不要觉得业务与自己无关，理解业务流程是工作的一部分</strong></li><li><strong>要客观的认清自己，是否真的有编程天赋？与大牛的距离有多大？避免盲目学习与努力</strong></li></ul><h2 id="技术是需求（3-5）"><a href="#技术是需求（3-5）" class="headerlink" title="技术是需求（3-5）"></a>技术是需求（3-5）</h2><blockquote><p>既然技术的最终呈现方式是业务，我直接关注业务不就好了？</p></blockquote><p>​业务的落地由多个角色协作完成，后端、ui、运营、产品、项目经理，我大学期间学习了经济学相关知识，并且对此一直很感兴趣，我选择了与前端最贴近的产品经理。同时在公司，我也走向了基层管理岗位，前端组长。</p><p>​同时我与我的上级表明我想做产品的想法，并希望在现有项目中，发挥自己的产品的作用，上级欣然应允，同时也非常鼓励我继续做下去。</p><p>​所以在这个阶段，我从原本的纯技术开发，变成了技术 + 产品 + 管理齐头并进。</p><p>​学习产品思维是一个艰难的过程，在这个阶段，我系统性的学习了NPDP国际产品经理认证课程，看了《增长黑客》《人人都是产品经理》《幕后产品》《微信背后的价值观》等一系列产品经理相关的书籍，慢慢形成了产品逻辑。</p><p>​这个阶段，我经常问自己产品方面的问题。</p><p>​为什么拼多多不做购物车？难道是因为拼多多技术能力太差吗？</p><p>​为什么美团会员规则是这样的？如何演变形成的？</p><p>​为什么双11的优惠券规则如此复杂？为什么不直接给用户优惠？</p><p>​为什么最近上线的某个需求效果很差，为什么某个功能点又非常受到大家欢迎？</p><p>​羊了个羊爆火，我会尝试去分析，为什么他可以火，他是如何做的？</p><p>​参考竞品的时候，我会去思考，为什么他这样设计？</p><p>​<strong>在如何做的基础上，我更进一步的思考了，为什么这么做？</strong>别人做得好，我会去分析，为什么他做得好，自己做的不好，我也会分析，自己为何做的不好的原因，而不是团队一起拍脑袋，或者个人主义去理解与看到需求。</p><p>​在这几年，我做过很多需求与产品，大部分需求都成功落地，并达到预期效果，但是绝大部分产品都失败了，只有零星的几个产品在某个场景下做出了效果；随着在产品方面的经验越来越多，我对需求的理解越来越准确，逐渐在团队中的产品角色站稳脚步</p><p>​</p><p>​</p><p>​如何平衡 技术与其他工作？</p><p>​如何学习产品相关知识？</p><h2 id="技术是产品（5-？）"><a href="#技术是产品（5-？）" class="headerlink" title="技术是产品（5-？）"></a>技术是产品（5-？）</h2><h2 id="技术是？"><a href="#技术是？" class="headerlink" title="技术是？"></a>技术是？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	我们小时候都听过这样的一个故事，&lt;/p&gt;
&lt;p&gt;​	为什么大家都说35岁是技术岗的危机，甚至现在还出现了更加提前的趋势，30岁危机就已经出现。在本文开始之前，我也先丢几个问题给大家，一起思考一下以下现象的原因是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件开发是否是劳动密集型行</summary>
      
    
    
    
    <category term="关于程序员" scheme="https://bluedancers.github.io/categories/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
    <category term="记录" scheme="https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(3) - 从游戏名词到电商营销，我们一起来聊聊“秒杀”</title>
    <link href="https://bluedancers.github.io/2023/10/30/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%883%EF%BC%89%20-%20%E4%BB%8E%E6%B8%B8%E6%88%8F%E5%90%8D%E8%AF%8D%E5%88%B0%E7%94%B5%E5%95%86%E8%90%A5%E9%94%80%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%81%8A%E8%81%8A%E7%A7%92%E6%9D%80/"/>
    <id>https://bluedancers.github.io/2023/10/30/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%883%EF%BC%89%20-%20%E4%BB%8E%E6%B8%B8%E6%88%8F%E5%90%8D%E8%AF%8D%E5%88%B0%E7%94%B5%E5%95%86%E8%90%A5%E9%94%80%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%81%8A%E8%81%8A%E7%A7%92%E6%9D%80/</id>
    <published>2023-10-29T16:00:00.000Z</published>
    <updated>2023-11-27T03:13:59.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史上的“秒杀”"><a href="#历史上的“秒杀”" class="headerlink" title="历史上的“秒杀”"></a>历史上的“秒杀”</h2><p>​在1980美国的11月24号，这一天是美国最重要的传统节日<strong>感恩节</strong>，我们的主角小帅一家聚会到深夜才结束，但是他们并没有休息，反而穿着厚厚的大衣，前往附近早已停止营业的沃尔玛。</p><p>​但是当小帅抵达沃尔玛的时候，门前却排上了长长的队伍，超市关门了反而门前开始排队了？</p><p>​因为明天就是<strong>黑色星期五</strong>！</p><blockquote><p>感恩节后的黑色星期五标志着圣诞购物季的开始，美国人民通常会利用这一天购买圣诞礼物或者需要的商品。</p></blockquote><p>​小帅早早来的原因是他在11月22号沃尔玛的宣传单上看到的<strong>限时限量优惠！</strong>，只要<strong>1元就可以获得一个崭新的柯比吸尘器</strong>，但是限量500个；虽然现在寒风凛冽，但是捡漏的快乐还是让小帅充满干劲，美国的11月还谈不上太冷，就这样等到11月25号的凌晨5点，沃尔玛开门了！</p><p><img src="http://qiliu.vkcyan.top/FpsVAIISf_iWj4CwNxJfNxR-7MGF.png"></p><p>​排在前面的人都是冲着限时限量商品去的，都一个劲往里挤，事后发现大门都被挤坏了。</p><p>​尽管沃尔玛出动了大量安保人员维持秩序，但是还是出现了小范围踩踏事件，我们主角小帅非常幸运的挤在队伍的前列，在丧尸一般的人潮中成功抢到了仅售1元的限量商品柯比吸尘器，当然小帅不会立刻结账走人，他还会在沃尔玛购买圣诞节礼物、自己需要的东西。</p><p>​最后付款离场，小帅心满意足回家。</p><p>​<strong>但是感恩节之后，沃尔玛决定明年不再做限时限量优惠活动了。</strong></p><h2 id="线下商超为何对“秒杀”又爱又恨？"><a href="#线下商超为何对“秒杀”又爱又恨？" class="headerlink" title="线下商超为何对“秒杀”又爱又恨？"></a>线下商超为何对“秒杀”又爱又恨？</h2><p>我们一般认为，秒杀活动存在3个主要特征，<strong>限时、限量、高值低价</strong>。</p><p>线下秒杀在大多数情况下，都会获取预期效果，并且可以达到增加销售额、增加客流量的核心目的，具体来说作用如下</p><ul><li>通过制造热点吸引潜在用户、老用户、引导到店消费。</li><li>被吸引到的用户多半会购买一些产品，增加商超的销售额</li><li>秒杀活动会增加品牌、商超自身的知名度</li></ul><p>这么看挺不错的啊，能抓到老鼠就是好猫，能完成目标就是好活动，那何来的恨呢？</p><p>虽然秒杀能带来一些用户，但是也许要付出很多显性与隐性的成本。</p><ul><li>线下商超的目标是提供广泛而优质的服务，有可预期的周边几公里顾客，并不是很需要通过秒杀低价这种”激进“的营销策略来获取用户的青睐。</li><li>由于价格便宜并且限量，而黑色星期五本身就存在庞大的人流量，会出现人员拥挤与混乱的情况，不稳定因素大大增加。</li><li>秒杀活动会导致顾客之间发生冲突与纠纷的概率大幅增加，有损商超的的形象与品牌建设。</li></ul><p>比如这样</p><p><img src="http://qiliu.vkcyan.top/FnOB7X8l9_5k8IXVfQSWV5CuNIS8.png"></p><p>还有这样</p><p><img src="http://qiliu.vkcyan.top/FtY-pyoXDvjRGseKD3awOzUA41uf.png"></p><p>而黑色星期五的人流量是这样</p><p><img src="http://qiliu.vkcyan.top/FgToytXjQTy1M3qmyZsk3mt2nqCH.png"></p><p>​</p><p>​总的来说就是<strong>线下秒杀是一把双刃剑</strong>，<strong>相对来说雨露均沾式的优惠更加适合线下商超的价值定位</strong>；商超会根据自己的营销目的，选择不同的促销方式去吸引客户。</p><p>​也正是以上的一些原因，在线下商超出现之前，秒杀一直不是非常主流的营销方式，比我们之前聊的优惠券差远了。</p><h2 id="互联网时代，”秒杀“为什么破圈了？"><a href="#互联网时代，”秒杀“为什么破圈了？" class="headerlink" title="互联网时代，”秒杀“为什么破圈了？"></a>互联网时代，”秒杀“为什么破圈了？</h2><p>​1989年发生了一件影响人类历史进程的事情：由美国国家科学基金会推动的商业互联网正式成立，互联网开始走向大众。</p><p>​亚马逊为代表的电子商务公司开始兴起。2004年亚马逊推出了一项叫做<strong>Gold Box</strong>的业务，专门提供各种产品的打折促销和限时特惠。</p><p>​该功能一上线，取得了非常好的的效果，手机上点点就可以花少量的钱购买想要的产品，消费者对此类限时限量优惠的商品自然是很有兴趣，线上秒杀也开始被更多人注意到，<strong>Gold Box</strong>类型的营销方式开始电子商务领域被使用。</p><p>​我们考虑一下线上秒杀相对于线下秒杀有什么优势？解决了以前的什么问题？为什么线下不温不火的秒杀业务，到了线上就成了常见的营销方式？</p><p>​我们先分析一下线下秒杀的痛点到底是什么。</p><p>​<strong>用户参与秒杀的成本高</strong></p><p>​对于用户而言，提前一晚上到超市门口排队，抢到了还好，要是没抢到直接破防，这要是有啥烦心事，做出过激举动，身边人都遭殃。</p><p>​<strong>对于大型商超来说，成本可能大于收益</strong></p><p>​面对线下秒杀这样的活动，一方面商家需要增加额外的人力，另一方面还存在不可控的风险，比如损伤商超形象、影响顾客消费，等等一系列问题，除了新店开业需要快速拉新，稳定期间的经营者一定会慎重选择该营销策略。</p><p>​而且大型线下商超是存在<strong>区域性</strong>，比如在你家距离2公里处有一个沃尔玛，距离第二的超市可能就是5公里以上，你几乎不可能来回多跑6公里去距离更远的超市。而站在商超的视角看，除了特殊的开业阶段，应该多做老客户的维护，培养用户习惯。</p><p>​而互联网的出现，几乎弥补了以上所有痛点。</p><p>​<strong>用户参与门槛极低</strong></p><p>​在手机上就可以秒杀抢购，足不出户，就算抢不到，无非就是吐槽有内幕，付出的成本微乎其微。</p><p>​<strong>对于电子商务来说，收益大概率大于成本</strong></p><p>​相较于线下秒杀，线上开展这样的活动，主要成本在研发，用的辐射的人越多<strong>边际会成本越低</strong>，只要提前考虑到可能的意外情况，加上优质的运营方案，几乎不存在风险。</p><p>​另外，不同于线下商超固定的辐射圈，电子商务<strong>不存在物理空间的限制</strong>，这就意味着理论上网络上的任何一个人都是潜在用户，这样的前提下，平台的增长潜力是极大的，上升期也是极长的，秒杀这样吸引眼球的活动就成了一个非常不错的选择。</p><p>​<strong>那线上秒杀有什么缺点呢？</strong></p><p>​存在技术难度，瞬间巨量的访问，会直接让服务器宕机，相信经历过早期国内双11的用户都深有体会，而伴随秒杀业务的火热，一系列的技术方案都火起来了，所以技术难度也随着生态的完善而降低。</p><p>​亚马逊的秒杀业务在2000年左右开始发展壮大，除了日常折扣和限时促销的<strong>Gold Box</strong>之外，还细分出了<strong>Lightning Deals（闪电交易）、Deal OF The Day（团购）、7-day Deals（7天优惠）</strong>，等等针对不同类型商品的秒杀活动，直到现在，相关业务依旧是亚马逊促销策略中重要的一环。</p><p>​相比于线下秒杀，线上秒杀只能说是：<strong>优雅，实在是太优雅了！</strong></p><p><img src="http://qiliu.vkcyan.top/FmWevXBSpQZGxXVCFA7xhqEY_oBR.png"></p><p>​</p><h2 id="国内为什么叫“秒杀”？"><a href="#国内为什么叫“秒杀”？" class="headerlink" title="国内为什么叫“秒杀”？"></a>国内为什么叫“秒杀”？</h2><p>​不知道大家注意到没有，我们上面谈论了很多秒杀，都是打引号的，国外这种模式不叫秒杀，电商领域的”秒杀“是一个本土词汇。</p><p>​<strong>以前的人怎么想到这个名字的？</strong>，为啥不叫限时抢购？</p><p>​秒杀这个词在电商之前高频出现在竞技、游戏中，在国内电商兴起的同时，网游也在蓬勃发展，众多RPG游戏进入中国市场，比如大名鼎鼎的《红月》；大概就是看起来像<strong>是兄弟就来砍我、一刀999</strong>的游戏。</p><p><img src="http://qiliu.vkcyan.top/FheXDA7WVgXxyPH_MIaJVsvxBCm4.png"></p><p>​这个游戏可以升级到1000级，每次升级会给技能点，有些玩家将这些技能点全部加到攻击上，几百级之后，就会出现极其脆弱的身板 + 极其变态的攻击力，要么自己秒死，要么对方秒死，玩的就是心跳。</p><p>​秒杀一词也慢慢在社区流行起来，而玩游戏的多半是年轻人，这部分年轻人与电商领域从业者产生交叉，电商从业者目睹限时限价低价商品在电商平台瞬间抢购一空，发出了惊呼：”<strong>一下子就没了，就秒了！</strong>“。</p><p>​这时候人们转念一想，抢购没有体现极致的速度与紧迫感，哎！<strong>秒杀</strong>这个词很不错，商品直接售空，与游戏中的血条消失场景非常类似。</p><p>​有了这样的先例后，<strong>9.9秒杀、限时秒杀，京东秒杀、秒杀专区、老板娘生日，全场秒杀</strong>….在电商领域犹如雨后春笋般出现，直到现在几乎成了电商平台的专用名词。</p><p>​</p><h2 id="从专业角度看，人们为何喜爱秒杀"><a href="#从专业角度看，人们为何喜爱秒杀" class="headerlink" title="从专业角度看，人们为何喜爱秒杀"></a>从专业角度看，人们为何喜爱秒杀</h2><p>​可能会有小伙伴说了，这个问题很简单，因为大家都喜欢物超所值！其实不仅仅是简单的价格对比，限时限量抢购活动能够被人类选择，是有他的底层逻辑的。</p><p>​<strong>收益不最大化（商家）</strong>：在秒杀的场景下，用户支付比心里预期更低的价格就可以获得商品，用户会自发性的通过已知渠道进入秒杀活动中，而目标用户的参与动机，与需要支付的金额数量成反比，对于商家来说，秒杀场景下收益肯定不最大化的，这也是秒杀的显性成本。</p><img src="http://qiliu.vkcyan.top/FuriXSVGpvjd68sn5RaNT3-gr6Xo.png" style="zoom:33%;" /><p>​<strong>厌恶损失</strong>：根据科学验证，失去的痛苦是的得到的快乐的2倍以上，丢掉100元的痛苦远高于捡到100元的快乐，人们聪明的脑瓜自然能推理出，如果不通过此刻稀缺的秒杀活动购买到商品，后续多支付的部分金额，就是我的损失，则会进一步强化用户参与秒杀的动机</p><p>​<strong>稀缺效应</strong>：秒杀的特征，都是在加强稀缺这一点，限时、限量、高值低价，用户对稀缺的感知直线上升，从而增加购买的兴奋度与成就感。</p><p>​<strong>从众效应</strong>：我们想象一个场景，你的面前有2家超市，一家门可罗雀，一家人人潮汹涌，你会选择哪一家店？我相信绝大多数人都会无意识的认为，人多的肯定好，其实秒杀的场景也是这样，只是换了舞台，从线下变成了互联网上，如果秒杀活动可以在一个圈子中被炫耀、宣传，人们就会被这种“火热场景”所“迷惑”。</p><h2 id="秒杀的目是什么？"><a href="#秒杀的目是什么？" class="headerlink" title="秒杀的目是什么？"></a>秒杀的目是什么？</h2><p>​聊了这么多，我们还是要回到最关键的问题上。</p><p>​为什么要秒杀，我们的目的是啥？线上秒杀与几十年前的线下秒杀还是一个东西吗？</p><p>​我们先看线下商超做秒杀的目的是什么？</p><p>​<strong>用限时限量低价把用户吸引过来，然后为用户提供消费空间，并让更多用户了解与记住产品。</strong></p><p>​几十年前线下秒杀受到现实世界的限制，无法发挥全部实力，而有了互联网加持之后，弥补了现实世界的缺陷，<strong>秒杀进化为完全体状态</strong>，其核心目的没有根本变化；</p><p>​很多新人产品只理解了前半句话，把用户吸引过来，让用户参与”秒杀“，人气确实吸引过来了，但是人家只秒杀，花钱赚吆喝，就是不挣钱，甚至羊毛党越来越多。</p><p>​线上商城不像线下商超，用户来线下商超参与秒杀活动，来都来了，大概率会消费，线上则不是这样，无论用户是否”秒杀“成功，没兴趣了会直接右划走人，这就达不到开展秒杀活动的目的了。</p><p>​所以线上秒杀的运营目的并非秒杀活动进行状态，而是<strong>秒杀活动开始前后的活动运营，以及产品的曝光与留存</strong>。</p><p>​<strong>等待秒杀的用户运营</strong></p><p>​店铺付出较高成本开展秒杀活动，吸引来的新老用户都是极其宝贵的，如何引导这些用户转化为店铺的忠实用户，如何引导用户增强与店铺的粘性都是极其重要的，在这段时间可以做的事情很多，社交互动、相关营销活动曝光、强化品牌价值等等；只要能加强与用户的粘性，用户强化用户认知的目的，营销方案的形态都是可以畅想的。</p><p>​<strong>秒杀之后的用户运营</strong></p><p>​秒杀之后有些用户抢到了，有些用户没抢到，抢到的用户必然会增加对店铺的信任，我们再引导用户多下单，并在下单过程中继续曝光产品能力，比如签到、会员、让用户发自内心的认可产品；</p><p>​而没抢到的用户呢？我们也不能白白浪费宝贵的流量，时刻记住我们秒杀的目的。</p><p>​猜测一下”秒杀“失败用户的心理，可能还对抢到抱有一丝希望，是否还有下一波?是否可以捡漏？这时候我们是否可以提示用户，没抢到没关系，预约下一次的秒杀，还有机会抢！或者贴出其他相对优惠的非秒杀的商品，来安慰用户；总之就是拉升用户的心情曲线，给予用户继续操作的空间，也是将用户留存下来。</p><p>​所以秒杀并不是简单的低价抢购，短期吸引巨量人气的活动，因为如果没有合理的运营策略，最后陷入只能花钱赚吆喝的虚假繁荣之中。</p><h2 id="一定是秒杀吗"><a href="#一定是秒杀吗" class="headerlink" title="一定是秒杀吗?"></a>一定是秒杀吗?</h2><p>​我们纵观人类发展史，无论是工业革命时代的路边小卖部，还是信息化时代的全球电商平台，总有时代的先驱者找到了当下时代的技术与底层逻辑的结合，归根结底其实研究的还是是<strong>人与组织、交易</strong>。</p><p>​互联网秒杀此类业务模式的出现是在特定历史阶段的产物，而我们真正要关注的是此类活动的底层逻辑以及我们的营销目的，最终以什么样的形态展示到用户面前，一定不是永恒不变的，<strong>秒杀是手段，不是目的</strong>。而在高速发展的当下，已经有了相对于传统秒杀更加有效的活动模式，以及电商突破物理限制后，能够触达的新业态。</p><p>​<strong>万变不离其宗</strong>，了解消费者，了解底层逻辑，与自身资源有机结合，形成可落地的面向用户的活动形式，最后落地的一定是秒杀吗？我想一定不是的。</p><p>​谢谢朋友们的观看，我是懂点技术的saas电商产品经理狗阿木，如果您觉得我的文章对您有帮助，记得点赞关注~</p><p>​</p><p>参考资料</p><p><a href="https://www.163.com/dy/article/GJ7AQT7E0526D7OK.html">曾将中文带火的韩国网游，却被自己搞凉，15年后又想复活捞一笔？</a></p><p><a href="https://www.itsiwei.com/2434.html">“秒杀起源”，电商年代告诉你什么是真正的秒杀</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;历史上的“秒杀”&quot;&gt;&lt;a href=&quot;#历史上的“秒杀”&quot; class=&quot;headerlink&quot; title=&quot;历史上的“秒杀”&quot;&gt;&lt;/a&gt;历史上的“秒杀”&lt;/h2&gt;&lt;p&gt;​	在1980美国的11月24号，这一天是美国最重要的传统节日&lt;strong&gt;感恩节&lt;/st</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="秒杀" scheme="https://bluedancers.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(2) - 细致解读,Saas商城必备的优惠券产品设计攻略</title>
    <link href="https://bluedancers.github.io/2023/10/20/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89%20-%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91/"/>
    <id>https://bluedancers.github.io/2023/10/20/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89%20-%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91/</id>
    <published>2023-10-19T16:00:00.000Z</published>
    <updated>2023-11-27T03:12:56.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​在上一篇文章中，我们了解了优惠券的起源，以及随着互联网的出现，优惠券的能力进一步被挖掘的发展历程；今天直接上干货，聊一聊<strong>Saas商城系统的优惠券产品逻辑究竟要如何设计</strong>。</p><h2 id="优惠券的框架设计"><a href="#优惠券的框架设计" class="headerlink" title="优惠券的框架设计"></a>优惠券的框架设计</h2><p>优惠券的生命周期如下</p><p><img src="http://qiliu.vkcyan.top/FtAcMuNyjljceuzGB871e9Zp3Xra.png"></p><p>我们的优惠券设计的目的，也就是解决生命周期每个环节的问题。</p><ol><li>店铺如何发布优惠券？</li><li>店铺中的用户如何领取到优惠券？</li><li>领取到优惠券的用户如何使用优惠券？</li><li>店铺通过那些维度去复盘优惠券的效果？</li></ol><p>​其中的问题1、2是放在一起考虑的，发布优惠券的时候，我们不仅需要考虑优惠券的基本信息，也需要<strong>提前思考优惠券通过什么渠道发放到目标用户手中</strong>。</p><p>​我们首先聚焦于发布优惠券的产品逻辑。</p><h2 id="发放优惠券"><a href="#发放优惠券" class="headerlink" title="发放优惠券"></a>发放优惠券</h2><p>发布优惠券中我们可以将其分为2个大类，<strong>基础设置</strong>与<strong>发放规则</strong>。</p><p>​<strong>基础设置</strong>包含优惠券名称、优惠券类型、发放数量，等的优惠券的基本信息，这样的<strong>基本信息在任何商城几乎都是通用的。</strong></p><p>​<strong>发放规则</strong>是发放渠道、定向发放、发布平台、领取限制，等等平台独特的，<strong>配合运营而存在的设置。</strong></p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>  <img src="http://qiliu.vkcyan.top/FtT9pjaAgxFwEuuCX-Omr6HCu-4l.png"></p><p>​这部分产品逻辑无论哪一家的saas都是大同小异的，都是对<strong>现实优惠券的抽象</strong>。</p><p>​有的saas系统中，将优惠券的设置单独抽出来，叫做<strong>优惠券模板</strong>，其产品流程为，首先发布优惠券模板，然后发布优惠券的时候再选择模板，随后设置发放规则，才算发放成功，比如微盟；</p><p>​绝大部分saas都没有这样做的必要，因为如果不是极其复杂的产品，过于细化产品逻辑，反而增加了技术、运营的使用难度。</p><h4 id="券名称（用户见）-券名称（店铺见）"><a href="#券名称（用户见）-券名称（店铺见）" class="headerlink" title="券名称（用户见） + 券名称（店铺见）"></a>券名称（用户见） + 券名称（店铺见）</h4><p>​券名称不仅需要设置用户可见的优惠券名称，还需要设置后台独有的优惠券名称</p><p>​为什么存在这样一个字段呢？</p><p>​因为<strong>同名称 + 规格的优惠券可能被发布在不同的渠道</strong>，如果不存在字段在后台进行区分，店铺运营人员就无法通过用户见的优惠券名称快速区分同名优惠券的具体渠道；</p><p>​<strong>为了满足运营人员快速区分渠道的目的，系统内部就需要针对优惠券增加一个内部可见的名字</strong></p><p>​也许有小伙伴会说，将不同的渠道信息写到优惠券备注里面不就好了，这样确实可以，但是优惠券备注字段一般是不支持搜索的，这就需要运营人员手动筛选，所以店铺见的券名称字段是非常有必要的。</p><p>​<strong>这2个字段在优惠券列表页面都需要支持搜索。</strong></p><h4 id="优惠券类型"><a href="#优惠券类型" class="headerlink" title="优惠券类型"></a>优惠券类型</h4><p>​尽管优惠金额千变万化，我们始终可以用满减券、折扣券这2个抽象纬度进行归纳；当然虽然场景的精细化，还可以衍生出更加细分的优惠券类型，我们先说通用的。</p><p>​折扣券除了设置<strong>具体折扣</strong>之外，一般还要设置<strong>门槛</strong>与<strong>优惠上限</strong>，我们归纳一下，一般这样设置</p><ul><li><strong>优惠内容</strong><ul><li>满xx元，打xx折</li><li>无门槛，打xx折</li></ul></li><li><strong>优惠上限</strong><ul><li>无优惠上限</li><li>最多优惠xx元</li></ul></li></ul><p>满减券的逻辑和折扣券类似，不过满减券已经设置了具体的优惠金额，所以不再需要设置优惠上限，一般存在以下设置</p><ul><li><strong>优惠内容</strong></li><li>满xx元，减xx元</li><li>无门槛，减xx元</li></ul><p>​以上2种类型几乎包含了<strong>通用saas商城90%以上的应用场景</strong>，所以如果不是非常重视用户运营，或者行业需要，增加额外的优惠券类型是不划算的。</p><p>​趣味性的包含<strong>随机金额券</strong>，则需要设置随机区间、<strong>商品兑换券</strong>，需要设置指定商品、<strong>买一送一券</strong>、<strong>赠品券</strong>，此类优惠券使用频率与场景相对低频，所有在开发优先级上，需要慎重考虑。</p><h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><p>​回想一下，我们拿到的线下优惠券，是不是基本都会指定单品或者指定类目，这样指定优惠范围的逻辑在saas商城系统的发布优惠券中是不可或缺的，一般应用范围存在以下几种纬度。</p><p><strong>指定商品、指定类目、指定供货商、全场通用</strong></p><p>注意一点，这里的指定都是可以指定多个的，并非只能指定一个，比如指定多个商品、指定多个类目。</p><p>另外就是关于全场通用，这个选项saas商城谨慎添加，因为该应用范围存在以下特点</p><ol><li>应用范围太大</li><li>同时使用频率不高</li><li>全场通用券容易被撸羊毛，偏离效果预期</li><li>一旦运营人员点错，后果不堪设想</li></ol><p>​所以如果全场通用类型优惠券在业务上不是必要的，则不进行添加。</p><h4 id="发放数量"><a href="#发放数量" class="headerlink" title="发放数量"></a>发放数量</h4><p>​这就是指优惠券具体的发放数量。</p><p>​要注意的是，发放数量在编辑的时候，一般只能添加，不允许减少，这是因为减少优惠券可能导致已领取的优惠券数量超出实际库存，也会对系统的稳定性造成风险。</p><h4 id="有效期与活动时间"><a href="#有效期与活动时间" class="headerlink" title="有效期与活动时间"></a>有效期与活动时间</h4><p>​在店铺后台发券的时候可以指定优惠券可使用时间，一般存在2种类型</p><ul><li><strong>用券时间</strong><ul><li>指定用券时间范围，比如指定xxxx - xxxx时间段可用</li><li>指定领券后有效期，比如领券后x天内有效</li></ul></li><li><strong>活动时间</strong><ul><li>执行之间端，优惠券是</li></ul></li></ul><p>​用券时间的限制，大家都比较好理解，存在时间限制的券，会增加用户的使用动机，存在有效期的优惠券也降低了程序的运行负担。</p><p>​而活动时间，我调研多数竞品看是不存在的，而我站在店铺运营者的角度来看，觉得这个字段是有存在的必要的。</p><p>​我们可以想象一个场景，在春节节假日期间运营需要发布了一张全场优惠券，用户领券后，30天内可用，春节之后无法领券。如果不存在活动时间，运营人员就需要在春节节假日结束的时候手动关闭优惠券，或者活动入口。</p><p>​这样的事情，完全可以交给程序完成，就是增加活动时间的概念。</p><p>​还有一点需要注意的是，当活动时间小于优惠券的使用时间的时候，优惠券不会随着活动时间的过期而过期，而是按照自己的使用有效期规则。</p><p>​到此为止，我们的发布优惠券的基础模块就完成了，这一部分的产品设计是比较简单的，大部分的产品逻辑都是类似的，无论是参考竞品，还是自行设计，最终都会走向类似的终点，将尽力聚焦于商家运营需求，或者用户需求才是重点；</p><h3 id="基础设置的示例图"><a href="#基础设置的示例图" class="headerlink" title="基础设置的示例图"></a>基础设置的示例图</h3><p><img src="http://qiliu.vkcyan.top/FvGjr5XHiv-c4_YuTqAV4SZkHHNo.png"></p><p>​完成了如何发布优惠券，下一步，我们就要看看用户如何获得优惠券。</p><h3 id="发放规则"><a href="#发放规则" class="headerlink" title="发放规则"></a>发放规则</h3><p><img src="http://qiliu.vkcyan.top/FjIjbcXN74Jae5Ahy4rT7aKB0Mgj.png"></p><h4 id="发放渠道（重点）"><a href="#发放渠道（重点）" class="headerlink" title="发放渠道（重点）"></a>发放渠道（重点）</h4><p>​我们可以想象一下，在我们的日常生活中，有多少种途径可以完成领券动作</p><ul><li>在商品详情页领券。</li><li>在社群中的优惠券链接完成领券。</li><li>在线下海报完成领券。</li><li>通过特定的卡密兑换优惠券。</li><li>在签到、抽奖活动中获取优惠券。</li><li>….</li></ul><p>​我们可以想到很多很多领券的途径，在我们发布优惠券的时候，需要控制优惠券可以在什么渠道被领取，如果没有渠道的概念，原本打算发给社群的优惠券，在商城类就可以领取，券就会被截胡了；后期的数据统计也无法细分查看不同渠道的转化率。</p><p>​另外优惠券有了渠道的区分，即使是同样规格的优惠券，在后期的优惠券数据统计上，也可以<strong>看到不同渠道的效果如何</strong>，总之，优惠券渠道的区分对于店铺运营来说都有很重要的意义。</p><p>​一般存在什么样的发放渠道呢？</p><h5 id="商城渠道"><a href="#商城渠道" class="headerlink" title="商城渠道"></a>商城渠道</h5><p>​用户可在商城内的优惠券集合页面、可用商品的商品详情页面领取优惠券</p><h5 id="手工渠道"><a href="#手工渠道" class="headerlink" title="手工渠道"></a>手工渠道</h5><p>​一般用于客服为用户补发优惠券，用户无法手动领取。</p><h5 id="外部渠道"><a href="#外部渠道" class="headerlink" title="外部渠道"></a>外部渠道</h5><p>​运营可以<strong>导出可兑换优惠券的券码</strong>，并分配给第三方，第三方的用户通过兑换、购买等等方式获取到指定券码，最后按照活动提示，回到商城中，将兑换码兑换成可使用的优惠券；一般用于异业合作。</p><blockquote><p>以上3个渠道为基本渠道，几乎每个saas商城都存在的，而下面的渠道则和具体的业务绑定，属于个性化的渠道</p></blockquote><h5 id="券包渠道"><a href="#券包渠道" class="headerlink" title="券包渠道"></a>券包渠道</h5><p>​券包渠道优惠券无法直接被用户领取，而是需要运营人员在后台的券包管理模块，选择多个该渠道的优惠券，发布成一个券包，用户再通过指定渠道、或者首页弹窗，领取券包，自动获取券包中的所有优惠券。</p><h5 id="抽奖渠道"><a href="#抽奖渠道" class="headerlink" title="抽奖渠道"></a>抽奖渠道</h5><p>​发布在抽奖渠道的优惠券，可以在发布抽奖活动的配置中，配置指定优惠券，用户即可通过抽奖获得该优惠券。</p><h5 id="签到渠道"><a href="#签到渠道" class="headerlink" title="签到渠道"></a>签到渠道</h5><p>​发布在签到渠道的优惠券，可以在发布签到活动的配置中，配置指定优惠券，用户即可通过指定的签到天数获取该优惠券。</p><h5 id="标签渠道"><a href="#标签渠道" class="headerlink" title="标签渠道"></a>标签渠道</h5><p>​发布在标签渠道的优惠券，可以在标签管理中配置指定优惠券，用户达成某种条件，自动获得标签的时候，也就会自动获取优惠券。</p><p>​自动标签可以有效的完成用户精细化运营的需求，我文中所写的方式是，先发券，再去标签管理中进行绑定，<strong>如果精细化运营要求比较高，可以在发布优惠券的时候就指定标签，这样操作上更加直观</strong>。</p><p>​关于 券包、抽奖、签到、标签与活动运营存在强关联的优惠券渠道，如果对运营不存在精细化的需求，可以不在进行划分，统称为<strong>自动渠道</strong>。</p><p>​细分的渠道虽然可以让系统更加稳健，让后期的统计更加简单直观，但是也不是没有缺点，增加了实际运营的理解难度，也增加了操作步骤，所以<strong>到底是精细化还是简单直观，需要根据自己的产品特性进行判断</strong>。</p><h4 id="领取限制"><a href="#领取限制" class="headerlink" title="领取限制"></a>领取限制</h4><p>​券的数量是有限的，一个用户可消费的量也是有限的，如果不对券的领取加一限制，会造成券的浪费，也会造成潜在订单的流失，所以发放优惠券的领取限制是很有必要的</p><p>​领取限制一般存在以下几种</p><ul><li>不限次数</li><li>每人限制x次</li><li>每人每天限制x次</li><li>每人每月限制x次</li></ul><p>​领取限制并非一成不变的，究竟是什么样的领取限制，在设计产品的时候，我们需要根据服务对象的需求来决定。</p><h4 id="领取与使用平台"><a href="#领取与使用平台" class="headerlink" title="领取与使用平台"></a>领取与使用平台</h4><p>​很多saas商城不仅支持微信小程序，可能还支持h5、微信公众号、xx小程序，等等。</p><p>​首先，不同平台的运营规则是不一样的，比如虚拟类商品就不允许在小程序中进行售卖，那么虚拟类商品的优惠券就不可以在微信小程序中被领取与使用；或者某些运营需求，我们希望用户在指定渠道领取与使用，这些运营需求的实现都需要再发布优惠券的时候限制领取与使用平台。</p><h4 id="是否加入微信券包"><a href="#是否加入微信券包" class="headerlink" title="是否加入微信券包"></a>是否加入微信券包</h4><p>​如果saas商城支持微信公众号、微信小程序，我们的ToC的商城用到微信的鉴权能力，技术上就没有阻碍了。</p><p>​开启该功能后，用户在商城中完成领券的时候，我们也可以将券<strong>加入到用户的微信券包</strong>，加入微信券包的券存在过期提醒，可以快过期的时候<strong>二次唤醒用户</strong>，也可以通过优惠券直达商城，是不错的功能。</p><p>​不过要注意的是，加入微信券包的券，尽量是高价值的，低价值的优惠券无法引起用户的兴趣，快过期了再提示用户使用，会加剧用户的反感，甚至导致用户的投诉，所以该功能也需要慎重使用。</p><p><img src="http://qiliu.vkcyan.top/FoD4PbIDLgrVTZs-O8FHiRC1742Z.png"></p><h2 id="外部优惠券的发放逻辑"><a href="#外部优惠券的发放逻辑" class="headerlink" title="外部优惠券的发放逻辑"></a>外部优惠券的发放逻辑</h2><p>​在上述优惠券发放渠道中，存在一个比较特殊的优惠券渠道，就是我们的外部渠道，外部渠道的券，是我们发放给第三方产品，或者公开区域，用户无法在站内获取的优惠券。</p><p>​因为站内无法获取，则需要我们导出券码，让用户可通过站外渠道进行领取，<strong>所有我们的后台需要支持导出优惠券的功能</strong>。</p><p>​为了更好的运营效果，优惠券也不是一股脑全部导出的，因为可能存在多个外部渠道，A渠道需要1000张，b渠道需要2000张，不能让运营人员去手动拆分做这种工作，所以<strong>我们需要先生成指定渠道，再导出优惠券。</strong></p><p>​外部优惠券在优惠券列表表格中会多出2个按钮，第一个是<strong>生成</strong>，第二个是<strong>导出</strong>。</p><p>​假设我发布了10000张优惠券，分别导出给A、B、C渠道，则发布完成后，点击生成，生成的时候填写<strong>生成数量、导出渠道</strong>，完成指定渠道的外部优惠券的生成，B、C同理。</p><p>​外部优惠券生成完成后，再点击导出，<strong>再选择上一步声明的指定渠道</strong>，即可导出指定渠道的所有优惠券兑换码，同时还可以在导出时设置券码状态，未领取、未使用、已使用或者全部，针对性导出。</p><p>​最后，我们将导出的csv文件，给到第三方的外部渠即可。</p><p>​到此为止，我们发放优惠券的全部功能就梳理完成了。</p><h2 id="用户使用优惠券"><a href="#用户使用优惠券" class="headerlink" title="用户使用优惠券"></a>用户使用优惠券</h2><p>​在C端用户使用优惠券的逻辑就非常简单了，为了更好的用户体验，领券页面到下单的产品路径一定是越短越好，一般存在如下特征</p><ul><li>商城内存在一个“我的优惠券”页面，我的优惠券页面需要有<strong>券码兑换功能</strong>，方便用户兑换发放出去的外部优惠券</li><li>如果优惠券是指定单商品，点击使用优惠券，则直接进入指定单商品，如果是多商品可用，则进入一个可用商品集合页面，<strong>确保最短产品路径</strong>。</li><li>在最终下单环节，自动帮助用户选择最便宜的优惠券，同时为用户提供切换可用优惠券的产品功能。</li></ul><p>关于ToC的产品逻辑可参考竞品非常多，也不是本文的重点，所以这里就不做过多赘述了。</p><h2 id="优惠券效果复盘"><a href="#优惠券效果复盘" class="headerlink" title="优惠券效果复盘"></a>优惠券效果复盘</h2><p>​每当我们的优惠券活动结束后，并且用户的券已经全部被使用，或者失效，我们便可以根据优惠券的多维数据建立漏斗模型。</p><p>​<strong>发券数量 - 领券数量 - 使用数量</strong></p><p>​另外还有<strong>优惠券成本、优惠券支付金额、优惠券新老用户数</strong>，等等偏向于业务维度的数据统计。</p><p>​假设数据分析发现，大量用户没有领券，我们则需要反思我们渠道是否存在问题，导致优惠券的曝光不足。</p><p>​亦或者领取到使用的转化低于预期，我们则需要考虑，领券用户是否对商品不感兴趣，或者券的价值过小，最终导致用户领券，但没有足够的下单动机。</p><p>​总之，在领券与使用2个环节的转化漏斗结合用户画像，以及渠道的，等相关影响因素，可以分析出一些宝贵的结论，再反哺下一次的优惠券营销活动。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​优惠券作为saas电商系统最常见的营销活动，在用户的拉新、促活、转化，等多个维度都可以发挥作用，是作用极大的，贯穿整个系统的功能，所以各位产品，一定要思考用户的需求，慎重做产品决策，构建出操作便捷、功能强大的优惠券模块。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	在上一篇文章中，我们了解了优惠券的起源，以及随着互联网的出现，优惠券的能力进一步被挖掘的发展历程；今天直接上干货，聊一聊&lt;strong&gt;</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="优惠券" scheme="https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(1) - 人人都爱用的优惠券，背后逻辑竟然这么复杂？</title>
    <link href="https://bluedancers.github.io/2023/09/29/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%881%EF%BC%89%20-%20%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%88%B1%E7%94%A8%E7%9A%84%E4%BC%98%E6%83%A0%E5%88%B8%EF%BC%8C%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F/"/>
    <id>https://bluedancers.github.io/2023/09/29/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%881%EF%BC%89%20-%20%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%88%B1%E7%94%A8%E7%9A%84%E4%BC%98%E6%83%A0%E5%88%B8%EF%BC%8C%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-11-27T03:03:54.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="带着问题思考"><a href="#带着问题思考" class="headerlink" title="带着问题思考"></a>带着问题思考</h2><ol><li>为什么淘宝要把优惠券规则设计的那么复杂？</li><li>为什么不直接降低价格，而是使用优惠券才可以优惠?</li><li>商家发放优惠券的目的究竟是什么？</li><li>为什么公司就算被消费者唾弃，也要大数据杀熟。</li></ol><p><strong>看完这篇文章，你将理解以上这些令人费解的事情。</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​最近负责的Saas商城系统中的优惠券模块开始重构，借此机会作者也打算深入学习与理解优惠券，了解优惠券的前世今生，为后续的产品功能设计环节做好知识储备，避免浅尝辄止的借鉴竞品。</p><p>​让我们搭乘时光机，先回到工业革命时代，看看优惠券是如何“诞生”与“破圈”的，成为人们生活中的一部分。</p><h2 id="时间的齿轮开始转动"><a href="#时间的齿轮开始转动" class="headerlink" title="时间的齿轮开始转动"></a>时间的齿轮开始转动</h2><blockquote><p>​根据广告学中目前公认的说法，全世界首张优惠券是美国著名广告文案撰写人<strong>克劳德.霍普金斯</strong>发明的，他为一款炼乳产品在报纸上设计了一张优惠券，消费者撕下报纸的优惠券，再凭借优惠券去购物便可以享受到优惠。</p></blockquote><p>​19世纪中后期，美国工业革命走向巅峰，随着工业化的兴起与城市化的快速发展，商店、百货公司的数量开始高速增加，购物流程上已经开始现代化，从早期的顾客将想要的商品告知店员，店员将商品从货架拿到顾客手中，演变成了<strong>自助选购模式</strong>。</p><p>​商店数量的增加以及早期供应链的完善，产品与服务开始同质化，竞争也随之变得越发激烈，百货公司与百货公司、品牌与品牌之间逐渐开始相互内卷；</p><p>​在19世纪后期，广告成本非常低廉，主要有以下原因</p><ol><li>由于科技水平的限制，广告多为报纸、海报，广告覆盖与传播的范围有限</li><li>19世纪后期并不是信息过载的时代，竞争不算激烈，消费者对广告的接受度较高。</li><li>电子印刷术进入普及阶段，同时简单的文字与配图被被用户广泛接受，制作成本低。</li><li>没有广告法的限制，进一步降低广告的制作成本</li></ol><p>​而一部分人已经看到了营销对产品的巨大影响，大批企业开始肆无忌惮的投放广告，巨幅墙体海报、有轨电车海报、报纸、促销宣传单，广告开始越来越多的，以各种各样的形式出现在大家的生活中，还有公开分发优惠券以及在用户消费后赠送固定折扣券的行为；</p><p>​不过19世纪末期，整个市场仍处于增量阶段，所以那时宣传依旧具有良好的效果，优惠券这样的营销方式还没有引起大家足够的注意。</p><p>​到这里，我们没法不谈谈这个世界上最伟大的公司之一Coca Cola，根据互联网现存资料的主流声音，优惠券模式通过可口可乐完成被更多人所了解。</p><p>​同样在19世纪末期，可口可乐的营销负责人非常相信广告曝光的巨大价值，他采用各种平面海报、免费饮品券的方式，来开展可口可乐的营销工作，后续靠产品的上瘾性形成复购（上瘾是因为那时候的可口可乐里面含有可卡因）。</p><p>​<strong>当时谁也没想到，那时候不受待见的免费饮品券综合下来竟然是效果最好的</strong>，因为早期彭伯顿（coca cola创始人）认为免费券不挣钱了，因为可口可乐的上瘾性，用户侧反映出极高复购率，<strong>让彭伯顿不禁相信，专业的事情还是应该专业的人来做</strong>。</p><p>​<strong>于是免费饮品券开始被大力使用，甚至通过邮寄的方式直接送到你家门口</strong>，优惠券玩法第一次出圈，当然可口可乐的成功是非常复杂的，优惠券仅仅是一段小小的佳话。</p><p>​非常幸运的是，这样的一张优惠券，目前在互联网上依旧可以找到</p><img src="http://qiliu.vkcyan.top/FutIDma1qVyyN0KukUeRmIJOv4AM.png" style="zoom:90%;" /><p>this card entitles you to one glass of free coca cola at the fountain of any dispense of genuine coca cola</p><p>图片的中文是：<strong>这张卡可以让您在任何出售真正可口可乐的饮料机处免费领取一杯可口可乐。</strong></p><p>我们来简单分析一下，coca cola免费饮品券发挥的作用是什么，或者说传统优惠券有何作用？</p><ol><li>极大降低用户的首次消费门槛，用户面对折扣与免费的优惠，倾向于立即行动，可快速刺激销量。</li><li>创新与新颖性，免费优惠券是新颖的概念，用户收到免费优惠券后，会存在兴趣与好奇心。</li></ol><p>其实除此之外，传统优惠券还有以下作用</p><ol><li>增加品牌忠诚度，用户通过优惠券获取额外的价值的时候，会对品牌产生积极的情感。</li><li>清除库存与滞销商品，通过该优惠券的方式来达到快速周转的目的。</li></ol><p>​<strong>总的来说，传统优惠券就一个点：无套路！真的优惠了！</strong></p><p>​虽然初代优惠券的方式很原始，但是<strong>已经符合大部分人对优惠券的认知了</strong>，而在美国19世纪前中期的大萧条阶段，消费者为了省钱，经常会收集各种优惠券，优惠券进一步受到用户的青睐。</p><p>​在后来的几十年中，互联网时代来临之前，优惠券早已被大众广泛接受，不过其核心玩法和概念没有变化，只不过是表现形式上会变的更加新颖，<strong>产品描述、售价</strong>依旧是重点、如果是免费的会写一个大大的<strong>FREE</strong>。</p><h2 id="在互联网时代优惠券发生变化了吗？"><a href="#在互联网时代优惠券发生变化了吗？" class="headerlink" title="在互联网时代优惠券发生变化了吗？"></a>在互联网时代优惠券发生变化了吗？</h2><p>​当我们了解了优惠券的历史后，现在让我们搭乘时光机器回到互联网时代，看看100多年后的出现的电子优惠券有何变化。</p><p>​<strong>先说结论：互联网的电子优惠券玩法相对传统优惠券是颠覆式的改变</strong></p><p>​到底改变了什么？我先卖个关子，这100年间发生了太多改变人类事情，所以在讲电子优惠券之前，我们首先了解一些极其重要又简单的经济学概念。</p><h3 id="需要提前了解的经济学概念"><a href="#需要提前了解的经济学概念" class="headerlink" title="需要提前了解的经济学概念"></a>需要提前了解的经济学概念</h3><h4 id="差别定价"><a href="#差别定价" class="headerlink" title="差别定价"></a>差别定价</h4><p>​差别定价又被称为价格歧视，<strong>表示生产者针对相同生产成本的产品，以不同的价格售予不同的买家</strong>，这并非是一个贬义词，只是商家为了利益最大化的一种方式。</p><p>  简单来说就是有钱多花点，没钱少花钱。</p><h4 id="消费者剩余"><a href="#消费者剩余" class="headerlink" title="消费者剩余"></a>消费者剩余</h4><p><strong>消费者剩余  &#x3D; 用户可接受最高价 - 实际售卖价</strong></p><p>比如一个手机，张三本来打算5000块钱买，但是这时候突然拿到了一个500块优惠券，张三最终以4500块就买下了的手机。</p><p>此时，<strong>消费者剩余就是5000 - 4500 &#x3D; 500</strong>，而商家的成本是3500，<strong>生产者剩余为4500 - 3500 &#x3D; 1000</strong>，虽然商家挣了1000块，但是他原本是可以挣消费者1500块，所以消费者剩余越大，商家越不赚钱。</p><img src="http://qiliu.vkcyan.top/Fnsl689q92YLLHdYEENXToxFQlSP.png" style="zoom:33%;" /><h4 id="利润最大化"><a href="#利润最大化" class="headerlink" title="利润最大化"></a>利润最大化</h4><p>​我们还是看上面的案例，张三可接受的最高价是5000元，实际消费了4500元，消费者剩余是500元，理想情况下，商家希望用户都通过<strong>可接受最高价进行购买</strong>，这样的情况下商家利润最大，消费者也依旧愿意购买。</p><p>​而针对这个5000的手机，张三消费能力强，5000块愿意购买，李四消费能力弱，最多愿意4500元购买，王五是个学生，最多愿意4000元购买，那么最理想的情况则是，大家分别按照自己的能接受的最高价进行购买。</p><p>​张三消费5000、李四消费4500、王五消费4000，张三、李四、王五的消费者剩余均为0，这样的情况下，<strong>商家看起似乎打折少挣钱了，实际上却是最挣钱的状态，也就是利润最大化。</strong></p><h3 id="线下优惠券的局限性"><a href="#线下优惠券的局限性" class="headerlink" title="线下优惠券的局限性"></a>线下优惠券的局限性</h3><p>​在互联网到来的前夕，企业就已经在讨论如何利用优惠券实现收益最大化。大家都发现了一个非常难以解决的问题，<strong>精准投放无法实现</strong>。</p><p>​比如同样在纽约的张三与李四，张三相对富裕，而李四是一个穷苦大学生，他们都喜欢吃肯德基的单人套餐。</p><p>​假设肯德基的单人套餐原价是30元，张三没有觉得原价贵，无论是否有券，他都会直接买，而李四不是，只有在打折到8折及以下的时候，他才会有消费动机。</p><p>​最后让我们假设，肯德基的单人套餐综合成本是15元</p><p>​<strong>在不发券的情况下</strong>，张三30元购买，消费者剩余是0，商家实现了收益最大化，但是李四不会买，没有收益；</p><p>​<strong>在发券的情况下</strong>，张三与李四都会获取优惠券，假设是8折券，此时张三和李四都会去消费了，张三平时30元也会买，但是现在他只需要花24元，而李四呢，8折优惠券达到了他可下单的最高价，他使用8折券进行下单了；</p><p>​现在在让我们看一下发券场景下，张三与李四的消费者剩余</p><p>​张三可接受最高价30，实际消费 24，商品成本价15，消费者剩余6元，没有实现收益最大化</p><p>​李四可接受最高价24，实际消费 24，商品成本价15，消费者剩余0元，实现了收益最大化</p><p>​虽然少挣了张三的钱，但是多获得了李四的钱，似乎比不发券的效果好；但是这依旧不是理想的效果，因为张三还存在消费者剩余。</p><p>​但是券也不能一直发，长时间这样会降低品牌形象，影响消费者对品牌的信心，并提升用户对价格的敏感度，造成不可逆的严重影响，到那时候再想提价就极其困难了。</p><p>​<strong>最理想的结果应该是让大家都按照自己可接受最高价购买，用户愿意购买，商家收益最大化</strong></p><p>​张三消费能力强，不应该给他发券，他使用原价30元进行消费，消费者剩余为0</p><p>​李四消费能力弱，从高折扣券陆续发到低折扣券，不断试探用户可接受的最高价，直到消费者剩余为0</p><p>​只有这样，商家才能实现收益最大化。</p><p>​但是线下优惠券由于投放不精准问题，是无法达到理想效果的，所以商家极难实现收益最大化。但是互联网的出现改变了这一切。</p><h3 id="线上优惠券的出现"><a href="#线上优惠券的出现" class="headerlink" title="线上优惠券的出现"></a>线上优惠券的出现</h3><p>​我们的主角终于要登场了，时间来到了21世纪初期，并将视野聚焦到我们身边的国家，日本。</p><p>​日本的移动互联网的发展在当时是全球领先的，2010年3G网络几乎就达到了100%的覆盖率，在这样的背景下，<strong>日本麦当劳找到了优惠券投放不精准的解法</strong>。</p><p>​日本麦当劳此前一直想尽量收集消费者信息，比如用户的性别、年龄，来为用户提供更加精准的优惠券，具体做法就是需要用户自行填写个人信息，但是收效甚微。</p><p>​但是如果大家都通过线上进行消费呢？通过交易系统的将可以准确的采集到每个人的消费信息，并记录在数据库。</p><p>​<strong>基于用户数据 + 用户信息挖掘系统，分析用户的消费频次、消费门店、消费金额、购买品种，便可以猜测出用户的消费水平与消费习惯，进而通过电子优惠券的方式实现精准营销</strong></p><ul><li>对于经常购买汉堡的用户，发放小食优惠券，增加用户消费上限</li><li>对于一段时间未关顾的用户发放以前经常购买产品的优惠券</li><li>对于价格敏感型用户，这发放更加大幅的优惠券刺激用户的消费</li></ul><p>​<strong>线上优惠券的出现完全改写了传统优惠券的定义，从商家决定优惠券是什么，变成由用户自己的消费习惯决定优惠券是什么</strong>，完全脱离了以前的单纯的打折促销的作用。</p><p>​而是经过数据分析、精准营销，再通过电子优惠券的方式，实现了不同用户的相同产品的差别定价，更大限度的实现消费者满意，商家利润最大化的理想状态。</p><p>​电子优惠券带着他无法取代的优势开始被大众所熟知，用户分群、基于用户的消费习惯动态给予优惠券的精准营销逻辑开始进入大家的生活，优惠券进入了全新的时代；</p><p>​那么问题来了，新时代的优惠券还可以为大家省钱吗？</p><p>​</p><h3 id="优惠券真的是为了给大家省钱吗？"><a href="#优惠券真的是为了给大家省钱吗？" class="headerlink" title="优惠券真的是为了给大家省钱吗？"></a>优惠券真的是为了给大家省钱吗？</h3><p>​电子优惠券的出现确实让消费者省钱了，但是商家也挣钱了，这看似不合理，<strong>买家更省钱，卖家更挣钱，钱还能凭空变出来不成？</strong></p><p>​只有一种可能，省钱的消费者和不省钱的消费者不是一拨人，而电子优惠券做到了用户分群。</p><p>​让我们看看这几年的双十一购物节，淘宝令人诟病的复杂优惠券机制，站在用户视角，一定是让大部分人不耐烦的，直接把优惠给我不就行了吗？站在淘宝的视角，给用户优惠，但是不能无脑给，给的同时要实现收益最大化，想要收益最大化就需要<strong>让尽可能多的人使用可接受的最高价下单</strong>，大家在淘宝花时间玩游戏也好，活跃也好，如果感觉价格合适了，一般就不存在足够的动机继续下去，于是为了商家、平台的利益最大化，淘宝设定了一套复杂的优惠机制，让消费者利用时间与精力换取优惠。</p><p>​当价格高于心理可接受的最高价的时候，时间与精力的价值小于优惠的价值，用户会自发性的参与活动，获取优惠。</p><p>​当价格低于心理可接受最高价的时候，用户则没有足够的动机继续参与活动获取优惠，而是进入下单流程。</p><p>​<strong>通过这样一个付出成本获取优惠的机制，实现了针对不同用户的动态优惠，完成了用户分层与针对每个用户的区别定价；最终不同消费能力的用户都认为省钱了，同时消费者剩余为0，商家+平台利润最大化状态。</strong></p><img src="http://qiliu.vkcyan.top/FmmnhC5ER69UigqsnSeWXFyVSE92.png" style="zoom:50%;" /><p>相比较与传统优惠券，电子优惠券有一些非常突出的优点</p><ul><li>电子优惠券实现了动态定价，让商品覆盖到了更多的维度，同时更大限度的实现了消费者剩余为0。</li><li>价格标高 + 复杂的优惠券规则，实现对用户的分层，动态实现利润最大化，这个本质上是<strong>优惠券 + 大数据 &#x3D; 卡用户心里最高价</strong>。</li></ul><h3 id="传统优惠券与现代优惠券"><a href="#传统优惠券与现代优惠券" class="headerlink" title="传统优惠券与现代优惠券"></a>传统优惠券与现代优惠券</h3><p>​当我们用传统的优惠券思维，去理解电子优惠券的时候，一切似乎都不合理，而看懂了基于互联网的优惠券的逻辑，我们才能解释现代世界中发生很多事情。</p><ul><li><p>为什么会存在大数据杀熟？</p></li><li><p>为什么不直接降价而是让用户通过优惠券的方式来购买？</p></li><li><p>为什么商家千方百计的想获取你的信息？</p></li><li><p>为什么现如今数据是极其宝贵的资源？</p></li></ul><p>​商家、平台在满足用户需求的情况下，都是为了收益最大化而努力，凭借消费者的用户信息、用户标签、消费习惯，等等信息，实现收益最大化；</p><p>​<strong>通过以上案例与分析，我们可以发现电子优惠券和传统优惠券早已经不是一种东西，虽然他们都叫优惠券</strong>，电子优惠券虽然很厉害，但是也存在很强的开发成本与技术壁垒，传统优惠券虽然能力有限，但是使用门槛很低，成本更低。所以也不能片面说电子优惠券就是好，传统优惠券就是差，<strong>思考自己拥有的资源与需求，理性判断最合适的产品方案</strong>即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​本来只是想回顾一下优惠券的历史，结果一不小心就写了一篇5000字的文章，无论是消费者还是商家，理解优惠券的规则都可以帮助大家更好的理解这个世界发生的事情。</p><p>​下一篇文章，我们将进入实战篇，谈谈<strong>营销工具 - 优惠券的产品设计逻辑</strong>。</p><p>​</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.foodtalks.cn/news/5374">2万字深度拆解可口可乐百年营销史：如何从冷启动到风靡全世界？</a></p><p><a href="https://mp.weixin.qq.com/s/u2nLG2dk3-BxqX8zVhg2mA">我无比怀念肯德基和麦当劳的纸质优惠券</a></p><p><a href="https://weibo.com/1721030600/zmFhXbyAy">艾瑞咨询</a></p><p><a href="http://tech.sina.com.cn/t/2008-05-10/03432187170.shtml">日本3G市场</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;带着问题思考&quot;&gt;&lt;a href=&quot;#带着问题思考&quot; class=&quot;headerlink&quot; title=&quot;带着问题思考&quot;&gt;&lt;/a&gt;带着问题思考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为什么淘宝要把优惠券规则设计的那么复杂？&lt;/li&gt;
&lt;li&gt;为什么不直接降低价格，而是使用优惠券</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="优惠券" scheme="https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>runtime运行时</title>
    <link href="https://bluedancers.github.io/2023/09/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/runtime%E7%9B%B8%E5%85%B3/"/>
    <id>https://bluedancers.github.io/2023/09/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/runtime%E7%9B%B8%E5%85%B3/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-11-27T02:44:34.885Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟dom存在2个非常核心的概念</p><ol><li>挂载：mount</li><li>更新：patch</li></ol><p>h函数作用，生成vnode</p><p>render函数的作用，解析vnode并生成真实dom</p><h1 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h1><p>源码地址在：<strong>packages&#x2F;runtime-core&#x2F;src&#x2F;h.ts</strong></p><p>首先进入<strong>h</strong>函数</p><p>h函数存在3个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type：当前节点类型</span><br><span class="line"></span><br><span class="line">propsOrChildren：props或者children</span><br><span class="line"></span><br><span class="line">children：子节点</span><br></pre></td></tr></table></figure><p>该函数的作用就是处理好以上三个函数的传参的多种情况。</p><p>然后再将处理好的<strong>type，props，children</strong>传入到<strong>createVNode</strong>函数中</p><p>createVNode最终会执行_createVNode函数，只不过开发环境会做一些额外的处理</p><p>对于初始化的组件来说，_createVNode的主要目的就是给当前组件增加组件类型标识shapeFlag</p><p>然后进入createBaseVNode，在该出构建了完成的VNode，并根据children的字段，重新计算shapeFlag，最终返回vnode</p><p>小结：<strong>h - createVNode - _createVNode - createBaseVNode</strong></p><ol><li>h函数 处理入参，使其标准化的进入到vnode创建流程</li><li>根据type类型预先赋值shapeFlag，并增强处理class与style</li><li>构建VNode基础数据</li><li>根据children的类型，再次刷新ShapeFalg，完成对组件类型的全部标识。</li></ol><p>h函数最终就是要生成可用于render函数渲染的vnode数据</p><h1 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h1><p>在h函数中处理过去的vnode，将会在render函数中被渲染为真实dom</p><p>render的核心代码在runtime-core中进行实现，核心代码与平台式无关的，runtime-dom中存放所有dom渲染相关的代码</p><p>在导出render之前，首先会将dom相关方法放入render函数，我们使用的render其实已经被处理过了</p><p>代码执行流程大概如下</p><p>render：传入vnode与挂载阶段</p><p>patch：判断阶段类型，进入对应渲染函数</p><p>processElement：文本组件进入这里，首先判断是更新还是新增</p><p>mountElement：新增文本组件进入该函数 （创建节点 填充数据 设置props 插入dom）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚拟dom存在2个非常核心的概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;挂载：mount&lt;/li&gt;
&lt;li&gt;更新：patch&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;h函数作用，生成vnode&lt;/p&gt;
&lt;p&gt;render函数的作用，解析vnode并生成真实dom&lt;/p&gt;
&lt;h1 id=&quot;h函数&quot;&gt;</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>从读《微信背后的产品观》到思考前端工程师的“35岁”</title>
    <link href="https://bluedancers.github.io/2023/08/10/%E9%98%85%E8%AF%BB/%E4%BB%8E%E8%AF%BB%E3%80%8A%E5%BE%AE%E4%BF%A1%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E3%80%8B%E5%88%B0%E6%80%9D%E8%80%83%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E2%80%9C35%E5%B2%81%E2%80%9D/"/>
    <id>https://bluedancers.github.io/2023/08/10/%E9%98%85%E8%AF%BB/%E4%BB%8E%E8%AF%BB%E3%80%8A%E5%BE%AE%E4%BF%A1%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E3%80%8B%E5%88%B0%E6%80%9D%E8%80%83%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E2%80%9C35%E5%B2%81%E2%80%9D/</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2023-11-27T02:43:09.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://qiliu.vkcyan.top/FkbBqDq59Gu7Pjwi9xwN4P1Dz7fM.png"></p><p>​我是一名前端开发者，同时兼任pm职责，近半年在公司负责升级一直在开发与运营的一个B端的Saas商城系统；</p><p>​在对需求剖析、需求抽象、每个字段含义的推敲的时候，我越发对微信这样简洁、自然的产品产生兴趣与共鸣。</p><p>​也会情不自禁的赞叹微信清晰明了、谨慎内敛的结构化产品思路。</p><p>​虽然微信这么多年上线了如此多功能与特性，但是产品简洁而克制的灵魂从来没有改变，哪怕对于60岁的人来说，也几乎不存在用不好微信的情况。</p><p>​而我做为微信的使用者，广义技术上的开发者，无论是产品还是技术维度，都让我越加佩服与引起共鸣(恶心的小程序开发除外)。</p><p>​昨天终于行动了起来，把这本知名的<strong>《微信背后的产品观》</strong>找出来并读了起来，与其叫一本书，不如说是一个演讲的记录，很短，大约2小时就读完了，主要内容是2012年微信4.0发布时候，张小龙长达8个多小时的公开演讲的内容；</p><p>​不同于其他产品经理的书籍，他们会告诉你各种方法论、科学分析方法，张小龙截然相反的采用了一种极其浪漫的方式去看待产品，去理解所谓的用户需求，我认为这种产品思路的领先是微信这么多年在社交领域立于不败之地的根本。</p><p>​虽然在最后，张小龙看似补刀似的说：<strong>我所说的，都是错的</strong>；但是这恰恰就是他的产品理念，所谓产品没有任何科学方法，完全来自于对人，对人类群体的理解，对自己的拷问与质疑。</p><p>​我也斗胆推荐大家看看这本书，很快就能看完，人类之所以存在信息差，就是因<strong>为不知道</strong>，或许看完这本书，你会打开新的思路，某些问题也能豁然开朗。</p><p>​借此机会，我也想与大家分享一下，这几年我<strong>作为一名前端开发者的迷茫与努力</strong>。</p><h2 id="业务前端开发者的困境"><a href="#业务前端开发者的困境" class="headerlink" title="业务前端开发者的困境"></a>业务前端开发者的困境</h2><blockquote><p>我只是一名普通学历，普通的业务前端开发者，所以以下仅是我的个人感觉，不代表所有前端开发者。</p></blockquote><p>​目前在一个小型互联网公司的saas电商部门下，主要职责是前端开发组长，我们公司的主营业务不是saas电商，所以这几年算不上受到到很强的市场冲击，平时会管理几人的小团队，我18年毕业至今，一直在这家公司。</p><p>​而我大学毕业之后一直从事前端开发方向，在我工作1-3年的阶段，我都保持着对技术的热情，主要是因为尝到了学习技术的甜头，那时候我坚定的认为下一个阶段是<strong>全栈</strong>，在工作之余我花费了大量的精力学习技术；但是后面我就发现了一个很现实的问题，公司需要大家更好分工协作，所以高级别的项目后端是绝对轮不到一个前端去开发开发；并不是说能力不行，而是人的精力有限，前后端都干，还要管团队，是忙不过来的。</p><p>​在这样的环境下，关于全栈技术的学习，我也越发疑虑，逐渐走到了大多数业务前端开发者的临界点。</p><ul><li>业务前端的35岁危机在普通人身上是存在的，我们的年纪、精力、外部压力都不允许你永远征战一线，并始终保持高竞争力。</li><li>业务前端的上限很低，大多数努力的前端开发者可以在3 - 5年内触摸到业务前端的上限，职位也就是前端组长。</li><li>技术纵深是很好的选择，但是受限于综合实力（英语、计算机基础、天分），普通人可以达到的纵深远比想象的要浅。</li><li>技术学会了，但是用不上，也会慢慢被遗忘；demo级别的应用无法让开发者对某一项技术有深刻理解。</li><li>在业务开发场景下的前端，永远是<strong>没有灵魂的大头兵</strong>，上限低就意味着待遇相对较低、可替代性相对较强。</li><li>代码写的越多，与人交流的机会越少，对于几十年的人生而言，这是一件很没安全的事情。</li></ul><p>​总结一下，就是因为兴趣而走的前端技术路径开始越来越窄，前路开始越来越看不清，时间推着我向前，这不禁让我低头沉思，下一步究竟要怎么走？</p><h2 id="说回产品"><a href="#说回产品" class="headerlink" title="说回产品"></a>说回产品</h2><blockquote><p>到目前为止我也依旧不确定前路怎么走，接下来的一些结论，只是我的一些探索。</p></blockquote><p>​在大学后期，我隐约感觉技术路线并非我所擅长的时候，我有目的的学习了微观经济学、企业管理、竞争战略相关的知识，从而间接接触到了互联网产品，也就是pm。</p><p>​我很快就感受到了pm的魅力：<strong>创造</strong>，我恰好是一个喜欢新鲜事物的人，在技术上总喜欢优化、迭代、升级，亲手构建出优美并且有价值的产品极具满足感，而前端开发者与用户的距离比任何一个岗位都要近，甚至可以说：前端开发者决定了用户体验。</p><p>​如果一个人同时具备前端开发 + 产品的能力是不是还不错？</p><ul><li>消除技术与产品的认知壁垒，后续我们做到了，在我们公司，产品和技术从来不吵架</li><li>如果有能力决定产品走向，开发者就可以是一名有灵魂的大头兵，甚至晋升军衔。</li></ul><p>也就是说，我逐渐不再下探技术，而是<strong>走向用户</strong>。</p><p>​走向用户，并不意味着开发者要放弃对技术的学习，技术很重要，技术能力依旧是核心竞争力，而是随着我对技术的理解逐渐深入，开始越发清晰的了解到，究竟什么样的能力是前端开发者最需要的，什么样的能力边际收益是最高的。</p><img src="http://qiliu.vkcyan.top/Fj5ClfMkacFzfRYeT1ie06gkYNn8.png" style="zoom:30%;" /><p>​在我从事前端开发第2年至今，我一直都有在产品这方面作出努力与尝试。</p><p>​关于这几年产品的结果，大概可以用这句话来形容：</p><p>​100个想法中，80个想法死在在调研与分析阶段，15个想法死在在demo阶段，最后落地5个想法，其中4个反响平平，只有1个还算成功。</p><p>​虽然绝大部分都是失败，但是站在此刻回头来看，这几年的产品的学习将我的思维高度提升了很多，综合能力也提升了很多，因为很多想法初期是没有团队介入的，凡事都需要亲力亲为，需要思考需求、写最小demo、UI设计、沟通，而上线后，有需要又要为产品负责，就需要进行数据分析，线上数据的观察，等等….，这其实比写代码累多了。</p><p>​这些进步不像程序的学习有一个可量化的指标，这样的软实力很多的是一种感觉，虽然依旧是时而迷茫，但是也偶尔会有一些收获。</p><p>​虽然我做的产品决策越来越多，公司与同事给予的信任也越来越多，所以在产品上的舞台也是越来越大，而看了《微信背后的产品观》，里面的想法非常符合我对产品的理解，当然我的理解是相对浅显与张小龙没法比的，不过张小龙对产品的理念，以及他对需求的理解，这样一套浪漫的方法论，真的非常有魅力，这也是为什么，我看完最后决定写这篇文章。</p><h2 id="跨越“技术”思维"><a href="#跨越“技术”思维" class="headerlink" title="跨越“技术”思维"></a>跨越“技术”思维</h2><p>​这几年，我的老板经常会找我聊天，因为我和他提过对产品很有兴趣，在前两年，他反复和我提一句话<strong>技术为业务服务</strong>，我当时觉得我理解这句话了。</p><p>​我想，这不是废话，写代码最终都是为了公司的项目，为了更好更快的完成公司需求，我要狠狠的学习技术。</p><p>​之后来随着我写的代码越来越多，我对这句话逐渐有了新的理解。</p><p>​之前过于执着于<strong>技术</strong>，总是站在写代码的角度去理解，而这句话的侧重点是<strong>业务</strong>，或者我们换个词<strong>交付</strong>。</p><p>​并不是技术推动交付，而是在推动交付的因素中，技术是其中之一，我们可以衍生出很多类似的话；设计为业务服务、产品为业务服务….</p><p>​所以<strong>技术的目的并非技术，而是交付价值。</strong></p><p>​<strong>人们总是不自知的放大自己在团队中的价值</strong>，这样只会蒙蔽大家的视野，走到更高处，对很多事物将会有不一样的理解。</p><p><img src="http://qiliu.vkcyan.top/Fh1A7U86ZW-_I64VW8gr-hmg2Zd8.png"></p><p>低纬度的技术思维，走向高纬度的业务（交付）思维。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​其实我本来只是觉得读了还不错的一本书，不复盘、不留下点什么反思会达不到学习的目的，写着写着就想到了自己的职业，想到了这几年的经历；</p><p>​总结性的话不说太多，希望可以帮助到屏幕前你，我们共同成长，共同进步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://qiliu.vkcyan.top/FkbBqDq59Gu7Pjwi9xwN4P1Dz7fM.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	我是一名前端开发者，同时兼任pm职责，近半年在公司负责升级一直在开发与运营的一个B端的Saas商城系统；&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="书摘" scheme="https://bluedancers.github.io/categories/%E4%B9%A6%E6%91%98/"/>
    
    
    <category term="产品" scheme="https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
    <category term="张小龙" scheme="https://bluedancers.github.io/tags/%E5%BC%A0%E5%B0%8F%E9%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>这是我写过的最简单的Vue3中后台动态路由 + 侧边栏渲染方案</title>
    <link href="https://bluedancers.github.io/2023/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BF%99%E6%98%AF%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Vue3%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%20+%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/"/>
    <id>https://bluedancers.github.io/2023/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BF%99%E6%98%AF%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Vue3%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%20+%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/</id>
    <published>2023-06-14T16:00:00.000Z</published>
    <updated>2023-11-27T03:16:52.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​在3年前发布了一篇<a href="https://juejin.cn/post/6844903816593145864">vue2后台管理系统动态路由方案</a>，时至今日，<strong>vue2</strong>已经升级到了<strong>vue3</strong>，动态路由的实现方案也同步做出了一些升级迭代，帮助开发者们更高效的完成业务需求，然后摸鱼🐟。</p><p>​本次逻辑的升级，主要聚焦于2点</p><ol><li><p><strong>更加简单的实现逻辑</strong></p></li><li><p><strong>更加便捷的路由配置</strong></p></li></ol><h2 id="之前的动态路由方案"><a href="#之前的动态路由方案" class="headerlink" title="之前的动态路由方案"></a>之前的动态路由方案</h2><ul><li><p>前端只存储基础的路由（<strong>登录、首页、404</strong>）</p></li><li><p>根据不同的登录角色，返回其对应的可访问路由树</p></li><li><p>从服务端获取路由树（<strong>JSON</strong>）并递归处理成<strong>vue-router</strong>可使用的数据结构，并通过<strong>addRouters</strong>拼接到基础路由树，完成动态路由</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>相当安全，项目里面只有基础路由，业务路由全部来自接口</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>代码中只保存了基础路由，<strong>业务路由的全部字段需要前端开发人员手动录入到超级管理系统之中，维护业务路由非常繁琐。</strong></li><li>客户端逻辑相对复杂，<strong>addRouters</strong>的逻辑必须在路由钩子<strong>beforeRouter</strong>中完成，这部分逻辑比较烧脑。</li></ul><p>有没有一种办法，可以<strong>既保留动态路由的特性，也保证代码逻辑的简单性，同时将路由配置回归前端项目呢？</strong></p><h2 id="转变解决思路"><a href="#转变解决思路" class="headerlink" title="转变解决思路"></a>转变解决思路</h2><p>​通过以上分析，我们首先可以明确一点，动态路由的配置数据还是<strong>需要放在前端项目</strong>中，而不是将路由的配置录入到系统中。所以，我们可以简化系统后台的权限配置，由之前的超多字段简化为两个字段 <strong>路由名称、路由标识，仅服务于为角色勾选路由，路由配置交还给前端项目</strong>。</p><p>​<strong>路由的树形结构还是需要录入到系统中</strong>，因为我们还需要<strong>保留动态路由的核心逻辑</strong>，给（角色&#x2F;用户）勾选指定路由。</p><img src="http://qiliu.vkcyan.top/Fmtj-mmyZ6NTcHap9GnkgQ6_YXSE.png" style="zoom:50%;" /><p>​<strong>Vue2</strong>版本，我们通过<strong>addRouters为项目路由树“做加法”实现动态路由</strong>。</p><p>​<strong>Vue3</strong>版本，我们则为项目路由树手动<strong>“做减法”实现动态路由</strong>。</p><h2 id="做“减法”实现动态路由"><a href="#做“减法”实现动态路由" class="headerlink" title="做“减法”实现动态路由"></a>做“减法”实现动态路由</h2><p>首先依旧将我们的全部路由分成2部分，<strong>基础路由数组，动态路由数组</strong></p><p>基础路由：无论什么角色都可以访问的路由（登录后的公共页面，比如工作台，没有可以为空）</p><p>动态路由：拥有权限的角色才可进行访问的路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础业务路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">baseRouter</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态业务路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">asyncRouter</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 这一层的路由除了dashboard，其他都是业务无关的路由，比如登录 注册 404 500，不属于动态路由</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/login/index.vue&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;baseDashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;根路径&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">component</span>: layout,</span><br><span class="line">      <span class="attr">children</span>: [...baseRouter, ...asyncRouter], <span class="comment">// 全部注册到vue-router中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们直接将全部路由都注册到<strong>Vue</strong>中，如果不存在鉴权，此时任意角色都可以访问所有页面。</p><p>为了实现动态路由的需求，我们只要解决两个问题</p><ol><li><strong>如何实现路由拦截，拦截不允许被访问的页面。</strong></li><li><strong>如何做减法，筛选出指定的权限树，用于侧边菜单栏的展示。</strong></li></ol><h3 id="如何实现路由拦截"><a href="#如何实现路由拦截" class="headerlink" title="如何实现路由拦截"></a>如何实现路由拦截</h3><p>在用户登录的时候，我们会调用服务端的**<code>获取当前用户权限</code>**接口，获取到当前用户的权限数据</p><p>无论后端给我们返回的什么样的接口，嵌套也好、一维数组也罢，我们都将其处理成一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;index&quot;</span>, <span class="string">&quot;dashboard&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;goods&quot;</span>, <span class="string">&quot;goodsList&quot;</span>, <span class="string">&quot;goodsClass&quot;</span>]</span><br></pre></td></tr></table></figure><p>并将这样的一维数组，保存到我们全局状态库<strong>pinia</strong>中，我们假设变量名称为<strong>authList</strong>。</p><p>然后我们再增加路由钩子的逻辑，每次跳转之前，都判断<strong>next</strong>的页面<strong>name</strong>在<strong>authList</strong>中是否存在，如果不存在，则直接<strong>404</strong>，如果存在，则<strong>允许访问</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> auth = <span class="title function_">useAuthStore</span>()</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// 登录后逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (auth.<span class="property">isLogin</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断权限是否通过</span></span><br><span class="line">    <span class="keyword">if</span> (auth.<span class="property">asyncRouter</span>.<span class="title function_">includes</span>(<span class="title class_">String</span>(to.<span class="property">name</span>))) &#123;</span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未登录逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>经过beforeEach的逻辑之后，我们现在就已经实现了基本的鉴权，不允许访问的页面，都将404</strong>。</p><h3 id="递归筛选出菜单树"><a href="#递归筛选出菜单树" class="headerlink" title="递归筛选出菜单树"></a>递归筛选出菜单树</h3><p>​接下来，我们考虑第二个问题，用户登录之后，自身权限获取完毕，用户进入到管理系统内部，右侧显示功能侧边栏，<strong>我们不能将不属于该用户的动态路由都显示出来</strong>，所以我们需要根据服务端返回的权限数据，实现项目中的动态路由<strong>asyncRouter</strong>的筛选。</p><p>​因为我们路由层级理论上是无限的，所以这里使用<strong>递归</strong>进行实现比较合理。</p><img src="http://qiliu.vkcyan.top/Fjpi98MtbL0irT1Va_-kNy2BXSfw.png" style="zoom:50%;" /><p>实现思路如下</p><ol><li>递归遍历<strong>asyncRouter</strong>路由树，如果路由的<strong>name</strong>在权限数组内，并且该菜单可显示，则继续递归<strong>children</strong>，如果没有<strong>children</strong>则不做处理</li><li>如果路由的<strong>name</strong>不在权限数组中，则将其<strong>splice</strong>，也就是<strong>做减法</strong>，并且循环下标后退一位，防止跳过下一个。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取可访问路由树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">tree</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">loopRouter</span>(<span class="params">tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = tree.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = tree[i]</span><br><span class="line">    <span class="keyword">if</span> (asyncRouter.<span class="title function_">includes</span>(item.<span class="property">name</span>!) &amp;&amp; item.<span class="property">meta</span>!.<span class="property">showMenu</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">children</span>) &#123;</span><br><span class="line">        item.<span class="property">children</span> = <span class="title function_">loopRouter</span>(item.<span class="property">children</span>!, asyncRouter)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tree.<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">      len = tree.<span class="property">length</span> <span class="comment">// 刷新循环长度</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; tree.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除后,数组长度-1,数组的下一位前进了一位,所以一旦splice掉不存在的权限,便需要i--,否则会跳过下一位</span></span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上代码后，我们的路由树便会过滤掉那些不允许被访问的路由</p><p>接下来，我们便可以进行菜单的渲染工作了，前端基操我就不做过多赘述了，大家可以看看我精心为大家准备的<a href="https://github.com/BlueDancers/vue3-dynamic-routing-admin">源码案例</a>。</p><p>到此为止，我们的动态路由就实现了，是不是非常简单~</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>有经验的小伙伴会问，用户登录后，刷新页面再访问的时候，我们如何处理权限呢？</p><p>在我看来这有2个方案</p><p><strong>方案1（相对简单）</strong>：使用<strong>pinia</strong>的持久化插件<strong>pinia-plugin-persistedstate</strong>来持久化我们存储<strong>pinia</strong>的权限数据，无论用户如何刷新，我们的权限数据都一直有效，这样的实现非常简单，但是存在一定的安全隐患，就是心怀不轨的某些人，知道了不允许访问的菜单路由名称之后，可以通过手动修改当前页面的<strong>localStorage</strong>实现权限的突破。</p><p><strong>方案2（更加安全）</strong>：在<strong>pinia</strong>中创建一个变量<strong>isRouterInit</strong>标识权限是否已经被初始化，如果没获取过权限数据，则为<strong>false</strong>，如果获取过则为<strong>true</strong>；每次<strong>beforeEach</strong>的时候，登录情况下都判断该值是否为<strong>false</strong>，如果为<strong>false</strong>，则请求当前角色的权限数据，并在请求完毕后，再进行相关路由拦截逻辑，并将变量<strong>isRouterInit</strong>改为<strong>true</strong>，表明权限已经被初始化。</p><p>​以上2种方案都可以用，如果安全性要求不是特别高，建议方案1，如果对安全性、实时性要求比较高，则建议方案2。</p><p><img src="http://qiliu.vkcyan.top/Fq4pwPLiWUPmGhd34tSFDfd8x4Ag.png"></p><h2 id="菜单的排序问题"><a href="#菜单的排序问题" class="headerlink" title="菜单的排序问题"></a>菜单的排序问题</h2><p>​经过实操的小伙伴还会发现一个问题，在项目中的路由排序也许是个麻烦事。</p><p>​可能角色A说：我要<strong>acb</strong>，角色b说：我要<strong>bac</strong>，但是我们路由表放在项目中，其排序是固定不变的，有什么办法可以实现项目左侧路由树按照后台返回的权限字段数据进行渲染呢？</p><p>​其实这个问题很简单，我们针对递归后的动态路由的结果，加一个<strong>sort</strong>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取可访问路由树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">tree</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">loopRouter</span>(<span class="params">tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="comment">// 将菜单按照当前拥有权限asyncRouter的顺序排序</span></span><br><span class="line">  <span class="keyword">return</span> tree.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> asyncRouter.<span class="title function_">indexOf</span>(a.<span class="property">name</span>) - asyncRouter.<span class="title function_">indexOf</span>(b.<span class="property">name</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样项目的右侧菜单树就会按照我们后端返回的顺序进行排序了。</p><h2 id="不需要的路由可以删除吗？"><a href="#不需要的路由可以删除吗？" class="headerlink" title="不需要的路由可以删除吗？"></a>不需要的路由可以删除吗？</h2><p>​vue3提供了动态路由的相关<a href="https://router.vuejs.org/zh/guide/advanced/dynamic-routing.html">API</a>，其中有一个<strong>removeRoute</strong>，可以删除不需要的路由，那么，我们在根据登录角色动态删除剔除不需要在侧边栏显示的路由的时候，是否也同步将不需要的路由进行删除呢？</p><p>​关于这个问题，我的建议是，不建议删除，首先我们的路由模块均为异步加载的，是否删除一定不会访问的路由，都不会影响项目的加载。而一旦真的删除了，用户在推出登录切换账号的时候，一定要<strong>重载当前页面</strong>，因为我们不知道用户下一次登录的角色是什么，会不会用到已经被删除的路由。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​B端项目通过动态路由实现角色鉴权，已经是一个非常成熟的方案，无论是使用<strong>“加法方案”</strong>实现，还是使用<strong>“减法方案”</strong>，都是可行的，理论上都是对权限的一次递归筛选。</p><p>​大家主要根据项目规模、要求合理选择最适合的方案，在安全、便捷、开发难度、稳定性，等多角度做好权衡利弊。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	在3年前发布了一篇&lt;a href=&quot;https://juejin.cn/post/6844903816593145864&quot;&gt;vue2后台</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="动态路由 - vue3" scheme="https://bluedancers.github.io/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 笛卡尔积算法构建SKU最佳实践！看完不会来打我</title>
    <link href="https://bluedancers.github.io/2023/06/03/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BASKU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%81%E7%9C%8B%E5%AE%8C%E4%B8%8D%E4%BC%9A%E6%9D%A5%E6%89%93%E6%88%91/"/>
    <id>https://bluedancers.github.io/2023/06/03/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BASKU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%81%E7%9C%8B%E5%AE%8C%E4%B8%8D%E4%BC%9A%E6%9D%A5%E6%89%93%E6%88%91/</id>
    <published>2023-06-02T16:00:00.000Z</published>
    <updated>2023-11-27T02:38:00.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​商城一直都是平台研发类的高频项目，也存在诸多含金量与难度非常大的功能点，比如<strong>购物车模块、支付模块、装修模块、商品模块</strong>、以及很多与业务相关的模块，主导此类复杂需求的开发与落地不仅可以<strong>升职加薪</strong>，也是面试中的<strong>展示肌肉</strong>的时刻，</p><p>​所以今天，我和大家分享一个在正式项目中沉淀出来的<strong>Vue3版发布商品 - 构建sku的思路以及具体实现方案</strong>；附带源码与案例，点赞收藏不迷路，接下来进入正文~</p><p>源码：<a href="https://github.com/BlueDancers/vue3-sku-demo/blob/main/src/views/goods/add/index.vue">https://github.com/BlueDancers/vue3-sku-demo/blob/main/src/views/goods/add/index.vue</a></p><p>案例：<a href="https://bluedancers.github.io/vue3-sku-demo">https://bluedancers.github.io/vue3-sku-demo</a></p><h2 id="什么是SKU"><a href="#什么是SKU" class="headerlink" title="什么是SKU"></a>什么是SKU</h2><p>​在开始正文之前，首先要做一次扫盲，那就是我们说的电商项目中的SKU，究竟是什么？</p><p>​SKU的全称是<strong>Stock Keeping Units</strong>，我们可以理解为<strong>商家用于管理商品库存和销售的一种方式</strong>。</p><p>​每个 SKU 对应着一个若干<strong>属性</strong>的组合，例如一个商品存在<strong>颜色、尺寸、款式</strong>等属性。商家可以根据商品的不同属性设置不同的 SKU，并对每个 SKU 进行价格、库存若干信息的管理。</p><p>​举个例子，假设商家有一件衬衫商品，有<strong>红色、蓝色</strong>两种颜色、<strong>S、M、L</strong> 三种尺码可选。那么该商品便存在 <strong>6 个 SKU</strong> ，分别为：</p><ul><li>红色 S 号</li><li>红色 M 号</li><li>红色 L 号</li><li>蓝色 S 号</li><li>蓝色 M 号</li><li>蓝色 L 号</li></ul><p>在这里我们就要明确一下概念了，<strong>颜色、尺码</strong>都是我们的商品属性中的<strong>销售属性</strong>，而生成的 <strong>红色 S 号 红色 M 号 等等</strong> 就是我们的<strong>SKU</strong>。</p><p>再让我们在看看某宝的SKU选择弹窗</p><img src="http://qiliu.vkcyan.top/FnoRiGevwfyWw1iDnZu5FD_mNrQi.png" style="zoom:33%;" /><p>​这个商品的<strong>销售属性</strong>：尺码（6个） 颜色分类（6个），那么通过销售属性，最终将会生成<strong>6*6&#x3D;36个SKU</strong>，而用户选择任意尺码 + 颜色分类的搭配都可以匹配到具体的价格与库存等信息。</p><p>​以上提到的功能点，就设计到电商后台的商品模块的SKU构建知识点，接下来让我们看看，如何使用Vue3构建SKU。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="构建销售属性"><a href="#构建销售属性" class="headerlink" title="构建销售属性"></a>构建销售属性</h3><p>​通过上面的案例，我们得知了SKU并非凭空捏造出来的，而是由<strong>销售属性</strong>动态生成。</p><p>​那么根据某宝的SKU信息，我们反向推导一下，他的销售属性的数据结构可能是这样</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果，不考虑SKU的图片，我们的每个销售属性的数据结构都这样，存在一个销售属性的名称，以及若干个属性值。</p><p>​我们继续观察某宝，发现无论如何修改尺码，白色的图片都是同一张，不会随着尺码的变化而变化，因此我们可以推断出，<strong>sku的图片是由着销售属性进行设置的</strong>；</p><p>​另外还要注意一个细节，一个商品无论存在多少个销售属性，最终只能为其中一个销售属性设定图片，所以我们优化一下我们的销售属性数据结构，增加销售属性图片的字段。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">isAddImage</span>: <span class="built_in">boolean</span> <span class="comment">// 是否上传图片（最多只能打开一个）</span></span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">    thumbnailUrl?: <span class="built_in">string</span> <span class="comment">// 属性图片</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​于是，我们便可以得出我们案例的数据结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> skuAttrItemType = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;尺码&#x27;</span>,</span><br><span class="line">    <span class="attr">isAddImage</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">values</span>: [</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;S&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;M&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;颜色分类&#x27;</span>,</span><br><span class="line">    <span class="attr">isAddImage</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">values</span>: [</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;白色&#x27;</span>, <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;黑色&#x27;</span>, <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​这样的数据结构便满足了我们客户端渲染商品SKU，用户可以将不同的尺码与颜色分类进行搭配，但是我们目前仅能实现SKU的选择，还无法满足用户选择任意尺码 + 颜色分类的搭配后，立刻得知价格的场景。</p><p>这也是我们下一步需要解决的问题，就是基于销售属性构建商品SKU。</p><h3 id="使用笛卡尔积算法实现商品SKU的构建"><a href="#使用笛卡尔积算法实现商品SKU的构建" class="headerlink" title="使用笛卡尔积算法实现商品SKU的构建"></a>使用笛卡尔积算法实现商品SKU的构建</h3><p>基于以上销售属性，我们的目标是构建一个如下的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>SKU的生成是存在明确的运算规则的，<strong>销售属性的属性名称的数量的乘积等于SKU的数量</strong>。</p><p>比如我们上线的销售属性是 两个尺码 两个颜色分类，则生成的SKU数量2 * 2 &#x3D; 4个</p><p>假如我们存在三个尺码 三个颜色分类，则生成的SKU数量3 * 3 &#x3D; 9个</p><p>假如我们再多一个销售属性 两个尺码 三个颜色 四个风格，则生成的SKU数量为 2 * 3 * 4 &#x3D; 24个</p><p>​我们程序如何实现以上逻辑呢？大部分小伙伴面对这样的诉求的第一反应应该都是递归，因为销售属性的数量是未知的，写死循环实现是不现实的，不过在SKU生成上，我们一般使用更加简单的<strong>笛卡尔积算法</strong>。</p><p>​<strong>笛卡尔积：笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积，又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 。</strong></p><img src="http://qiliu.vkcyan.top/Fmr0wr2qWAEvldYISLN3RLzcK6zt.png" style="zoom:30%;" /><p>接下来，我们就来实现这一部分的逻辑</p><p>sku的生成是实时的，销售属性的变化会引发sku的变化，所以我们需要监听销售属性的变化，这里我们通过watch进行实现</p><blockquote><p>笛卡尔积本身不复杂，熟练了解reduce即可，如果有点忘记了，请去<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">MDN</a>复习一下~</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">isAddImage</span>: <span class="built_in">boolean</span> 是否上传图片（限制最多只能打开一个）</span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">    thumbnailUrl?: <span class="built_in">string</span> <span class="comment">// 属性图片</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听销售属性的变化,并构建sku</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> skuAttributes.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">generateSku</span>(<span class="title function_">deepClone</span>(value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新销售属性构建sku</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">skuAttribute</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateSku</span>(<span class="params">skuAttribute: skuAttrItemType[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">attrValue</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  skuAttribute.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> attrValue.<span class="title function_">push</span>(item.<span class="property">values</span>)) <span class="comment">// 获取所有属性名称 =&gt; [[&#x27;S&#x27;,&#x27;M&#x27;], [&#x27;白&#x27;,&#x27;黑&#x27;]]</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始构建sku </span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">skus</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  <span class="comment">// 笛卡尔积算法（注意，我们的reduce没有指定第二个参数，则第一次循环中，col是数组第一位，set是数组第二位）</span></span><br><span class="line">  skus = attrValue.<span class="title function_">reduce</span>(<span class="function">(<span class="params">col: <span class="built_in">any</span>[], set</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">res</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">    <span class="comment">// 对于每个属性值集合，依次与当前已有的结果集做笛卡尔积</span></span><br><span class="line">    col.<span class="title function_">forEach</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">// 将两个属性值合并为一个字符串，并存入结果集中</span></span><br><span class="line">        <span class="keyword">let</span> t = c.<span class="property">attributeValue</span> + <span class="string">&#x27;,&#x27;</span> + s.<span class="property">attributeValue</span></span><br><span class="line">         <span class="comment">// 寻找销售属性指定的图片</span></span><br><span class="line">        res.<span class="title function_">push</span>(&#123; <span class="attr">attributeValue</span>: t, <span class="attr">thumbnailUrl</span>: c.<span class="property">thumbnailUrl</span> || s.<span class="property">thumbnailUrl</span> || <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">// 将笛卡尔积后的结果集返回，作为下一轮的结果集</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="comment">// 将结果存储起来</span></span><br><span class="line">  stockKeepUnits.<span class="property">value</span> = skus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上的代码，我们变化销售属性，就会得出以下的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这便实现了我们的sku算法，无论是多么复杂的销售属性，都可以通过该函数，输出符合预期的SKU。</p><p>这时候有同学要说了，哎，我SKU的价格，库存等等属性呢？</p><p>这还不简单？赋值之前再循环一遍，增加字段即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">skus.<span class="title function_">map</span>(<span class="function">(<span class="params">e: skuType</span>) =&gt;</span> &#123;</span><br><span class="line">  e.<span class="property">price</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 价格</span></span><br><span class="line">  e.<span class="property">marketPrice</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 市场价</span></span><br><span class="line">  e.<span class="property">stock</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 库存</span></span><br><span class="line">  e.<span class="property">specificationBarCode</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 销售规格</span></span><br><span class="line">  <span class="keyword">return</span> e</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 将结果存储起来</span></span><br><span class="line">stockKeepUnits.<span class="property">value</span> = skus</span><br></pre></td></tr></table></figure><p>最终我们得到了这样的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>数据准备妥当后，接下来我们就可以渲染表格了，这都是前端基操，我就不做过多赘述，有兴趣的朋友，可以看看<a href="https://github.com/BlueDancers/vue3-sku-demo">源码</a>以及我精心为大家准备的案例。</p><h3 id="实现SKU数据缓存"><a href="#实现SKU数据缓存" class="headerlink" title="实现SKU数据缓存"></a>实现SKU数据缓存</h3><p>如果大家仔细想以上代码，会发现一个问题</p><p>​假设，运营人员在发布商品的时候漏填了一个销售属性，尺码L，但是这时候运营已经填写好了SKU表格中的信息，如果这时候运营想增加字段，根据我们上面的代码，会触发skuAttributes.value的watch，进而运行generateSku，<strong>开始重新构建SKU，导致运营人员之前的数据全部被重置了</strong>。</p><img src="http://qiliu.vkcyan.top/FtwTwzykFR8qzHJwZFVsHIA2XYug.png" style="zoom:50%;" /><p>​而以上提到的场景是项目实际运营期间非常常见的场景，那么有没有办法，可以实现SKU的变动，不影响已经填写好的SKU呢。</p><p>​实现起来其实也很简单，那就是，我们保存每一次生成的SKU的副本，然后在下一次SKU重新构建的时候，对比副本，再回填信息。</p><p>思路如下：</p><ol><li>实时保存SKU的副本</li><li>SKU重新构建的时候对比副本</li><li>销售规格一致的SKU回填副本数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">afterSku</span>: skuType[] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听sku本身的变化,并将当前sku进行备份</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> stockKeepUnits.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    afterSku = <span class="title function_">deepClone</span>(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新销售属性构建sku</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">skuAttribute</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateSku</span>(<span class="params">skuAttribute: skuAttrItemType[]</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line"> <span class="comment">// 增加,回显相关字段</span></span><br><span class="line">  skus.<span class="title function_">map</span>(<span class="function">(<span class="params">e: skuType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找销售规格一致的副本数据</span></span><br><span class="line">    <span class="keyword">let</span> old = afterSku.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">attributeValue</span> == e.<span class="property">attributeValue</span>)</span><br><span class="line">    e.<span class="property">id</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">id</span></span><br><span class="line">    e.<span class="property">price</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">price</span></span><br><span class="line">    e.<span class="property">marketPrice</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">marketPrice</span></span><br><span class="line">    e.<span class="property">stock</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">stock</span></span><br><span class="line">    e.<span class="property">specificationBarCode</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">specificationBarCode</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">  &#125;)</span><br><span class="line">  stockKeepUnits.<span class="property">value</span> = skus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以是其他回填规则，比如按照下标的方式回填，这就看具体业务的要求了，基于副本我们便完成了SKU的变动后数据的缓存功能。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们vue3版本的商城项目的SKU核心实现到此就全部结束了，如果你想了解全部代码，请点击<a href="https://github.com/BlueDancers/vue3-sku-demo">这里</a>，如果你想测试案例，请点击这里</p><p>作为一名Vue3开发者，你可能对这个专栏感兴趣</p><p><a href="https://juejin.cn/column/7124246398278565895">Pinia 源码分析专栏</a></p><p><a href="https://juejin.cn/column/7199826518570172472">Vue3 硬核源码解析系列</a></p><p><a href="https://juejin.cn/post/7052952117425733663">写给前端nginx教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	商城一直都是平台研发类的高频项目，也存在诸多含金量与难度非常大的功能点，比如&lt;strong&gt;购物车模块、支付模块、装修模块、商品模块&lt;/</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="vue3" scheme="https://bluedancers.github.io/tags/vue3/"/>
    
    <category term="sku" scheme="https://bluedancers.github.io/tags/sku/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（7）watch源码解析.md</title>
    <link href="https://bluedancers.github.io/2023/05/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/05/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-17T16:00:00.000Z</published>
    <updated>2023-11-27T02:40:13.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​原本打算本章讲讲<strong>computed</strong>，但是<strong>computed</strong>的源码相当复杂，使用文章的形式说清楚，难度真的很大，所以暂时跳过<strong>computed</strong>，先说说<strong>watch</strong>。</p><p>​<strong>watch</strong>即为监听的意思：<strong>监听响应式数据，每当状态发生变化，就会触发回调函数</strong>。</p><p>​如果大家对之前的源码分析有所理解的话，我相信大家可以猜到watch实现原理，<strong>一定是初始化的时候进行依赖收集，依赖项发生变化的时候依赖触发</strong>。</p><p>​如果能领悟到这一层，那么对vue3的核心实现你已经有所理解啦。</p><p>​接下来就让我们走进watch的世界，让我们看看，vue3是如何实现他的吧。</p><p>首先还是放出watch的逻辑图，watch的逻辑相对简单，因为对于watch而言，响应式是其一部分逻辑。</p><p><img src="https://www.vkcyan.top/FmR0g8twA5yVrokQ-uXkSNKqD5Cn.png"></p><h2 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h2><p>在我刚刚使用Vue3 watch的时候，经常出现以下让我无法解释的情况。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactive的案例</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span> &#125;)</span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">name</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三&#x27;</span>, value))<span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">name</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第四&#x27;</span>, value))<span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span> <span class="comment">// 修改reactive 期望触发watch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ref案例</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">ref</span>(<span class="string">&#x27;卖鱼强&#x27;</span>)</span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个watch&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">value</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个watch&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三次watch&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">value</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第四次watch&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">value</span> = <span class="string">&#x27;狂飙强&#x27;</span> <span class="comment">// 修改reactive 期望触发watch</span></span><br></pre></td></tr></table></figure><p>以上案例，我相信大部分写vue的同学，都很难在第一时间准确判断其watch是否有效无效，接下来就让我们一起从源码中寻找答案。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>watch</strong>的源码并不在<strong>reactivity</strong>中，而是在<strong>runtime-core</strong>中</p><blockquote><p>关于这一点我会谈谈我的想法，讨论一下为什么不在<strong>reactivity</strong>中，而在<strong>runtime-core</strong>中。</p></blockquote><h3 id="watch初始化"><a href="#watch初始化" class="headerlink" title="watch初始化"></a>watch初始化</h3><p>当我们使用<strong>watch</strong>的时候，其执行的具体源码位置为<code>packages/runtime-core/src/apiWatch.ts</code> <strong>line131</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;T = <span class="built_in">any</span>, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span>&gt;(</span><br><span class="line">  <span class="attr">source</span>: T | <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">cb</span>: <span class="built_in">any</span>,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span></span><br><span class="line">): <span class="title class_">WatchStopHandle</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(source <span class="keyword">as</span> <span class="built_in">any</span>, cb, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WatchOptions</span> &#123;</span><br><span class="line">  immediate?: <span class="built_in">boolean</span></span><br><span class="line">  deep?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以了解到，<strong>watch</strong>是存在三个参数的</p><ol><li><strong>source</strong> ：监听项</li><li><strong>cb</strong>：watch的回调函数</li><li><strong>options</strong>： 关于watch的设置，内部存在2个参数<ol><li><strong>immediate</strong>  首次是否运行</li><li><strong>deep</strong>  是否深度监听</li></ol></li></ol><p>这些消息和我们通过Vue文档了解到的信息完全一致，最终我们会发现，其实际返回了一个<strong>doWatch</strong>函数，并将<strong>watch</strong>的三个参数传递了进去。</p><p><strong>doWatch内部的逻辑就是watch实现的核心逻辑了</strong>，我们从三个阶段分析<strong>doWatch</strong>的代码。</p><p><strong>第一阶段：处理source，监听项分析</strong></p><p><strong>第二阶段：构建响应式模块，完成依赖收集</strong></p><p><strong>第三阶段：明确依赖触发方式</strong></p><h2 id="第一阶段：处理source，监听项分析"><a href="#第一阶段：处理source，监听项分析" class="headerlink" title="第一阶段：处理source，监听项分析"></a>第一阶段：处理source，监听项分析</h2><p>我们在使用<strong>watch</strong>的时候，第一个参数，也就是被监听项，是可以传入很多类型的，<strong>ref reactive function array</strong>，在<strong>doWatch</strong>函数中，我们可以看到，针对不同类型与属性的<strong>source</strong>，都做了个性化的依赖处理。</p><p>接下来就让我们看看，<strong>doWatch</strong>都是如何处理这些变量的吧。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote><p>后续getter函数一旦执行，将会访问ref，<strong>触发 ref本身的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// 如果当前source的值是ref, 则处理为() =&gt; source.value</span></span><br><span class="line">  <span class="comment">// 这里注意const num = ref(1) num是ref，num.value并不是ref而是基础类型</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.<span class="property">value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><blockquote><p>后续getter函数一旦执行，将会访问reactive，<strong>触发 ReactiveEffect 完成依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// 如果是reactive则,直接处理成() =&gt; source</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> source</span><br><span class="line">  <span class="comment">// 同时将deep赋值为true 因为reactive为object，一般为多层嵌套，需要深度递归</span></span><br><span class="line">  deep = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><blockquote><p> 后续getter函数一旦执行，将会运行fn，访问函数返回值，如果fn返回的是ref 或者reactive 就会<strong>触发相应的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// callWithErrorHandling函数比较复杂，这里就不做展示了</span></span><br><span class="line">  <span class="comment">// 函数效果为：返回 () =&gt; fn()</span></span><br><span class="line">  <span class="comment">// 后续getter</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> <span class="title function_">callWithErrorHandling</span>(source, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><blockquote><p> 后续getter函数一旦执行，将会访问getter中的所有的访问值，如果fn返回的是ref 或者reactive 就会<strong>触发相应的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isArray</span>(source)) &#123;</span><br><span class="line">  isMultiSource = <span class="literal">true</span> <span class="comment">// 标识为多个监听项</span></span><br><span class="line">  <span class="comment">// array类型的source，可能包含ref reactive Function 所以都需要进行处理</span></span><br><span class="line">  <span class="comment">// 其中reactive比较复杂，需要通过traverse函数，递归触发所有依赖项，也可以说array类型的source，默认deep参数就是true</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> </span><br><span class="line">    source.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isRef</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="property">value</span> <span class="comment">// </span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">traverse</span>(s)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callWithErrorHandling</span>(s, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">callWithErrorHandling</span>(<span class="params">fn,instance,<span class="keyword">type</span>,</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未知类型"><a href="#未知类型" class="headerlink" title="未知类型"></a>未知类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">NOOP</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">getter = <span class="variable constant_">NOOP</span> <span class="comment">// 如果watch的第一个参数不是以上类型，这起getter函数为空</span></span><br></pre></td></tr></table></figure><p>以上就是<strong>watch</strong>针对所有类型的<strong>source</strong>的处理。</p><p>我们可以发现其实就做了一件事，就是将其包装为<strong>getter</strong>函数，<strong>getter</strong>函数一旦运行，便可以触发相关<strong>依赖收集</strong>。</p><p>完成第一阶段的分析，其实我们文章开头提出的问题已经有了明确答案，我们回过头来继续看看</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// user是reactive，将会被处理为（）=&gt; user，同时deep参数默认设置为true，reactive中的所有依赖都将会触发依赖收集，watch有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">name</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// name是reactive内的基础对象，将会被识别为未知类型，所以watch无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 函数返回，并未访问proxy的属性，无法完成依赖收集，所以watch无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">name</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 函数返回 而user.name是proxy下的属性，将会触发依赖收集，所以watch有效</span></span><br></pre></td></tr></table></figure><p>以上就是<strong>reactive + watch</strong>不同使用方式的效果解读。</p><p>有兴趣的小伙伴可以试试解读一下<strong>ref + watch</strong>的结果。</p><p>如果真的记不住，我们就记住下面的这句话：<strong>watch 监听对象本身，使用对象的形式；watch监听对象内部属性，使用函数形式。</strong></p><h2 id="第二阶段：构建响应式模块，完成依赖收集"><a href="#第二阶段：构建响应式模块，完成依赖收集" class="headerlink" title="第二阶段：构建响应式模块，完成依赖收集"></a>第二阶段：构建响应式模块，完成依赖收集</h2><blockquote><p>这上小节，我们完成<strong>getter</strong>函数的构建，这一步我们需要进行依赖触发，与依赖收集，使<strong>watch</strong>的监听功能正式生效。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">  <span class="comment">// 如果deep为true, 则将getter函数再通过traverse进一步处理，使其可以被深度监听</span></span><br><span class="line">  <span class="comment">// traverse的作用前面说过，目的就是递归触发对象所有属性的get。</span></span><br><span class="line">  <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">  getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(<span class="title function_">baseGetter</span>()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化oldValue，如果source是数组isMultiSource为true，否则为false</span></span><br><span class="line"><span class="keyword">let</span> oldValue = isMultiSource ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch的核心实现，注意一下，此刻我们还没有执行</span></span><br><span class="line"><span class="comment">// 内部逻辑非常复杂，我们这里简化处理</span></span><br><span class="line"><span class="comment">// 简单来说就是每次watch的属性或者字段发生变化，都会触发该方法，可以触发的原因是我们getter函数完成了依赖收集的必要逻辑</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">job</span>: <span class="title class_">SchedulerJob</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>() <span class="comment">// 获取被监听项的最新值</span></span><br><span class="line">  <span class="comment">// 如果deep为true 或者新旧值不一致, 则会执行watch的cb，也就是我们需要触发的函数</span></span><br><span class="line">  <span class="keyword">if</span> (deep || <span class="title function_">hasChange</span>(newValue, oldValue)) &#123;</span><br><span class="line">    <span class="title function_">cb</span>(newValue, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">scheduler</span>: <span class="title class_">EffectScheduler</span></span><br><span class="line"><span class="comment">// flush：回调的刷新时机 </span></span><br><span class="line"><span class="comment">// queuePreFlushCb  queuePostRenderEffect 后续再说，我们先假设flush就是async</span></span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">  scheduler = job</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class="property">suspense</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePreFlushCb</span>(job) <span class="comment">// queuePreFlushCb 暂时先忽略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter是第一步处理的，可以访问到响应式字段的函数</span></span><br><span class="line"><span class="comment">// scheduler是watch监听字段发生变化，实际需要执行的回调函数，我们可以理解为scheduler = job = getter</span></span><br><span class="line"><span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, scheduler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cb) &#123;</span><br><span class="line">  <span class="comment">// 如果immediate为true,则代表默认watch初始化阶段自动执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">    <span class="comment">// job中的effect.run运行，完成依赖收集，建立其了变量与cb函数之间的联系。</span></span><br><span class="line">    <span class="comment">// 同时也执行了cb函数，首次watchcb被执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果immediate为false，则直接运行effect.run()，完成依赖收集，建立其了变量与cb函数之间的联系。</span></span><br><span class="line">    oldValue = effect.<span class="title function_">run</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回了effect的stop函数，则意味着，watch api存在返回值，只需要执行一下返回值 就会结束掉watch的监听</span></span><br><span class="line">  effect.<span class="title function_">stop</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​到此为止，我们可以明确了解到，在<strong>Vue</strong>的初始化阶段，<strong>watch</strong>其内部通过<strong>ReactiveEffect</strong>，以及<strong>effect.run()<strong>的触发，完成了</strong>watch</strong>需要监听的变量与触发函数的绑定，<strong>ReactiveEffect</strong>逻辑在<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>可以了解其具体实现。</p><p>​<strong>也就是相当于说，watch内部通过手动访问source，触发source的get事件</strong>，<strong>source</strong>依赖一旦触发，就会开始依赖收集，就会<strong>收集到watch的第二个参数cb</strong>，经进而完成<strong>watch</strong>的依赖收集；<strong>只要source发生改变，一定会触发cb函数。</strong></p><p>​其实到这里<strong>watch</strong>的核心源码就已经结束了，依赖已经完成收集；</p><p>​当被监听变量或者属性发生变化的时候，<strong>cb</strong>函数一定会执行，但是<strong>watch</strong>的执行时机是非常有讲究的；</p><p>​<strong>所以接下来就要讲讲watch第三个参数的flush，该字段就是控制cb函数的执行时机。</strong></p><h2 id="第三阶段：依赖触发"><a href="#第三阶段：依赖触发" class="headerlink" title="第三阶段：依赖触发"></a>第三阶段：依赖触发</h2><p>当我们<strong>watch</strong>监听的字段发生变化的时候，<strong>watch</strong>的第二个参数，<strong>cb</strong>会被触发，但是并不是监听字段发生变化的下一步就立刻触发。</p><p>这里我们回顾一下<strong>watch</strong>源码中变量<strong>scheduler</strong>的相关逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">  scheduler = job</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePreFlushCb</span>(job)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 为了便于理解，暂时认为__FEATURE_SUSPENSE__为false，此处一定等于queuePostFlushCb</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> queuePostRenderEffect = __FEATURE_SUSPENSE__</span><br><span class="line">  ? queueEffectWithSuspense</span><br><span class="line">  : queuePostFlushCb</span><br></pre></td></tr></table></figure><p>我们可以看到，<strong>flush</strong>参数不同的时候<strong>scheduler</strong>的值也是不同的</p><p>如果我们指定了<strong>flush</strong>是<strong>sync</strong>，则<strong>source</strong>发生变化下一个同步任务就是执行<strong>watch</strong>的<strong>cb</strong>函数，</p><p>如果我们不进行指定，默认将是<strong>pre</strong>，则会触发<strong>queuePreFlushCb(job)</strong></p><p>如果指定为<strong>post</strong>，则会触发<strong>queuePostFlushCb(job)</strong></p><p>根据文档我们可以了解到当<strong>flush</strong>为<strong>pre</strong>的时候，<strong>watch</strong>第二个参数<strong>cb</strong>，将会在<strong>Vue</strong>组件更新之前被调用，<strong>post</strong>则会让<strong>cb</strong>函数在<strong>Vue</strong>组件更新之后被调用</p><p>接下来就让我们看看<strong>queuePreFlushCb</strong>与<strong>queuePostFlushCb</strong>内部是如何实现的吧！</p><h3 id="queuePreFlushCb与queuePostFlushCb"><a href="#queuePreFlushCb与queuePostFlushCb" class="headerlink" title="queuePreFlushCb与queuePostFlushCb"></a>queuePreFlushCb与queuePostFlushCb</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedPromise =  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line"><span class="keyword">let</span> currentFlushPromise = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">pendingPreFlushCbs</span>: <span class="title class_">SchedulerJob</span>[] = []</span><br><span class="line"><span class="keyword">let</span> <span class="attr">activePreFlushCbs</span>: <span class="title class_">SchedulerJob</span>[] | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> preFlushIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cb传入到queueCb中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePreFlushCb</span>(<span class="params">cb: SchedulerJob</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行方法附带一些关于pre队列的全局变量</span></span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cb传入到queueCb中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePostFlushCb</span>(<span class="params">cb: SchedulerJobs</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行方法附带一些关于post队列的全局变量</span></span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将cb加入到全局变量pendingPreFlushCbs或者pendingPostFlushCbs中，我们可以理解为缓存了cb函数，并执行了queueFlush</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueCb</span>(<span class="params"></span></span><br><span class="line"><span class="params">  cb: SchedulerJobs,</span></span><br><span class="line"><span class="params">  activeQueue: SchedulerJob[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  pendingQueue: SchedulerJob[],</span></span><br><span class="line"><span class="params">  index: number</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  pendingQueue.<span class="title function_">push</span>(cb)</span><br><span class="line">  <span class="title function_">queueFlush</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数最终将缓存的cb函数访问到Promise的.then中，resolvedPromise已经是resolve状态，则意味着，将会在下一次微任务的时候触发flushJobs</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若干时间后watch被触发，然后一轮事件循环结束，开始触发flushJobs</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  isFlushPending = <span class="literal">false</span></span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">      <span class="keyword">if</span> (job &amp;&amp; job.<span class="property">active</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title function_">flushPostFlushCbs</span>(seen)</span><br><span class="line">    isFlushing = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次触发之前存储的所有cb函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushPreFlushCbs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pendingPreFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> activePreFlushCbs = [...<span class="keyword">new</span> <span class="title class_">Set</span>(pendingPreFlushCbs)]</span><br><span class="line">    </span><br><span class="line">    pendingPreFlushCbs.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; activePreFlushCbs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      activePreFlushCbs[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次触发之前存储的所有cb函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushPostFlushCbs</span>(<span class="params">seen?: CountMap</span>) &#123;</span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>()</span><br><span class="line">  <span class="keyword">if</span> (pendingPostFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> deduped = [...<span class="keyword">new</span> <span class="title class_">Set</span>(pendingPostFlushCbs)]</span><br><span class="line">    pendingPostFlushCbs.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    activePostFlushCbs = deduped</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (postFlushIndex = <span class="number">0</span>; postFlushIndex &lt; activePostFlushCbs.<span class="property">length</span>; postFlushIndex++) &#123;</span><br><span class="line">      activePostFlushCbs[postFlushIndex]()</span><br><span class="line">    &#125;</span><br><span class="line">    activePostFlushCbs = <span class="literal">null</span></span><br><span class="line">    postFlushIndex = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码看起来似乎比较复杂，但是执行的逻辑其实非常简单，<strong>Vue3的更新队列存在三种分别是pre，queue，post，这三个队列按照顺序执行相应代码</strong></p><ol><li>执行<strong>pre</strong>队列中的代码</li><li>执行<strong>queue</strong>队列中的代码，（<strong>queue为组件update的相关逻辑</strong>）</li><li>执行<strong>post</strong>队列中的代码</li></ol><p>这里对照<strong>vue3</strong>文档，我们可以发现，我们的分析是符合文档描述的。</p><blockquote><p>因为涉及到<strong>vue3</strong>的更新队列，这并非<strong>watch</strong>关联的知识，为了方便源码阅读，可以假设<strong>watch</strong>的<strong>flush</strong>的参数为<strong>async</strong>，这样是最好理解的。</p></blockquote><p>到此为止，我们的<strong>watch</strong>核心源码分析就全部完毕了。</p><h2 id="关于ref的一些问题"><a href="#关于ref的一些问题" class="headerlink" title="关于ref的一些问题"></a>关于ref的一些问题</h2><h3 id="watch的源码为什么在runtime-core中？"><a href="#watch的源码为什么在runtime-core中？" class="headerlink" title="watch的源码为什么在runtime-core中？"></a>watch的源码为什么在runtime-core中？</h3><p>关于这一点我是这么理解的，watch不仅仅是一个响应式组件，他涉及到了组件的生命周期，更新渲染等等逻辑，放在runtime中更好与组件系统进行集成，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​通过以上源码分析我们可以发现，watch的响应式原理相对来说是比较简单的，完全依赖我们的之前说过的ReactiveEffect，所以如果小伙伴了解reactive的源码，相信看watch的源码的响应式部分是非常轻松的</p><p>​相对于其他api，watch的响应式实现具备一下2个特点</p><ol><li>watch的依赖收集是<strong>被动触发</strong>的</li><li>watch的依赖触发，实际上是调度器scheduler，然后通过不同的flush，达到控制执行顺序、规则的目的。</li></ol><p>​watch的源码分析就到这里，我们下期再见吧~👋🏻</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:151</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（6） 100行代码 实现mini版ref</title>
    <link href="https://bluedancers.github.io/2023/03/22/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/"/>
    <id>https://bluedancers.github.io/2023/03/22/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/</id>
    <published>2023-03-21T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:55.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>​在上一节，我们完成了<strong>vue3</strong>的<strong>ref</strong>核心源码解读，其实<strong>基础类型的ref的核心逻辑还是非常简单的</strong>，所以在我们的简易版源码环节，我们直接切入基础类型，复杂类型仅做支持，不做讲解。</p><blockquote><p>注：单基础类型场景的ref源码，几乎可以说是整个vue3源码中最简单的一部分，所以这一节的学习难度是最小的</p></blockquote><p><a href="https://github.com/BlueDancers/vue3-mini/tree/ref">mini版vue3仓库地址</a>，还请大家不要吝啬star，下次不迷路~</p><p><strong>仅保留最核心逻辑，极大减低阅读难度，80行代码实现vue3 ref</strong>，让我们直接进入源码实现环节！</p><h2 id="逻辑图（基础类型）"><a href="#逻辑图（基础类型）" class="headerlink" title="逻辑图（基础类型）"></a>逻辑图（基础类型）</h2><blockquote><p>完整版ref逻辑图，请看 Vue3硬核源码解析系列（5） ref源码解析</p></blockquote><p><img src="https://www.vkcyan.top/FjE3zqx5l7zpmv0is0_Fusim1mhf.png"></p><h2 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h2><blockquote><p>如同逻辑图所示，我们简易版源码的具体实现也从 <strong>初始化 依赖收集 依赖触发</strong>三个角度来进行实现</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>ref</strong>的初始化非常简单，逻辑流程如下</p><ol><li>判断传入对象是否已经是<strong>ref</strong>，如果是，这直接返回，如果不是，则继续运行代码</li><li><strong>ref</strong>的本质就是一个<strong>Class RefImpl</strong></li><li>初始化<strong>RefImpl</strong>的时候，将ref的参数保存到<code>_value</code>，同时将参数的原始值保存到<code>_rawValue</code></li><li>通过<strong>get value</strong>，实现<strong>ref.value</strong>的访问</li><li>使用<strong>set value</strong>，实现<strong>ref.value &#x3D; xx</strong>的更新逻辑</li></ol><p>确定实现逻辑的同时，我们也仿照vue3的源码结构开始输出吧~</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue: <span class="built_in">unknown</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否已经是ref,如果是直接返回其本身</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ref本质上就是RefImpl的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T <span class="comment">// ref每次读取与返回的属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T <span class="comment">// ref中value的原始属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">dep</span>: <span class="title class_">Dep</span> | <span class="literal">undefined</span> <span class="comment">// 当前ref相关effect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">__v_isRef</span>: <span class="built_in">boolean</span> = <span class="literal">true</span> <span class="comment">// 标记__v_isRef为true,以后将无法在通过isRef()的判断</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = value     <span class="comment">// 赋值原始值</span></span><br><span class="line">    <span class="comment">// ref API中 __v_isShallow,一定为false （__v_isShallow 表示是否浅层代理）</span></span><br><span class="line">    <span class="comment">// value是基础类型,则toReactive返回原值，value是复杂类型,则toReactive会将其处理成为reactive(proxy)再返回,这就意味着,此时的value是一个proxy</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现ref.value能力</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 配合effect阶段保存的activeEffect,将依赖收集到this.dep中（依赖收集）</span></span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 返回最新value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现ref.value = xx能力</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前set的value是否存在变化, 有变化则进入if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChange</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="comment">// 保存最新的参数原始值，便于下次hasChange判断</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">      <span class="comment">// 如果value是基础类型, 则toReactive返回value本身，否则返回通过toReactive生成的proxy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="comment">// 触发get阶段收集在this.dep中的依赖（依赖触发）</span></span><br><span class="line">      <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><blockquote><p>ref &#x3D; Class RefImpl</p></blockquote><p>​经过我们上一章的<strong>ref</strong>源码分析我们可以了解到，<strong>ref</strong>的依赖收集，并不是依赖<strong>WeakMap</strong>进行完成，而是其自行完成依赖收集，收集在自身<strong>class</strong>的<strong>dep</strong>中，逻辑大概是这样的</p><ol><li>每次触发<strong>ref</strong>的<strong>get</strong>的时候，都会执行一次<strong>trackRefValue</strong>（trackRefValue的作用是完成依赖收集）</li><li>每次执行<strong>effect</strong>的时候，都会将<strong>effect</strong>本身保存到变量<strong>activeEffect</strong>中（具体请看<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>）</li><li>如果<strong>RefImpl</strong>的<strong>dep</strong>不存在，则说明是第一次进行依赖收集，将通过<strong>createDep</strong>将<strong>RefImpl.dep</strong>赋值为<strong>Set</strong></li><li>将<strong>activeEffect</strong>，也就是当前正在运行的<strong>effect</strong>，<strong>push</strong>到<strong>RefImpl</strong>的<strong>dep</strong>中，<strong>ref</strong>完成依赖收集</li></ol><p>明确了逻辑之后，我们依旧结合vue3的源码结构，来完成ref依赖收集的代码输出。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref 依赖收集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref: RefImpl</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断当前是否存在需要收集的依赖</span></span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 判断RefImpl的实例中的dep是否被初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (!ref.<span class="property">dep</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有, 则赋值为Set</span></span><br><span class="line">      ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前effect收集到当前RefImpl实例的dep中, 完成依赖收集</span></span><br><span class="line">    <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">dep</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p>若干时间后，<strong>ref</strong>的<strong>value</strong>被更新，触发<strong>RefImpl</strong>的<strong>set value</strong>，在更新<strong>value</strong>的同时，也会执行其内部的<strong>triggerRefValue</strong>，开始依赖触发逻辑</p><ol><li>获取到当前ref，也就是class <strong>RefImpl</strong>本身的<strong>dep</strong></li><li>循环<strong>dep</strong>中存储的所有<strong>effect</strong>，并执行其<strong>fn</strong>，完成依赖触发。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref 依赖触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefImpl</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前当前RefImpl实例中是否存在收集的依赖</span></span><br><span class="line">  <span class="keyword">if</span> (ref.<span class="property">dep</span>) &#123;</span><br><span class="line">    <span class="comment">// 触发依赖</span></span><br><span class="line">    <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理所有待触发依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="comment">// const effects = isArray(dep) ? dep : [...dep]</span></span><br><span class="line">  <span class="keyword">const</span> effects = [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发执行依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们的<strong>ref</strong>就具备响应式的能力了，是不是很简单~</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​这时候肯定有同学要说了，<strong>你这ref不保熟啊</strong>，仅支持基础类型，不支持复杂类型啊，这不是阉割版ref吗？</p><p>​这里必须澄清一下，虽然简易版ref 100行代码不到，但是他是支持复杂类型的响应式的，因为复杂类型的响应式是依赖<strong>reactive</strong>进行完成的，不过<strong>reactive</strong>的源码解读，并不是本文的重点，所以，这里就跳过了，有兴趣的同学，请看这里<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>，了解<strong>reactive</strong>的响应式实现，再看<a href="https://juejin.cn/post/7212910997778350136">Vue3硬核源码解析系列（5）ref源码解析</a>，了解复杂类型场景下的源码执行逻辑吧。</p><p>​最后，建议大家<a href="https://github.com/BlueDancers/vue3-mini/tree/ref">clone</a>源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，在简历上留下浓墨重彩的一笔~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;​	在上一节，我们完成了&lt;strong&gt;vue3&lt;/strong&gt;的&lt;strong&gt;ref&lt;/strong&gt;核心源码解读，其</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>chatGPT一些学习记录</title>
    <link href="https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-03-20T16:00:00.000Z</published>
    <updated>2023-03-22T03:17:16.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最早"><a href="#最早" class="headerlink" title="最早"></a>最早</h2><p>​自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段文本做到深入的理解与分析，并生成高质量的语言表达。</p><p>​那他究竟是什么原理呢？</p><p>​从一段文本中，随机扣掉一部分字，然后模型不断学习此处到底应该填写什么，<strong>所谓学习与训练就是从大量的数据中学习理解复杂的上下文关系。</strong></p><p>​注：学习 无监督学习 训练 有监督学习</p><p>​bert的出现推动了自然语言处理领域的发展，在bert出现之前，我们都是基于规则与浅层神经网络（关键字理解）去解决，bert的出现使得深度学习在自然语言处理上得到了更加广泛的使用。</p><p>​在bert出现之前，openid就出版了GPT1，GPT1也是基于Transformers进行实现，但是gpt没有走双向Transformers的方向，而是走类似单字接龙的方向，由长文单字接龙的自回归所生成，不过GPT1并没有出现bert的惊人效果，所以早期的GPT没啥热度。</p><h2 id="GPT2-GPT3"><a href="#GPT2-GPT3" class="headerlink" title="GPT2 GPT3"></a>GPT2 GPT3</h2><p>​基于bert的成就，大家都看到深度学习在语言模型上的可行性，于是大家都开始各种预训练模型，完形填空，判断题，改错题，GPT2、3也确实是这个思路，开始提升训练数据量，这个成果我们称之为开卷有益（无监督学习）。</p><p>​让chatGPT对海量互联网文本做单字接龙，以扩充模型的词汇量、语言只是、世界的信息与知识。是chatGPT从哑巴鹦鹉变成了脑容量超大的懂王鹦鹉，这个和人类的学习其实很相似，小孩刚刚来到这个解释，就是不断的输入信息。</p><p>​经过巨量的数据训练之后，我们下一步就需要情景学习（<strong>in-context learning</strong>），这两个阶段是NLP模型的基础工作流程，简单来说，就是让chatGPT对优质对话范例做单字接龙，以规范回答的对话模式和对话内容。是chatGPT变成懂规矩的博学鹦鹉，这里的场景标记几个就够了，机器一旦学会了规范，便可以应对此类所有问题。</p><h2 id="关于强化学习（RL）"><a href="#关于强化学习（RL）" class="headerlink" title="关于强化学习（RL）"></a>关于强化学习（RL）</h2><p>​几年前，alpha go击败了柯洁，几乎说明了，经过强化学习，机器可以做到近乎人类极限的程度，但是这样的场景有一个前提，一个非常明确的奖惩机制，alpha go并不理解围棋规则，但是他可以接收到成功、失败的反馈，模型会根据反馈不断调整策略，已达到更多次成功的目的。</p><p>​我们可以看到alpha go的强化学习规则书相对简单的，因为目标明确，而在NLP领域强化学习却很难实现。</p><p>​因为NLP是语言，语言是没有固定的对错，这就意味着无法设定奖惩机制，除非人工来做反馈。</p><p>​openid还就这么干了，这被称之为 <strong>RLHF（Reinforcement Learning from Human Feedback）</strong></p><p>​openid公司找了40家外包公司，不断帮助gpt筛选什么是好的，什么是坏的，通过这种方式构建了一个奖励（reward）模型。</p><p>​这样训练是为了让他学会举一反三的规律，开始出现类似人类的价值价值观与思考模式。</p><p>​于是gpt通过这样奖励模型，开始感知到真实世界，开始了与真实世界的拟合。甚至可以说奖励模型就是gpt的母体，他对人类的理解不取决于世界，而是取决于模型。</p><p>​这样引导学习的方式，在超大模型上出现惊人的效果，gpt在巨量的数据与规范 + 手动标注引导下，变成了看起来有心智的超级人工智能，甚至出现了理解、例子、思维链的能力。</p><p>​这样的方式也是存在缺点的，比如缺点是可能混淆记忆，无法直接查看个更新所学，并且高度依赖学习材料</p><img src="https://www.vkcyan.top/FgOCZQEw2fTJZsn40Q_b5KP5EvZy.png" style="zoom:50%;" /><h2 id="GPT对现今社会的可能影响"><a href="#GPT对现今社会的可能影响" class="headerlink" title="GPT对现今社会的可能影响"></a>GPT对现今社会的可能影响</h2><p>​chatGPT是里程碑的产品，就像流浪地球里面的行星发动机，刚开始大家都都不知道其潜力，经过验证后，地球上迅速出现了几万座行星发动机，并完成了最后的流浪地球，chatGPT这样大语言模型就像最开始几座行星发动机 ，最终也将会形成改变我们生活的推力</p><p>​合理的使用大预言模型，就可以让一个普通人快速准确的触及各行各业的平均知识， 以及具体解法</p><p>​所以我们可以畅想，未来我们也许不在需要学习如何打架，只需要对gpt发号施令，让机器去具体的做事即可</p><p>​除了chatGPT本身具备对人类的能力输出，chatGPT具备我们人类不具备的一点，那就是他可以在语言中学会世界知识。</p><p>​人脑是有限的，寿命是有限，个体死亡，一切都会消失，直到语言的发明，打通了过去与未来，知识以文字作为载体传承至今，一直以来我们通过纸质、或者其他物理形式进行存储，其效率是有限的，直到计算机的出现，我们开始用电子文档替代纸质， 信息传递的效率飞速提升，但是同时也带来了信息处理的巨大成本。</p><p>​所以人工智能领域的自然语言技术应运而生（NLP），其目标就是让机器理解人类的语言，协助人类处理工作，这是人工智能领域非常重要的发展方向，虽然这些年发展缓慢，但是依旧被很多公司加以厚望，因为机器不需要作息，没有情绪，效率极高，可以为企业节省大量的成本。</p><h2 id="与行业结合的可能性"><a href="#与行业结合的可能性" class="headerlink" title="与行业结合的可能性"></a>与行业结合的可能性</h2><ul><li>搜索引擎，帮助用户更加精准的筛选信息</li><li>笔记工作结合，辅助阅读与写作</li><li>办公软件结合，辅助文字处理，数据分析，演示制作</li><li>教育培训结合，指定学习计划，寻找学习资料</li><li>开发工具结合，辅助编写业务代码，调试纠错</li><li>客服系统结合，全天候问答，</li><li>视频会议结合，会议记录，总结，谈话查找</li><li>审核机制结合，少选评论，统计舆论，给出提醒</li><li>行业顾问，提供法律，医疗，健身等等建议</li><li>社交媒体结合，帮助寻找兴趣相投的用户与话题</li><li>与视频音乐结合，个性化推荐视频、音乐、小说、动漫</li><li>游戏剧情结合，让NPC给玩家带来更加灵活的对话体验</li></ul><h2 id="GPT具备对文字行业巨大的改造潜力"><a href="#GPT具备对文字行业巨大的改造潜力" class="headerlink" title="GPT具备对文字行业巨大的改造潜力"></a>GPT具备对文字行业巨大的改造潜力</h2><ul><li>学术界 创造知识</li><li>教育行业 传承知识</li><li>新闻行业 传播知识</li></ul><p>​还有对传统教育行业的巨大挑战，不是GPT可以给学生写作业，而是对现有的人才教育模式存在很大的冲击。</p><p>​按照现在的教育模式（应试教育，传授既有知识）出来的学生，还能应对未来的5-10年的社会需求吗？</p><p>​其实现在已经不太符合了，因为社会变化太快了，以前人们可以通过学习的知识终生受益，现在能满足毕业后5年其实都比较难了，因为知识过时的太快了，人们就需要不断学习新的知识。</p><p>​正因如此，随着互联网时代的到来，终生学习的理念开始被人们推崇，同时教育模式也开始以【培养学习能力与创造能力】为主了，只有这样才能适应不断变化的时代。</p><pre><code> 试想一下你学习了20年，掌握了一些知识，但是GPT却可以瞬间替代你完成你的能力，怎么办？以后人人都有一个熟读人类既有知识的超级大脑，市场不会因为学校的禁用，而集体不使用。</code></pre><p>​任何事物都存在两面性，好的一面是，GPT将方便人来对既有知识进行集成，推进教育去培养高层次人才</p><h2 id="GPT对网络安全的巨大挑战"><a href="#GPT对网络安全的巨大挑战" class="headerlink" title="GPT对网络安全的巨大挑战"></a>GPT对网络安全的巨大挑战</h2><p>​因为GPT的第一阶段，需要大量录入信息，这其中的信息难免会存在一个坏的信息，亦或者军事机密等等信息，所以国家与国家之间很难愿意共享数据，这也意味着，在不就得将来每个有实力的国家都会自己研发大语言模型</p><p>​同时在应用层面，大预言模型将会像口语、文字、电脑、互联网对社会进行再一次改造。</p><h2 id="社会影响"><a href="#社会影响" class="headerlink" title="社会影响"></a>社会影响</h2><p>​只有会工具的人取代不会使用工具的人，没有工具取代人的说法，所以真正需要害怕的是，我们成为无法成为使用工具的人，时代的车轮势不可挡，抵触新工具就意味着落后，学20年干一辈子的时代已经逐渐远去，我们身处加速时期，必须学会终生学习</p><p>​GPT正在改变人类群体应用知识的方式与继承知识的方式，甚至未来可能会形成人机合作的科研，改变人类创造知识的方式，甚至步入下一个文明形态。</p><p>​每个人的学习能力与理解能力，将是驾驭这项技术的瓶颈，也意味着是否可以充分发挥这一技术的优势，</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>bert（Bidirectional Encoder Representations from Transformers 双向编码变换器）</strong></p><p>​BERT 基于 Transformers 模型架构，使用双向编码器来训练深度双向表示，并在多项自然语言处理任务上实现了最先进的性能</p><p><strong>浅层神经网络（Shallow Neural Network）</strong></p><p>​浅层神经网络是一种神经网络，它只有一层或几层隐层，通常用于浅层特征学习和分类任务。与深层神经网络相比，浅层神经网络的参数量少，计算速度较快，但也可能会受到学习能力和表示能力的限制。</p><p><strong>【UL】无监督学习（Unsupervised Learning）</strong></p><p>​无监督学习是一种机器学习的范畴，其目的是在没有明确的标签或目标函数的情况下，从数据中发现隐藏的结构和规律。在无监督学习中，模型需要从数据中学习如何将数据分组、降维、聚类等。</p><p><strong>【SL】有监督学习（Supervised Learning）</strong></p><p>​有监督学习是一种机器学习的范畴，其目的是在有标签的训练数据上学习一个模型，使其能够预测新的数据。在有监督学习中，模型需要学习如何将输入映射到输出，并根据标签调整模型参数以提高预测性能。（特定的任务上进行微调，例如情感分析、文本分类、命名实体识别）</p><p><strong>【RL】情景学习（Reinforcement Learning）</strong></p><p>​情景学习是一种机器学习的范畴，其目的是通过试错来学习如何在特定的情景下做出正确的决策。在情景学习中，模型需要学习如何在不断尝试和反馈的过程中最大化累计奖励。</p><p><strong>【NLP】自然语言处理技术（Natural Language Processing）</strong></p><p>​自然语言处理技术是一种人工智能技术，旨在让计算机能够理解和生成自然语言。NLP 技术可以应用于文本分类、情感分析、机器翻译、问答系统等领域。</p><p><strong>【LLM】大语言模型（Large Language Model）</strong></p><p>​大语言模型是一种基于神经网络的自然语言处理模型，它可以处理大量的文本数据，并学习语言的语法和语义。目前的大语言模型通常使用预训练加微调的方式进行训练，并在各种自然语言处理任务中取得了很好的表现。</p><p><strong>【MLLM】多模态大语言模型（Multi modal Large Language Model）</strong></p><p>​多模态大语言模型是一种结合了自然语言处理和计算机视觉等多种模态的模型，旨在解决多模态数据的处理和理解问题。与传统的大语言模型不同，多模态大语言模型可以同时处理文字、图片、声音等不同类型的数据，并学习它们之间的交互和关联，从而提高自然语言处理和视觉任务的性能。</p><p><strong>RLHF（Reinforcement Learning from Human Feedback 从人类反馈中强化学习）</strong></p><p>​这是一种机器学习的方法，旨在通过与人类交互来提高强化学习算法的性能。在 RLHF 中，算法会在执行任务的过程中接收人类反馈，并将其作为一种奖励信号来调整自己的策略。与传统的强化学习不同，RLHF 可以在学习过程中快速地获得关于任务的准确信息，并且更容易被应用于实际场景中，如自动驾驶、机器人控制等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最早&quot;&gt;&lt;a href=&quot;#最早&quot; class=&quot;headerlink&quot; title=&quot;最早&quot;&gt;&lt;/a&gt;最早&lt;/h2&gt;&lt;p&gt;​	自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段</summary>
      
    
    
    
    <category term="日常" scheme="https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/tags/chatGPT/"/>
    
  </entry>
  
  <entry>
    <title>（3.1）vue3 手摸手实现mini版reactive.md</title>
    <link href="https://bluedancers.github.io/2023/03/13/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/"/>
    <id>https://bluedancers.github.io/2023/03/13/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/</id>
    <published>2023-03-12T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:41.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>​在上一节，我们完成了<strong>vue3</strong>的<strong>reactive</strong>的核心源码解读，总的来说还是非常复杂，文章的表现能力有限，我想可能有很多同学无法完全理解其精髓，所以在本节，我将带领大家完成mini版本源码的输出。</p><p>​<strong>仅保留最核心逻辑，极大减低阅读难度，200行代码实现reactive + effect</strong>，话不多说，我们直接开始！</p><p><a href="https://github.com/BlueDancers/vue3-mini/tree/reactive">简易版vue3仓库地址</a>，<strong>还请大家不要吝啬star，留个标记，下次迷路~</strong></p><h2 id="逻辑图"><a href="#逻辑图" class="headerlink" title="逻辑图"></a>逻辑图</h2><p><img src="https://www.vkcyan.top/FmPJt0I04Cs834SauJHg3WgJgy5O.png"></p><h2 id="逻辑流程"><a href="#逻辑流程" class="headerlink" title="逻辑流程"></a>逻辑流程</h2><h3 id="reative初始化"><a href="#reative初始化" class="headerlink" title="reative初始化"></a>reative初始化</h3><p>​将<strong>reactive</strong>处理为<strong>proxy</strong>，同时预先声明<strong>set</strong> <strong>get</strong>方法，赋值、取值均通过<strong>Reflect</strong>完成，<strong>get</strong>中存在<strong>track</strong>（依赖收集），<strong>set</strong>中存在<strong>trigger</strong>（依赖触发），完成<strong>reactive</strong>的初始化。</p><h3 id="effect初始化（依赖收集）"><a href="#effect初始化（依赖收集）" class="headerlink" title="effect初始化（依赖收集）"></a>effect初始化（依赖收集）</h3><blockquote><p>cb  &#x3D; callback &#x3D; 回调函数 effect(() &#x3D;&gt; {})   &#x2F;&#x2F; () &#x3D;&gt; {} 就是cb</p></blockquote><p>​初始化<strong>effect</strong>函数，通过一个类<strong>ReactiveEffect</strong>运行其<strong>cb</strong>，同时将当前<strong>cb</strong>存储到公共变量，<strong>cb</strong>中读取了<strong>reactive</strong>的属性，进而触发<strong>proxy</strong>的<strong>get</strong>，同时完成<strong>track</strong>（依赖收集），让<strong>reative</strong>收集到存储在公共变量中的<strong>effect</strong>的<strong>cb</strong>，至此完成依赖收集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重点：reactive - key - effect // 依赖收集完成后，将会形成这样的从上到下的可追溯关系</span><br></pre></td></tr></table></figure><h3 id="reactive改变（依赖触发）"><a href="#reactive改变（依赖触发）" class="headerlink" title="reactive改变（依赖触发）"></a>reactive改变（依赖触发）</h3><p>​若干时间后，<strong>reactive</strong>属性发生变化，触发<strong>reactive</strong>属性的赋值操作，进而触发<strong>proxy</strong>的<strong>set</strong>事件，同时完成trigger（依赖触发），根据指定的<strong>reative + key</strong>，找到特定<strong>effect</strong>运行，完成依赖触发，形成响应式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重点：reactive + key 找到指定effect，进而完成触发</span><br></pre></td></tr></table></figure><h2 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h2><h3 id="proxy处理"><a href="#proxy处理" class="headerlink" title="proxy处理"></a>proxy处理</h3><p>​经过真实的源码分析之后，我们都知道<strong>reactive</strong>实际上就是<strong>proxy</strong>，我们仿照源码的格式，将<strong>reactive</strong>经过<strong>proxy</strong>处理后返回就好了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存proxy</span></span><br><span class="line"><span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">object</span>, <span class="built_in">any</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(target, mutableHandlers, reactiveMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理被代理对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;<span class="built_in">object</span>&gt;,</span></span><br><span class="line"><span class="params">  proxyMap: <span class="built_in">WeakMap</span>&lt;<span class="built_in">object</span>, <span class="built_in">any</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果已经被代理过,这直接返回结果</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, baseHandlers)</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-set函数编写"><a href="#get-set函数编写" class="headerlink" title="get set函数编写"></a>get set函数编写</h3><p>​以上代码我们完成了变量的<strong>proxy</strong>处理，为了完成后续的响应式，我们需要预先声明好<strong>get set</strong>函数，我们依旧仿照源码格式，并只保留核心逻辑，<strong>get</strong>阶段返回结果，并触发<strong>（依赖收集）track</strong>，<strong>set</strong>阶段通过<strong>Reflect</strong>完成赋值，并触发<strong>（依赖触发）trigger</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> get = <span class="title function_">createGetter</span>()</span><br><span class="line"><span class="keyword">const</span> set = <span class="title function_">createSetter</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    <span class="comment">// 核心逻辑: 依赖收集</span></span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, newValue: <span class="built_in">unknown</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    <span class="comment">// 核心逻辑: 依赖触发</span></span><br><span class="line">    <span class="title function_">trigger</span>(target, key, newValue)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="effect实现"><a href="#effect实现" class="headerlink" title="effect实现"></a>effect实现</h3><p><strong>effect</strong>的核心的实现，就是在运行<strong>effect</strong>的时候<strong>保存当前的this</strong>，以便于后续流程中的<strong>依赖收集</strong>，所以其核心代码非常简单，保证一下2点即可。</p><ul><li>运行effect本身</li><li>保存effect的fn到activeEffect即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> effect&lt;T = any&gt;(<span class="attr">fn</span>: <span class="function">() =&gt;</span> T) &#123;</span><br><span class="line">  <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn)</span><br><span class="line">  _effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">activeEffect</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span>&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public fn: () =&gt; T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集（track）"><a href="#依赖收集（track）" class="headerlink" title="依赖收集（track）"></a>依赖收集（track）</h3><p>按照时序，<strong>effect</strong>函数初始化阶段会执行，<strong>effect</strong>函数本身也会被保存到<strong>activeEffect</strong>中，同时触发<strong>effect</strong>中的<strong>reactive</strong>中的<strong>get</strong>事件，进而触发<strong>track</strong>，我们在<strong>track</strong>中完成 <strong>reactive- key - effect之间关系的构建</strong>，确保以后可以在<strong>set</strong>阶段找到<strong>指定的effet的fn</strong>即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="title function_">createDep</span>()</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">trackEffects</span>(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖触发（trigger）"><a href="#依赖触发（trigger）" class="headerlink" title="依赖触发（trigger）"></a>依赖触发（trigger）</h3><p>若干时间后，<strong>reative</strong>中的某个属性发生了变化，也就会发生<strong>set</strong>事件，这时候其实就很简单了，我们只需要通过<strong>reactive - key</strong>找到对应的<strong>effect的fn</strong>，然后执行即可。</p><p><strong>这就形成了我们看到的“响应式”</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, newValue: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dep</span>: <span class="title class_">Dep</span> | <span class="literal">undefined</span> = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">triggerEffects</span>(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  effect.<span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​到此为止，我们简易版的<strong>reactive + effect</strong>的全部源码就完成了，虽然<strong>vue3</strong>的源码很复杂，但是我们抽丝剥茧，仅保留核心逻辑，大幅降低<strong>vue3</strong>源码阅读的难度，让绝大多数的前端开发者都可以读懂核心实现~</p><p>​最后，建议大家<a href="https://github.com/BlueDancers/vue3-mini/tree/reactive">clone</a>源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，然后在简历上留下浓墨重彩的一笔~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;​	在上一节，我们完成了&lt;strong&gt;vue3&lt;/strong&gt;的&lt;strong&gt;reactive&lt;/strong&gt;的核心</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>（7）vue3 runtime-dom源码解析</title>
    <link href="https://bluedancers.github.io/2023/02/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%887%EF%BC%89vue3%20runtime-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/02/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%EF%BC%887%EF%BC%89vue3%20runtime-dom%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-17T16:00:00.000Z</published>
    <updated>2023-11-27T02:38:45.025Z</updated>
    
    <content type="html"><![CDATA[<p>html叫做DOM节点数</p><p>vdom是正式dom的JavaScript数据结构的描述</p><p>在运行时runtime中，渲染器rerender会遍历整个虚拟dom树，并根据此结构构建正式dom树，这个过程我们称之为mount</p><p>当vnode发生变化的时候，，我们会对比旧的vnode与新的vnode，找出他们的区别，并应用于真实dom上，这个过程我们称之为patch。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;html叫做DOM节点数&lt;/p&gt;
&lt;p&gt;vdom是正式dom的JavaScript数据结构的描述&lt;/p&gt;
&lt;p&gt;在运行时runtime中，渲染器rerender会遍历整个虚拟dom树，并根据此结构构建正式dom树，这个过程我们称之为mount&lt;/p&gt;
&lt;p&gt;当vnode发生</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）</title>
    <link href="https://bluedancers.github.io/2023/02/17/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/webpack%E3%80%81vite%E5%9C%A8proxy%E4%B8%AD%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEheaders/"/>
    <id>https://bluedancers.github.io/2023/02/17/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/webpack%E3%80%81vite%E5%9C%A8proxy%E4%B8%AD%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEheaders/</id>
    <published>2023-02-16T16:00:00.000Z</published>
    <updated>2023-02-18T08:16:39.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）"><a href="#通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）" class="headerlink" title="通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）"></a>通过webpack、vite实现proxy headers的动态设置（高某强看后都要请我吃鱼）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都知道，利用<strong>webpack、vite</strong>的<strong>proxy</strong>可以解决开发环境的跨域问题。</p><p>但是在真实开发场景下，我们可能不仅要面对跨域问题，还有可能面对<strong>动态header</strong>的情况。</p><p>让我们来看如下案例</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>强盛集团开发了一套<strong>多店铺的H5商城系统</strong>，此时小安 小龙 小虎，都想利用这个系统开一个线上商城，我们如何区分他们的店铺呢？</p><p>聪明的同学肯定已经想到了答案，用二级域名进行区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小安 -&gt; xa.shop.com</span><br><span class="line">小龙 -&gt; xl.shop.com</span><br><span class="line">小虎 -&gt; xh.shop.com</span><br></pre></td></tr></table></figure><p>接下来让我们把视角聚焦到强盛集团的技术部门。</p><p>面对这样的多店铺商城系统，开发环境肯定无法用ip直接访问了，因为ip无法识别具体是什么店铺。</p><p>这个问题其实也很好解决，修改本地host即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 xa.shop.com</span><br><span class="line">127.0.0.1 xl.shop.com</span><br><span class="line">127.0.0.1 xh.shop.com</span><br></pre></td></tr></table></figure><p>假设我们开发环境的端口是8082，我们想在开发环境访问小安的店铺，则通过<code>xa.shop.com:8082</code>进行访问。</p><p>​直到某一天，安全部门发现了沙海集团的的scrf恶意攻击，决定限制该产品请求发起方的<strong>Origin Header</strong>与<strong>Referer Header</strong>，并且限制了必须是80端口。</p><blockquote><p>这两个请求头的含义是标记来源域名，可以起到防止scrf攻击的目的。</p></blockquote><p>​此时前端开发就麻烦了，因为在开发环境，我们的<strong>Origin Header</strong>与<strong>Referer Header</strong>都是<strong>x.shop.com:8082</strong>，这会被服务端识别为不合法的请求来源，同时因为浏览器安全限制，前端是不具备直接修改<strong>referer</strong>头的能力， 除非将项目端口号改为80端口，但是这并不是一个好办法。</p><p><strong>如果你是强盛集团的前端开发，你会怎么解决以上问题呢？</strong></p><h2 id="后端高某强提供的思路"><a href="#后端高某强提供的思路" class="headerlink" title="后端高某强提供的思路"></a>后端高某强提供的思路</h2><p>​后端开发高某强这时候提供了一个想法，通过本地nginx代理8082端口就好了呀。</p><ol><li>在开发机器本地启动一个<strong>nginx</strong></li><li>通过<strong>nginx</strong>将<strong>x.shop.com</strong>指向<strong>127.0.0.1:8082</strong></li><li>同时配合<strong>host</strong>的修改，实现开发环境去端口的诉求。</li></ol><p>后续，我尝试了这个方案，确实是可以实现的，也在团队中推广并使用了一段时间；</p><p>但是长期使用下就暴露了一些问题</p><ol><li>每次新增一个站点，都需要同时增加host、nginx中的配置，流程复杂。</li><li>并不是每个前端都了解nginx，初级开发非常容易出问题，增加团队内耗。</li></ol><h2 id="proxy解决方案"><a href="#proxy解决方案" class="headerlink" title="proxy解决方案"></a>proxy解决方案</h2><h3 id="Vite解决方案"><a href="#Vite解决方案" class="headerlink" title="Vite解决方案"></a>Vite解决方案</h3><p>​直到某一天，我在<strong>vite</strong>的文档中突然发现一个细节，<strong>server.proxy</strong>的实现依赖<a href="https://github.com/http-party/node-http-proxy">node-http-proxy</a>，而这个库具备<strong>设置请求头的能力</strong></p><p><img src="https://www.vkcyan.top/Fl8GqobFWoDlUT-UZTrUN43npq1H.png"></p><p>​如果是这样，我是否可以在开发环境通过proxy代理请求接口，同时覆写<strong>Origin Header</strong>与<strong>Referer Header</strong>的方式来解决我们遇到的多域名+端口限制问题呢？进而在开发环境规避掉nginx。</p><p>​通过<strong>vite</strong>的问题可以了解到参数<strong>configure</strong>可以编写<strong>http-proxy</strong>相关逻辑，再结合<strong>http-proxy</strong>文档，我们便可以完成相关代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;/client&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;https://api.xxxx.com&#x27;</span>, <span class="comment">// 需要代理的地址</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">true</span>, <span class="comment">// 如果是https接口，需要配置这个参数</span></span><br><span class="line">      <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/client/</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      <span class="attr">configure</span>: <span class="function">(<span class="params">proxy</span>) =&gt;</span> &#123;</span><br><span class="line">        proxy.<span class="title function_">on</span>(<span class="string">&#x27;proxyReq&#x27;</span>, <span class="function">(<span class="params">proxyReq, req, res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// req是当前真实请求的地址 开发环境为：a.shop.com:8082</span></span><br><span class="line">          <span class="keyword">let</span> host = req.<span class="property">headers</span>.<span class="property">host</span>!.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>] <span class="comment">// a.shop.com 动态获取当前请求地址，并去除端口</span></span><br><span class="line">          proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;referer&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>)</span><br><span class="line">          proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;origin&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="comment">// .....</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​测试结果符合预期，<strong>web</strong>端请求被<strong>proxy</strong>代理，并在代理请求中完成了端口的去除，符合了服务端对<strong>Origin Header</strong>与<strong>Referer Header</strong>的要求。</p><h3 id="Webpack解决方案"><a href="#Webpack解决方案" class="headerlink" title="Webpack解决方案"></a>Webpack解决方案</h3><p>​<strong>vite</strong>测试成功后，我们便开始对<strong>webpack</strong>的<strong>vue2.x</strong>项目<strong>proxy</strong>动态<strong>headers</strong>进行评估；通过<strong>webpack4</strong>的文档，我们可以了解到<strong>webpack4</strong>的<strong>proxy</strong>是基于<a href="https://github.com/chimurai/http-proxy-middleware">http-proxy-middleware</a> 进行实现。</p><p>​接下来我们也顺利在<strong>http-proxy-middleware</strong>文档中找到相关配置</p><p><img src="https://www.vkcyan.top/Fh7xKiiJnus0ciu_JRlUfqO7Wyk9.png"></p><p>我们基于<strong>webpack</strong>与<strong>http-proxy-middleware</strong>的文档，就可以很顺利的做产出了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;/client&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;https://api.xxxx.com&#x27;</span>, <span class="comment">// 需要代理的地址</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">true</span>, <span class="comment">// 如果是https接口，需要配置这个参数</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/client&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">onProxyReq</span>: <span class="function">(<span class="params">proxyReq, req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> host = req.<span class="property">headers</span>.<span class="property">host</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;referer&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>) <span class="comment">//添加请求头</span></span><br><span class="line">        proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;origin&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;host&#125;</span>`</span>) <span class="comment">//添加请求头</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​项目配置完成后，我们便可以在开发环境利用proxy的动态headers完成<strong>a.shop.com:8082</strong>正常访问线上端口了，只需要在本地配置host即可。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>高某强了解到前端部门使用<strong>proxy + 动态headers方案</strong>后，连连称赞，表示请我去他家吃鱼。</p><p>如果你也遇到了类似的问题，快来试试proxy的解决方案吧~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）&quot;&gt;&lt;a href=&quot;#通过webpack、vite实现proxy-headers的动态设置（高某强看后都要请我吃鱼）&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="日常开发" scheme="https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="关于proxy" scheme="https://bluedancers.github.io/tags/%E5%85%B3%E4%BA%8Eproxy/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（5）ref源码解析</title>
    <link href="https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%20ref%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%20ref%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-02T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:46.861Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​本文是<a href="https://juejin.cn/column/7199826518570172472"><strong>Vue3硬核源码解析系列</strong></a>的第五篇文章，在之前文章中，我们了解到了<strong>reactive effect</strong>的源码实现原理，并抽丝剥茧输出了<a href="https://juejin.cn/post/7209967260898033722">mini版本的reactive + effect</a>，带领大家充分理解<strong>reactive</strong>的实现原理，同时我们也发现了<strong>reactive</strong>在使用上的一些局限性，比如无法代理基础类型。</p><p>​正因为此，<strong>Vue3</strong>提供了另一个API <strong>ref</strong>，面对<strong>proxy</strong>无法代理基础类型数据的问题，<strong>ref</strong>又是如何实现其响应式的呢，本文将带领大家一起走进vue3源码世界，看看<strong>ref</strong>的实现原理</p><h2 id="逻辑图"><a href="#逻辑图" class="headerlink" title="逻辑图"></a>逻辑图</h2><p>因为<strong>ref</strong>既可以传入<strong>基础类型</strong>，也可以传入<strong>复杂类型</strong>，所以其实现逻辑要比<strong>reactive</strong>更加复杂，并且依赖<strong>reactive</strong>。</p><p><img src="https://www.vkcyan.top/FkmdQj_dyMoiD6Rg7PaH-Lf7FdHO.png"></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>如果关于class get set已经很了解，请跳过前置知识</p></blockquote><p>为了降低大家理解<strong>ref</strong>源码的难度，我们在正式阅读源码之前，先学习一下JavaScript的 <strong>class</strong>以及修饰符<strong>get set</strong>相关知识点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  _value = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value的get行为触发&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value的set行为触发&#x27;</span>, val)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Obj</span>()</span><br></pre></td></tr></table></figure><p>get： 被get修饰的方法，允许通过<strong>属性读取</strong>的方式，触发方法</p><p>set： 被set修饰的方法，允许通过<strong>属性赋值</strong>的方式，触发方法</p><p>当访问<code>obj.value</code>的时候，会执行被<strong>get</strong>修饰的<strong>value()<strong>，打印log，并得到返回值</strong>‘张三’</strong></p><p>当我们执行<code>obj.value = ’李四‘</code>，进行赋值的时候，将会执行被<strong>set</strong>修饰的**value()**方法，打印log，并完成变量_value的赋值</p><p>​看到这里，大家是否有点似曾相识的感觉，<strong>访问与赋值触发get set</strong>，和<strong>proxy</strong>代理的对象的<strong>get set</strong>很相似，大家能理解到这一点就足够了。</p><p>​因为ref可以代理<strong>简单类型</strong>，同时也可以代理<strong>复杂类型</strong>，并且这两种情况下的响应式实现逻辑是完全不同的。</p><p>​所以接下来，我们从这两个角度分别解读ref的源码实现，以及其核心逻辑。</p><p>​首先我们看相对简单的基础类型场景，从源码的角度去了解ref是如何实现响应式的。</p><h2 id="基础类型场景"><a href="#基础类型场景" class="headerlink" title="基础类型场景"></a>基础类型场景</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ref, effect &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;卖鱼强&#x27;</span>)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = name.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  name.<span class="property">value</span> = <span class="string">&#x27;狂飙强&#x27;</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>​上述代码现象：</p><ol><li><p>页面初始化的时候显示“卖鱼强”</p></li><li><p>2s之后，<strong>name</strong>发生改变，变成了“狂飙强”。</p></li></ol><p>通过<strong>现象</strong>与我们之前分析<strong>reactive</strong>的经验，这个我们可以将<strong>ref</strong>的实现分为三大模块</p><ol><li><strong>初始化</strong></li><li><strong>读取</strong>（依赖收集）</li><li><strong>赋值</strong>（依赖触发）</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>packages/reactivity/src/ref.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ref 实际上就是createRef</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue: <span class="built_in">unknown</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果已经是ref，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ref API 参数shallow 为 false 含义是 代理是否是浅层的,浅层则只会代理第一层数据</span></span><br><span class="line">  <span class="comment">// ref 就是RefImpl的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T <span class="comment">// 被代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T <span class="comment">// 原始对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span> <span class="comment">// Dep是reative阶段声明的Set, 内部存放的是ReactiveEffect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span> <span class="comment">// 将RefImpl实例默认为true, 未来的isRef判断就一定为true</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123; </span><br><span class="line">    <span class="comment">// 寻找原始类型，如果是基础类型不会做任何处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = <span class="title function_">toRaw</span>(value) </span><br><span class="line">    <span class="comment">// 如果value是基础类型，toReactive内部不会做任何处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    newVal = <span class="title function_">toRaw</span>(newVal)</span><br><span class="line">    <span class="comment">// 判断新旧值是否一致，不一致进入if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="comment">// 每次value的值发生修改的时候，都保存一下原始对象</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">     <span class="comment">// 如果value是基础类型 toReactive不会做任何处理</span></span><br><span class="line">     <span class="comment">// 如果value是复杂类型，则重新进行proxy处理</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 依赖触发，后面单独说</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码分析，我们可以发现，<strong>ref</strong>的本质就是<strong>new RefImpl</strong></p><p>我们ref传入的参数 原始对象被保存到_rawValue，同时将参数（“卖鱼强”）保存到-value中，便于后续的get set</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>调用<code>name.value</code>的时候，会触发<strong>RefImpl</strong>的**get value()**，方法内部返回最新的_value，完成读取。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// trackRefValue(this) // 依赖收集，后面单独说</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p><code>name.value</code>发生赋值的时候，会触发<strong>RefImpl</strong>的**set value()**方法，方法内部进行_value的赋值，完成数据更新。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断新旧值是否一致，不一致进入if</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果value是基础类型 toReactive不会做任何处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triggerRefValue(this)// 依赖触发，后面单独说</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，<strong>ref</strong>的基础逻辑就完成，我们已经具备给<strong>ref</strong>赋值、读取的能力。</p><p>但是还不具备响应式的能力，接下来就让我们看看，ref的响应式系统是如何实现的。</p><h3 id="依赖收集（trackRefValue）"><a href="#依赖收集（trackRefValue）" class="headerlink" title="依赖收集（trackRefValue）"></a>依赖收集（trackRefValue）</h3><p>​根据我们解读<strong>reactive</strong>的源码经验，我们可以猜到，<strong>ref</strong>一定是在<strong>get</strong>中完成依赖收集的，事实也是如此。</p><p>​而第一次<strong>ref</strong>的<strong>get</strong>是何时触发的呢？</p><p>​答案是初始化时期的<strong>effect</strong>，<strong>effect</strong>触发后，内部<strong>fn</strong>被保存到<strong>activeEffect</strong>中，并触发<strong>fn</strong>，<strong>fn</strong>访问了<code>name.value</code>，触发了<strong>ref</strong>的<strong>get</strong>行为，所以接下来我们前往<strong>RefImpl</strong>的<strong>get</strong>中，看看<strong>ref</strong>是如何完成依赖收集的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖收集函数 将当前RefImpl实例传入方法</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref</span>) &#123;</span><br><span class="line">  <span class="comment">// shouldTrack一定为true，activeEffect在effect执行阶段保存了fn，所以一定存在</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="comment">// createDep我们在reactive中见过，含义为创建一个Set</span></span><br><span class="line">    <span class="comment">// 所以这个实际函数是给RefImpl实例的dep赋值为Set，然后在传入trackEffects方法</span></span><br><span class="line">  <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep,</span>) &#123;</span><br><span class="line">  <span class="comment">// 将当前activeEffect，也就是effect的fn，保存到当前RefImpl实例的dep中，effect成功被ref依赖收集到实例的dep中</span></span><br><span class="line"> dep.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上源码，我们可以发现，他们都公用了<strong>activeEffect</strong>部分的逻辑，但是<strong>ref</strong>收集依赖的方式与<strong>reactive</strong>是存在一些差别的</p><ul><li><strong>reactive</strong>的依赖收集通过<strong>WeakMap</strong>完成，实现<strong>属性、变量与effect fn</strong>的绑定关系</li><li><strong>ref</strong>则通过自身实例内部的<strong>dep</strong>变量来保存所有相关的<strong>effect fn</strong></li></ul><h3 id="依赖触发（triggerRefValue）"><a href="#依赖触发（triggerRefValue）" class="headerlink" title="依赖触发（triggerRefValue）"></a>依赖触发（triggerRefValue）</h3><p>若干时间后，<code>name.value</code>的值被修改，触发<strong>RefImpl</strong>的<strong>set value</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断传入值是否与原始值不一致</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">    <span class="comment">// 完成赋值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">    <span class="comment">// 依赖触发</span></span><br><span class="line">    <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ref.<span class="property">dep</span>) &#123; <span class="comment">// dep为依赖收集阶段收集到的依赖，内部为effect的fn</span></span><br><span class="line">    <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = <span class="title function_">isArray</span>(dep) ? dep : [...dep] <span class="comment">// 转为数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="comment">// 进入依赖触发函数</span></span><br><span class="line">      <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  <span class="comment">// 依次通过run触发被收集的effect的fn，至此完成依赖触发工作</span></span><br><span class="line">  effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖触发的逻辑就非常简单了，<strong>set value</strong>的同时，获取当前<strong>ref</strong>的<strong>dep</strong>，并遍历<strong>dep</strong>中的依赖，依次执行，完成依赖触发。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​到此为止，我们基础类型场景的<strong>ref</strong>源码解读就结束了，我们简单做一下总结，</p><p>​相比较于<strong>reactive</strong>，该场景下的逻辑要稍微简单一点，相关依赖<strong>（effect fn）</strong>被实例本身的<strong>dep</strong>管理，没有构建复杂的<strong>WeakMap</strong>对象。</p><p><strong>ref</strong>与<strong>reactive</strong>的收集与触发的逻辑也不相同</p><ul><li>ref实际上是一个<strong>class</strong> <strong>RefImpl</strong>的实例</li><li>数据响应并不是通过<strong>proxy</strong>实现，而是通过<strong>class</strong> 的<strong>get</strong> <strong>set</strong>修饰符实现</li><li>依赖收集、触发并不是通过<strong>WeakMap</strong>实现，而是通过<strong>RefImpl</strong>实例中的变量<strong>dep</strong>实现</li></ul><h2 id="复杂类型场景"><a href="#复杂类型场景" class="headerlink" title="复杂类型场景"></a>复杂类型场景</h2><p>​大家都知道<strong>ref</strong>不仅可以实现基础类型的响应式，还可以实现复杂类型的响应式，我们可以说<strong>ref</strong>是<strong>reactive</strong>的超集，那<strong>ref</strong>是如何实现既支持基础类型也支持复杂类型的呢？</p><p>​接下来就让我们看看复杂类型场景下的<strong>ref</strong>是如何完成响应式的吧。</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ref, effect &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = obj.<span class="property">value</span>.<span class="property">name</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span></span><br><span class="line">&#125;, <span class="number">4000</span>)</span><br></pre></td></tr></table></figure><h3 id="Ref初始化"><a href="#Ref初始化" class="headerlink" title="Ref初始化"></a>Ref初始化</h3><p>首先依旧是进入<strong>ref</strong>函数中，开始<strong>new RefImpl</strong>，前面流程完全一致，所以直接我们进入<strong>RefImpl</strong>内部</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T <span class="comment">// 被代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span> <span class="comment">// Dep是reative阶段声明的Set,内部存放的是ReactiveEffect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span> <span class="comment">// 将RefImpl的实例全部置为true,下次isRef判断就会为true</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = <span class="title function_">toRaw</span>(value) <span class="comment">// toRaw 获取原始数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(value) <span class="comment">// 跳转到toReactive函数中 并且最终会获取到一个proxy对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toReactive = &lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>&gt;(<span class="attr">value</span>: T): <span class="function"><span class="params">T</span> =&gt;</span></span><br><span class="line">  <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value <span class="comment">// value为object，进入reactive(value)逻辑 最终返回一个proxy的对象</span></span><br></pre></td></tr></table></figure><p>​在<strong>constructor</strong>逻辑中，我们可以看到<strong>this._value &#x3D; toReactive(value)<strong>，而</strong>toReactive</strong>函数中，会首先识别<strong>value</strong>类型，如果不是<strong>object</strong>，原路返回，如果是<strong>object</strong>，将会被<strong>reactive</strong>函数处理，所以在该场景下，<strong>value</strong>将被<strong>reactive</strong>函数处理成<strong>proxy</strong>对象。</p><p>​也就是说，此时<strong>ref</strong>内部的**_value<strong>实际上成了</strong>reactive**类型。</p><h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><p>​初始化阶段，<strong>effect</strong>触发的时候，将会读取<strong>obj.value.name</strong>，，首先会访问量<strong>obj.value</strong>，触发<strong>ref</strong>的<strong>get</strong>方法。</p><p>​<strong>obj.value</strong>获取完成后，继续去获取<strong>obj.value.name</strong>，而<strong>name</strong>已经在初始化阶段，被<strong>toReactive</strong>处理成了<strong>proxy</strong>，所以接下来，会再触发<strong>reactive</strong>的<strong>get</strong>，来获取<code>name</code></p><p>​也就是说，读取阶段，实际上触发了2次<strong>get</strong>，一次是<strong>ref</strong>的<strong>get value</strong>，一次是<strong>proxy</strong>的<strong>get</strong>，进而完成了变量的读取。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// trackRefValue(this) // 依赖收集，后面单独说</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span> <span class="comment">// 获取到proxy类型的&#123;name: &#x27;张三&#x27;&#125;，进而再次触发proxy的get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h3><p>若干时间后，<strong>obj.value.name</strong>发生<strong>set</strong>行为，首先依旧会触发<strong>ref</strong>的<strong>get</strong>，获取<code>obj.value</code>，然后再触发<strong>reactive</strong>的<strong>set</strong>方法，完成<strong>name</strong>的赋值。</p><p>整个赋值过程，实际上分别触发了ref的<strong>get value</strong>，和proxy的<strong>set</strong>，进而完成变量的赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ref 本身的set在value为object，并且没有直接修改ref.value的情况下，不会被触发</span></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们了解了ref在处理复杂对象时候的读取与赋值的逻辑。</p><p>读取：<strong>先触发ref的get，再触发proxy的get</strong></p><p>赋值：<strong>先触发ref的get，再触发proxy的set</strong></p><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>依赖收集是在<strong>get</strong>阶段进行完成，而通过上面的分析我们可以了解到，<strong>ref</strong>的<strong>get</strong>实际上其内部是两次<strong>get</strong>事件，所以我们分开来看。</p><h4 id="ref的依赖收集（trackRefValue）"><a href="#ref的依赖收集（trackRefValue）" class="headerlink" title="ref的依赖收集（trackRefValue）"></a>ref的依赖收集（trackRefValue）</h4><p>effect初始化阶段执行的时候，会读取<code>obj.value.name</code>，首先会触发<strong>ref</strong>的<strong>get</strong>方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖收集函数 将当前ref本身传入方法</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ref</strong>的<strong>get</strong>方法触发了<strong>trackRefValue</strong>，会在当前<strong>ref</strong>的<strong>dep</strong>中收集到<strong>effect</strong>，此处逻辑与<strong>ref</strong>为基础类型的逻辑一致。</p><h4 id="proxy的依赖收集（track）"><a href="#proxy的依赖收集（track）" class="headerlink" title="proxy的依赖收集（track）"></a>proxy的依赖收集（track）</h4><p>​<strong>ref</strong>的的<strong>get</strong>完成后，紧接着触发了<strong>reactive</strong>的<strong>get</strong>，然后<strong>get</strong>内部通过<strong>WeakMap</strong>再次完成依赖收集（相关逻辑参考<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>）。</p><p>​我们会发现，在该阶段，我们内部实际上<strong>触发了2次依赖收集</strong>，<strong>effect fn</strong>被<strong>ref</strong>收集的同时，也被<strong>proxy</strong>收集了。</p><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p>因为ref内部是一个对象，所以赋值也存在多种方式，这依赖触发存在多种方式</p><h4 id="对象属性触发依赖"><a href="#对象属性触发依赖" class="headerlink" title="对象属性触发依赖"></a>对象属性触发依赖</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span></span><br></pre></td></tr></table></figure><p>这种<strong>不会破坏RefImpl初始化阶段其内部构建的proxy</strong>，仅修改已有<strong>proxy</strong>内部变量的值。</p><p>首先触发的是<strong>obj.value</strong>的<strong>get</strong>行为（此时没有<strong>effet</strong>在执行，不会发生依赖收集）。然后<strong>ref</strong>的<strong>get</strong>函数返回<strong>proxy</strong>对象 <code>&#123;name:&#39;卖鱼强&#39;&#125; </code>，紧接着触发<strong>proxy</strong>的<strong>set</strong>，并完成依赖触发（proxy的依赖触发请看这里<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>）。</p><h4 id="对象触发依赖"><a href="#对象触发依赖" class="headerlink" title="对象触发依赖"></a>对象触发依赖</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">value</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;狂飙强&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式首先触发<strong>obj.value</strong>的<strong>set</strong>行为，同时替换掉ref的值，<strong>注意这会破坏RefImpl初始化构建的_value的proxy</strong>，进而导致<strong>WeakMap</strong>中已有的<strong>依赖关系断裂</strong></p><p>然后执行<strong>triggerRefValue</strong>，触发，ref本身在get阶段收集了相关effect fn，。</p><p>effect fn被触发后，再次触发<strong>ref的get</strong>，<strong>proxy的get</strong>，并帮助<strong>proxy</strong>又重建了与<strong>effect fn</strong>之间的依赖关系。</p><p>这就是为什么存在依赖收集2次的原因。</p><p>到此为止，我们的<strong>ref</strong>核心源码分析就全部完毕了。</p><h2 id="关于ref的一些问题"><a href="#关于ref的一些问题" class="headerlink" title="关于ref的一些问题"></a>关于ref的一些问题</h2><p><strong>Q：为啥一定要.value，不能干掉吗？</strong></p><p>A：非常遗憾，value是去不掉的，因为ref依赖class get set 进行实现，在当前实现的场景下，可以简写为v，但是无法去除</p><p><strong>Q：我是不是可以完全使用ref，不用reactive？</strong></p><p>A：是的，可以完全使用ref，因为ref会根据你传入的类型，自动识别内部是否需要使用reactive，但是读过源码的同学知道ref在处理响应式系统中，存在重复收集依赖的场景，如果你有极致的性能要求，建议复杂类型依旧使用reactive完成，业务开发场景则无所谓。</p><p>如果还有其他问题，请评论区提问~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​通过对ref源码的阅读，我们可以察觉到，如果仅仅聚焦基础类型的ref，其实底层实现还是比较简单的，所以建议有兴趣的同学渐进式的阅读源码，先完成基础类型场景的源码解读，再进行复杂类型的源码解读，这样事半功倍~</p><p>​如果有任何问题，请评论区留言~</p><p>​下一个阶段，我将手摸手带大家完成<strong>mini版本vue3 ref API</strong>，帮助大家深入理解<strong>ref</strong>~</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:151</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue - 源码解读" scheme="https://bluedancers.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（7）有点难的computed源码解析</title>
    <link href="https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89computed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/02/03/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89computed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-02T16:00:00.000Z</published>
    <updated>2023-11-27T02:40:03.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写过vue的同学，写过<strong>computed</strong>的都知道，<strong>computed</strong>会在依赖属性发生变化的时候自动更新结果。</p><p>他有一个重要的特点：<strong>计算值是可缓存的，只有依赖项发生变化的时候，才会重新计算</strong></p><p>而通过之前的文章，我们已经了解了<strong>reactive</strong>，<strong>ref</strong>的实现原理，相信大家已经对<strong>vue3</strong>响应式机制有所了解，今天我们就来了解一下<strong>computed</strong>是如何实现的。</p><blockquote><p>注：computed的源码难度相当大，我会尽力描述清楚其实现原理，如有不足之处，还请见谅</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> showName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;我叫&#x27;</span> + obj.<span class="property">name</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerText</span> = showName.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>​以上代码运行后，我们可以看到如下现象</p><ul><li>页面显示：<strong>我叫张三</strong></li><li>2s后，页面显示<strong>我叫李四</strong></li></ul><p>按照我们之前源码分析的思路，我们依旧从以下三个角度入口</p><ul><li><strong>初始化</strong></li><li><strong>读取（依赖收集）</strong></li><li><strong>赋值（依赖触发）</strong></li></ul><p>接下来就让我们走进computed的源码世界吧~</p><h2 id="computed初始化"><a href="#computed初始化" class="headerlink" title="computed初始化"></a>computed初始化</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> computed&lt;T&gt;(getterOrOptions) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter;</span><br><span class="line">  <span class="keyword">let</span> setter;</span><br><span class="line">  <span class="comment">// 传入的是否是一个方法</span></span><br><span class="line">  <span class="keyword">const</span> onlyGetter = <span class="title function_">isFunction</span>(getterOrOptions)</span><br><span class="line">  <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">    <span class="comment">// 如果是方法, 则直接赋值到getter, 同时屏蔽setter行为</span></span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    <span class="comment">// dev环境下 set函数给予提示</span></span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="variable constant_">NOOP</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是方法,则认为是对象,将对象中的get set分别赋值到getter setter中</span></span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span></span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cRef = <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR)</span><br><span class="line">  <span class="keyword">return</span> cRef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​入口函数的逻辑还是非常简单的，如果传入的是一个匿名函数，这处理为<strong>getter</strong>，如果传入的是对象，这赋值<strong>getter</strong> <strong>setter</strong>，这部分逻辑符合我们对这个API的使用习惯，也解释了computed为何是这样的传参方式。</p><p>​抹平两种传参方式的差异后，<strong>new ComputedRefImpl</strong>，并返回，所以<strong>computed &#x3D; new ComputedRefImpl</strong> ，我们接下来就进入该<strong>Class</strong>中看看吧。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性的响应式也是通过class get set去实现的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span> <span class="comment">// 依赖收集处(effect)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> _value!: T  <span class="comment">// 存储计算属性结果的值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">effect</span>: <span class="title class_">ReactiveEffect</span>&lt;T&gt; <span class="comment">// 存储依赖</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span> <span class="comment">// 所有的计算属性也会被识别为ref</span></span><br><span class="line">  <span class="keyword">public</span> _dirty = <span class="literal">true</span> <span class="comment">// 判断是否需要重新计算</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    getter: ComputedGetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _setter: ComputedSetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    isReadonly: <span class="built_in">boolean</span>, <span class="comment">// 是否只读,如果存在setter,则为false</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 将计算属性的识别为effect，初始化一个ReactiveEffect</span></span><br><span class="line">    <span class="comment">// 初始化阶段仅仅声明 但是却没有触发</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 脏变量（_dirty）的本质就是判断什么时候去触发依赖</span></span><br><span class="line">      <span class="comment">// 脏变量为false的时候才会触发  </span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 触发依赖</span></span><br><span class="line">        <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">computed</span> = <span class="variable language_">this</span> <span class="comment">// 赋值ReactiveEffect中的computed为当前this</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue: T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在<strong>ComputedRefImpl</strong>初始化阶段，我们看到了非常熟悉的api，<strong>ReactiveEffect</strong>，在我们的前面的reactive，ref源码分析中，我们使用这个api来完成关键步骤<strong>依赖收集</strong>，不过这里有些区别，传入了第二个参数，一个匿名函数，目前还无法体现其作用，我们后面再说</p><p>​总的来说，<strong>ComputedRefImpl</strong>初始化阶段，生成了一个<strong>ReactiveEffect</strong>并保存到当前类的<strong>effect</strong>变量中。</p><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>按照我们实例代码，首次访问<strong>effect</strong>初次执行的时候，我们会触发<code>showName.value</code>的<strong>get</strong>，也就是说，会触发<strong>ComputedRefImpl</strong>的<strong>get</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被读取的时候触发</span></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖收集</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// 判断是否需要更新，如果需要则进入函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果更新过，这下一次就不需要更新了，</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// effect的run执行，也就是执行computed的fn，将会得到一次计算属性的结果</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="title function_">run</span>()! </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回computed的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="comment">// 首次computed内部的dep是不存在的，会通过createDep生成一个Set</span></span><br><span class="line">  <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span> || (ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="comment">// 将activeEffect，此时是effect的fn，收集到computed的dep中</span></span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当我们触发<strong>computed</strong>的<strong>get</strong>的时候，首先会触发<strong>trackRefValue</strong>，将当前<strong>activeEffect</strong>收集到ComputedRefImpl的<strong>dep</strong>中，这正是依赖收集，这里effect被收集到了computed的dep中，<strong>建立起了computed与其被依赖项（effect）的联系</strong>。</p><p>​然后判断**_dirty<strong>是否为</strong>true<strong>，默认是</strong>true<strong>，所以进入判断中，首先将</strong>_dirty<strong>改为</strong>false<strong>，下一次则不会进入判断，直接返回</strong>computed**之前的结果，之后再执行computed初始化阶段声明的ReactiveEffect，也就是我们computed本身的effect。</p><p>​<strong>computed</strong>的<strong>effect.run</strong>一旦触发，全局<strong>activeEffect</strong>将会被替换为当前computed的 <strong>effect的fn</strong> ，并且触发<strong>computed</strong>依赖项<strong>obj.name</strong>的<strong>get</strong>，进而触发<strong>proxy</strong>的依赖收集，于是<strong>obj.name</strong>成功收集到了<strong>computed</strong>内部的<strong>effect</strong>，<strong>proxy与computed建立了联系</strong>，同时返回了最新的computed结果。</p><p>​<strong>computed的get行为触发的时候，我们发现computed收集了effect，reactive收集了computed，三者之间建立起了联系。</strong></p><img src="http://www.vkcyan.top/FulT2b9ii1-iTvws8zj2z8vEn0Hn.png" style="zoom:33%;" /><h3 id="关于-dirty"><a href="#关于-dirty" class="headerlink" title="关于_dirty"></a>关于_dirty</h3><p>​现在我要个大家着重讲一下ComputedRefImpl中的这个参数，_dirty是实现计算属性缓存性的关键所在，</p><p>我们假设一下，没有缓存性的computed，是什么样的运行逻辑</p><p>计算属性依赖了变量abc，并返回abc的总和，每个获取计算属性的时候，我都需要计算一次abc的总和，即使abc这三个值没有发生任何变化，就是这样的</p><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p><strong>2s</strong>后，我们触发了<strong>obj.name</strong>的<strong>set</strong>，所以首先触发<strong>obj.name</strong>的依赖触发，此时我们将可以通过WeakMap会找到之前收集到<strong>computed</strong>，我们直接进入依赖触发的逻辑。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span><br><span class="line"><span class="params">  key?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  newValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">deps</span>: (<span class="title class_">Dep</span> | <span class="literal">undefined</span>)[] = []</span><br><span class="line">  deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(key))</span><br><span class="line">  <span class="title function_">triggerEffects</span>(deps[<span class="number">0</span>]) <span class="comment">// 找到了之前收集到的computed中的effect</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照常理来说，我们找到指定依赖之后，就是触发依赖，但是计算属性有所不同，因为计算属性存在“调度器”</span></span><br><span class="line"><span class="comment">// 还记得computed初始化阶段，new ReactiveEffect传递的第二个参数吗?</span></span><br><span class="line"><span class="comment">// 该参数将会被保存到ReactiveEffect的scheduler(调度器)中</span></span><br><span class="line"><span class="comment">// 所以此时的ReactiveEffect中，fn是computed的匿名函数，scheduler是computed初始化阶段new ReactiveEffect的第二个参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep | ReactiveEffect[]</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = <span class="title function_">isArray</span>(dep) ? dep : [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line"><span class="comment">// 调度器的优先级大于run，所以此时会执行调度器逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (effect.<span class="property">scheduler</span>) &#123;</span><br><span class="line">    effect.<span class="title function_">scheduler</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    effect.<span class="title function_">run</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度器代码</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 还记得我们get之后将dirty改为false吗？</span></span><br><span class="line">  <span class="comment">// 此时computed的依赖发生变化，将_dirty改为true，表示下次重新计算</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 触发当前computed中收集了相关effect（依赖触发）</span></span><br><span class="line">    <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefBase&lt;<span class="built_in">any</span>&gt;, newVal?: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 公共依赖触发逻辑</span></span><br><span class="line">  <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// computed的dep中收集的effect触发，再次触发computed的get</span></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖项发生变化的时候activeEffect不存在，所以此处收集不到任何依赖</span></span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// 刚才依赖项发生了变化，所以dirty为true，表示本次需要更新计算属性的结果</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算后dirty改为false 除非依赖项发生变化，否则将不会再重新计算。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 重新计算 computed的结果</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="title function_">run</span>()! </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​计算属性的触发逻辑还是非常复杂的，首先<strong>proxy</strong>的set，触发<strong>computed</strong>的<strong>scheduler（调度器）</strong>，<strong>scheduler</strong>通过<strong>computed</strong>的<strong>dep</strong>找到相关<strong>effect</strong>，<strong>effect的fn</strong>执行又会触发<strong>computed</strong>的<strong>get</strong>，<strong>并与首次完成computed的计算，同时缓存最新的computed的结果</strong>，进而再完成effect的全部逻辑。</p><img src="https://www.vkcyan.top/Fu-QElucOgKlCPvYBJuMIQst0Fuo.png" style="zoom:33%;" /><h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><h3 id="依赖收集阶段"><a href="#依赖收集阶段" class="headerlink" title="依赖收集阶段"></a>依赖收集阶段</h3><ol><li><strong>computed</strong>初始化阶段，通过<strong>ReactiveEffect</strong>进行初始化，并且生成<strong>scheduler（调度器）</strong></li><li><strong>effect</strong>初始化，触发<strong>computed</strong>的<strong>get</strong>，将当前<strong>activeEffect（effect）</strong>收集到<strong>computed</strong>的<strong>dep</strong>中<strong>（computed将effect收集）</strong></li><li>执行<strong>computed</strong>自身逻辑，刷新全局<strong>activeEffect</strong></li><li>进而触发<strong>proxy</strong>的<strong>get</strong>事件触发，将当前<strong>activeEffect（computed）</strong>收集到<strong>WeakMap</strong>中<strong>（proxy将computed收集）</strong></li><li><strong>proxy</strong>的返回值返回<strong>computed</strong>，完成<strong>computed</strong>的计算逻辑</li><li>获取到<strong>computed</strong>结果，完成<strong>effect</strong></li></ol><h3 id="依赖触发阶段"><a href="#依赖触发阶段" class="headerlink" title="依赖触发阶段"></a>依赖触发阶段</h3><ol><li>触发<strong>proxy</strong>的<strong>set</strong>，<strong>set</strong>行为中触发依赖，触发之前保存的<strong>computed</strong>的<strong>调度器scheduler</strong>（proxy找到computed）</li><li><strong>调度器scheduler</strong>触发，<strong>dirty</strong>改为<strong>true</strong>，同时触发<strong>computed</strong>中保存的依赖，其中都是相关<strong>effec</strong>的<strong>fn</strong>。（computed找到effect）</li><li><strong>effect</strong>触发，<strong>fn</strong>执行，触发<strong>computed</strong>的<strong>get</strong>行为</li><li><strong>dirty</strong>为<strong>true</strong>，首次进行计算属性的重新计算（除非依赖项改变，否则下次不会重新计算），返回最新的<strong>computed</strong>结果，</li><li><strong>effect</strong>执行完成</li></ol><h2 id="回答一些问题"><a href="#回答一些问题" class="headerlink" title="回答一些问题"></a>回答一些问题</h2><h4 id="computed如何实现高性能缓存的？"><a href="#computed如何实现高性能缓存的？" class="headerlink" title="computed如何实现高性能缓存的？"></a>computed如何实现高性能缓存的？</h4><p>​通过<strong>调度器scheduler</strong> + <strong>脏值检查_dirty</strong>，实现依赖项不变化，不进行重新计算，依赖项变化后仅执行一次的逻辑，进而实现高性能缓存。</p><h4 id="为什么访问computed需要-value"><a href="#为什么访问computed需要-value" class="headerlink" title="为什么访问computed需要.value"></a>为什么访问computed需要.value</h4><p>​因为我们访问<strong>computed</strong>实际上是访问<strong>ComputedRefImpl</strong>这个<strong>Class</strong>的实例，他的内部通过<strong>get value</strong>返回被访问值，所以我们必须通过**.value**来访问</p><h4 id="简述computed的实现原理？"><a href="#简述computed的实现原理？" class="headerlink" title="简述computed的实现原理？"></a>简述computed的实现原理？</h4><blockquote><p>vue的响应式api都可以从依赖收集 依赖触发2个角度出发阐述其原理实现</p></blockquote><p>依赖收集阶段：computed通过首次get的完成相关effect的依赖收集，首次计算的时候proxy完成computed的依赖收集。</p><p>依赖触发阶段：computed的依赖项发生变化后，会通过proxy找到computed的调度器 scheduler，触发所有effect，effct中再出发computed的get，首次get将进行一次结果运算（后续不在运算，除非computed依赖项发生变化），effect触发完成</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​到此为止，我们<strong>computed</strong>的核心源码就解读完毕了，虽然总体依旧可以从<strong>依赖收集</strong>和<strong>依赖触发</strong>两个角度去理解实现原理，但是新增加的<strong>scheduler（调度器）</strong>与**_dirty（脏值检查）**机制，让逻辑复杂了很多。</p><p>​大家在理解computed源码的时候，一定要多走几遍流程，多捋几遍逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写过vue的同学，写过&lt;strong&gt;computed&lt;/strong&gt;的都知道，&lt;strong&gt;computed&lt;/strong&gt;会在依赖</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
</feed>
