<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vkcya Blog</title>
  
  
  <link href="https://bluedancers.github.io/atom.xml" rel="self"/>
  
  <link href="https://bluedancers.github.io/"/>
  <updated>2024-03-25T08:13:11.639Z</updated>
  <id>https://bluedancers.github.io/</id>
  
  <author>
    <name>bluedancers</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《经济学的思维方式》读书笔记1-3</title>
    <link href="https://bluedancers.github.io/2024/01/20/%E9%98%85%E8%AF%BB/%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881-3%EF%BC%89/"/>
    <id>https://bluedancers.github.io/2024/01/20/%E9%98%85%E8%AF%BB/%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881-3%EF%BC%89/</id>
    <published>2024-01-19T16:00:00.000Z</published>
    <updated>2024-03-25T08:13:11.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《经济学的思维方式》读书笔记1-3"><a href="#《经济学的思维方式》读书笔记1-3" class="headerlink" title="《经济学的思维方式》读书笔记1-3"></a>《经济学的思维方式》读书笔记1-3</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​本书来自于“蜜獾吃书”播客的推荐，我一直都经济学都挺感兴趣的，毕竟经济学涉及到每一个人，也涉及到人的决策，大学里面学过一些微观经济学，但是理解比较浅显，工作多年也深感自己浮于表面，所以趁此机会打算好好读读保罗海恩的《经济学的思维方式》，强加一下自己的经济学思维。</p><h2 id="第一章：经济学的思维方式"><a href="#第一章：经济学的思维方式" class="headerlink" title="第一章：经济学的思维方式"></a>第一章：经济学的思维方式</h2><p>Q：经济学的定义</p><p>A：一套关于选择以及选择产生的意外之果的理论</p><p>Q：介绍优化行为的概念？</p><p>A：在进行选择的时候，个体会不断比较各种行为能为他们带来的额外收益和额外预期成本</p><p>Q：理解个人决策的重要性</p><p>A：所有社会现象都来自于个体的行为和个体之间的互动，而个体在选择行为时只考虑对自身的预期收益和预期成本，而且所谓集体从选择，归根结底仍然是个体的选择。</p><p>Q：介绍产权的概念：产权是经济学游戏的重要规则</p><p>A：产权是经济学游戏的规则中的关键元素，产权通过法律将稀缺资源的所有权分配到个人。</p><p>Q：理解社会互动中“看不见的手”扮演的重要角色</p><p>A：这个看不见的手，实际上都是人们面对不断变化的收益和支出，总是做出最优解的集体行为。</p><ul><li>当人们习惯某件事情后，就很容易讲起视为天经地义，而难以看清它的本质</li><li>人们总是关注失败，而把成功视作理所应当，甚至根本意思不到他的存在。</li><li>高峰时段的交通最大的特点不是堵塞，而是流动，每个人都独立选择自己的路线，相互不商量，驾驶技术参差不齐，风险偏好都不一致，礼貌程度天差地别，但是这样的交通系统不仅没有瘫痪，反而仅仅有条，仿佛有一双看不见的手，在引导车辆的运动，着是社会协作的奇迹</li></ul><p>​一个社会必须完成大量生产活动，而这些活动一非常复杂的方式相互关联。如何鼓励每个人的紧缺采取行动，形成共同体？也就是说社会协作究竟是如何发生的呢？</p><p>​先人在几百年前开始研究这一问题，但是他们他们的社会比我们的要简单的多，也收到了诸多限制，所以直到18世纪</p><p>​思想家才开始思考社会究竟是如何运转：个体仅拥有极为有限的信息，且仅关心自己的利益，然而我们得到的结果并非一团混乱，而是令人惊叹的充满秩序、生产力充沛的社会，为什么会这样呢？</p><p>​亚当斯密毫无疑问是最有洞察力的思想家，在他的时代，大部分受过教育的人都相信，政治统治者必须进行精心的计划，否则整个社会将会退化到贫困和无序，亚当斯密不同意这个观点，他认为社会的运作依赖于某种协作过程。但是，想要驳倒当时的主流看法，他必须把社会协作描述出来，斯密认为，这个过程能够自发运转，不仅不需要政府随时监管，甚至还能抵消与之相左的政府政策。</p><p>​经济学的思维方式：<strong>所有社会现象都产生与个体的行为和相互作用，而个体根据行为给自身带来的预期收益和预期成本进行选择。</strong></p><p>​经济学不仅关于金钱和利润、商业和金融，也不仅研究人们的竞争性行为。事实上，经济学研究所有类型的选择，以及这些选择所产生的意外之果，也就是人们在选择自己行为时没有预料到的副作用。</p><p>​虽然适用于世间万物，但实际这并不是说所有人都是自私、物质，只关心利益，而是一切都取决于如何定义收益与成本，以及他们赋予这些收益和成本的相对价值。</p><p>​实际应用这，经济学的思维主要涉及三个方面 </p><ul><li>行为，强调优化与权衡，或者说取舍</li><li>互动，互动是自发性的，没有超级管理员，互动可以良好的分工进而产生更多价值，现代社会，人人靠专业分工与交换为生。</li><li>结果</li></ul><p>1.5</p><p>​经济学理论认为，你的选择、计划会改变他人的机会；人际互动使各种选择的净收益不断变化，人们再根据这些变化不断相互调整，从而完成社会协作的过程。</p><p>​想象一条高速公路，在2个方向上各有四条车道，所有的入口和出口，都设置到车道的右侧，为什么有些人还有费事换到最左侧行驶呢？因为右侧车速最慢，那离开最有道后，实际会选择剩下三道的那一道呢？根据经济学的理论，每一条车道的净收益都在不断变化，司机会随时关注这些变化，最终所有车道的车速都会一致，以上协调过程能够自发的快速、准确的完成，如果强制每一辆车到指定车道，效率将会远低于自动协作系统的效率。</p><p>​<strong>只要稍稍改变某种选择的经济成本和经济收益，就能让很多人改变自己的行为，这个机制就是市场经济的核心机制。</strong></p><p>1.6 信号</p><p>​要想成功调整自己的行为、适应他人的行为，信息是必不可少的，以路上开车为例子，指示牌、交通灯、转向灯、，简单的行为将信息广播到数不清的人，但是我们通常意识不到这个过程，就像开车的型号，价格也帮助我们决定生产与消费，明确各种选择与权衡，如果没有价格的引导，我们就像失去信号灯一样一样盲目。</p><p>1.7 游戏规则</p><p>​人们通过一套约定俗称的习惯来协调各种目标与计划，这个习惯就是经济系统，要想一个游戏顺利进行，必须满足以下2个条件</p><ul><li>参与者必须大致明白规则并基本同意遵守</li><li>游戏规则需要决定一定稳定性。</li></ul><p>​如果游戏规则不清晰，或者自相矛盾，都会导致游戏的崩溃，人们会既不明白别人希望你做什么也不知道该期待别人做什么，互惠消息无法再缺乏规则的情况下进行，人们会犹豫试图弄清游戏规则，甚至试图破坏并建立对自己有利的新规则。</p><p>1.8 产权是一种游戏规则</p><p>​游戏规则的重头戏是产权，私有产权是市场交换型经济体的根基，所谓私有产权，是指法律以所有权的形式将权利明确分配到具体的个人。私有产权清楚界定了谁在法律上拥有什么。任何人都无权在未经你的同意的情况下使用与改变你的财物，哪怕是给你的汽车装一个更好的音响。</p><p>​此外，人们可以资源的买卖或者交换私有产权，即放弃自己的产权，换取对其他商品或服务的类似产权，所以购买被视为产权的一种交换，交易完成后你拥有了物品的拥有权，卖家则拥有了你支付的现金的所有权。</p><p>​私有产权能够为社会成员提供可靠的信息和激励机制，但是清晰、令人满意的私有产权系统并非一朝一夕的事情，需要相当长的时间进行演化</p><p>1.9 经济理论的偏向性：是长处还是弱点</p><p>​经济学理论并非完美的理论，不能提供一种毫无偏见的意见，不能同时呈现所有事实，不能赋予所有价值观相同的权重。</p><ul><li>经济学总是过于强调个人选择，难道是人们选择成为穷人或者失业吗</li><li>经济学家试图将集体（企业、政府、国家）的选择分解为集体中的个人选择。</li><li>经济学的思维强化优化过程，强调权衡和计算，强调目的手段的一致性，但是人们真的如此精于计算吗？我们的行为难道不是更多的受无意识的欲望和未经权衡的冲动引导。</li><li>经济学的思维方式是一种偏向于市场的思维方式，确实是这样的，经济学家更加喜欢能促成互惠交易和高效生产的社会支付和游戏规则，并让所有参与者获益。</li></ul><p>1.10 是偏见还是结论</p><p>​经济学是一门关于选择以及选择的意外之果的理论</p><p>​很多人对华丽的理论嗤之以鼻，职员椅相信常识和日常经验，但这些人事实上往往相信一些极为模糊笼统的假设，并沦为这些东西受害者。</p><p>​仅仅因为几组事实之间具有统计上的相关性就认为这几组事实之间有某种因果关系，这是一种非常常见的错误思维。</p><p>1.11 经济学家的技能</p><p>​我们可以观察事实，但是要想解释事实发生的原因，就必须建立一套理论，一套关于因果关系的理论。正式有理论的存在，我们才能在大部分情况下从眼花缭乱、头晕目眩的各种事实中找出规律和原因。事实上，我们知道的事情总，只有一小部分来自观察，我们在这里发现一点提示，在那里找到一点线索，剩下的部分都是理论。</p><p>​</p><h2 id="第二章-效率、交换和比较优势"><a href="#第二章-效率、交换和比较优势" class="headerlink" title="第二章 效率、交换和比较优势"></a>第二章 效率、交换和比较优势</h2><p>Q：区分免费商品、稀缺商品和负商品</p><p>A：免费商品是不需要付出任何成本的商品，稀缺商品是需要付出成本的的商品，也要进行取舍，负商品是越少越好的商品</p><p>Q：解释经济效率的概念以及这个概念与主观价值的联系</p><p>A：经济效率是比较各种决策的成本与收益，预期额外收益与预期额外成本之间的关系，这个取决于当事人的价值观</p><p>Q：理解自由交换对交换双方都有益</p><p>A：自由交换可以让双发都获取对自己有价值的产品，自由交换不是等价交换，交换也是另一种形式的生产</p><p>Q：用生产可能性曲线比较优势</p><p>A：生产可能性曲线可以帮助我们找到几乎成本最低的生产方案，实现更多的收益。</p><p>Q：探索中间人在较低交易成本和提供细且信息方面发挥的作用</p><p>A：中间生可以让双方获取更多信息，以及机会，这些信息会增加参与者的收益。他们协调不同地区之间的市场交易，将本地市场整个进入更大的经济系统中</p><p>Q：引入对长期经济增长现象的解释</p><p>A：</p><p>​认为交换不能产生任何真正的收益是一种偏见，人们总是认为从交易中获利的商人一定是对社会进行了某种剥削，农民和工匠生产了所谓真正的产品，而商人似乎并不播种、不劳而获，他们的活动似乎没有创造出任何产品，但是他们竟然从中获利，因此游戏人认为贸易是一种社会浪费。</p><p>​实际上这是一种完全错误的观点，交换是一种能产生效益的生产活动，我们说交换能商城效益是因为这种活动能让人获得更多他们想要的东西。</p><p>2.1 正商品与负商品</p><p>​如果面临选择的人认为某种东西多多益善，那么这种东西就是一种正商品</p><p>​免费商品是指不需要做出任何医生就能获得到的商品，而想要获得稀缺商品就必须牺牲某些其他有价值的东西。</p><p>​如果只有通过牺牲才能获得一种商品，那么这种商品就是稀缺的。</p><p>​免费商品确实都存在，比如空气，但是在潜水场景，空气也是稀缺商品。</p><p>​然而大部分商品都是稀缺商品，所以我们必须做出选择，也就是经济学问题，稀缺性。</p><p>​负商品：越少越好的东西，比如夏天咬人的蚊子，恐怖袭击。</p><p>​同一个东西可以同时是一个人的负商品和另一个人的正商品，比如榴莲。</p><p>2.2 物质财务的迷思</p><p>​什么是财富？并不是具体的物品，在经济学思维方式下，只要是人认为有价值的东西都是财富。</p><p>​人认为有价值的都是财富，对于想要灌溉农田的农民来说，更多的雨水意味着更多财富，对于洪困住的农民来说，雨水显然不是财富。</p><p>​积极增长并不是指物品数量的增长，而是指财富的增长，虽然物质的产品能够为财富的创造做出贡献，但是财富的增长与物质产品的体积、数量并没有必然联系，所以我们要否定“财务等于物质产品”的想法。</p><p>​专业分工与交换正是亚当斯密所说的商业社会的核心。</p><p>2.3 贸易创造财富</p><p>​通常认为，交换是等值物品的交换，事实恰好相反，当人们资源进行交换的时候，他们交换的从来不是价值相等的物品，如果2件东西价值相等，那根本就没有必要发生交换。</p><p>​参与交换的人相互合作，是为了抓住机会获得更多他们认为有价值的东西，正是因为双方都想获得更加价值，才产生了交换的动机。这是因为参与交易的双方的有着不同的价值观。</p><p>​价值观的差异正是交易活动生产效益的根源，交易完成后，双方的财富都增加了。</p><p>​也许会有人说，交易并没有使财富发生实质性的增长，因为交易没有正常产出任何东西。没错，确实没有创造新的物质，但是我们想一下“制造”究竟是是那么？</p><p>​从技术的角度来说，制造是改变原料的排布方式，让原谅以更有价值的方式组合起来，制造的目的是增加价值，如果不能增加价值，就没必要进行制造活动。</p><p>​我们跳出具体的制造，交换的本质也是对物品进行了重组，大家都认为重组后的物品价值更高，所以交易活动为双方创造了价值，交换活动被视为生产的另一种方式，交易双方都通过有价值的商品换来了另一个更有价值的商品。</p><p>​自愿交易是一种能同时为双方创造财富的办法，通过在交换活动中与对手合作，交易双方都活动了增加自身财富的机会。</p><p>2.4 值不值？效率和价值</p><p>​做决策的时候，个人通常会权衡这项决策将带来的所有预期额外收益和所有预期额外成本，并比较两者的关系。</p><p>​比如买车，每公里的油耗是技术效率，是客观因素，经济学家所说的效率这是从选择者的角度出发，比较各种决策的额外收益和额外成本，我们将这种效率成为经济效率。</p><p>​在个人层面，值不值实际上是一个经济效率的问题，比如同样是上班，有人选择坐地铁，有人选择骑自行车，有人选择开车，每一位员工都会选择从经济角度最有效率的通勤方式</p><p>​每个人的选择都反应了他们的偏好和价值观，我们的价值观决定了我们认为什么决策效率高，什么决策效率低</p><p>​当产权清晰，稳定并且可以交换的时候，稀缺资源通常具有合理的价格，价格会反应相对稀缺程度，如果有人认为自由市场决定的商品价格是错误的，那么他实际上否定的是决定价格的市场，是现存产权体系以及产前之外的其他游戏规则。</p><p>2.5 认识取舍：对生产的机会成本进行比较</p><p>生产可能性曲线：在给定资源和给定技术的前提下能够生产的最大组合。</p><p>琼斯每三个月可以生产10加仑的淡啤酒或者5加仑的黑啤酒</p><p>布朗每三个月可以生产3加仑的淡啤酒，4加仑的黑啤酒</p><p>从量度来看，似乎琼斯无论是生产淡啤酒还是黑啤酒都比布朗有效率，但是生产能力的高低本身并不是量度效率，而是看多多的代价是什么？</p><p>若想获得更多啤酒，就必须牺牲某些东西，我们需要比较这种获得和牺牲之间的取舍，这就是研究机会成本。</p><p>假设琼斯只生成淡啤酒，那么他生产10加仑淡啤酒的成本是5加仑1的黑啤酒，反之生产5加仑黑啤酒的代价是牺牲10加仑的淡啤酒</p><p>布朗生产4加仑黑啤酒的的代价是放弃生产3加仑的淡啤酒</p><p>我们可以看出，在淡啤酒方面，琼斯的效率更高，机会成本最小</p><p>在黑啤酒方面，布朗的效率更好，因为布朗生产1加仑黑啤酒的机会成本是四分之三淡啤酒，所以在黑啤酒的生产上，布朗机会成本更低。</p><p>2.6 分工和交换带来的效益</p><p>​如果2人分工，每个人只生产自己相对擅长的产品，并相互按照1:1的方式进行交换，会带来什么样的结果呢？</p><p>两个人的的生产可能曲线都处于自身的外侧，也就是代表他的财富增加了，生产和交换拓展了人们的生产可能性，如果不与布朗交换，他不可能产出这么多啤酒。</p><p>​通过只生产自身具有比较优势的产品，他们提高了稀缺资源的使用效率，两位生产者同时提高了自己的财富。</p><p>​<img src="http://qiliu.vkcyan.top/FvWvF5uUxwQvx0noIhScJM34leXz.png" style="zoom:50%;" /></p><p>2.7 为什么要进行专业分工</p><p>​专业分工就是选择自己具有优势的工作，因为这样能提高他们的财富水平，人们通过分工拓展自己面对的可能性，他们可以用自己生产的产品去交换那些自己生产成本更高的东西，市场经济的规则允许让你们进行产权交换。</p><p>​这种想法被称为<strong>比较优势法则</strong>，这个概念解释了专业分工的动机，以及专业分工能提高经济增长，也解释了人们自己不生产所有东西，之所以会产生比较优势，也许是因为不同的人天生擅长的不同，或者是练习与学习的技术不同；人们可以通过自己拥有比较优势的活动来获得财富。</p><p>2.8 从个人贸易到国际贸易，再从国际贸易到个人贸易</p><p>​从本质上来看，交易双方都在用自己出口的产品来交换自己进口的产品。</p><p>​无论是组织之间的贸易还是国家与国家之间贸易，本质上都是人在进行交易，只是他们以组织的名义交易，只有个人才能做出选择。</p><p>2.9 交易成本</p><p>​在私有产权系统下，人们进行专业分工的动机很强，因为比较优势能穿在更多的个人财富，系统的游戏也鼓励人们进行这些活动，但是除了机会生产本外，寻找交易对象的过程也会生产成本，在上述的例子中，我们有意忽略了交易成本，但是实际上发现交易机会并不简单，因为双方可能不在一个国家、不在一个地区，交易因此变得困难。</p><p>​我们把这些因素称为交易成本，交易成本是安排相关方达成契约和协议的成本。</p><p>2.10 降低交易成本的动机：中间人</p><p>​中间人扩大了可供我们选择的机会范围。</p><p>​人们常常对中介费颇有微词，因为我们习惯把实际情况和并不存在的更优情况进行比较，但是我们实际进行交易甚少能像“假设我们知道所有信息时可能进行的交易”那样有利，所以我们认定中间人利用我们的无知占我们的便宜。</p><p>​实际上，这种中间人和正常岗位没有区别，医生也会利用你对疾病的无知而收费，中间人和医生一样在创造真正的财富，因为他们为我们创造了更多我们想要的选择机会。</p><p>2.11 中间人创造信息</p><p>​自由市场过程中的供给与需求产生了价格，价格是一种信息，这种信息能帮助人们评估不同商品与服务的稀缺程度，其中市场参与者可以低成本的产生高质量的信息，这是市场最重要却最容易被人忽视的优点之一，这个过程就反映了中间人的优势</p><p>​有些市场是有组织的市场比如股票，该市场在较广的地理范围内交易同质化程度很高，另一些市场有组织化药低很多，比如二手家具。</p><p>​每一种价格对其他人来说，都是一条潜在的有用信息，这种信息能告诉人们有哪些机会可供选择，人们面临的选择机会越多，人们的财富就越高，更多的选择机会意味着有能力做更多我们想做的事情。</p><p>​中间人的专长就是组织市场，创造有价值的信息，比如ebay的出现，让使用该网站的人生产有价值的信息，降低双方的交易成本，中间人能够减少交易的阻碍。</p><p>​如果没有中间人，双方都要付出更高的成本的获取更多信息。</p><p>2.12 市场是一种发现的过程</p><p>​市场中的个体从事他们自认为具有比较优势的行当。个体衡量自身的成本和收益，并根据这些判断来选择自己的行为。</p><p>​比较优势预期生产的效率不是在黑板上被发现，而是通过产权交换在真实的市场中被发现。</p><p>​在大多数的决策中，相对价格为决策者提供了极为重要的根本性信息，我们根据自身的情况，选择各种工作能带来的工资，还有选择自己感兴趣的项目、学生选择学位，当然并不是说人们仅仅关注价格，而是多数情况下，相对价格能够对人的决策起到指导作用。</p><p>​达到某种目标的最高效的方式就是成本最低的方式，人们不断协调合作互动和相互调整过程，这个过程构成了我们的经济。</p><p>2.13 关于经济增长的初步思考</p><p>​在人类历史的绝大部分，除了少数特权阶级，贫困是大部分人的生活常态，而大约300年前，欧亚大不了的西北角出现了经济的增长，少部分人是如何致富的呢？这是经济学研究的问题</p><p>2.14 寻找一种解释</p><p>究竟发生了什么？</p><p>​分工是的各种产品能够成倍制造和数量激增。在井然有序的社会里，由于劳动产品极大丰富，以至可以提供到最下层人民。</p><p>​马克思认为，一个以私有产权和盈利而生产为特征的社会具有一些深刻的缺陷，这些缺陷将会摧毁整个资本主义系统，但是他并不怀疑这样的社会确实具有创造财富的能力。</p><p>2.15 鼓励专业分工和交换的规则如何演进</p><p>​尽管人类能够预见劳动分工将袋子普遍赋予，并设法通过劳动分工加以实现，但劳动分工带来的诸多利益并不是人类智慧的结果，是随着时间缓慢、逐渐演化而来的。</p><p>​复杂的社会支付是长期演化而来，事先并无蓝图，金钱支付的演化过程与社会分工的演化过程一样：人们自发推进自己感兴趣的事业，并在这个过程中与其他人互动，这个互动自动催生了金钱系统。</p><p>​一个国家从最低级的野蛮到最高的富裕状态，只需要和平、轻税赋以及一套合理的司法管理系统，剩下的部分都会自己完成。</p><p>​这并不是说预见不重要，也不是说，政府没有对成功的经济系统发展做出贡献，亚当斯密主张：“井然有序的社会”中才能演化出广泛的专业分工，从而提高产出，实现”普遍的富裕“。</p><p>​再谈第一章的重要概念，游戏规则以及经济学的最重要特点：界定清晰并受充分保护的产权。如果没有相对安全的产权，人们就不会为未来投资，不会启动任何有成本的事业。</p><p>​成功的商业社会，必须满足2个比较条件，第一是相对安全的产权系统，第二是产权的自由交换</p><p>简要回顾</p><p>​商品交换的本质是产权的交换，社会具有一个清晰的产权，社会产生的价格信息就能指引人们发现自己的比较优势，市场过程能够告诉大家可供选择的机会，有了这些信息，人们就能发现市场参与者创造收益的途径。</p><h2 id="第三章-无处不在的替代品：需求的概念"><a href="#第三章-无处不在的替代品：需求的概念" class="headerlink" title="第三章 无处不在的替代品：需求的概念"></a>第三章 无处不在的替代品：需求的概念</h2><ul><li>建立”所有稀缺商品都有替代品“的论点</li><li>引入”选择都是在边际上做出“的概念</li><li>引入需求法则，并解释这个概念</li><li>清晰区分需求和去需求量的概念</li><li>研究使需求曲线移动的因素</li><li>指导需求的价格弹性，并运用这个概念</li></ul><p>​之前我们一直讨论取舍的问题，并且我们知道大部分商品都是稀缺商品，也就是说想要获取这些商品必须牺牲其他有价值的东西，现在我们深入讨论稀缺性，任何东西都存在替代品，我们要考虑如何比较不同替代品的预期额外成本与预期额外收益，也就是取舍。</p><p>3.1 关于”需要“这个词</p><p>​需要并不是一个确定的词，会收到很多因素的影响，所谓需要也可以通过多种方式进行实现，而当我们选择A的方式，就会牺牲掉其他的方式</p><p>3.2 边际价值</p><p>​当我们在日常生活中，钻石的价值比水的价值更高，当我们在沙漠里面的时候，水的价值比钻石的价值更好，我们的选择是在特定的背景下进行，<strong>我们的选择取决与我们面对环境</strong>。</p><p>​牙缝里面卡住骨头的时候，一根牙签比一个鸡腿更有价值，当你想想上厕所的时候，卫生纸比《莎士比亚全集》更加有价值，价值完全取决于我们面对的情况。</p><p>​在经济学上，起作用的价值是边际价值。边际收益和边际成本是决策过程中仅有的两个重要因素。</p><p>3.3 分叉路口：日常选择是边际选择</p><p>​假设明天你就要进行期末开始，但是晚上9点你正要复习的时候，你的对象打电话给你希望你陪她打游戏，你拒绝的时候，她问你”考试比我还重要吗“？这时候你可以运用你的经济学思维告诉他，在此刻的边际价值上，考试比你重要。</p><p>​经济学的思维否定非此即彼的决策方式，而要求我们关注边际收益和边际成本。这一规律适用于所有稀缺商品的优化过程。</p><p>3.4 需求曲线</p><p>​人们面临各种取舍，为了多获得某样东西，就得少获得另一样东西，正是因为如此所以才有了”需求“的概念。</p><p>​需求的概念把人们希望获得的东西的数量和必须付出的代价联系了起来。</p><p>​当付出的的代价出现变化，人们希望获得的东西的数量也会随之发生变化</p><p>​比如一个小镇上，当水费越贵，居民用的水也就会越少，具体用水与水的费用就呈现出一个关系</p><img src="http://qiliu.vkcyan.top/FsOa6I3j1gjgBk4-dhStiarczzJa.png" style="zoom: 33%;" /><p>​这样的需求就被称为需求曲线，需求曲线描绘了在所有给定价格下消费者计划购买的商品数量。</p><p>​当水相对便宜的时候，人们会将水用于饮用、洗澡、烹饪、洗衣、草坪浇水、洗车，但是当水的价格变贵的时候，人们就会改变他们的计划，比如人们可能会降低洗车的频率、洗衣服的频率，水被用于”更重要“的场景，或者个体决策者眼中价值最高的用途。</p><p>​他们判定把水用在某些方面不再值得，人们会选择替代方案，比如高压淋浴喷头，取消游泳池，这些都可以算作水的替代品。</p><p>3.5 需求法则</p><p>​将其他条件保持不变，如果某种商品的价格上升，其需求量就会下降。同样，当其他条件保持不变，如果某个商品的价格下降，其需求量就会上升</p><p>​需求法则：当其他条件不变的前提下，价格和需求量之间的关系是负相关的。</p><p>3.6 需求和需求量</p><p>​需求和需求量并不是一种东西，我们常说的需求的的减少与增加，其实说的是需求量。</p><p>​对任何一个商品的需求都不是一个具体的数量，需求永远是一种关系，这种关系将不同的价格下人们愿意购买的数量联系起来。</p><p>​无论价格怎么变化，需求本身是不会变的，要想区分需求和需求量，最佳的方式是始终牢记需求这个词永远可以被替换称为需求曲线或者需求表。</p><p>3.7 需求本身也可以变化</p><p>​对某种特定商品而言，如果商品的价格不变，但人们愿意购买的商品数量却发生了变化，那么这种商品的整体需求就发生了变化。</p><p>​我们依旧以小镇居民对水的需求为例子，若是想整体需求提高，就必须发生某件事，比如当地出现了干旱，用水量可能就会上升，当地出现了水源污染，当地的用水量就会下降，这些都会导致需求曲线的上升或者下降，但是需求法则依旧成立，需求与价格依旧是反相关的关系。</p><p>3.8 所有东西都取决于其他东西</p><p>​有些因素会导致商品需求发生变化，我们要分离并注意这些因素</p><ul><li>消费者数量的变化，老年人增加会导致养老类产品需求的增加</li><li>消费者的品味和偏好的变化，追求健康的潮流会导致高脂肪视频需求的变化</li><li>收入的变化，经济繁荣的时候，去迪士尼玩的人会更多</li></ul><p>​消费者收入增加，某些商品的需求曲线开始右移，这是正常商品，如果消费者收入上升，对某种商品的需求反而下降，那么这种商品就是低档商品。</p><p>​但是我们不要忘记，价值还是做出选择的人眼中的价值，这是非常动态的。</p><p>​对经济学家而言，低档商品和正常商品的区别仅在与收入变化时消费者对这种商品的需求如何变化。</p><p>​经济学的思维方式理解所有东西都是相互关联的，所有东西区取决于其他东西。</p><p>​单一商品的价格本身没有意义，只有吧这种价格与选择者面对的大量其他商品和服务的价格进行对比，这种价格才有意义。</p><p>​所以<strong>替代品价格的变化也是影响需求的因素</strong></p><p>​在其他条件不变的前提下，如果一个商品的价格上升，其替代品的需求也就会上升。</p><p>​<strong>互补品的价格变化也会让需求曲线发生移动</strong>。</p><p>​在其他条件不变的前提下，如果一种商品的价格上升，其互补品的需求就会下降，比如油价上升会导致燃油车的需求下降。</p><p>​<strong>商品预期价格的变化会导致对这种商品的整体需求的变化</strong>，比如油价明天将会上涨，汽油的需求曲线将会右移，这个时刻，你对汽油需求增加了。</p><p>3.9 通货膨胀导致的误解</p><p>​因为通货膨胀的存在，商品的价格发生了增加，但是需求曲线却并没有左移，这似乎并不符合需求曲线的定义，也就是价格与需求呈反比。</p><p>​这是对通货膨胀的误解，通货膨胀是指商品的平均货币价格的增加，现在我们思考一个理想情况，如果人们的收入以及他们使用的所有其他商品的价格同时翻倍了，则所有商品的相对价格都没有发生变化，只是过去的金钱的实际价格变了，只有过去的一半。</p><p>​通货膨胀是一个比较特殊的情况，日后我们会单独讨论。</p><p>3.10 时间站在我们这边</p><p>​价格变化后人们的购买量也许没有太大变化，但是这仅限于价格刚刚变化的时候，有时候这种现象会让人认为价格对消费者没有影响，这是非常错误的结论，因为顾客需要调整的时间。人是习惯性东西，寻找任何东西的替代品都需要一定的时间。</p><p>3.11 需求的弹性</p><p>​如果某种商品只要价格小幅变化，人们的购买量就会显著改变，那么我们就说对这个商品的需求是有弹性的。相对的，如果某种商品即使价格大幅度改变，需求也不怎么变化，我们就说这种商品的需求缺乏弹性。</p><p>​需求的价格弹性精确定义如下：价格弹性等于需求量变化的百分比除以价格变化的百分比，因此，如果鸡蛋价格上升了10%，会使消费者的购买量下降5%，这鸡蛋需求的价格弹性就是5%除以10%，即0.5（忽略负数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求的价格弹性 = 需求量变化的百分比 / 价格变化的百分比</span><br></pre></td></tr></table></figure><p>如果一个商品的价格弹性大于1.0，我们就认为这个需求有弹性</p><p>如果一个商品的价格弹性小于1.0，我们就会认为需求缺乏弹性</p><p>如果一个商品的价格弹性等于1.0，我们就会任务需求具有单一弹性</p><p>需求弹性受到三个因素的影响</p><ul><li>时间，价格变化后，供人们调整的时间越长，需求的弹性越大</li><li>消费者获得已知替代品的难易程度以及已知替代品与原商品的接近程度，越容易知道替代品，或者替代品越多，弹性越高。</li><li>花在这个商品上的钱占总支出的比例，比例越小，需求弹性越低，比例越大，需求弹性越高，也会对价格的变化更加敏感。</li></ul><p>3.12 对弹性的思考</p><p>​即使盐的价格翻一倍，我还是会买同样数量的盐，因此所谓需求法则并不成立。实际上是因为这些商品占总支出的比例很小，你没有动机成为一个小心挑剔的消费者。</p><p>​盐的价格从5毛到1元，可能你没啥感觉，但是到5元、10元，开始占据较大比例的总支出的时候，你和很难不挑剔了。</p><p>​相对于盐这样的刚需产品，汽车的价格弹性就高出了很多，因为替代品非常多。</p><p>3.13 弹性与总收入</p><p>​如果大学的学费降低20%，大学收到的学会总数其实会上升。</p><p>​如果价格变化后收入的变化方向与价格的方向相反，那么需求一定有弹性。</p><p>​如果价格变化后总收入的变化方向与价格变化的方向相同，那么需求一定缺乏弹性</p><p>​大学是否总能通过降低学费来改善财政呢？并不是的，虽然降低学费可以提高总收入，但是大学必须考虑总收入的提高是否大于总成本的提高。</p><p>​另一方面，弹性和总收入的关系也让我们产生一个误解，提高售价可以多挣钱，但是价格的替身会导致商品的需求量下降，企业的总收入也会下降。</p><p>3.14 竖直需求曲线的迷思</p><p>​需求曲线不可能在价格上完全没有弹性，也就是价格无论怎么变化，需求都不变，这就意味这这个东西没有替代品，在现实世界这是不可能的。</p><p>​比如糖尿病患者对胰岛素的需求，这个看起来是没有替代品，因为这是糖尿病一个最好的解决方案，但是即使这样，他的需求弹性曲线也不是竖直的，因为随着价格的升高，人们会采用克制的生活方式、甚至祈祷来降低胰岛素的使用量。价格降低也会有更多人选择胰岛素。</p><p>3.15 需求应该扮演怎样的角色</p><p>​到目前为止，我们一直把市场价格以及支付这种价格的意愿高低作为决定谁可以获得哪些稀缺商品和服务主要标准。</p><p>​除了这个之外，我们现实生活中还有其他系统，而这是一个产权问题。</p><p>​按需分配：但是这个评价标准过于含糊，容易被滥用。</p><p>​先到先得：就像排队，人们都要花极长的时间，非常低效。</p><p>​随机抽签：抽签似乎是一种公平的办法，但是也会让蛋糕小到失去价值</p><p>​强权就是正义：稀缺商品属于配得上他的人，不管配得上的原因是什么，但是这样会让弱者没有任何资源，抢着必须浪费资源夺取他和捍卫他们的资源</p><p>​论功行赏：就不需要界定什么是功绩，这个只能小范围达成。</p><p>​而以上的系统还都忽略了供给的问题，生产者希望自己获得回报，生产者需要系统基于的鼓励。</p><p>​现在的系统：鼓励资源以产权交换稀缺商品，并让愿意支付的边际价格最高的人获得稀缺商品。这样的系统会使得每个人都能根据自己的特定条件进行优化，从而扩大人们的自由和权利。</p><p>​当某件商品价格上涨，消费者会自信优化，不需要有人来命令他们优化，也不需要经济学家们来告诉他们如何优化。从消费者的自身利益出发，优化是最佳的选择，即使他们从来没有听说过这个词。</p><p>​需求让大家为了自己主动选择最优解，社会也达到了最优解的动态平衡。</p><p>3.16 金钱是唯一重要的因素吗？货币成本、其他成本和经济计算</p><p>​需求的概念绝不说明金钱是人们唯一关心的东西。</p><p>​当商品的成本商城，消费者就会少买，这并不意味着人们是自私的，相反经济学的思维方式指出：<strong>当某种行为的机会成本上升的时候，决策者就会较少的采取这种行动，当某种行为的机会成本下降的时候，决策者就会较多的采取这种行动</strong></p><p>​人们不是仅仅对预期收益的变化做出反应，他们会比较预期额外收益和预期额外成本，<strong>不管他们以何种方式度量成本</strong></p><p>​货币度量价格使得经济计算成为可能。</p><p>小结</p><p>需求法则：人们会自己优化自己的行为，不管什么商品，当价格下降的时候，人们就会多买，价格上升的时候，人们就会少买</p><p>需求曲线：需求与价格之间关系的曲线。</p><p>需求的价格弹性：需求量变化的百分比除以价格变化的百分比</p><p>价格弹性的敏感程度主要取决于商品占总支出的比例以及替代品价格的变化</p><p>需求曲线上升的影响因素</p><ul><li>消费者数量增加</li><li>消费者品味和偏好改变</li><li>消费者收入上升</li><li>互补品的价格下降</li><li>替代品的价格商城</li><li>消费者预期这种商品未来会涨价</li></ul><p>需要不代表一定要得到，需要到得到收到诸多因素的影响，毕竟价格，价格的上升会降低用户购买的欲望。</p><blockquote><p> ps：为什么需求曲线中间的点的收入是最高的？暂时不知道怎么解释这种情况</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《经济学的思维方式》读书笔记1-3&quot;&gt;&lt;a href=&quot;#《经济学的思维方式》读书笔记1-3&quot; class=&quot;headerlink&quot; title=&quot;《经济学的思维方式》读书笔记1-3&quot;&gt;&lt;/a&gt;《经济学的思维方式》读书笔记1-3&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="经济学" scheme="https://bluedancers.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《经济学的思维方式》读书笔记4-6</title>
    <link href="https://bluedancers.github.io/2024/01/20/%E9%98%85%E8%AF%BB/%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%884-6%EF%BC%89/"/>
    <id>https://bluedancers.github.io/2024/01/20/%E9%98%85%E8%AF%BB/%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%884-6%EF%BC%89/</id>
    <published>2024-01-19T16:00:00.000Z</published>
    <updated>2024-03-25T08:14:54.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《经济学的思维方式》读书笔记4-6"><a href="#《经济学的思维方式》读书笔记4-6" class="headerlink" title="《经济学的思维方式》读书笔记4-6"></a>《经济学的思维方式》读书笔记4-6</h1><h2 id="第四章：成本与选择：供给的概念"><a href="#第四章：成本与选择：供给的概念" class="headerlink" title="第四章：成本与选择：供给的概念"></a>第四章：成本与选择：供给的概念</h2><ul><li>回顾机会成本的改变<ul><li>机会成本是选择A这件事，就是去了做其他事情的成本，这个不仅受到选择本身的影响，还有替代品，组合品的影响。</li></ul></li><li>区分沉没成本与边际成本。探索成本的一下性质：成本永远是行为的成本<ul><li>沉没成本是已经出现的成本而边际成本是本次选择的成本，我们的判断不应该受到沉没成本的影响</li></ul></li><li>确定机会成本如何影响供给决策，用生产可能性曲线推导供给曲线<ul><li>机会成本越高，供给会越少，反之；生产可能性曲线会影响具体商品的供给曲线的斜率</li></ul></li><li>解释能移动供给曲线的因素<ul><li>成本、科技创新、竞品</li></ul></li><li>分析供给的价格弹性<ul><li>供给的价格弹性是供给量的变化除以价格的变化，大于1表示有弹性，小于0表示缺乏弹性。</li></ul></li></ul><p>​激励机制鼓励生产者生产与供应稀缺商品，我们将讨论机会成本和市场价格如何塑造这种激励机制</p><p>4.1 回顾机会成本的概念</p><p>​机会成本就是做出选择后，放弃其他选择的成本，这个在每个人身上都会做出不同的反应</p><p>4.2 成本是行为的成本，而不是东西的成本</p><p>​成本不是东西的成本，成本永远与行为、决策、选择有关。</p><p>​成本从来都不是客观的，当我们谈论成本的时候，成本永远都是对某人而言的成本。</p><p>​主观成本等于某人赋予被放弃的机会的价值。</p><p>4.3 我们现在该怎么做？“沉没成本”的无关性</p><p>​在考虑成本的时候，最常见的错误就是将此前已经产生的成本与边际成本该混。</p><p>​做成本计算时不应该回望过期，因为过去的成本是沉没成本（不可能追回的成本）；正确的做法是向前看，看目前的机会成本。</p><p>​假如你中午点了一个外卖，一共20元，吃的时候发现非常难吃，如果这时候你选择不吃，你的成本是什么？</p><p>​其实并不是20元，因为20元已经不属于你，无论你吃完还是不吃完，20元都回不来了；这里我们就必须考虑边际成本，也就是获得外卖那一刻开始你新的行动可能带来的成本。</p><p>​比如你选择不吃，你的边际成本就是浪费这些粮食，以及再买一份新的午餐，还有一些时间</p><p>​如果你选择吃，你的边际成本就是自己的情绪，吃了会不开心，甚至下午会肚子疼，这都是这个决策的成本。</p><p>​边际成本就是未来的成本。沉没成本已经无法追回，现在你已经站到了一个新的岔路口，新的岔路口：新的边际。</p><p>​在经济学思维下，沉没成本只是过去的历史，因为他不代表未来的选择机会。沉没成本也许会导致苦涩与悔恨，但是不管有什么意义上看，它都不再是与现在的经济决策有关的成本，沉没成本只是一种信息，只是生命中的一个教训。</p><p>4.4 生产者的成本是机会成本</p><p>​为什么低技术劳动力在印度工资那么低？因为在这个国家，大量能参加工作的潜在劳动者没有机会通过任何方式用自己的劳动力生产队他人更有价值的产品。</p><p>​生产者生产的成本取决于他们获取必要的资源需要花多少钱</p><p>​与供给决策有关的所有成本都是未来的成本，这些资源可以用于生产其他产品，生产的产品的机会成本等于被牺牲的次最佳机会的价值。</p><p>​高技术工人比低技术工人更加有价值，是因为他的技术在别人更加有价值。</p><p>​如果一个大企业来到某一个小郑，该地区的相关工作人员的成本都会提升，因为新企业进驻后可能会提供更好的机会，比如工资、福利、环境，医疗，旧企业用原本的机会就会难以留住员工，因为劳动者发现了别人有更加有价值的机会。</p><p>​</p><p>4.5 边际机会成本</p><p>​机会成本就是边际成本，只是两个不同的描述角度</p><p>​机会成本：为采取某一行为而放弃的其他机会的价值</p><p>​边际成本：关注为采取某一行为会对目前的产生的影响</p><p><strong>做决策的时候应该考虑的成本只有一种，这种成本的全名是边际机会成本</strong></p><p>​</p><p>4.6 成本与供给</p><ol><li>在决定生产什么、生产多少的时候，生产者会考虑生产的边际成本</li><li>当生产者判断各种生产计划的边际成本和边际收益时，相对价格为他们提供了进一步的信息</li><li>供给曲线描绘的是在不同产量上供应某种商品的边际机会成本，同时生产者也跟从需求法则的体现</li></ol><p>4.7  供给曲线</p><img src="http://qiliu.vkcyan.top/FiheVVC8rExoydAauRguVcUH9Ouv.png" style="zoom:33%;" /><p>4.8 供给曲线本身也可以变化</p><ul><li>生产要素价格上升，导致单位产量的机会成本增加，曲线向上。</li><li>成本下降，或者技术创新导致成本下降，曲线向下。</li><li>其他商品的变化也会影响统计曲线，比如竞品价格降低了一半，则当前商品的收益会提升一半，供给曲线会下降50%。</li></ul><p>生产者预期商品价格未来会变价，产品的总体供给也会随之变价</p><ul><li>6个月后降价，则意味着该商品相对未来成本增加，则会增加当前市场投放量</li><li>6个月后涨价，则意味着该商品相对未来成本降低，则会减少当前市场投放量</li></ul><p>​最后，生产者总数变化，供给曲线也会变化，如果有更多的竞争者进入市场，供给通常会提升，如果竞争者退出市场，供给就会下降，一般来说，预期利润越高，进入市场的供应者越多，市场供给就会提升；预期利润月底，退出市场的供应者就会越多，市场供给就会下降。</p><p>4.9 边际成本与平均成本</p><p>假设生产一个单位玉米的成本是失去1.1美元的其他农作物，让我们看看生产0、1、2、3单位的总成本、边际成本、平均成本的差异</p><table><thead><tr><th>玉米产量</th><th>总成本</th><th>边际成本</th><th>平均成本</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2.1</td><td>1.1</td><td>1.05</td></tr><tr><td>3</td><td>3.3</td><td>1.2</td><td>1.1</td></tr></tbody></table><p>每个单位预期生产成本是否小于每个单位商品的预期售价，其实这里的预期成本指的就是边际成本</p><p>不论商人是否用平均概念考虑问题，知道决策的仍然是预期边际成本。</p><p>平均成本只是历史（历史具备参考意义），而做经济决策时永远应该立足当下、着眼未来。</p><p>4.10 志愿兵役制度的成本</p><p>​在20世纪90年代，这是一段经济繁荣时期，美国军队在招募新兵和延长老兵的时间方面面临困难，自愿入伍的人越来越少，强制征兵制的呼声越来越高。</p><p>​对于潜在入伍的年轻人而言，入伍的成本究竟是多少？<strong>这个并没有一个具体的值，而是看每个人放弃其他就业机会以及各种其他价值的成本</strong>。</p><p>​如果想要在经济繁荣时期自愿参军的人更多，就需要不断提高军事人员的工资，直到工资水平正好能够吸引政府需要的入伍人数。</p><p>​也就是说年薪与志愿兵的数量是存在正相关的关系的。</p><p>​如果为了召集到指定人数的人，而多付了钱，那么多付的钱就是政府的财富转移。</p><p>​如果强制征兵，是否可以降低自愿参军支付下的成本呢？答案是不能，因为强制征兵非自愿的，如果某个人每年的工资是2.4w美元，但是入伍只能拿到0.9美元，则参军者需要承担1.5w美元的成本，强制征兵支付没有降低组建军队的成本，只是把纳税人的成本转嫁给了入伍者。</p><p>​爱国情绪越高涨，能吸引人们自愿入伍的货币工资就越低，因为爱国也是人的一种精神上的<strong>价值</strong>。</p><p>4.11 供给的价格弹性</p><p>​供给的价格弹性 &#x3D; 供给量变化的百分比 &#x2F; 价格变化的百分比</p><p>​在供给中，价格和供给量朝同一个方向变化，只有提高商品的价格，才能诱使生产者提高商品的供应量</p><p>​供给具备弹性：供给量变化的百分比大于价格变化的百分比</p><p>​供给缺乏弹性：供给量变化的百分比小于价格变化的百分比</p><p>​</p><p>4.12 用成本论证正当性</p><p>​针对成本的经济分析是比较复杂的，因为成本不仅有经济上的意义，还有道德和政治上的意义。</p><p>​很多人都相信卖家有权收回成本，但是无权把价格订的显著高于成本，如果卖家的价格过高或者过低，几乎可以肯定卖家在谋求某种不正当的利益。</p><p>​有些人认为，需求应该与成本关联，其实这个想法是错误，举个例子取暖用的燃气涨价，这就应该允许房东提高房租，但是如果是因为住房的需求增加而涨房租，则被认为是一种投机倒把行为。</p><p>​但是租房需求的上升和燃气涨价其实都与成本有关，因为租房的人多了，房子就变的稀缺，人们就会为了争夺有限的房源而竞价，所以房东为了利益最大话，就可以选择出价最高的那个人，就像燃气的使用者也会竞价，燃气使用的人多了，燃气也会涨价。</p><p>​<strong>成本永远是由需求与供给共同决定的，成本永远不可能独立于需求存在</strong></p><p>简要回顾</p><p>人们之所以对不同决策的成本有争议，通常是因为他们谈的是此决策对不同人的成本</p><p>过去的支出都是沉没成本，做决策时不应考虑这些成本，做决策只应该考虑未来的成本，因为目前的决策不会影响过去已经发生过的事情。</p><p>供给取决于成本，但是供应某种商品的成本是为了供应这种商品而牺牲的其他机会的价值。</p><p>人们常常对某件东西的“真实”成本有争议，实际上东西是没有成本的，只有行为才意味着牺牲某种机会，因此只有行为才有成本。</p><p>谈论成本时，永远不要忘记问自己“对谁而言的成本”，“干什么的成本”。想经济学家一样思考。</p><blockquote><p>书中供给曲线的计算这一块没看懂，因为书中的供给曲线没有斜率，这就意味着任何一段xy轴的变化比例都是一样的，算出来的价格弹性也都是一样的。</p></blockquote><h2 id="第五章-供给与需求：一种协调过程"><a href="#第五章-供给与需求：一种协调过程" class="headerlink" title="第五章 供给与需求：一种协调过程"></a>第五章 供给与需求：一种协调过程</h2><ul><li><p>生产一种商品需要数百万人的合作，描述市场过程如何协调是他们的计划</p><ul><li>市场通过价格作为信号协调每个环节的供给与售卖</li></ul></li><li><p>用供给与需求模型分析市场</p><ul><li>供给和需求两个因素去影响价格</li></ul></li><li><p>区分短缺现象与过剩现象，解释自由市场价格如何调整使市场出清</p><ul><li>短缺的时候，需求不足，价格提升，过剩的时候，需求过剩，价格下降，本质上还是通过价格这个信号。</li></ul></li><li><p>描述自由市场价格如何传递信息</p><ul><li>价格反映了市场对于某种商品或者服务的相对稀缺程度</li></ul></li><li><p>解释金钱如何降低交易成本</p><ul><li>金钱是物品与物品之间交易的纽带，方便携带，颗粒度低，从而达到降低交易成本的目的。</li></ul></li><li><p>分析利率在协调经济活动的过程中扮演怎样的角色</p><ul><li>利率增加，存款增加，贷款减少，抑制经济过热，利率减少，存款意愿降低，贷款意愿增加，增长经济热度。</li></ul></li></ul><p>​按照亚当.斯密对分工的理解：如果一个社会的成员能够高效的将工作专业化，这个社会就会富裕起来。</p><p>​而在一个富裕、高度专业化的商业社会中，人们享有的商品和服务丰富到不可思议，人们必须相互协作、采取大量相互关联的行为才可能生产出这些商品和服务。</p><p>​商业社会究竟是如何鼓励其他人采取行动的呢？</p><p>​这个过程里面最基本的问题就是人们知道的太少，任何一个专家不可能知道所有事情，信息和知识对每个人都是稀奇的，也就是说：我们确实具备一些技术和能力，但是同时他们对无数其他技术与能力一无所知。</p><p>​哪怕是最普通的2B铅笔，这个世界上也找不到一个人知道怎么从头到尾的制造出来。</p><p>​一个人也许知道制作怎么组装一支铅笔，但是会组装的人并不知道如何生成原谅，如何运输，这是其他无数专家发挥自己的比较优势，贡献自己有限的知识与技术，才形成的结果，这些人可能相互不认识，甚至不是一个信仰，不是一个语言，但是却能协调在一起，生产出2b铅笔。</p><p>​<strong>有人说市场是一个奇迹，这个形容非常恰当。在市场中，数百万人互不相识，却能相互合作。他们不仅合作生产出了2B铅笔，还合作生产出了无数比2B铅笔复杂的多的商品，并且让消费者能够轻松、足量的获取这些商品。</strong>这一些并不是政府的规划，而是确定整体的游戏规则。</p><p>​市场的有序性看起来想一个奇迹，但事实上并不是神秘的，在商业社会中，人们如何将多种多样的生产计划和消费计划协调在一起，这个过程中，关键信号是价格。价格为数亿人提供重要的信息与信号。</p><p>​在本章，我们把需求与供给放在一起，描述市场过程本身的原理。</p><p>5.1 市场是计划协调的过程</p><p>​很多人把“市场”理解为地点或者集市，这是非常不经济学的思考方式，市场是跨越地区，遍布全球，甚至延伸到宇宙。</p><p>​记者和金融人士用各种各样的比喻描述市场，这个比喻常常将市场拟人化，比如市场很经常或者兴奋</p><p>​市场系统并不是自动的，也不是自我调整的，而是收到人类干预的，市场也不是一个人，不是一个地方，也不是一个东西，<strong>市场是一个过程，买家与卖家通过它协调双方的计划。</strong></p><p>5.2 基本过程</p><img src="http://qiliu.vkcyan.top/FvYqCbkGosfPnlhHgjUS6_c_M3AO.png" style="zoom: 33%;" /><p>​注意供给曲线与需求曲线的交点，这是市场达到完全协调的点，在这个店，生产不会过剩。</p><p>​假设市场价格高于500，是700元，此时供给开始提升，但是由于价格的增加，需求量开始下降，商品的供应量大于需求量，就会出现过剩的现象，在市场经济中面对过剩的商品最简单的办法，就是降低商品的售价。</p><p>​假设市场价低于500元，是300元，需求就是1200，但是生产者仅仅计划生产800个，这就会导致很多消费者买不到产品，出现了短缺的现象，来不到怎么办？只能提高售价去与其他消费者进行竞争，而面对价格的替身，生产这也会生产更多产品</p><p>​无论是以上那种情况，市场最后都趋向于完全协调点。</p><p>​</p><p>5.3 竞争、合作和市场出清</p><p>​有一种关心思维，市场经济中卖家与买家是竞争关系，因为一个大家的诉求是对立的，但是资源购买是买家与买家之间互惠交易的本质，你们双方最终是最远的达成了合作。</p><p>​在整个市场过程中，竞争与合作一样无处不在，但是竞争双方并不是卖家与买家，，买家通常与买家竞争，卖家通常与卖家竞争；买家与卖家相互合作。</p><p>​商品短缺价格升高的时候，卖家将商品与出价最高的买家交换，这是买家与买家的竞争。</p><p>​商品过剩价格下降的时候，买家与出价最低的买家交换，这是卖家与卖家的竞争。</p><p>​在我们上一节内容我们可以看出，商品短缺价格提升，商品过剩价格下降，最后会走向完全协调点，竞价过剩自动终止。</p><p>​此时的时候价格，被称为“均衡价格”，也被称为“市场出清价格”。</p><p>​市场出清是指市场上不再出现短缺与过剩的现象，买家的消费计划与卖家的生产计划完全协调。</p><p>​任何自由市或者服务市场都具有出清的倾向。</p><p>​这里的市场出清并不是并不是政府或者经济学家的干预，而是每个人都做出了对自己最有利的选择，大家相互竞争与合作，最终形成了市场出清的“意外之果”。</p><p>5.4 市场情况的变化</p><p>​我们之前的讨论都是建立在供给曲线与需求曲线不变的情况下，市场出清的情况，现在我们考虑一下需求或者供给曲线本身移动，会产生什么影响</p><p>​假设因为上游原料成本的下降，供给的边际机会成本开始下降，这会导致生产该商品的人变多，最终让生产曲线向下移动，如果这时候还是原来的价格500元，需求就会过剩，所以卖家只能通过降低售价的方式相互竞争，最终形成新的市场出清价格，400元。</p><p>​再让我考虑一个例子，因为某些原因，某些商品的需求开始增加了，这将会导致原本价格500元下，商品会脱销，买家与买家竞争，此时需求曲线开始上移，最终形成新的市场出清价格，600元。</p><p>5.5 从自由市场价格中获取信息</p><p>​没有人会把天冷怪到温度计身上，也没有人真的认为用蜡烛烤温度计就能在冷天让整个房间暖和起来。这是因为人们对气候的变化的原有有先天正确的理解。然后，在某种商品稀缺的时候，人们却责怪价格太高，他们似乎认为只要执行价格管控就能解决商品稀缺的问题。</p><p>​稀缺性是<strong>购买意愿和供应水平之间的关系，或者说是需求与供给之间的关系</strong>。</p><p>​稀少与稀缺是两个截然不同的概念，商品是否稀少与消费者的购买意愿无关，比如我在纸上写一个签名，全世界只有一个，非常稀少，同样的周杰伦有2000个签名，但是我的签名的价值一文不值，而周杰伦的签名值1000元，这是因为周杰伦的签名是更加稀缺的，稀缺的原因是远大于供给的需求。</p><p>​面对稀缺商品的时候，人们必须建立某种挑选过程或者标准，以决定在想要这种商品的人中谁可以获得多少。</p><p>​挑选的标准可以是任何东西，<strong>年龄、学历，金钱，才华，颜值</strong>，商业社会<strong>消费能力</strong>是最常见的挑选标准，在其他场合也存在其他标准，</p><p>​比如哈佛大学每年的申请人数远大于招生名额，哈佛大学会通过成绩、分数、推荐信等等因素去决定录取哪些学生。</p><p>​或者很多女孩子想和肖战谈恋爱，他的挑选标准可能是颜值，智力、温柔程度。</p><p>​要想在上述竞争中胜出，就需要相互竞争，而这些标准就是竞争的信号。</p><p>​<strong>竞争的根源是稀缺性，要想彻底消灭竞争，只有彻底的消灭稀缺性。只要决定“谁获得什么”的标准还存在，人们就会努力达到这些标准，竞争随之发生。</strong></p><p>​不同标准的竞争，对结果会造成很大的影响，比如社会用<strong>支付意愿</strong>的高度来协调经济计划，同时作为竞争标准，社会成员遵守这样的规则，就会努力赚钱，如果是体能，就会全民健身，如果是美貌，大家就会全民整容。</p><p>​就像中国高考是以考试分数作为标准，优质的大学的招收名额是稀缺的，高中生就需要在考试分数上展开竞争，但是这就仅仅是这一个考试这一个场景的竞争标准，并不是人生。</p><p>5.6 计划经济与知识问题</p><p>​要想让大量素不相识的个人有效协调他们的加护，交易条件必须清楚、简单、标准化，只有这样的才能保持低廉的交易成本。</p><p>​在计划经济中，所有的生产资料都不是私有的，而是由整个社会共有的。一小群专家有权决定这些稀缺商品的最佳用途，这些专家包括，经济专家、社会专家、化学家等，这些人组成一个中央计划委员会，决定生产什么、如何生产以及为谁生产。整个社会经济的运营方式就像一个巨大的国有邮局。市场被废止，金钱也被废止。</p><p>​而人们需要种类繁多的商品和服务，中央计划者必须有力、高效的生产和分配这些商品和服务。</p><p>​他们靠何种信息来完成上述工作呢？毕竟，具体的生产计划掌握在委员会手上，他们也是根据信息来决定生产什么、如何生产，生产多少。</p><p>​比如使用黄金只做公共汽车，在市场经济下，这不会这么做，因为这么做根本没有利润。这些资源的市场价格以及人们愿意为最终产品支付的价格帮助生产者认识到这么做会导致亏损，市场经济下的生产者在生产之前就认识到了这一点。</p><p>​但是竞价经济废除了市场过程，计划者能获取什么信号呢？也许是大量工程原理、公式、劳动力，复杂的数据系统，这些数据从经济学角度来说是没用的，这些数据不体现商品的稀缺，这样如何又如何确定商品究竟该制作多少呢？又如何确定不制作商品A，制作商品B是否更加满足大家的需求？</p><p>​计划经济废除了经济计算及其提供的信息。</p><p>​即使中央经济计划者智慧高超、一心为民，他们也不可能有效管理商业社会的日常运营，因为他们无法完全获取与处理必要的信息。所以问题不在于如何让更加聪明的人通过计划去帮我们实现经济增长，而是如何通过更高效的制度和游戏规则鼓励人们自己发现比较优势，并让每个人将自己有限的知识、信息、资源用在最高效的地方。</p><p>​粮食烂在地里面一定是浪费吗？其实不一定，因为如果粮食运到消费者手中的成本高于粮食的价值，那么让粮食烂在地里显然更加值。</p><p>​5.7 产权与制度</p><p>​在一个允许产权所有者自由交换产权的系统中，有能力高效利用资源的人会快速以低成本获得必要的资源。</p><p>​成熟的产权系统下，产权被清晰的界定，人们可以根据自己的选择高度自由的交换产权，人们较频繁或者规律地进行的交易都能因此保持较低的交易成本。</p><p>​市场参与者一直努力较低他们希望参与的交易成本，上述网络再此过程中逐渐演化而来，最终自发的形成了专业化的分工。</p><p>延伸思考：货币和利息的协调角色</p><p>​为什么市场系统中几乎所有交易都是为了交换货币而发生？</p><p>​钱可以降低交易成本，货币是交换的通用媒介，在只能以物换物的经济系统中，人们需要花费大量的时间寻找他们愿意交易的对象，这会导致生产者没有时间再去生产。最终会导致人们倾向于生产自己所需要的东西</p><p>​货币的另一个优势是，交易的报价非常灵活，在以物换物的经济体中，一个鸡可以换20个玉米，但是我只想要一个玉米，不能给他一小部分鸡，而钱可以毫不费力的多买一点少买一点，也就是调整货币价格。</p><p>​调价能力是商业社会达成协作的关键要素，当商品和服务的货币价格上下浮动，人们会做出相应的反应，人们相互配合实际上是因为商品和服务的货币价格不断发出变化的型号，人们根据这些型号协调自己的行为。</p><p>​虽然货币在社会运作中发挥了至关重要的作用，但是这与共鸣的品格或道德毫无关系，人们关注货币价格，是因为他们想尽量让自己手上的资源换取更多有价值的东西，货币及价格帮助生产者计算预期成本与预期收益，这种关注价格的自利（自利不是自私）行为，最终变成合作行为。</p><p>货币与利息</p><p>​借贷意味着获取我们尚未获得的购买力。</p><p>​为什么你愿意支付学生贷款的利息，因为你认为现在的逆利息相对学习带来的未来的机会，成本更低，只要借贷的预期收益高于利息，借贷就是合理的。</p><p>时间偏好</p><p>​现在的商品和未来的商品价值不一样，人们一般喜欢正的时间偏好率：相比于遥远的享受，我们通常认为现在的享受价值更高。</p><p>​比如现在你有一张100元的支票，但是3个月后才能兑换，你就会略感失望，但是如果3个月后可以兑换150，你又不会觉得难过，则你的时间偏好率是25%。</p><p>储蓄创造了借贷的机会</p><p>​借方支付利息，是为了诱使贷方放弃现在享受商品的机会</p><p>​银行承诺向储户支付一定的利息汇报，接着银行再将这些美元借给借款者，收取高于支付给储户的利息，这个利息差就是银行潜在的获利机会。</p><p>​这个也是符合供给曲线+需求曲线的，利率越高，供给越多、利率越低，需求越大</p><p>​借贷的需求量增加，需求曲线上移，银行也会给供给方更多的利息，如果市场借款需求少，需求曲线下降，则利率下降，供给也开始减少，</p><p>​当供给曲线与需求曲线相交的时候，就产生了市场利率。</p><p>利率中的风险因素</p><p>​市场反应了时间偏好率，市场利率还包含大小不一的风险溢价，比如信用好的客服支付贷款利率降低，信用较差的用户贷款支付利率较高，这里的溢价利润可以被认为是一种保证金。</p><p>实际利率与名义利率</p><p>​贷方预见货币未来的购买力会下降，因此为了保持盈利要求，就需要额外考虑通货膨胀的影响，比如原本打算收取3%的利率，但是未来1年会通货膨胀2%，则应当收取5%的利息。</p><p>​实际利率 &#x3D; 名义利率 - 通货膨胀率</p><h2 id="第六章-意外之果：供给与需求的更多应用"><a href="#第六章-意外之果：供给与需求的更多应用" class="headerlink" title="第六章 意外之果：供给与需求的更多应用"></a>第六章 意外之果：供给与需求的更多应用</h2><ul><li>区分行动计划导致的有意之果和意外之果</li><li>探索规则如何塑造激励机制，以及激励机制如何影响供给和需求决策</li><li>分析和解释价格管控如何使商品短缺或过剩</li><li>论证”生产成本通常由价格决定“</li><li>不懂经济学的人会错误的使用供给和需求分析并做出错误的预测，举出一些这样的例子。</li></ul><p>​这一章，我们探索一些新的主题，比如价格管控、禁酒令和禁毒令、当代奴隶贸易以及关于成本与价格的偏见。</p><p>6.1 灾难中的困惑</p><p>​当自然灾难来临的时候，我们常常看见偷窃、抢劫以及其他暴行增多，这不是合作破裂的案例吗？但是这并不是说明市场交换过程失效了，仅仅代表人们冲动的拒绝遵守现行的游戏规则和产权规则</p><p>6.2 灾难中的协调</p><p>​在自由市场经济体系中，每个人都试图推进国自己的项目，市场出清或者系统化的计划协调是上述行为的意外之果。</p><p>​如果一个地方即将发生风暴，那么胶合板的数量将会大大增加，在供给不变的情况下，需求曲线上移，也许还有敏锐的商人选择撤走部分货源，这样供给也会部分减少。</p><p>​如果说价格是被贪婪的浪潮推高的，那么买房并不比卖方无辜。</p><p>​不懂经济学的人和批评家会说这种涨价行为是”趁火打劫“。这里到底是谁打劫了谁，其实是消费者自己，消费者的竞争者永远是消费者，消费者与商家是互利关系。</p><p>​物价飙升说明市场过程正在发挥作用：需求的上升和供给的下降共同导致价格的上涨，商品相对稀缺程度更高了。</p><p>​价格升高并非是坏事，这方双方能够继续协调计划，无论是在产品调度，还是原料生产商，更高的价格带来更多的供给，市场鼓励人们采取适当的行动，让他们看起来<strong>仿佛</strong>在为国家出力，最终随着供给的不断增加，生产曲线开始向右移动，出清价格不断下降。</p><p>​将涨价现象认为是”趁火打劫“的批评家不仅没有准确理解这个词的意思，也没有理解市场机制传达的信息和提供的激励机制。</p><p>​如果政府长期严格的执行哄抬物价的手段，协调的责任将会落在政府机构身上。</p><p>​</p><p>6.3 解决价格问题的冲动</p><p>​虽然说上述协调让大家公共解决了问题，但是其过程中依旧存在物价飙升的问题，我们能否通过价格管控的措施去改变游戏规则，禁止人们以超过上限的价格买卖汽油呢？</p><p>​我们首先要面对一个问题，卖多少价格才算公平？以及到底对谁公平？我们价格是倾向于用户，然后定价2美元，法律不允许每升汽油超过2美元；</p><p>​然后这也会导致另一个问题</p><img src="http://qiliu.vkcyan.top/FkvCf2zw_3BqtD8L_RDIzGY8zE-Q.png" style="zoom:33%;" /><p>​原本市场的出清价格是4美元，供需达成一致，现在变成2美元够，需求增加了到了1200，但是供给却下降到了2，市场每天都会缺少2的汽油。</p><p>​这样的情况人下，消费者可能会更多的驾车出行，购买大排量汽车，但是卖方的收入和利润都会下降，面对这样的情况他们不得不做出优化，减产；这个计划是不可能实现的。</p><p>​</p><p>6.4 价格锁定时的竞争</p><p>​如果卖方和买方都不能提价，他们如何解决商品短缺问题？面对稀缺商品，必然是存在某种分配标准的，所以我们我们还要看到购买汽油的非货币成本的上升，这个非货币成本可能是某种规则，也可能是自然演化而来。</p><p>​<img src="http://qiliu.vkcyan.top/FroUpJKfe0CRDClPQZ3QRwoEEt2w.png" style="zoom:33%;" /></p><p>​比如加油站排起长队，也许就是非货币成本的最佳例子，在限价措施下，让你们发现自己并不能想买多少就卖多少，他们只能赶在汽油售空之间赶到加油站，消费者与消费者开始竞争。</p><p>​当然还有一些其他手段，比如雇人买油，走后门交易，为加油工付小费，购买加油站的增值服务，这些做法都会提高汽油的成本，直到需求量降至供应量。</p><p>​经济学家认为短缺现象的核心是货币价格。当需求方相互竞争的时候，货币价格应发挥分配稀缺商品的功能；只有当货币价格无法发挥功能时，才会出现商品短缺现象。在现实生活中，每当获取某种稀缺商品或服务的非货币成本上升，我们都会观察到短缺现象。稀缺是不可避免的，但只要允许价格浮动就能避免短缺现象。</p><p>6.5 恰当的信号与不恰当的信号</p><p>​当一个商品明显短缺，但是法律不允许涨价的时候，供应方会怎么做呢？他们通常会寻找其他方式从当前局面中获利，比如缩短营业实现，如果2小时就可以卖完，又何必买8个小时呢？而最终都会进一步增加买房购买汽油的成本。</p><p>​作为供应商，因为商品的稀缺性，需求的主导权就发生了变化，又为您服务，变成为我服务。</p><p>​<strong>原本我们是为消费者考虑，最终却让消费者承担了更多、更复杂的成本。</strong></p><p>​我们的社会和经济系统高度复杂、相互依存，不断变化的货币价格保证其中的协作能有效的发生，我们对这种信号极度依赖。当商品的相对稀缺程度改变的时候，如果不允许物价发送相关信号，供给方和需求方就会收不到恰当的信号，最终变得无序混乱。</p><p>​</p><p>6.6 想在城里找间公寓？去看讣告栏吧</p><ul><li>纽约市出租公寓一直短缺，这并不是因为市场失灵，而是存在房租管控制度</li><li>因为房租管控的存在，寻找一间出租房的非货币成本极高，阅读讣告就是成本之一</li><li>随着出租房需求的是增加，同一间房的租金增加了200美元，人们对此表达不满。</li><li>租房的供给曲线比较特殊，其供给曲线是0，短时间内不存在供给数量的变化</li></ul><img src="/Users/wukai/Library/Application Support/typora-user-images/image-20240216164849482.png" style="zoom: 33%;" /><ul><li><p>增加了房租管控之后，需求量增加到了1000，这将会让250人租不到房子。</p></li><li><p>公寓还是一样稀缺，当租金无法达到需求量等于供给量的水平，就一定会出现价格以外的其他分配标准，比如性别、年龄、人种，抱有歧视的房东将会更多。</p></li><li><p>有限的收益以及紧缺的房源，让房东没有维护公寓的动力，甚至会不断恶化，退掉公寓改成停车场或者办公楼，供给进一步减少。</p><p><strong>租房管控本来是帮助租客，结果却让他们可以租到的公寓越来越少了。</strong></p></li></ul><p>6.7 烈酒和烈性毒品：犯罪的激励机制</p><p>​在美国20年代，出现过禁酒令，这里出现了一些有趣的现象</p><ul><li>黑市的高度烈酒流通的更多多，啤酒葡萄酒的产量锐减，是因为人们爱喝高度酒吗？</li><li>芝加哥街头，烈酒的制造商与经销商经常发生野蛮暴力的冲突，为什么做生意会打架呢？</li></ul><p>​首先，禁酒令并非摧毁了酒类的供给与需求过程，而是将其定义为非法行为，人们只能通过地下的方式协调自己的活动，所以禁酒令实施后，酒类的生产开始被黑帮、犯罪分子控制。</p><p>​禁酒令的出现让酒的供给大幅下滑，但是需求却没有明显降低，这导致了需求曲线左移，酒类价格飙升。</p><p>​酒类的生产与分销转移到地下后，在犯罪领域具有比较优势的人成为行业内的佼佼者，他们的游戏规则更加没有下限。</p><p>​关于酒类的生产，如果运一车啤酒的风险与运送一车烈酒被抓的概率一样，为什么不做收益更大的事情呢？这导致地下市场上高度酒非常普遍，低度的酒精饮料非常少见，这并非消费者的需求偏好。</p><p>​禁酒令的初衷是希望整个社会更加稳定，但是最终却导致黑帮的快速崛起，警匪一家亲整个社会的安全系数下降，大批工人失业，更多的人酒精中毒。</p><p>​以上情况的出现，并非市场的失灵，恰恰相反，即使在非法领域，市场依旧表现出惊人的顽强。最只能说是政府的失灵，因为政府没能有效的指定自己指定的游戏规则。</p><p>6.8 脱脂奶、全脂奶和牛奶黑帮</p><p>​如果不是酒，而是牛奶，也会形成以上场景，更贵的全脂牛奶将会占据地下市场，黑帮会挤走在牛奶行业兢兢业业工作多年的好人。</p><p>6.9 价格下限与商品过剩</p><p>​通过上述的一些思考，我们知道了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《经济学的思维方式》读书笔记4-6&quot;&gt;&lt;a href=&quot;#《经济学的思维方式》读书笔记4-6&quot; class=&quot;headerlink&quot; title=&quot;《经济学的思维方式》读书笔记4-6&quot;&gt;&lt;/a&gt;《经济学的思维方式》读书笔记4-6&lt;/h1&gt;&lt;h2 id=&quot;第四章：成</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="经济学" scheme="https://bluedancers.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《如何避免孤独终老》读书笔记</title>
    <link href="https://bluedancers.github.io/2024/01/04/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AD%A4%E7%8B%AC%E7%BB%88%E8%80%81/"/>
    <id>https://bluedancers.github.io/2024/01/04/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AD%A4%E7%8B%AC%E7%BB%88%E8%80%81/</id>
    <published>2024-01-03T16:00:00.000Z</published>
    <updated>2024-01-04T07:17:07.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="为什么现在谈恋爱比以前更难了"><a href="#为什么现在谈恋爱比以前更难了" class="headerlink" title="为什么现在谈恋爱比以前更难了"></a>为什么现在谈恋爱比以前更难了</h3><ul><li>我们的身份开始完全由自己决定，而不是上一辈安排</li><li>互联网的出现，大大增加了人与人交流的机会，也有了太多选择，这反而导致我们难以选择。</li><li>我们都渴望确定性，选择太多导致了大家都不稳定，这不利于感情的建立</li><li>社交媒体造成了攀比与绝望，信息的茧房与误导性，会导致人们错误的认知</li><li>亲密关系中，我们缺少扮演，我们的上一代自由恋爱不多，很多都是为了生存，我们不知道如何成为亲密的人之间是什么样子的。</li><li>在亲密关系中，需要考虑的太多，因为这个世界太自由了</li><li>为了做出正确的选择，我们压力都很大</li></ul><h3 id="婚恋倾向"><a href="#婚恋倾向" class="headerlink" title="婚恋倾向"></a>婚恋倾向</h3><h4 id="浪漫主义倾向"><a href="#浪漫主义倾向" class="headerlink" title="浪漫主义倾向"></a>浪漫主义倾向</h4><ul><li>期待找到灵魂伴侣</li><li>对另一半过于具体与不缺实际的幻想</li><li>相信爱情是充满故事性的</li><li>对爱情抱有不切实际的幻想</li></ul><h4 id="完美主义倾向"><a href="#完美主义倾向" class="headerlink" title="完美主义倾向"></a>完美主义倾向</h4><ul><li>不远降低自己的标准</li><li>过于理性的去看待爱情，喜欢对比与研究</li><li>对对方抱有不缺实际的幻想</li></ul><h4 id="自我怀疑倾向"><a href="#自我怀疑倾向" class="headerlink" title="自我怀疑倾向"></a>自我怀疑倾向</h4><ul><li>自己没有成为理想的自己</li><li>自己还有很多不足</li><li>对自己抱有不切实际的幻想</li></ul><h4 id="浪漫主义倾向的解决办法"><a href="#浪漫主义倾向的解决办法" class="headerlink" title="浪漫主义倾向的解决办法"></a>浪漫主义倾向的解决办法</h4><ul><li>放弃幻想，任何人都有他的缺点，白马王子也会早上口臭，大家都是普通人类</li><li>从此以后过上幸福的生活，是一个错误的幻想</li><li>爱情的邂逅需要自己主动去寻找，电视剧里面都是骗人的</li><li>亲密关系从来没有一帆风顺，都需要人们去可以维护的</li><li>敞开心扉，接受一份与你想象的完全不同的爱情</li><li>并不是降低标准，而是白马王子是不存在的</li></ul><h4 id="完美主义倾向的解决办法"><a href="#完美主义倾向的解决办法" class="headerlink" title="完美主义倾向的解决办法"></a>完美主义倾向的解决办法</h4><ul><li>不仅害怕错过，也害怕选错</li><li>我们的大脑会自己说服自己，自身合理化</li><li>知足常乐者并不是要求低，而是找到了期望的之后，就不在考虑其他选项</li><li>如果一个人的婚姻时间是18-40，按照37%法则，那么在26岁的时候，就可以结合之前的经验做出判断了，当我们有足够的数据，则不需要做更多的研究了</li><li>送给自己一份知足常乐的礼物吧！</li></ul><h4 id="自我怀疑倾向的解决办法"><a href="#自我怀疑倾向的解决办法" class="headerlink" title="自我怀疑倾向的解决办法"></a>自我怀疑倾向的解决办法</h4><ul><li>自我苛求者被恐惧束缚了手脚</li><li>不进行行动的自我怀疑成本极高，也会失去学习的机会</li><li>每个人都会犯错，最好现在就犯错</li><li>设定明确的目标，比如一个月最少认识一位异性</li><li>做自己拉拉队长，对自己进行鼓励</li></ul><p>一旦决定某件事，你的大脑就会开始不断的合理化。</p><h3 id="依恋类型"><a href="#依恋类型" class="headerlink" title="依恋类型"></a>依恋类型</h3><ul><li>焦虑型</li><li>安全型</li><li>回避型</li></ul><h4 id="体现在婴儿身上"><a href="#体现在婴儿身上" class="headerlink" title="体现在婴儿身上"></a>体现在婴儿身上</h4><ul><li>焦虑型是妈妈离开后会哭泣，回来后，会停止哭泣，但是随后又会愤怒，再次哭泣</li><li>安全型是妈妈离开后会哭泣，回来就会停止哭泣，安心玩耍</li><li>回避型是妈妈离开后，反应很淡，虽然心跳会加速，但是不会进行表现</li></ul><h4 id="体现在成年人身上"><a href="#体现在成年人身上" class="headerlink" title="体现在成年人身上"></a>体现在成年人身上</h4><h5 id="焦虑型"><a href="#焦虑型" class="headerlink" title="焦虑型"></a>焦虑型</h5><ul><li>一刻不停的想念自己的伴侣</li><li>会对感情抱有不安全感，阶段性怀疑，它还爱我吗</li><li>可能会做出一些过激行为</li></ul><h5 id="回避型"><a href="#回避型" class="headerlink" title="回避型"></a>回避型</h5><ul><li>觉得不能依赖他人</li><li>总是避免和人走的太近，对亲密关系有点抵触</li><li>总是会仔细琢磨另一半不好的地方，然后设法离开，幻想单身或者换个人更好</li></ul><p>自我评价一下自己，50%的安全、35%的焦虑，15%的回避</p><h3 id="寻找终生伴侣而不是舞伴"><a href="#寻找终生伴侣而不是舞伴" class="headerlink" title="寻找终生伴侣而不是舞伴"></a>寻找终生伴侣而不是舞伴</h3><ul><li>出去约会到底是为了短暂的快乐，还是长久的亲密关系？</li><li>在爱情上，我们容易过于重视当前的感觉，而忽略了未来的价值，我们实际寻找的是终生伴侣</li><li>有意识的摆脱寻找舞伴的思维</li></ul><h4 id="没那么重要"><a href="#没那么重要" class="headerlink" title="没那么重要"></a>没那么重要</h4><p>人们总是会将正在思考的事情认为成更加重要，也就是聚焦错觉</p><h5 id="金钱"><a href="#金钱" class="headerlink" title="金钱"></a>金钱</h5><ul><li>从金钱中获得的快乐不取决于金钱的多少，而是取决于你周围人多有钱</li><li>在亲密关系中考虑这个没错，但是财富不是最重要的</li></ul><h5 id="长相"><a href="#长相" class="headerlink" title="长相"></a>长相</h5><ul><li>人们看重长相有历史上的进化原因，在现代社会的加持下，这不是大问题</li><li>当你习惯了他的长相，或者随着时间的推移，迷恋都会随之消失</li><li>不要将长相放在其他更加重要的事情前面</li></ul><h5 id="相似的性格"><a href="#相似的性格" class="headerlink" title="相似的性格"></a>相似的性格</h5><ul><li>你真的愿意和自己谈恋爱吗</li><li>科学研究证明，相似的性格并不意味着亲密关系一定会成功</li><li>可以试试互补的人，未来会更加有趣</li></ul><h5 id="共同的爱好"><a href="#共同的爱好" class="headerlink" title="共同的爱好"></a>共同的爱好</h5><ul><li>没必要一定共同爱好，只要给彼此留出足够的空间与自由</li><li>各自探索，对一个未来更好</li></ul><h4 id="更加重要的"><a href="#更加重要的" class="headerlink" title="更加重要的"></a>更加重要的</h4><h5 id="情绪稳定，心地善良"><a href="#情绪稳定，心地善良" class="headerlink" title="情绪稳定，心地善良"></a>情绪稳定，心地善良</h5><ul><li>夫妻情绪都稳定，婚姻美满的概念就会大大提升</li><li>心地善良的人会最好的伴侣，愿意成为另一半的后盾</li></ul><h5 id="忠诚"><a href="#忠诚" class="headerlink" title="忠诚"></a>忠诚</h5><ul><li>人生不仅仅是共享荣华富贵，也是共担患难</li></ul><h5 id="成长型心态"><a href="#成长型心态" class="headerlink" title="成长型心态"></a>成长型心态</h5><ul><li>成长型心态相信，可以通过后天提升自己的智力与技能</li><li>一个成长型心态的人更会认真努力</li></ul><h5 id="能否激发出你好的一面"><a href="#能否激发出你好的一面" class="headerlink" title="能否激发出你好的一面"></a>能否激发出你好的一面</h5><ul><li>要一起变得越来越好，而不是数落与打击</li><li>和他理解的开始，是否会觉得无聊，泄气，还是快乐，充满渴望</li></ul><h5 id="懂得合理争吵"><a href="#懂得合理争吵" class="headerlink" title="懂得合理争吵"></a>懂得合理争吵</h5><ul><li>吵架不是坏事，不要将不满憋在心里</li><li>需要人认识到亲密关系中大约有69%的事情是无法解决的</li><li>理性表达、采取行动、多加欣赏</li><li>目标是合理争吵，而不是避免争吵</li></ul><h5 id="很一起做出艰难决定的人"><a href="#很一起做出艰难决定的人" class="headerlink" title="很一起做出艰难决定的人"></a>很一起做出艰难决定的人</h5><ul><li>面对困境，能否一起做出合理的解决方案</li><li>是否一个乐于领导，一个乐于服从</li><li>事情出现了差错，你是否会责怪另一半</li></ul><p><strong>一段亲密关系成功的关键：一个人的情绪是否稳定，是否善良、忠诚，以及和这个人在一起的时候，我们感觉如何。</strong></p><p><strong>把舞伴留在舞台，寻找长期伴侣吧！</strong></p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="你其实并不知道自己想要什么"><a href="#你其实并不知道自己想要什么" class="headerlink" title="你其实并不知道自己想要什么"></a>你其实并不知道自己想要什么</h3><h4 id="社交媒体上"><a href="#社交媒体上" class="headerlink" title="社交媒体上"></a>社交媒体上</h4><h5 id="你并不知道自己想要什么"><a href="#你并不知道自己想要什么" class="headerlink" title="你并不知道自己想要什么"></a>你并不知道自己想要什么</h5><ul><li>我们过于关注可量化的数字，但是这个常常不是重点</li><li>我们错误的使用自己想要的数据把潜在对象过滤掉了</li><li>交友软件催生了 购物式恋爱，而不是显示生活的渐进式恋爱，将活生生的人变成了被搜索到商品</li><li>交友软件太多的选择，反而让我们约会这件事变得更加困难</li><li>放开交友软件中的过滤条件</li><li>寻找接受对方的理由，而不是寻找缺点，很多人比档案里面表现的要有趣的多</li></ul><h5 id="如何利用社交媒体"><a href="#如何利用社交媒体" class="headerlink" title="如何利用社交媒体"></a>如何利用社交媒体</h5><ul><li>挑选几张好照片</li><li>抓拍的照片比摆拍的更好</li><li>要准确、实际的描述自己，而不是理想中的自己</li><li>要写的具体，别人才有兴趣和你交谈，具体喜欢什么电影，具体爱做什么菜</li><li>关注自己喜欢什么，而不是不喜欢什么</li><li>构思一个巧妙的开场白</li><li>尽快进入正题，也就是面对面交流，因为聊的太多，反而不是好事情</li></ul><h3 id="现实生活中"><a href="#现实生活中" class="headerlink" title="现实生活中"></a>现实生活中</h3><h4 id="参加活动"><a href="#参加活动" class="headerlink" title="参加活动"></a>参加活动</h4><ul><li>多多参加社交活动，朋友需要自己主动去寻找</li><li>可以参考活动决策矩阵<ul><li>和他人互动多机会有多大</li><li>玩的开心的机会有多大</li></ul></li></ul><h4 id="朋友与家人的介绍"><a href="#朋友与家人的介绍" class="headerlink" title="朋友与家人的介绍"></a>朋友与家人的介绍</h4><ul><li>开口让别人给你介绍对象，并告诉他们你要找人生伴侣而不是舞伴</li><li>同时给你的好朋友发几张照片</li><li>要接受朋友们的安排，这都是他费心介绍的</li><li>给朋友反馈</li><li>为这件事提供奖励</li></ul><h4 id="考虑已经认识的人"><a href="#考虑已经认识的人" class="headerlink" title="考虑已经认识的人"></a>考虑已经认识的人</h4><h4 id="出门在外，勇敢的介绍自己"><a href="#出门在外，勇敢的介绍自己" class="headerlink" title="出门在外，勇敢的介绍自己"></a>出门在外，勇敢的介绍自己</h4><ul><li>主动才有缘份，注意分寸就行</li></ul><h3 id="如何更好的约会"><a href="#如何更好的约会" class="headerlink" title="如何更好的约会"></a>如何更好的约会</h3><ul><li><p>约会的环境很重要，人们是非常受环境影响的</p></li><li><p>避免评估式约会，应该体验式约会，多问自己感觉如何，而不是看条件</p></li><li><p>学会不是工作，不是求职</p></li><li><p>首次约会的目的并不是结婚，而是是否可以引起对方的好奇心</p></li><li><p>约会的心态很重要，消极的心态带来消极的结果，积极的心态带来积极的结果，期待会带来快乐</p><ul><li>约会前和最好朋友聊聊天，让自己充满自信也更加更讨喜</li><li>约会前听听喜剧，保持好心情</li><li>做一些简单运动，释放内啡肽</li><li>洗个香香的热水澡</li></ul></li></ul><h3 id="不要迷恋一见钟情"><a href="#不要迷恋一见钟情" class="headerlink" title="不要迷恋一见钟情"></a>不要迷恋一见钟情</h3><ul><li>一见钟情往往会蒙蔽我们的双眼，一见钟情不代表两个人就合适</li><li>一见钟情不是好事，这只能证明一个人有迷人或者自恋</li><li>一见钟情，不代表感情就可以很好维持，可能只是站在一见钟情的份子上，不断坚持</li></ul><p>然后这辈子都不去辜负这梦幻一般的相逢</p><p>不要因为好像找到了正确的人，而沿着错误的道路一直走下去。</p><h3 id="开始第二次约会"><a href="#开始第二次约会" class="headerlink" title="开始第二次约会"></a>开始第二次约会</h3><ul><li><p>不想被别人评价，就不要去评价别人</p></li><li><p>负面偏见，人们总是更加容易记住危险的，批评的话与人，我们要认清这一点</p></li><li><p>归因错误，这个迟到，就是不守信用，说话大声就还是脾气暴躁，这都是客观的评判，别被自己误解了</p></li><li><p>去寻找积极的一面，比如看到别人的善良、体贴、聪明</p></li><li><p>默认选项的重要性，默认自己会开始第二次约会，别给自己思考的机会</p></li><li><p>识别什么是小毛病什么是大毛病，小毛病别可以容忍，大毛病无法容忍</p><ul><li>小毛病， 这个人不是一米八、这个人不够英俊</li><li>大毛病，消费观不合、对未来的期待不合</li></ul></li><li><p>如果要拒绝别人，请不要玩失踪</p><ul><li>玩消失会让玩消失的人感觉难受，还不如直接表达自己的感受</li><li>根据自我知觉理论，人们不告而别后，会想：我做了一个不好的事情，我大概是个滚蛋</li><li>当人们玩消失的时候，他们认为自己走了一条轻松的路，但是他们错了，如果我们选择善良、坦率、礼貌的方式，我们更加能够获得正面回应</li></ul></li></ul><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><h3 id="主动决策，而不是顺其自然"><a href="#主动决策，而不是顺其自然" class="headerlink" title="主动决策，而不是顺其自然"></a>主动决策，而不是顺其自然</h3><ul><li>主动决策的关系要比顺其自然的关系更加具备信任感</li><li>主动明确关系，哪怕得到是不好的回答</li><li>同居更加容易让人们因为惯性走到一起，所以要认真对待这件事</li></ul><h3 id="既不要说走就走，也不患得患失"><a href="#既不要说走就走，也不患得患失" class="headerlink" title="既不要说走就走，也不患得患失"></a>既不要说走就走，也不患得患失</h3><h4 id="说走就走型"><a href="#说走就走型" class="headerlink" title="说走就走型"></a>说走就走型</h4><ul><li>不给感情发展的机会，过早的选择离开</li><li>通常是个完美主义者，追求或者相信自己可以找到更好的</li><li>不仅影响被甩的人，也影响自己，没有机会学习如何成为一个长期的好伴侣</li><li>说走就走永远都是原地踏步的循环，没人希望这样。</li><li>多多发现对方的长处，而不是盯着缺点一直想</li></ul><h4 id="患得患失型"><a href="#患得患失型" class="headerlink" title="患得患失型"></a>患得患失型</h4><ul><li>感情已经破裂，但是仍然不愿离开</li><li>我应该听从内心的声音和她分手吗，我会不会错过一段美好的姻缘？</li><li>因为沉没成本的执念，我在她身上花费了太多时间，现在退出太亏了</li><li>因为厌恶损失的影响，我们总是把损失看得比收益更加重要</li><li>我们对失去伴侣充满恐惧，胜过我们对新的约会的对象的兴趣</li><li>分手不是闸道，而是一个丁字路口，我们总是要做出选择，而不是停滞不前</li><li>我应该如何做出决定<ul><li>想象一下如果你的伴侣是衣柜一面的一件衣服，你认为是哪一种？</li><li>不好的表现是不是暂时的，还是长期这样</li><li>是否尝试修复你们的关系</li><li>你对长期伴侣的期望是什么样，是否实际？</li><li>在这段感情中，你做到最好的自己了吗？</li></ul></li><li>征求朋友与家人的意见</li></ul><h3 id="定制一个分手计划"><a href="#定制一个分手计划" class="headerlink" title="定制一个分手计划"></a>定制一个分手计划</h3><p>​及时决定分手的人，实际做起来都非常困难，人们害怕艰难的谈话，害怕伤害对方，害怕一个人独处，通常会花几个月，几年的时间去畏缩、迟疑，也许我们需要一个分手计划。</p><ul><li>记下你分手的原因<ul><li>喜欢攀比，看到别的男朋友好就会给我压力。</li><li>过于算计，一点亏吃不得。</li><li>太多要求让我倍感压力。</li><li>与我的长期目标不一致，不想结婚，不想生孩子，不想承担家庭的责任。</li><li>大家的脾气都非常尖锐，我们没有做到相互理解与尊重彼此。</li><li>我们总是吵架，这人我们都很糟糕，我不喜欢我们的表现。</li><li>我做出了挽回感情的努力，我相信现阶段结束是最好的选择。</li></ul></li><li>定制分手计划<ul><li>写下目标、定制计划会让实现目标的可能性高出33%</li><li>选择一个安静的地方，让大家好好交流</li><li>选择一个合适的时间，分手是引爆对方生活的炸弹，如果后面它有要紧的事情，别毁了它的计划。</li><li>提前思考谈话的目的，核心信息，语气，开场白，内容，对方可能的反应，如何结束对话</li></ul></li><li>和朋友建立一个问责体系<ul><li>找你的朋友确认一个目标，以及期限。</li></ul></li><li>我们去谈话，不是干其他的事情<ul><li>我们可能会谈话情绪的波动做出一些不该做的事情，参考尤利西斯契约，不要改变航向。</li></ul></li><li>为自己制定一个分手后的短期计划<ul><li>考虑好分手后你要做什么</li><li>朋友、家人、美食、电影</li><li>避免孤独与不安</li></ul></li><li>和前任签订分手协议</li><li>改变习惯，避免再次陷入这段感情<ul><li>分手后，生活中会有很多空洞</li><li>换个人来替换和对象经常做的事情吧，一个强有力的策略就是用新的活动、人代替她</li></ul></li><li>不要在分手后，做一个黏黏糊糊的老好人<ul><li>即使一切都在预料之中，对个人而言也不是一件容易的事情</li><li>分手后的一段时间，心情会做过山车，从极度放松到极度后悔，我会孤独终老吗，我为什么要这么做</li><li>可能会感到内疚，因为你伤害了在乎你的人</li><li>做老好人，很多是为了自己，而不是在帮助对方，给对方精简，</li></ul></li></ul><p>​如果我们曾经努力过，但仍然无法解决问题，有觉得彼此的伤害难以忘记，那或许分手是当前最好的选择，尽管还有感情存在，但长期的矛盾和伤害会削弱彼此的幸福感与成长空间，</p><p>​说实话，我依旧对你还有感情，我也很喜欢我们在一起的很多时光，但是我并不开心，我们都知道我们的感情出了问题，我们也都努力过尝试改善，但是我们一直都没有做出有效的改变；</p><p>​这很难说出口，因为我不想伤害你，非常感激我们在一起的时光。</p><h3 id="把分手看做收获而不是损失"><a href="#把分手看做收获而不是损失" class="headerlink" title="把分手看做收获而不是损失"></a>把分手看做收获而不是损失</h3><h4 id="如何克服分手后的心碎"><a href="#如何克服分手后的心碎" class="headerlink" title="如何克服分手后的心碎"></a>如何克服分手后的心碎</h4><ul><li>要想走出分手，关键是找对描述事物的框架</li><li>分手之所以痛苦，是因为大脑对损失非常敏感，分手是绝大的损失，你个伴侣曾经一起构想的未来就此终结，让你悲伤的不仅仅是不堪回首的过往、面目全非的现在、还有再无可能的未来，因为厌恶损失，我们总是尽量避免分手。</li><li>一切都都会过去，你的感觉都是暂时的，你终将走出这个阶段</li></ul><h4 id="关注分手的积极方面"><a href="#关注分手的积极方面" class="headerlink" title="关注分手的积极方面"></a>关注分手的积极方面</h4><ul><li>大脑会帮你合理化，尽量去想一些积极方面的事情</li><li>告诉大脑你渴望的东西，为什么这次分手很好</li></ul><h4 id="关注亲密关系中消极的部分"><a href="#关注亲密关系中消极的部分" class="headerlink" title="关注亲密关系中消极的部分"></a>关注亲密关系中消极的部分</h4><ul><li>思考已经结束的这段感情中不好的地方</li><li>不和谐的地方</li><li>让你讨厌的事情</li></ul><h4 id="重新发现自己"><a href="#重新发现自己" class="headerlink" title="重新发现自己"></a>重新发现自己</h4><ul><li>你恢复了单身，会成为什么样的人呢</li><li>做一些你们在一起的时候，你想做却没能做的事情</li><li>太多独处意味着对自我价值的怀疑，勇敢的出去走走</li></ul><h4 id="吸取分手的教训"><a href="#吸取分手的教训" class="headerlink" title="吸取分手的教训"></a>吸取分手的教训</h4><ul><li>把分手看成一个学习的机会，反思这段感情学到了什么，没做好什么</li></ul><p>试着不把分手看做失败，看成一个机会，促使你在未来做出更好决定。让你的思想升级一下，从时间能治愈一切创伤，变成意义能治愈一切创伤。</p><h4 id="需要思考的问题"><a href="#需要思考的问题" class="headerlink" title="需要思考的问题"></a>需要思考的问题</h4><ul><li>在上一段感情中，你的地位是什么？</li><li>在下一段感情中你希望扮演什么角色？</li><li>认真反思后，你认为一段长期亲密关系中，什么最重要</li><li>你是否在这一次关系中没有考虑到某件事</li><li>你希望在下一段关系中，首先从对方身上寻找什么特质？</li><li>在这段感情里面你学到了什么？</li><li>从分手中你学到了什么？</li><li>在这段感情之前的你和现在的你有什么不同？</li><li>这段经历对你的生活带来了什么改变？</li></ul><p>与其让自己被打碎，不如主动打碎自己的枷锁，哪些裂痕、不完美，会让你变的更加坚强。</p><h3 id="喜结连理之前要做的事情"><a href="#喜结连理之前要做的事情" class="headerlink" title="喜结连理之前要做的事情"></a>喜结连理之前要做的事情</h3><ul><li>婚姻对人生的幸福、自己的身心健康、寿命、财富、子女的幸福都存在巨大的影响，所以要慎重对待</li><li>彼此相爱并不够可能会让彼此产生“错误共识效应”，认为对方在生活中和自己想要的东西一样，直到婚后才发现，并不一样</li><li>首先问自己若干问题</li><li>问我们过去、现在、未来的若干问题</li></ul><h3 id="目标明确的爱情"><a href="#目标明确的爱情" class="headerlink" title="目标明确的爱情"></a>目标明确的爱情</h3><ul><li>随着婚姻时间的增加，满意度一定是逐渐降低的</li><li>现代社会，幸福婚姻的趋势在不断下降</li><li>爱情是需要我们认真经营，并不是说要做到最好，最恩爱的，而是营造可以适应变化的亲密关系</li><li>建立一个亲密关系的契约，它帮助伴侣们为他们的亲密关系设定一个共同的愿景，在编写亲密关系契约的时候，并不是抱怨对方的缺点，也不是提出要求，而是价值观上的一致：我们承诺支付对方的梦想，并为实现这些梦想做出必要的牺牲。</li><li>选择主动决策，而不是任凭感情自然发展，这更有助于亲密关系的实现</li><li>契约中要进行例行检查，契约保证你们发展在一个方向，而检查则确保始终沿着正确的轨道前进，这要可以在问题爆发之前，对亲密关系进行调整，一起谈谈身上正在发生的事情，我的生活变成了什么样子？</li><li>牢固亲密关系不会凭空出现，需要你尽心尽力的做出正确的选择</li></ul><p><strong>不论怎样，生活都是一次探索之旅，而不是意外事件，主动设计自己的生活，对自己负责，对自己诚实，知道自己是谁，想要什么，最重要的是，必要的时做出改变。你不必按照别人的想法生活，你要按照自己的想法生活。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一部分&quot;&gt;&lt;a href=&quot;#第一部分&quot; class=&quot;headerlink&quot; title=&quot;第一部分&quot;&gt;&lt;/a&gt;第一部分&lt;/h2&gt;&lt;h3 id=&quot;为什么现在谈恋爱比以前更难了&quot;&gt;&lt;a href=&quot;#为什么现在谈恋爱比以前更难了&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="恋爱" scheme="https://bluedancers.github.io/tags/%E6%81%8B%E7%88%B1/"/>
    
  </entry>
  
  <entry>
    <title>2023年终总结-黄金时代的总结</title>
    <link href="https://bluedancers.github.io/2023/12/22/%E6%97%A5%E5%B8%B8/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://bluedancers.github.io/2023/12/22/%E6%97%A5%E5%B8%B8/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2023-12-21T16:00:00.000Z</published>
    <updated>2024-03-25T08:16:14.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​大家好，我是阿木，马上就2024年，我身边是长江西路高架晚高峰的车水马龙，晚上闲来无事的时候，我很喜欢留在公司学习、看书，或者写点什么，今天就来回顾一下自己的2023年吧。</p><p>​我即将来到工作的第6个年头，总的来说，其实今年挺..糟糕的，前几年的年度回顾总是可以找到一些闪光点，今年似乎没有什么值得一提的成就。</p><p>​社会的变化会影响到每一个人，人在年轻的时候，总是会觉得自己潜力无限，总是会相信自己可以凭借自己的努力走的更远，甚至改变命运，这让我我又想到《黄金时代》里面有句非常经典的话。</p><p>​后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</p><p>​矫情到此结束，正文正式开始。</p><h2 id="关于跳槽"><a href="#关于跳槽" class="headerlink" title="关于跳槽"></a><strong>关于跳槽</strong></h2><p>​从18年工作至今，我没有换过工作，<strong>咱也是一家公司5年以上的老员工了</strong>。</p><p>​并不是我对自身实力不自信，或者不敢于去接受新鲜事物，而是一方面现在的公司有恩于我，另一方面外面的薪资比较低。</p><p>​工作的第二年，我因为之前比赛的原因获得专升本的机会，真的去学校的那种，和公司领导聊了之后，公司通过远程的方式继续工作，虽然收入要降低一半，但是完全足够我的日常开销，我可以不需要问家里要一分钱，我一边上学，一边每天工作4-6小时。</p><p>​后来遇到了口罩事件，就不需要到校了，我也正好回到公司正常工作，白天听听网课，这一点让我很感激。</p><p>​23年年初的时候，决定要换一个环境，面试了讯飞的消费者bg（百得思维），面试过程还算顺利，这几年有好好努力学习技术，但是出乎我意料的是，薪资比我现在的要低，我当时一心想换一个环境，跳出舒适圈，便答应了，后面一段时间又想了想，觉得还是不能跳，哪有降薪跳槽的，后面又拒绝了百得的hr，（PS：实在不好意思）。</p><p>​后面又陆续看了一些，要么是非常热门的公司，咱这学历和年限不够，剩下的公司基本都达不到的我对薪资的需求，合肥的前端薪资上限真的比想象的还要低。思来想去还是算了吧，<strong>工作，不就是为了钱吗？</strong>上半年的换工作事件就此终结。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="全面拥抱vue3-ts"><a href="#全面拥抱vue3-ts" class="headerlink" title="全面拥抱vue3+ts"></a>全面拥抱vue3+ts</h3><p>​在技术上，我个人推进将将公司内运营中的项目，全部逐步<strong>更新到vue3</strong>，彻底告别vue2。</p><p>​在年初的时候，因为过去几年针对项目在产品和技术上考虑不周全，团队内部过于技术思维，导致做出的产品难以使用，运营效率低下，技术维护难度也比较大，对产品的维护与使用造成了影响；</p><p>​在我个人的推动下，开始了整个项目的重构，其中包含2个后台和一个前台。<br>​前端借此机会，我们直接将相关项目的前端部分进行全面的重构。</p><ul><li><strong>全面升级为vue3 + ts</strong></li><li><strong>使用全新的项目架构，拥抱最新生态能力</strong></li></ul><p>​总体来说，转移的工作量没有特别大，部分功能直接重写了，总体来说三个前端项目团队大约花费了5个月的时间，在更新问题上，我们团队在nginx中使用二级路由进行区分，老项目中不断切换到新页面，实现渐进式更新项目。</p><p>​vue3以及其生态还是非常不错的。无论是开发体验、还是开发速度、开发范式都更加快速与稳定，这件事做的不错~</p><h3 id="解读vue3源码"><a href="#解读vue3源码" class="headerlink" title="解读vue3源码"></a>解读vue3源码</h3><p>​在年初的时候，我给自己立下了一个flag，要解读vue3的源码，这属实有点高估自己了，vue3的源码相当复杂。</p><p>​在上半年完成了<strong>reacivity模块、runtime模块</strong>的源码解读，也在掘金上专门输出了一个专栏<strong>Vue3硬核源码解析系列</strong>，在watch之后我就没写了，原因是computed的源码实在是过于复杂，我实在没有信心通过简单的话语，一篇文章的方式写清楚computed的核心原理，所以后期就没有再继续输出了。</p><p>​看源码还是虽然很痛苦，但是还是好处多多的，拓展技术思维、了解底层原理，知道文档中很多规则背后的原因，当然在code的时候，也具备更高的视野，编写出更优质的代码</p><p>​总体来说这个目标也算完成了吧，为什么到compiler就没有继续去理解源码了呢？</p><p>​<strong>我觉得是我心态变了</strong>，这个我下面具体再说。</p><h3 id="对技术的思考"><a href="#对技术的思考" class="headerlink" title="对技术的思考"></a>对技术的思考</h3><p>​对于一个5年以上的开发者来说，其实<strong>对技术这个名词的理解已经和刚毕业的同学不一样了</strong>。</p><p>​在我刚毕业的时候，我认为技术岗位非常关键，因为产品最终是由开发者来创造，我觉得自己具备很大的价值与能力，但是随着这几年经历的越来越多，我们会发现很多时候，<strong>很多非常重要的、我们不了解的决策、思考、判断才是决定项目走向的关键</strong>。</p><p>​而技术只是实现的一种方式，本质上来说，不了解业务的的开发者，和工地上打灰的其实没有本质区别，<strong>技术仅仅是工具</strong>。</p><p>​而作为一名业务开发者，我对技术开始有了一种无力感。</p><p>​以前我对技术充满兴趣，我可以不问目的的去了解内部逻辑与实现原理，因为我觉得这很有价值，我很享受自己发光发热的感觉，然而有一天，你突然发现，这其实并不能让你变的多强，并不能让你无所不能的时候，便会开始怀疑自己；</p><p>​下半年某天下班后，在安静的夜晚，我没着急回去，打算学习一会，我打开vue3的源码和教学视频；我无法控制的问自己，了解内部逻辑与实现原理，对我而言真的有用吗？我有天赋成为技术大牛吗？我身处的环境能让我发挥相关价值吗？</p><p>​我看源码的本心究竟是什么？</p><p>​其实说实话，我大部分时候对源码的理解都是了解，达不到游刃有余的使用，我觉得最能发挥的时候可能就是在面试的时候，证明我看过源码，证明我自驱力强，证明我是一个有追求的技术仔，或者说一名舍得出力的打灰人。</p><p>​好吧，其实这几年我逐渐意识到了，在技术领域我和天赋不沾边；况且在合肥这样的小城市，前端技术的上限真的不高，如果一直走技术路线，随着岁数增加，技术竞争力减弱，也许35岁被优化就是我的结局。</p><p>​所以我今年一直有思考下一个5年，下一个10年，我如何选择，如果长得更高，走得更远。</p><p>​<strong>我上面说的这些，并不是想做看源码没用，也并不是看衰技术，只是针对我身处的环境，结合自身的能力，似乎对我而言，技术价值的边际收益已经有限。</strong></p><h3 id="学习后端（nest）"><a href="#学习后端（nest）" class="headerlink" title="学习后端（nest）"></a>学习后端（nest）</h3><p>​每个前端都希望成为全栈工程师，在之前几年我一般都是使用koa2写一些后端应用，后来做一些项目的时候觉得不够规范，所以下半年学习了nest，<strong>这里推荐光神的nest小册，真的非常不错，简单易懂，比官方文档强百倍</strong>。</p><p>​如果说koa2太简单，实际使用nest 又会觉得nest太复杂，其实也有点怪怪的，可能是不太喜欢java这门语言的愿意吧。</p><p>​总的来说，下半年使用nest做了一些后端项目，还是挺不错的，在没有更好的替代品之前，我还是会继续使用nest。</p><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p>​其实上面说到的对技术思考，我前两年就有思考过，不走深度走广度，也是机缘巧合，加上自己的兴趣，我选择了toC产品经理的方向，而今年也是我<strong>做产品的第二年</strong>了。</p><p>​目前在团队里面基本可以承担产品的全部职责了，对产品的流程，对用户需求的分析也更加的熟练与高效；而作为一名95后，初中的时候就接触手机的年轻人，所以对用户体验这一块尤其敏感，所以在toC的产品上，可以基于自己的认知，以及对技术的理解，做出一些更好的用户体验，以及做出能产生积极影响的产品方案。</p><p>​但是23年，在产品领域并不顺利，首先我们公司并不是独立产品，或者说还没有发展到独立产品的程度，我们的产品用户基本都是依托于异业，我们为异业提供能力，异业同时会我们提供流量，因为某些原因，今年这方面的业务遇到了重大挫折，自然我也失去了发挥的空间。</p><p>​<strong>所以有时候面对这些事情，身为一名开发，真的深感无力，技术能决定的事情，其实很少；</strong></p><p>​有时候大家看某人天天摸摸鱼讲讲ppt，对技术发号施令，却拿着很高的薪资，也许并不是人家和老板有关系，或者组织架构有问题，而是人家真的对行业、用户、甲方、产品都有深刻理解，可以相对快速与简单的判断出正确的方向以及具备很强的总结与输出能力。</p><p>​今年没有看太多产品方面的书，其实很多产品的工具书并没有什么营养，<strong>产品的关键从来都不是书上方法论</strong>。</p><p>​有一本薄薄的书《微信背后的产品观》，我觉得很不错，我非常同意书中的一些观点，当时我写了一篇文章 从读《微信背后的产品观》到思考前端工程师的“35岁”。建议对产品有兴趣的同学都读读，这本书会告诉你一些做产品的理念，非常有意思。</p><h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><p>​chatgpt3首次公开是22年的10月，作为互联网人，应该也算是最前沿的一波人了，但是我的认知有限，没有很强的敏锐性，当时没有发现gpt对理解自然语言的巨大威力，只是觉得他挺聪明的，和他聊天很有意思。</p><h3 id="从兴奋到理性"><a href="#从兴奋到理性" class="headerlink" title="从兴奋到理性"></a>从兴奋到理性</h3><p>​到了今年3月，chatGPT开始出圈，我看到很多人对GPT的理解与看法，我才慢慢理解了GPT的巨大的前景。当时非常兴奋，火速开发了一个套壳网站，回头看，其实惊叹于GPT对自然语言强大的理解能力，而作为开发者，我当时只会写prompt，没有任何壁垒与技术含量；</p><p>​社区里面也看到过很多基于gpt做产品的，甚至还有辞职创业的，因为墙的原因，内地也存在需求，所以还是有成功的产品。</p><p>​但是他们更多的是通过对产品的宣传与圈子的传播，而不是对gpt有深刻的理解。所以在我的理解看来，这个今年能通过gpt挣到钱的，都是自媒体玩的好的人，或者打着危言耸听的旗号，利用信息差割韭菜的人，</p><p>​有多少人真的提升了生产力呢？可能并不多。</p><h3 id="始终在尝试公司内的应用场景"><a href="#始终在尝试公司内的应用场景" class="headerlink" title="始终在尝试公司内的应用场景"></a>始终在尝试公司内的应用场景</h3><p>​这一年我断断续续的在寻找gpt的应用场景，真正的从有用的角度去出发，学习了<strong>基于向量数据库的知识库的搭建</strong>，以及<strong>calling Function</strong>等等。</p><p>​关于知识库，本质上是在询问gpt之前，首先从向量数据库中匹配你的问题的相关文字，最后把问题与匹配的文字发给gpt，让他总结再输出，文本内容质量较高，内容较少，效果还可以，但是相对的作用就有限。</p><p>​如果是大量文本，最终的回答就会非常不佳，况且还需要人不断去维护知识库，这不是一件简单的事情。</p><p>​关于calling Funtion，这个挺厉害的，我们可以通过该方式给予gpt链接世界的窗口，进行联网、总结文章、查询天气等等，都可以做到，下半年也基于calling Funtion做一些企业内部的工具，最终感觉对生产力的提升也有限，对效率的提升也有限。所以在生产力方式，总是给我一种食之无味弃之可惜的感觉。</p><p>​也许并不是gpt的问题，我个人并不是相关专业，研究的比较浅显，但是从我个人研究来看，虽然gpt很强，能够理解人类语言，但是脚踏实地的回到现实来看，在23年，GPT能够针对单一场景辅助人类已经是极限了；</p><p>​但是我依旧认可它在未来具备巨大潜力。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a><strong>生活</strong></h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>​今年大约输出了<strong>20篇文章</strong>，关于技术类文章的输出不多，主要是因为业务上没有太多值得输出的亮点，我本人对输出这件事也从来没有抱有很强的目的性，有想法就写，贯彻费曼学习法；</p><p>​随着见多了优秀的文章与作品，我对我自己输出的文章的要求也越来越高，这更加导致找到一篇合适的输出变得不容易；还是对技术的重新思考，也让我对纯技术领域的思考与折腾变少。</p><p>​产品类文章输出了几篇，但是没有发布在掘金，主要发布在自己的<strong>公众号</strong>与<strong>人人都是产品经理</strong>，其中有一篇关于优惠券的文章反响出乎意料的好，得到了一些我认为比较大的平台的推荐与转载，倍感荣幸。</p><p>​朋友们，无论什么时候，无论未来是否还在做技术，都要坚持输出，<strong>输出是思考的结果，是碎片化知识的整合，好的内容不仅造福别人，也是造福自己。</strong></p><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>​上学的时候不好好学习，上班了开始坚持读书。</p><p>​人真的很怪，拥有的时候觉得理所当然不去珍惜，失去了再去怀念。</p><p>​今年看了堪堪<strong>100个小时</strong>的书，还是要多多自律啊。</p><p>​<strong>英语也坚持学习了一整年</strong>，再次推荐多邻国，每天学习十几分钟无痛学习英语~</p><p>​<strong>阅读是一件美好的事情，希望你也能从中得到属于自己的价值。</strong></p><p>​<img src="http://qiliu.vkcyan.top/Fu8MOSwEXOcZLE2R5Ad6osOnClvy.png" style="zoom:50%;" /></p><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>​也不知道是不是人以类聚，还是现代人对未知的恐惧，95后似乎年纪轻轻的都比较怕死，我也是其中一员，去年体检的时候，体检报告写我的颈椎曲度变直，吓得我哪一天都弯腰不敢低头，后脖颈的肌肉绷的像石头。</p><p>​于是重拾了锻炼计划，每周在楼下公园跑步2次，今年9月的公司附近新开了乐刻，价格也比较低，就顺理成章的办卡了，对我来说坚持锻炼似乎并不是一件很难的事情。</p><p>​年底体检的时候，颈椎曲度变直已经消失，今年体重也维持在130，明年继续坚持</p><img src="http://qiliu.vkcyan.top/FtDNHkdDRN_ovaVhfwJD329Yeyw1.png" style="zoom:50%;" /><p>​</p><h2 id="尝试一些新方向"><a href="#尝试一些新方向" class="headerlink" title="尝试一些新方向"></a>尝试一些新方向</h2><h3 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h3><p>​尝试发了一个视频，做视频真的是时间能麻烦的事情，本人还是一个i人，日常里面偏向于不苟言笑的那种，所以和有趣这个词似乎并不是太合拍，所以内容应该也不是特别优秀。</p><p>​最终的结果就是数据很差劲，对视频自媒体直接丧失信心，我大概还没有准备好。</p><h3 id="小红书"><a href="#小红书" class="headerlink" title="小红书"></a>小红书</h3><p>​今年在小红书上分享了一些图文，职场类，主要是针对互联网黑话的一些解读，内容非常简单，其实这个方向很一般，但是苦于找不到更好的输出方向，最终今年收货了接近500的粉丝与1万的阅读量（太少了），也算是一点心理上的慰藉吧。</p><p>​相当于视频，还是图文的方式更加低门槛一点，也更加是个入门，关于自媒体，持续探索吧。</p><img src="http://qiliu.vkcyan.top/FuriMHs2UKs2nbgg2LSxHhsrXdzg.PNG" style="zoom:25%;" /><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​马上元旦了，先祝大家元旦快乐，2023年作为口罩之后的一年，似乎大家都过得不太如意，人生在世，活的就是经历，多留意身边一直被忽略的景色与可爱的人吧，让每一天都过得精彩，让每一天，都有意义；</p><p>​2024年让我们一起共度时艰，明年年度总结，我们再见👋🏻</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	大家好，我是阿木，马上就2024年，我身边是长江西路高架晚高峰的车水马龙，晚上闲来无事的时候，我很喜欢留在公司学习、看书，或者写点什么，</summary>
      
    
    
    
    <category term="日常" scheme="https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="年终总结" scheme="https://bluedancers.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>《四万万顾客》读书笔记</title>
    <link href="https://bluedancers.github.io/2023/12/22/%E9%98%85%E8%AF%BB/%E3%80%8A%E5%9B%9B%E4%B8%87%E4%B8%87%E9%A1%BE%E5%AE%A2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://bluedancers.github.io/2023/12/22/%E9%98%85%E8%AF%BB/%E3%80%8A%E5%9B%9B%E4%B8%87%E4%B8%87%E9%A1%BE%E5%AE%A2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-21T16:00:00.000Z</published>
    <updated>2024-03-25T08:12:41.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《四万万顾客》读书笔记"><a href="#《四万万顾客》读书笔记" class="headerlink" title="《四万万顾客》读书笔记"></a>《四万万顾客》读书笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​作者卡尔克劳在中国生活了了25年，1911年以新闻记者的身份进入中国，1918年创建了克劳广告公司，1937年因为抗战爆发而离开。</p><p>​通过外国人的视角，他是看待中国的顾客？又是如何理解中国人，让我们借用他的视角去再次了解一遍作为中国人的自己。</p><p>​接下来是针对每一章内容的带有个人色彩的概括，以及摘抄，我的描述不代表作者的描述，具体内容还请阅读原文</p><h2 id="不同寻常的顾客"><a href="#不同寻常的顾客" class="headerlink" title="不同寻常的顾客"></a>不同寻常的顾客</h2><ul><li>只要足够便宜，中国人都会买，这是一个错误的观念，没人比中国人更加享受讨价还价</li><li>中国消费者喜欢相对固定的消费，或者说认牌子，一旦习惯了某种东西，即使更好的东西出现，他们也不会立刻改变选择。</li><li>中国认对自己喜欢什么，不喜欢什么非常执着，一旦养成消费喜欢，就会成为世界上最忠诚的客户。</li><li>中国人对任何微小的改变，都会起疑心，比如包装上英文字母的变化</li><li>洋货在中国市场享有主导权利，完全得益于长久以来的口碑</li><li>即使货品一样，中国人也更加看重品牌，不接受替代品</li><li>顾客一般非常清楚自己的需求，对其他的一律不感兴趣</li></ul><h2 id="中国小姐发现美腿"><a href="#中国小姐发现美腿" class="headerlink" title="中国小姐发现美腿"></a>中国小姐发现美腿</h2><ul><li>中国人绝不会亲口告诉你真实的原因，若想知道，你只能拿出认真的精神，专业的做调研。</li><li>美妆类产品并非新时代的产物，中国女孩很早就开始除毛、涂抹胭脂了</li><li>几百年前中国女人就发现了若能保持自身魅力，丈夫就会心甘情愿雇佣仆人洗衣做饭，因此，中国女人是梳妆打扮是全球最完美的。</li><li>只有上了年纪的寡妇才不爱慕这些虚荣之物，这是因为会别人觉得她放荡</li><li>为了美丽，中国小姐非常善于利用道具，比如一种用于缓解牙疼的小热水袋在中国畅销，原因是小姐买过来敷脸可以产生自然的光泽，模仿羞涩红晕</li><li>中国女人一旦冲出了传统重视家庭的限制，没什么再可以把他们拉回去了</li><li>中国女人更加注重身材</li><li>中国女人魅力的出发点多半是为了丈夫（异性）</li></ul><h2 id="无利润销售也可以发财"><a href="#无利润销售也可以发财" class="headerlink" title="无利润销售也可以发财"></a>无利润销售也可以发财</h2><ul><li>中国商人都非常聪明，如果发现某个产品卖的特别快，就会挂出低于正常售价出售，最后导致大家都不挣钱，用户到店的时候，因为挣不到钱，会推销其他品牌</li><li>因为赊账灵活，所以批发商总是有账期，手头上便重视存在现金流，在中国，有了现金流，赚钱的方法就很多了，也就是投资，这就是无利润销售也能发财的原因之一</li><li>中国的学徒不拿工资，理由是店主会提供必要的衣物，生意好的时候还会得到额外的收益与奖赏，还可以缓解父母的压力，还能学会一项技能，这是很多中国人的抱负，也是两情相悦的事情。</li><li>尽管打杂的伙计工资很低，但是很多废品都是店员的，可以二次售卖，店员更加愿意售卖包装更加精美的货品，因为有转售价值。</li><li>中国人懂得艰辛，看见掉在地上的无主铜板都会捡起来，他们无法理解赠品的存在，所以哪怕是赠品，只要有价值他们也会付钱。</li><li>赠品到了中国会失去他原本的目的，并且中间商转售，最终导致品牌受损，与达不到营销的预期。</li><li>中国的男人一般不会逃避或分担养家糊口的责任，常被称为家里顶梁柱</li><li>中国的企业偏向于家族化，所以邀请一个家族的年轻人就以为着获得一个家族的生意</li><li>一个原因在门面上花几千块的人，终究会想办法把钱从顾客手上赚回来，卖家的本能告诉他们，比起简陋的门面，热衷于花哨摆设人更加贪图利益，更应该被提防</li><li>在中国，毫无商业价值的东西，也会被排上用场，被做成鞋垫、做成好看的信封、装点家具</li></ul><h2 id="海鸥到这里都会挨饿"><a href="#海鸥到这里都会挨饿" class="headerlink" title="海鸥到这里都会挨饿"></a>海鸥到这里都会挨饿</h2><ul><li>上海中国人聚居区街道烟蒂都没有，外国人抽烟浪费，还剩半英寸的时候就会扔掉，老人们会捡起来，再手动卷制，这个小生意让街道保持整洁。</li><li>在1937年日本入侵的时候，所以政府岗位都停止了，只有清洁工哈在工作，他们会带着扫帚和篓子，蜂拥到街上回收弹壳和武器的肥料。</li><li>上海港口是世界上最干净的港口，并不是水有多干净，而是没有浮渣于弃物，因为这些都是有价值的东西，会被辛勤的乞丐船打捞，所以上海海鸥都没有</li><li>每当大商船在上海抛锚，因为会存在很多垃圾与被判定不适合的食物，打捞船就会一拥而上。</li><li>在中国，任何东西都具有价值，可以转化为现金</li><li>在中国，家庭苦力不会放在任何一件废弃物，总是可以被排上用场，无法使用的布料可以做鞋垫、旧面粉袋可以做船帆、废纸的另一面可以书写。</li><li>二手市场非常繁荣，并且人们非常具备商业头脑。</li></ul><h2 id="推销无须推销员"><a href="#推销无须推销员" class="headerlink" title="推销无须推销员"></a>推销无须推销员</h2><ul><li>美国人之所以可以组建全球史无前例的销售大军，是美国人心里使然，美国同胞非常享受推销员来访，他们像鉴赏家一样用评估推销员的技巧，遇到精彩的表演就会心情大好，这个过程中，签单的决定性因素并非产品的价格于质量，而是推销员的技能，美国人确实比其他国家的民众更加容易接受推销</li><li>中国推销员没有合适的心理材料，国内没有这个文化</li><li>大多中国人，知道自己想吃什么，知道自己想买什么，倘若他面对的事情不在自己的经验范围之内，就会向东航的朋友寻求建议</li><li>中国人对任何一种口若悬河、旨在让他们掏腰包的人都更加重点防范，因为在儒家文化看来这种人往往没有原则，没有良心</li><li>陌生人在商务与上交场合是不受欢迎的，挨家挨户兜售的人还没有开讲就已经被打败了，因为中国仆人将主人免收侵扰收为己任。</li><li>中国人更加愿意和朋友做生意，或者朋友的朋友，猜忌会烟消云散，双方直奔交易细节。后续如果出现问题有中间人帮忙摆平，这是一种简单高效的优良传统。</li><li>一个中国人最想和自家人做生意，其次是朋友，有可能的情况下，会尽量避免陌生人</li><li>他们这些人做的非常成功，但是于推销能力无关，主要取决于他们同特定品类经销商的友谊于关系。</li><li>因为将生意控制在家族于朋友圈的强烈渴望，某些行业被特定的地区与省份垄断了，丝绸基本都是苏州的，茶叶基本都是安徽的。</li></ul><h2 id="找工作，保工作"><a href="#找工作，保工作" class="headerlink" title="找工作，保工作"></a>找工作，保工作</h2><ul><li>90%的中国商号除了过年之外不打烊，一天10-12工作时长也是家常便饭，老板或者经理的亲戚重视优先获得提升与奖金。</li><li>相对而言国外公司要好非常多，午休、双休、法定节假日、晋升机会，上海的中国男孩都希望进入外国公司。</li><li>英文读写于口语表达能力是进入国外公司的基本条件，但是中国人不不依靠学校活着课本学出漂亮的英语，而是尽可能的走捷径。比如在某些书中照抄面试申请，如果真的面试就会发现这些行文流畅的写信人大多口语非常不自信，一般他们的解释是没有机会对话。</li><li>很多人原因0报酬进入，活着底薪，让任何人找不到辞退的理由，步步为营，再提升自己的收入</li><li>求职信的威力其实有限，因为一个职位的空权，会有数不清的带就业的表亲、探亲等着再，如果真的被新员工拿到，也未必是好事，因为其他员工会说这名员工不好的话，让其失去希望。</li><li>受雇的中国人会想方设法的体现自己的价值，不怕事情多，就怕事情少，没事会让他怀疑自己的对雇主的价值。</li><li>中国人喜欢自己的不可替代性，劝中国人休假是非常困难的事情，因为这意味着另一个人接手他的工作，这样他就不是不可或缺的人了；如果真的需要，会找一个亲戚。</li><li>中国人会自己行程部门化，各自的权责一旦确认，一般别人就不在过问，也不会抢别人的饭碗。</li><li>中国人因为本身思想观念问题，融入大公司其实并不容易，为什么要拼死拼活为一群既不是朋友也不是亲戚的人创造利润。</li><li>中国一般没有大公司买因为所谓的规则在他们眼中是虚假效忠的行为，这会导致最终会形成家族企业，员工名册变成了家族谱，这棵树接不了果，却始终活着，因为根部汲取了大量的养分，并且不产出利润的果实。</li><li>一个非家族的人会被排挤，压榨，也无法投诉，这会导致事情的进一步恶化。</li></ul><h2 id="工作斗志与驱鬼记"><a href="#工作斗志与驱鬼记" class="headerlink" title="工作斗志与驱鬼记"></a>工作斗志与驱鬼记</h2><ul><li>相信风水</li><li>他的祖先普遍认为，替你劳动者的工作不可或缺，并且他们发现，若是在雇主能看到的地方辛勤脑洞，主人家会更加愿意付钱，</li><li>劳动者多半不害怕辛苦，黄包车夫不介意包裹堆的多高，拉的货发多，在其他黄包车中穿行的时候，喊的越有派头。</li><li>中国人对工作抱有很高的热情，希望办公室忙碌起来，如果办公室不够忙，就就要想办法让它看起来很忙。</li><li>他们并不介意工作超时，似乎很享受偶尔的加班，热热闹闹的、愉快的做出忙碌的表面工作，能给中国员工极其公司带来自信。</li><li>中国人非常在意风水，一个看似相同的环境，某种行动有时能带来成功，有时却有会失败，必然是因为受到了恶灵的影响。</li><li>某地因为竖起了一个大大的香烟广告牌，后来庄稼歉收，患病者增加，还有数人死亡，请了风水先生提出专业意见，得出结论是香烟广告牌是恶鬼聚集之地；正对这件事，最终决定购买大量鞭炮将恶鬼吓走，鞭炮表演之后，小村子繁荣发展，再也没抱怨过了。</li></ul><h2 id="凛遵"><a href="#凛遵" class="headerlink" title="凛遵"></a>凛遵</h2><blockquote><p>凛遵：严格遵循 毋违：不得违误</p></blockquote><ul><li>中国古代多少个世纪，将这些套话放在官文的政客，深谙自己同胞的弱点与习性，仅仅服从命令，大多很愉快，倘若搞砸了，也会说，我都是按照指令办事，失败不怪我，所以针对重大命令，需要增加一个毋违！防止执行者推诿借口，简单来说，就是事情没办成别找借口！</li><li>中国人一般非常害怕负责，即使知道某个政策没错，也会由于是否要热烈赞成，倘若进入失败了，他就需要承担责任。最后终于有人小心翼翼的再提出一个谨慎无比的建议，大家都能撇清个人责任，才可以再谈论政策的细节。</li><li>中国人会根据直觉或者个人喜好得出结论，所以他们总是具体问题具体解决，但是如果一定要该出原因，这对中国人来说是一件困难的事情。</li><li>中国人有时候喜欢拖延，并不是懒惰，而是小心回避责任，或者需要再承担之前找出一个合理的借口。</li><li>无论一个中国人造成了多大的错误，都会给自己找一个天衣无缝的理由，一想到酿成大错的头脑和自圆其说的竟然是同一个，我就会惊叹不已。</li><li>大部分中国人缺乏做出决定，承担后果的勇气，但是当被比如复杂绝境的时候，却可以展示出惊人的谋略，非常善于随机应变。</li><li>比如我（卡尔.克劳）的的司机在战火中走丢了，当我认为他必输无疑的时候，他将几个伤员塞进汽车，然后一路开到上海；</li></ul><h2 id="快听！狗真的叫了"><a href="#快听！狗真的叫了" class="headerlink" title="快听！狗真的叫了"></a>快听！狗真的叫了</h2><ul><li>作者是一个非常善于观察的人，会留意动物对不同人的区别对待</li><li>外国人来到中国后，总是喜欢探索他和他的同胞们在哪些方面比所访问国家的人民要更加优越，对于这种行为，作者喜欢带他去小村庄逛逛，感受一下狗对外国人的狂吠</li><li>狗总是能精准识别外国人，即使使用了国际大牌的香皂，依旧骗不过它们。</li><li>村庄的水牛通常很温顺，但是白人也总是充满敌意，外国人闻起来似乎像他的老对手，激发他仇恨的本能。</li><li>中国的水牛，耕耘十载或者更久后，老到无法工作会被宰杀，这种牛肉做牛排都嫌老，但是给上海的外国人炖牛肉还凑合，他们以诶自己吃的是牛类某个更高贵的品种。</li><li>相较于狗与牛的区别对待，骆驼对任何人类都是一视同仁，当游客视图爱抚骆驼，可能会被咬一口，或者被喷口水，深谙世事的人绝对不会靠近与抚摸骆驼。</li></ul><h2 id="鱼和绳，西瓜子"><a href="#鱼和绳，西瓜子" class="headerlink" title="鱼和绳，西瓜子"></a>鱼和绳，西瓜子</h2><ul><li>在中国进行商务交易的，总是有很多意料之外的事情，倘若交易尚未彻底结束，买家尚未付款，商品尚未使用，没人敢确定交易细节是否不再发现变动。</li><li>中国人在误解方面很有天分，他们能从方方面面充分利用误解。</li><li>等到付钱的时候，之前敲定的价格总会处于这种或者那种的原因上涨</li><li>比如轿夫在一段旅途结束后总是会异口同声的说对我超重的身体表示诧异，他们相互喊话，说向我这样的外国人不是血肉之躯，而是石头之躯，当然这是一种恭维的话，因为胖是泰安处世之道的体现。</li><li>中国人总是喜欢讨价还价，双方信口开河、自由欢快、但是不会心生芥蒂，但是如果让他们争辩半天却一无所获，则会证明我们是吝啬的小气鬼，不配接受乡下人的热情招待，所以，就算没有道理，我们也会多给一些酒钱。</li><li>一个挂在绳子上的鱼即使买下来，绳子也是需要另付钱的，但是没有绳子将无法使鱼存活并保险，就要再商量绳子的价格。</li><li>如果你觉得中国人讨价还价，主要目标是从不加提防的人哪里敲诈几个铜板的话，那我必须纠正这个印象，他们讨价还价不仅是为了利润，更是从中找乐子。</li></ul><h2 id="很少有人能读报"><a href="#很少有人能读报" class="headerlink" title="很少有人能读报"></a>很少有人能读报</h2><ul><li>报纸是最廉价、有效的宣传方式，因为清朝把所有保持都禁了</li><li>中国的报纸读者最乐观估计不超过人口的百分之五，但是已经是15年前的2倍多了</li><li>中国文盲率很高，这并不是因为笨，而是没有学习机会、需要承担更紧急的义务</li><li>文盲不代表一定生活在底层，没有用纸笔也能成功度过一生</li><li>在刊登广告的时候，会利用图画语言来辅助文盲阅读报纸上的广告</li><li>虽然很多人目不识丁，但是不影响他们享受文学，因为有职业说书人</li><li>无论大小报刊，刊登广告的价格都一样，因为价格低就相当于亲口承认低人一等了</li><li>中国报纸更加职权分散、缺乏纪录，但是也可以正常运作</li></ul><h2 id="顺子和同花"><a href="#顺子和同花" class="headerlink" title="顺子和同花"></a>顺子和同花</h2><ul><li>翻译扑克规则是我们承接的最难的工作之一，但是当我们开始为汽车做广告的时候，发现汽车术语翻译成为中文也很困难</li><li>我们做出的第一份目录在上海畅通无阻，但是送到香港、汉口，哪里人就会看不懂，因为不同地方的术语都不同。</li><li>发明行话的中国人不仅限于司机，实际上每个行业都有一套外行不可能听懂的行话。</li><li>在其他国家家喻户晓的产品，在中国需要重新命名，品牌的中文名称要简单，朗朗上口，有特色，不能被轻易模仿，还要注意是否会引起粗俗的联想。</li></ul><h2 id="中国疗方"><a href="#中国疗方" class="headerlink" title="中国疗方"></a>中国疗方</h2><ul><li>每个人都愿意购买用于治疗的药物，但很少有人服用预防剂，哪怕是免费的。</li><li>中华民族大部分人住在通风极差的房间里面，也不怎么运动量，按理来说他们身体应该很差，但是事实并非如此，只是新生儿的死亡率比较高，只有强壮的婴儿才能活到中年。</li><li>如果真的病的厉害，急需寻医问药，那么他十有八九回去看中医，或者去中药铺抓草药</li><li>尽管中医疗法看似粗糙并且不完善，却赢得了无数同胞长达数个世纪的信任，中医界也不乏名医，不乏对科学事实的耐心求索。</li><li>中医实践从未列入正式的科学研究体系，以学徒制传授，每个医生讲自己的技艺传授给一名或多名徒弟，并且缺少监管，这给了江湖庸医可乘之机。</li></ul><h2 id="鱼翅和皮蛋"><a href="#鱼翅和皮蛋" class="headerlink" title="鱼翅和皮蛋"></a>鱼翅和皮蛋</h2><ul><li>中国人和其他人一样爱吃各种糖，但是他们的一日三餐却不含甜品，不过中国人喜欢在正餐之间吃小吃。</li><li>尽管中国人搜遍了地上跑的、水里游的、天上飞的食物，但是却没有学会享受乳制品，他们的食物中没有牛奶和黄油。</li><li>炒杂碎虽然是中国菜，但是在中国却非常不流行。</li></ul><h2 id="保面子，丢面子"><a href="#保面子，丢面子" class="headerlink" title="保面子，丢面子"></a>保面子，丢面子</h2><ul><li>丢面子：被羞辱，保面子：避免遭到公开羞辱。这种简短的定义在中国生活的方方面面中所扮演的重要角色起到了小小的提示作用。它包含了一套人类关系的行为准则，规定每个人在任何情况下都要帮助自己的同胞维持自尊、昂首挺胸。</li><li>每个人的面子都需要被尊重，你可以频繁的斥责中国仆人，让他反复做自己搞砸的工作，即便如此，家里也会波澜不惊，但是如果你斥责他的时候又其他人在场，尤其是又仆人在场的时候，就是另一回事了，</li><li>大部分的袭击既可以直接归咎于丢面子，工作时间长、干活累、薪资低这些他们都可以冷静的忍耐，只要不受羞辱。</li><li>有钱的中国父亲会通过贿赂的方式让儿子进银行，这种工作让雇员有面子，也让全家有面子。这让中国产生了一种特有的诈骗计划。</li><li>如果印刷商像我们提交了质量很差的印刷品，我们不会和他讨论公正，我们会说这样的印刷品交给客户，我们会丢面子，客户也会拒绝接受。</li><li>中国裁缝会在我丢弃的旧衣服的时候，将伦敦的商标取下来，缝在我的新衣服上，因为伦敦商标会让我更加有面子。</li><li>以前的面子都是私事，到了现代生活，主事者的领导下，他也开始了对城市的改造，街道肮脏不堪，城市就会丢了面子，居民也会丢了面子</li><li>仕途也是如此，一个野心勃勃的军阀发生叛乱，反对中央集权，反叛被镇压，在任何一个国家，判断将领都会被剥夺军衔，投入大牢，再被处决，但是在中国，也许不会这样，这会让军阀颜面扫地，相反他会得到一个较高的头衔，然后奉命到一个偏远地区执行人畜无害的使命；这样做的政治目的是避免败北将军的准随则产生强烈的敌意，巧妙的赢得他们的忠心。</li><li>中国人会买下牌号靠前的二手车，许多外国人按说出不了手的破二手车竟然可以买个好价钱（早期买车的基本都是外国人）</li><li>中国富商会觉得晚一点去公司很有面子，证明自己不是准点打卡的打工仔，于是这也形成了一个传统，商务拜访应该在下午进行。</li></ul><h2 id="神圣的饭碗"><a href="#神圣的饭碗" class="headerlink" title="神圣的饭碗"></a>神圣的饭碗</h2><ul><li>万万不可让人丢了面子蒙羞，也玩不可摧毁他谋生的机会</li><li>在商务活动中你可以占尽他的便宜，把他的价格压到最低，但是如果你让他一贫如洗，承受不必要的损失，坚持让人走投无路的履行合同，这些都被视为极其不人道的可怕行径。</li><li>中国人对同胞饭碗的体贴到了不合逻辑的程度，比如裁员的时候，会将最优秀的员工裁掉，留下庸才，因为他们知道庸才一旦被裁掉就找也找不到新工作了。</li><li>面对黄包车主收租过高的问题，横幅提议减少租金，这样的行为中国人并不感兴趣，但是后续黄包车主拒减租金，并拒绝出租黄包车，导致3.5w名黄包车主失业，这群强盗资本家瞬间被置于众怒之下，最后黄包车住妥协。</li><li>如果有人剥夺了他人谋生的手段，无论出于各种原因，中国人都不会让他逃过责任。</li><li>相对应的，你一旦喊出，你不能砸了我的饭碗，这也会得到很好的效果，在大多数国家向税收员博得同情是无效的，因为他们没有更高数字的权限，但是中国的处理方式更加讲道理，，在这里合理性和妥协精神比方法规程更加有分量，这里的税收人员虽然不能改变上级定制的税率，但是可以不跑出去清点到底有多少张广告牌，然后商量好，为15个广告牌收税，实际上竖起来20个。这样一来，人人愉快，税率符合标准，大家的饭碗也保住了，面子也保住了。</li><li>中国人能在专制政府下的统治下相对民主，全归功于行会，清政府的地方官员几乎拥有无限的权利，但是他们在具体实践中，力求减少冲突，避免民愤，否则行会就会发挥作用，出现罢市，停工，起义，孕育出民主精神。</li></ul><h2 id="几种黑心事"><a href="#几种黑心事" class="headerlink" title="几种黑心事"></a>几种黑心事</h2><ul><li>中国人在交易中讲究公平诚信，但是还有很多走邪门歪道的黑心事</li><li>中国的传统领域都有这很高的道德水平，比如丝绸，或者带有银匠铺的银器，自始至终都保持着高标准</li><li>其他商务领域就没那么高的标准了，比如建筑，还有制造业、出版业、出后贸易等等新兴行业，尚未建立起有模有样的职业道德标准。无一例外会陷入恶性循环，凿除优质商品 - 大卖 - 品质变差 - 销量下降 - 公司倒闭 - 下一个人收购。</li><li>子果子早上会恬不知耻的模仿知名品牌，也许只要是因为没有能力自主研发</li><li>在出口贸易上，发现出售不合格商品有利可图，而且出口贸易的风险下，因为到遥远的地方才会被打开，会想出口的蚕豆中掺假</li><li>如果没有赚快钱的手段，中国商人还有一招，略微夸张的发票，外国公司向中国一共假发票也是十分常见的事情，或者多给几个空发票，由经销商自己填写</li></ul><h2 id="出口商约翰牛和山姆大叔"><a href="#出口商约翰牛和山姆大叔" class="headerlink" title="出口商约翰牛和山姆大叔"></a>出口商约翰牛和山姆大叔</h2><blockquote><p>山姆大叔：美国 约翰牛：英国</p></blockquote><ul><li>上海是中国对外贸易的中心，来寻找代理商的品牌非常多，代理往往供不应求。</li><li>相对于英国、德国的制造商，美国制造商的变化无常邻人不满</li><li>如果代理的美国的产品销量很好，美国人就会撤销代理，建立分公司，代理商就会悲哀的发现，自己创造了令人满意的销售额，但是也因此失去了代理权</li><li>美国制造商喜欢频繁更换代理，似乎心怀一种徒劳的希望，新的一定比旧的好，相比较之下，英国厂商的代理就要稳定的多，仿佛拥有一份大胆付出努力的永久价值资产。许多英国公司更加悠然自得，不愿为了增加销量做任何努力，他们满足于不费吹灰之力的获取佣金。</li><li>美国商人写信之多、写信之长，远超其他国家的商人，相反英国人的信件非常简短。</li><li>在营销、包装、广告方面美国人做的更好，但是美国人更加短期主义，英国人更加长期主义，美国人求变，英国保守，有时候，诚恳热情的努力并不能带来相应的回报，比如中国市场本来也比较保守。</li><li>日本的优势在价格，通过无耻剥削廉价劳动力实现低成本生产，而德国制造商更加拼命，更加精益求精</li></ul><h2 id="每天一个苹果"><a href="#每天一个苹果" class="headerlink" title="每天一个苹果"></a>每天一个苹果</h2><ul><li><p>如果我们可以让潜在的四万万中国顾客相信“每天一个苹果，医生远离我”，那该多美妙啊。</p></li><li><p>只要一个国家的人还在制造东西卖给其他人，只要海运和国际贸易依然存在，向数亿勤勉中国人出售商品的金色幻想始终具有强大的诱惑力。无论卖什么，你都能在中国大赚一笔，前提是该买你东西的中国人的确愿意掏腰包。</p></li><li><p>中国对外买一有这长达两千年的历史，外商到中国并非出售而是采购，很长一段时间里，中国都是全球最大的制造国，例如丝绸、瓷器、茶叶</p></li><li><p>中国人本以为何种状态会永远维持下去，对外国人在售的物品还不在意，等他们发现蛮夷竟然可以制造出好东西的时候，傲气遭到了沉重的打击，到19世纪下半叶，潮流逆转，卖给中国人的洋货，反而比卖给洋人的中国人更加重要，更加有利可图了。</p></li><li><p>每一代制造商都会为全球市场贡献新产品，他们都在中国找到了市场，获得了新的财富。新的商品会替代老的商品成为生财之道，而未来的新产物又将取代它们。</p></li><li><p>中国人花了很长时间才决定要买西方制造的现代物件，可一旦开始，他们就发现，买得起的都想买，买不起的也又很多想买</p></li><li><p>司机上，中国四万万顾客经常遇到的问题是清单上写了10元，但是口袋里面只有5美元，买任何东西之前，都需要货比三家，还要把它拿来和其他性质迥异的物品做对比，比如6月西瓜丧尸，很多人不能同时享受西瓜和香烟，所以一部分人就会放弃香烟选择西瓜，香烟的消费到吃瓜季节结束后才能恢复正常。</p></li><li><p>我们做市场调查，推测他们会购买那些物品，这些东西应该怎么包装，怎么打广告，采用怎样定点推销方式比较有效，我们在自己的国家也需要解决相同的问题，但是在这里还需要面对其他复杂状况和难题，以及来自其他各国厂家的竞争，我们的付出于经济回报不成正比，却之其他方面得到了补偿，我们的工作始终充满了趣味性，尽管多年来市场遭遇幻觉破灭，但是我们依旧默默怀揣这样的念想：或许明年，着四万万顾客中就又了相当一部分会买我们的东西了。</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​尤其说作者是一名广告代理商，比如说他是一名优秀的人类观察学家，该本书出版于1937年，依旧是说书中的观点都是作者来华20多年的见闻，没有上流社会，也没有宏达需求，只有对每个个具体的，真实的中国人的观察，虽然已经过去了几十年，但是我们依旧可以在书中找到他对中国人的认知，比如对包装变化的敏感、充分利用一切，对推销员的反感，在公司不忙也要假装忙碌。</p><p>​作者对信息的输入，不来源于统计属于，而是来源于身边一个个具体的人，他更加善于发现具象的事实与观点，这来源于作者的记者身份，以及研究“中国人真实想法”的营销分析需求，并且基本看不见外国人看其他国家人的高高在上的感觉，而是尊重、融入其中。</p><p>​另外就是行文风格偏幽默，很多苦难被描绘成为乐天精神，真正的也许并非如此，只是客观情况下的无奈之举，总的来说这本书还是很不错的，值得一看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《四万万顾客》读书笔记&quot;&gt;&lt;a href=&quot;#《四万万顾客》读书笔记&quot; class=&quot;headerlink&quot; title=&quot;《四万万顾客》读书笔记&quot;&gt;&lt;/a&gt;《四万万顾客》读书笔记&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://bluedancers.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="四万万顾客" scheme="https://bluedancers.github.io/tags/%E5%9B%9B%E4%B8%87%E4%B8%87%E9%A1%BE%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>（23年12月）chatGPT绑虚拟卡并开通plus会员</title>
    <link href="https://bluedancers.github.io/2023/12/12/chatGPT/chatGPT%20plus%E5%BC%80%E9%80%9A%E6%8C%87%E5%8D%97/"/>
    <id>https://bluedancers.github.io/2023/12/12/chatGPT/chatGPT%20plus%E5%BC%80%E9%80%9A%E6%8C%87%E5%8D%97/</id>
    <published>2023-12-11T16:00:00.000Z</published>
    <updated>2024-01-04T07:14:06.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="看完这篇文章你将学会"><a href="#看完这篇文章你将学会" class="headerlink" title="看完这篇文章你将学会"></a>看完这篇文章你将学会</h2><ul><li>购买加密货币，包括BTC、ETH、USDT</li><li>注册虚拟银行卡，并充值美元</li><li>开通chatGPT PLUS会员</li></ul><h2 id="绑卡的好处"><a href="#绑卡的好处" class="headerlink" title="绑卡的好处"></a>绑卡的好处</h2><ul><li>可以使用gpt 4的api能力</li><li>gpt 3.5的api请求速率从每分钟3次到每分钟3500次，避免429状态码</li><li>可以进一步<strong>开通Plus会员</strong></li></ul><h2 id="平台简介"><a href="#平台简介" class="headerlink" title="平台简介"></a>平台简介</h2><p><strong>DuPay</strong></p><p>​前身为<strong>depay</strong>，可开通虚拟银行卡进行全球通用支付，并可使用加密货币进行充值。</p><p><strong>欧易OXK</strong></p><p>​加密货币交易所，可以购买绝大部分的加密货币，类似平台还是币安。个人推荐使用欧易，国内使用更加方便。</p><h3 id="如何下载相关APP"><a href="#如何下载相关APP" class="headerlink" title="如何下载相关APP"></a>如何下载相关APP</h3><p>​功能上APP相对网站更加齐全，体验感更好，所以推荐使用APP去完成相关操作，IOS的用户需要<strong>美区APPID</strong>才能下载，android手机可根据官方提供的下载地址，或者第三方资源完成下载与安装。</p><p>​亲测使用环节均不需要梯子。</p><h2 id="关于货币流转"><a href="#关于货币流转" class="headerlink" title="关于货币流转"></a>关于货币流转</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><blockquote><p>为了方便理解，下文使用中文进行描述</p></blockquote><p>USDT：中文名称为<strong>泰达币</strong>，价值与美元挂钩，一个USDT相当于一美元</p><p>USD：美元</p><h3 id="流转过程"><a href="#流转过程" class="headerlink" title="流转过程"></a>流转过程</h3><blockquote><p>为什么流程这么复杂？depay不接受人民币，仅支持泰达币的方式进行充值，或者内部转账</p></blockquote><p><strong>人民币 - 泰达币 - 美元</strong></p><ul><li>在欧易中完成<strong>人民币转化为泰达币</strong></li><li>在dupay中获取加密钱包地址，将欧易中的泰达币<strong>充值到dupay</strong>（每次大约2泰达币的手续费）</li><li>花费20泰达币完成虚拟卡的申请，或者50泰达币，取决于购买者的需求</li><li>将大约30泰达币转化为30美元，并充值到虚拟卡中</li><li>在openAI侧进行消费</li></ul><h3 id="大概费用"><a href="#大概费用" class="headerlink" title="大概费用"></a>大概费用</h3><p>开卡费<strong>20泰达币</strong>，后续每月卡费0.5泰达币（或者使用50泰达币，获得无需开卡费的虚拟银行卡）</p><p><strong>虚拟卡充值单次最少30美元</strong></p><p>各个流程的手续费累计在一起大约消耗2-3美元</p><p>所以建议一次性充值大约56-60泰达币，也就是<strong>430元人民币</strong>，<strong>注意每次充值都需要手续费，所以尽量一次充值到位</strong></p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="http://qiliu.vkcyan.top/FlGpff7vZHI3Is5Wyl7z1Eg8u0K6.png"></p><h3 id="注册DuPay"><a href="#注册DuPay" class="headerlink" title="注册DuPay"></a>注册DuPay</h3><p><a href="https://dupay.one/">https://dupay.one/</a></p><ul><li>建议通过手机号完成注册（使用的时候不要挂梯子，否则会注册失败）</li><li>根据要求完成实名认证</li></ul><h3 id="注册欧易OXK"><a href="#注册欧易OXK" class="headerlink" title="注册欧易OXK"></a>注册欧易OXK</h3><p> <a href="https://www.okx.com/cn">https://www.okx.com/cn</a></p><ul><li>根据网站要求完成手机号的注册</li><li>根据要求完成实名认证</li><li>使用人民币购买泰达币</li></ul><p><img src="http://qiliu.vkcyan.top/FshK_VQQMZgLEur12CXruuzUQhYY.png"></p><p>购买后存在一定的T+N的安全保护，大约<strong>1-3天</strong>后才可以进行后续的操作。这里就只能等待了</p><h3 id="充值到DuPay"><a href="#充值到DuPay" class="headerlink" title="充值到DuPay"></a>充值到DuPay</h3><p>欧易那边的T+N的安全保护结束后，我们就可以把泰达币充值到DuPay中了</p><p><img src="http://qiliu.vkcyan.top/Frz4IcRFfNSxkhrASZznJs52AkUU.png"></p><ul><li>DuPay中点击钱包 - 充币，获取到钱包地址</li><li>欧易中点击资产 - 提币，提取数字货币，选择USDT，在选择链上提币。</li><li>填写正确的钱包地址，与提币网络即可完成充值</li></ul><p><strong>注意：每次充值都会两头收取手续费，大约2泰达币，所以尽量一次充值到位</strong></p><h3 id="开卡-存款"><a href="#开卡-存款" class="headerlink" title="开卡+存款"></a>开卡+存款</h3><p>​泰达币充值到账之后，我们就可以开卡了，现在已经没有免费卡了，横向对比，应该只有这个20泰达币的高级卡是性价比最高了。</p><p><img src="http://qiliu.vkcyan.top/FjCd0xMFBS7RaT7lv61JLUCpdd3Q.png"></p><p>支付20泰达币之后，开通成功。</p><p>接下来我们在钱包中将剩下的<strong>泰达币转化为美元</strong>，再点击首页的充值，<strong>这里需要注意一定要准备30美元以上，这是DuPay的充值限制</strong></p><p><img src="http://qiliu.vkcyan.top/FhqVrzpV-aWUdrvd0JAc7IgUvvWS.png"></p><p>完成以上步骤后，我们就成功完成了开卡与充值；接下里让我们到openAI侧进行绑卡操作。</p><h3 id="openAI侧绑卡"><a href="#openAI侧绑卡" class="headerlink" title="openAI侧绑卡"></a>openAI侧绑卡</h3><p>登录进入自己的账号，并选择个人的</p><p><img src="http://qiliu.vkcyan.top/FhTN2n8SkaX-DUtlNWf7_EXwG6p2.png"></p><p>先使用<a href="https://www.dizhishengcheng.com/">https://www.dizhishengcheng.com/</a> 生成美国人虚构信息。</p><p>建议使用免税州的信息，免税州包括阿拉斯加州（Alaska）、特拉华州（Delaware）、蒙大拿州（Montana）、新罕布什尔州（New Hampshire）和俄勒冈州（Oregon）。</p><p><img src="http://qiliu.vkcyan.top/FoT2slhfpX0ZJpzV2DuPxFQZfsQo.png"></p><p>信息全部输入成功，点击continue即可，在这个环节我没有遇到被银行卡被拒绝的情况。</p><p>后续流程会建议你设置自动充值计划，这个按照自己的需要进行配置。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>​绑卡成功后，即可直接购买plus会员；就算不进行购买，chatgpt3.5的api也享受每分钟3500次请求的速率限制，还是非常不错的。</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;看完这篇文章你将学会&quot;&gt;&lt;a href=&quot;#看完这篇文章你将学会&quot; class=&quot;headerlink&quot; title=&quot;看完这篇文章你将学会&quot;&gt;&lt;/a&gt;看完这篇文章你将学会&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;购买加密货币，包括BTC、ETH、USDT&lt;/li&gt;
&lt;li&gt;注</summary>
      
    
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/categories/chatGPT/"/>
    
    
    <category term="chatgpt PLUS" scheme="https://bluedancers.github.io/tags/chatgpt-PLUS/"/>
    
    <category term="虚拟币" scheme="https://bluedancers.github.io/tags/%E8%99%9A%E6%8B%9F%E5%B8%81/"/>
    
    <category term="depay" scheme="https://bluedancers.github.io/tags/depay/"/>
    
    <category term="dupay" scheme="https://bluedancers.github.io/tags/dupay/"/>
    
  </entry>
  
  <entry>
    <title>chatgpt的calling Funtion让贾维斯不再遥远</title>
    <link href="https://bluedancers.github.io/2023/12/12/chatGPT/chatgpt%E7%9A%84calling%20Funtion%E8%AE%A9%E8%B4%BE%E7%BB%B4%E6%96%AF%E4%B8%8D%E5%86%8D%E9%81%A5%E8%BF%9C/"/>
    <id>https://bluedancers.github.io/2023/12/12/chatGPT/chatgpt%E7%9A%84calling%20Funtion%E8%AE%A9%E8%B4%BE%E7%BB%B4%E6%96%AF%E4%B8%8D%E5%86%8D%E9%81%A5%E8%BF%9C/</id>
    <published>2023-12-11T16:00:00.000Z</published>
    <updated>2024-01-04T07:15:07.042Z</updated>
    
    <content type="html"><![CDATA[<p>后续编写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;后续编写&lt;/p&gt;
</summary>
      
    
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/categories/chatGPT/"/>
    
    
    <category term="calling Funtion" scheme="https://bluedancers.github.io/tags/calling-Funtion/"/>
    
  </entry>
  
  <entry>
    <title>搭建一个企业内部的实用AI</title>
    <link href="https://bluedancers.github.io/2023/12/12/chatGPT/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%94%A8AI/"/>
    <id>https://bluedancers.github.io/2023/12/12/chatGPT/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%94%A8AI/</id>
    <published>2023-12-11T16:00:00.000Z</published>
    <updated>2024-01-04T07:15:41.718Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章</p><p><a href="https://longbig.github.io/2023/02/19/ChatGPT%E6%8E%A5%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%90%E4%B8%BA%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/">https://longbig.github.io/2023/02/19/ChatGPT%E6%8E%A5%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%90%E4%B8%BA%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/</a></p><p><a href="https://dingyx99.me/post/wechat-work-nodejs/">https://dingyx99.me/post/wechat-work-nodejs/</a></p><p><a href="https://juejin.cn/post/7133543712977584142">https://juejin.cn/post/7133543712977584142</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://longbig.github.io/2023/02/19/ChatGPT%E6%8E%A5%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%90%E4%B8%BA</summary>
      
    
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/categories/chatGPT/"/>
    
    
    <category term="ai机器人" scheme="https://bluedancers.github.io/tags/ai%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>正确的理解技术，可以让我们走的更远</title>
    <link href="https://bluedancers.github.io/2023/11/25/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C/"/>
    <id>https://bluedancers.github.io/2023/11/25/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C/</id>
    <published>2023-11-24T16:00:00.000Z</published>
    <updated>2023-11-29T09:35:34.578Z</updated>
    
    <content type="html"><![CDATA[<p>​我们小时候都听过这样的一个故事，</p><p>​为什么大家都说35岁是技术岗的危机，甚至现在还出现了更加提前的趋势，30岁危机就已经出现。在本文开始之前，我也先丢几个问题给大家，一起思考一下以下现象的原因是什么？</p><ul><li>软件开发是否是劳动密集型行业？</li><li>为什么在中国，为何倾向于更加年轻的程序员，多年经验的程序员反而越发艰难？</li><li>当程序员们意识到危机的时候，他们遇到了什么挑战？</li><li>如何应对程序员的”35岁危机”？</li></ul><p>​接下来我来谈一谈我这6年对技术的理解的变化，以及学习与适应变化的过程，从中我们一起寻找上述问题的答案。</p><p>​</p><h2 id="技术是代码（0-3年）"><a href="#技术是代码（0-3年）" class="headerlink" title="技术是代码（0-3年）"></a>技术是代码（0-3年）</h2><blockquote><p>那时候我就像是一个在技术的门外不断窥探的孩子，迷茫、思索，不断寻找属于我的自己的打开技术大门的钥匙。</p></blockquote><p>​当我在大学中刚开始接触代码的时候，我和大多数人一样苦于如何完成老师的课后作业，回想起来，我对技术这个词的理解非常直观，<strong>技术就是代码</strong>，要如何做好一名合格的技术呢？多多学习与理解代码。实话说，谈不上有写代码的天赋，大学中学的第一个语言课是C语言，学的也比较糟糕，后来慢慢培养了一点技术思维，学java的时候又败给了面向对象。</p><p>​我时常为自己的天赋平庸而烦恼。如果技术就是代码，那时候我的技术能力简直就是灾难。</p><p>​上帝还是给了我机会，偶然之间让我接触到了JavaScript，这并不是学校授课的语言，但是这确实一个令人着迷的语言，在面向过程的的JavaScript（ES5）中，我找到了突破点，顺着这条藤蔓，我找到了适合我的对技术的打开方式，技术思维逐渐被打开，以前不理解种种逻辑，面向对象、指针，也很自然的就理解了。</p><p>​再后来参加全国比赛，凭借兴趣与努力不断学习，逐渐成为我们计院的top，这才算走上了编程这条路。</p><p>​在我那短暂而又高强度的学习编程的经历中，我始终都有一个明确的理念，<strong>技术 &#x3D; 代码</strong>，要想编程能力进步，想成为更加厉害的程序员，就要拼命写代码，所以我知行合一，延续了在学校比赛时期的作息时间，工作时间外，晚上也继续学习技术，我非常积极的接触所有前端范畴的技术的上的工作，主动挑战任何技术难点，因为我坚信，代码写的好不好，是评价技术的唯一标准。</p><p>​就这样，在我写代码的前3年我几乎把前端范畴中能接触的所有技术，都学习了一遍，而对于重要的技术，也会重点学习与了解，通常会想方设法的了解实现原理；同时坚持费曼学习法，保持输出的习惯，这些年我的juejin博客的阅读量也还不错，大部分文章的内容也还说得过去。</p><p>​所以在我迈入职场的头几年，我的收入和社会认同感都有肉眼可见的增加，这些成果一方面激励我继续努力，但是另一方面我内心的疑惑也越来越大。</p><h3 id="对技术的疑虑"><a href="#对技术的疑虑" class="headerlink" title="对技术的疑虑"></a>对技术的疑虑</h3><p>​某一天晚上我在公司无所事事，学习ng，在学习的过程中，我突然开始思考起来，学习ng对我而言真的有用吗？</p><p>​公司不可能用ng的技术栈，不好招人、国内生态差、文档不友好，那在学习ng的过程中我能了解到什么？ng的一些编程思想，企业级的项目架构；可是我没有应用场景，怎么能有深刻的理解？最多只能扩大自己的知识面。自那之后我在学习新技术的时候我都会开始思考，我花这么多时间去学习这些我很难用到的技术，再随着知识慢慢被遗忘或者过期，是不是已经产生不了什么效果呢？</p><p>​我们时常说，技术为业务服务，若是学习的技术并没有在实际业务中发挥作用，没有让开发效率更高、没有让软件的速度更快、没有让团队成员开发体验更好，那岂不就是没用的技术。</p><p>​所以我转变了思路，决定不在走马观花式的学习，要打技术纵深，看axios、promise、vue2.x、vuex的底层实现，然而源码的复杂程度超乎我的现象，首先我个人不具备独立阅读源码的能力，在阅读的过程中，我需要搭配别人的博客，以及源码解读视频才能理解其核心逻辑，在这个过程中我充分认识到了一点就是这些人的水平，我一辈子都达不到。</p><p>​不过另一方面我还是要为阅读源码正名，这个确实有用，这就像数学公式一样，不理解原理就只能背诵，照搬硬套，但了解原理后，就能解释很多为什么，开发的能力得到很大的加强。</p><h3 id="对没有结果的疑虑"><a href="#对没有结果的疑虑" class="headerlink" title="对没有结果的疑虑"></a>对没有结果的疑虑</h3><p>​在我工作的前三年，我做过很多产品和需求、开源，有些是公司的，有些私人的，但是绝大部分都是失败，投入了很多精力，没有产生任何价值，我非常幼稚的认为技术是非常重要的一环，但是反复的失败，让我非常茫然，也让我逐渐意识到技术能决定的事情，并不多，也意识到做出一款被大家接受的产品是一件极难的事情，</p><p>​那段时间和我的领导聊了很多，这里我尊称一句<strong>w老师</strong>，w老师通过各种例子慢慢纠正我的对技术片面的理解，反复和我论述<strong>技术为业务服务</strong>，那时候我对这句话依旧是半知半解，我想技术当然是为了业务服务，技术好才能完成各种各样复杂的业务，这人我一度想不明白，w老师想和我表达什么，但是这还是埋下了一颗种子，为了我的下一个阶段做好了准备。</p><p>所以后面，我想明白了一些道理，也看到了我对技术理解上的局限性</p><ul><li><strong>技术只是工具，本身没有价值，有价值的是技术形成的产品。</strong></li><li><strong>程序员不仅需要怎么做，更需要知道为什么要做。</strong></li></ul><h3 id="对0-3年的建议"><a href="#对0-3年的建议" class="headerlink" title="对0-3年的建议"></a>对0-3年的建议</h3><p>从我的精力看，我觉得从小白 - 初级前端开发者 - 前端组长，3年时间足矣，需要做到以下几点</p><ul><li><strong>学习技术的第一源动力是出于兴趣、与技术的喜爱，而不是为了获得一份工作或者高薪资</strong></li><li><strong>打好计算机基础，良好的编程基础是程序员头三年高速进步的前提。</strong></li><li><strong>要多写代码，量变才能产生质变，尽快成长为前端团队中的顶梁柱是这个阶段的核心目标。</strong></li><li><strong>重视业务，千万不要觉得业务与自己无关，理解业务流程是工作的一部分</strong></li><li><strong>要客观的认清自己，是否真的有编程天赋？与大牛的距离有多大？避免盲目学习与努力</strong></li></ul><h2 id="技术是需求（3-5）"><a href="#技术是需求（3-5）" class="headerlink" title="技术是需求（3-5）"></a>技术是需求（3-5）</h2><blockquote><p>既然技术的最终呈现方式是业务，我直接关注业务不就好了？</p></blockquote><p>​业务的落地由多个角色协作完成，后端、ui、运营、产品、项目经理，我大学期间学习了经济学相关知识，并且对此一直很感兴趣，我选择了与前端最贴近的产品经理。同时在公司，我也走向了基层管理岗位，前端组长。</p><p>​同时我与我的上级表明我想做产品的想法，并希望在现有项目中，发挥自己的产品的作用，上级欣然应允，同时也非常鼓励我继续做下去。</p><p>​所以在这个阶段，我从原本的纯技术开发，变成了技术 + 产品 + 管理齐头并进。</p><p>​学习产品思维是一个艰难的过程，在这个阶段，我系统性的学习了NPDP国际产品经理认证课程，看了《增长黑客》《人人都是产品经理》《幕后产品》《微信背后的价值观》等一系列产品经理相关的书籍，慢慢形成了产品逻辑。</p><p>​这个阶段，我经常问自己产品方面的问题。</p><p>​为什么拼多多不做购物车？难道是因为拼多多技术能力太差吗？</p><p>​为什么美团会员规则是这样的？如何演变形成的？</p><p>​为什么双11的优惠券规则如此复杂？为什么不直接给用户优惠？</p><p>​为什么最近上线的某个需求效果很差，为什么某个功能点又非常受到大家欢迎？</p><p>​羊了个羊爆火，我会尝试去分析，为什么他可以火，他是如何做的？</p><p>​参考竞品的时候，我会去思考，为什么他这样设计？</p><p>​<strong>在如何做的基础上，我更进一步的思考了，为什么这么做？</strong>别人做得好，我会去分析，为什么他做得好，自己做的不好，我也会分析，自己为何做的不好的原因，而不是团队一起拍脑袋，或者个人主义去理解与看到需求。</p><p>​在这几年，我做过很多需求与产品，大部分需求都成功落地，并达到预期效果，但是绝大部分产品都失败了，只有零星的几个产品在某个场景下做出了效果；随着在产品方面的经验越来越多，我对需求的理解越来越准确，逐渐在团队中的产品角色站稳脚步</p><p>​</p><p>​</p><p>​如何平衡 技术与其他工作？</p><p>​如何学习产品相关知识？</p><h2 id="技术是产品（5-？）"><a href="#技术是产品（5-？）" class="headerlink" title="技术是产品（5-？）"></a>技术是产品（5-？）</h2><h2 id="技术是？"><a href="#技术是？" class="headerlink" title="技术是？"></a>技术是？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	我们小时候都听过这样的一个故事，&lt;/p&gt;
&lt;p&gt;​	为什么大家都说35岁是技术岗的危机，甚至现在还出现了更加提前的趋势，30岁危机就已经出现。在本文开始之前，我也先丢几个问题给大家，一起思考一下以下现象的原因是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件开发是否是劳动密集型行</summary>
      
    
    
    
    <category term="关于程序员" scheme="https://bluedancers.github.io/categories/%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
    <category term="记录" scheme="https://bluedancers.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(3) - 从游戏名词到电商营销，我们一起来聊聊“秒杀”</title>
    <link href="https://bluedancers.github.io/2023/10/30/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%883%EF%BC%89%20-%20%E4%BB%8E%E6%B8%B8%E6%88%8F%E5%90%8D%E8%AF%8D%E5%88%B0%E7%94%B5%E5%95%86%E8%90%A5%E9%94%80%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%81%8A%E8%81%8A%E7%A7%92%E6%9D%80/"/>
    <id>https://bluedancers.github.io/2023/10/30/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%883%EF%BC%89%20-%20%E4%BB%8E%E6%B8%B8%E6%88%8F%E5%90%8D%E8%AF%8D%E5%88%B0%E7%94%B5%E5%95%86%E8%90%A5%E9%94%80%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%81%8A%E8%81%8A%E7%A7%92%E6%9D%80/</id>
    <published>2023-10-29T16:00:00.000Z</published>
    <updated>2023-11-27T03:13:59.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史上的“秒杀”"><a href="#历史上的“秒杀”" class="headerlink" title="历史上的“秒杀”"></a>历史上的“秒杀”</h2><p>​在1980美国的11月24号，这一天是美国最重要的传统节日<strong>感恩节</strong>，我们的主角小帅一家聚会到深夜才结束，但是他们并没有休息，反而穿着厚厚的大衣，前往附近早已停止营业的沃尔玛。</p><p>​但是当小帅抵达沃尔玛的时候，门前却排上了长长的队伍，超市关门了反而门前开始排队了？</p><p>​因为明天就是<strong>黑色星期五</strong>！</p><blockquote><p>感恩节后的黑色星期五标志着圣诞购物季的开始，美国人民通常会利用这一天购买圣诞礼物或者需要的商品。</p></blockquote><p>​小帅早早来的原因是他在11月22号沃尔玛的宣传单上看到的<strong>限时限量优惠！</strong>，只要<strong>1元就可以获得一个崭新的柯比吸尘器</strong>，但是限量500个；虽然现在寒风凛冽，但是捡漏的快乐还是让小帅充满干劲，美国的11月还谈不上太冷，就这样等到11月25号的凌晨5点，沃尔玛开门了！</p><p><img src="http://qiliu.vkcyan.top/FpsVAIISf_iWj4CwNxJfNxR-7MGF.png"></p><p>​排在前面的人都是冲着限时限量商品去的，都一个劲往里挤，事后发现大门都被挤坏了。</p><p>​尽管沃尔玛出动了大量安保人员维持秩序，但是还是出现了小范围踩踏事件，我们主角小帅非常幸运的挤在队伍的前列，在丧尸一般的人潮中成功抢到了仅售1元的限量商品柯比吸尘器，当然小帅不会立刻结账走人，他还会在沃尔玛购买圣诞节礼物、自己需要的东西。</p><p>​最后付款离场，小帅心满意足回家。</p><p>​<strong>但是感恩节之后，沃尔玛决定明年不再做限时限量优惠活动了。</strong></p><h2 id="线下商超为何对“秒杀”又爱又恨？"><a href="#线下商超为何对“秒杀”又爱又恨？" class="headerlink" title="线下商超为何对“秒杀”又爱又恨？"></a>线下商超为何对“秒杀”又爱又恨？</h2><p>我们一般认为，秒杀活动存在3个主要特征，<strong>限时、限量、高值低价</strong>。</p><p>线下秒杀在大多数情况下，都会获取预期效果，并且可以达到增加销售额、增加客流量的核心目的，具体来说作用如下</p><ul><li>通过制造热点吸引潜在用户、老用户、引导到店消费。</li><li>被吸引到的用户多半会购买一些产品，增加商超的销售额</li><li>秒杀活动会增加品牌、商超自身的知名度</li></ul><p>这么看挺不错的啊，能抓到老鼠就是好猫，能完成目标就是好活动，那何来的恨呢？</p><p>虽然秒杀能带来一些用户，但是也许要付出很多显性与隐性的成本。</p><ul><li>线下商超的目标是提供广泛而优质的服务，有可预期的周边几公里顾客，并不是很需要通过秒杀低价这种”激进“的营销策略来获取用户的青睐。</li><li>由于价格便宜并且限量，而黑色星期五本身就存在庞大的人流量，会出现人员拥挤与混乱的情况，不稳定因素大大增加。</li><li>秒杀活动会导致顾客之间发生冲突与纠纷的概率大幅增加，有损商超的的形象与品牌建设。</li></ul><p>比如这样</p><p><img src="http://qiliu.vkcyan.top/FnOB7X8l9_5k8IXVfQSWV5CuNIS8.png"></p><p>还有这样</p><p><img src="http://qiliu.vkcyan.top/FtY-pyoXDvjRGseKD3awOzUA41uf.png"></p><p>而黑色星期五的人流量是这样</p><p><img src="http://qiliu.vkcyan.top/FgToytXjQTy1M3qmyZsk3mt2nqCH.png"></p><p>​</p><p>​总的来说就是<strong>线下秒杀是一把双刃剑</strong>，<strong>相对来说雨露均沾式的优惠更加适合线下商超的价值定位</strong>；商超会根据自己的营销目的，选择不同的促销方式去吸引客户。</p><p>​也正是以上的一些原因，在线下商超出现之前，秒杀一直不是非常主流的营销方式，比我们之前聊的优惠券差远了。</p><h2 id="互联网时代，”秒杀“为什么破圈了？"><a href="#互联网时代，”秒杀“为什么破圈了？" class="headerlink" title="互联网时代，”秒杀“为什么破圈了？"></a>互联网时代，”秒杀“为什么破圈了？</h2><p>​1989年发生了一件影响人类历史进程的事情：由美国国家科学基金会推动的商业互联网正式成立，互联网开始走向大众。</p><p>​亚马逊为代表的电子商务公司开始兴起。2004年亚马逊推出了一项叫做<strong>Gold Box</strong>的业务，专门提供各种产品的打折促销和限时特惠。</p><p>​该功能一上线，取得了非常好的的效果，手机上点点就可以花少量的钱购买想要的产品，消费者对此类限时限量优惠的商品自然是很有兴趣，线上秒杀也开始被更多人注意到，<strong>Gold Box</strong>类型的营销方式开始电子商务领域被使用。</p><p>​我们考虑一下线上秒杀相对于线下秒杀有什么优势？解决了以前的什么问题？为什么线下不温不火的秒杀业务，到了线上就成了常见的营销方式？</p><p>​我们先分析一下线下秒杀的痛点到底是什么。</p><p>​<strong>用户参与秒杀的成本高</strong></p><p>​对于用户而言，提前一晚上到超市门口排队，抢到了还好，要是没抢到直接破防，这要是有啥烦心事，做出过激举动，身边人都遭殃。</p><p>​<strong>对于大型商超来说，成本可能大于收益</strong></p><p>​面对线下秒杀这样的活动，一方面商家需要增加额外的人力，另一方面还存在不可控的风险，比如损伤商超形象、影响顾客消费，等等一系列问题，除了新店开业需要快速拉新，稳定期间的经营者一定会慎重选择该营销策略。</p><p>​而且大型线下商超是存在<strong>区域性</strong>，比如在你家距离2公里处有一个沃尔玛，距离第二的超市可能就是5公里以上，你几乎不可能来回多跑6公里去距离更远的超市。而站在商超的视角看，除了特殊的开业阶段，应该多做老客户的维护，培养用户习惯。</p><p>​而互联网的出现，几乎弥补了以上所有痛点。</p><p>​<strong>用户参与门槛极低</strong></p><p>​在手机上就可以秒杀抢购，足不出户，就算抢不到，无非就是吐槽有内幕，付出的成本微乎其微。</p><p>​<strong>对于电子商务来说，收益大概率大于成本</strong></p><p>​相较于线下秒杀，线上开展这样的活动，主要成本在研发，用的辐射的人越多<strong>边际会成本越低</strong>，只要提前考虑到可能的意外情况，加上优质的运营方案，几乎不存在风险。</p><p>​另外，不同于线下商超固定的辐射圈，电子商务<strong>不存在物理空间的限制</strong>，这就意味着理论上网络上的任何一个人都是潜在用户，这样的前提下，平台的增长潜力是极大的，上升期也是极长的，秒杀这样吸引眼球的活动就成了一个非常不错的选择。</p><p>​<strong>那线上秒杀有什么缺点呢？</strong></p><p>​存在技术难度，瞬间巨量的访问，会直接让服务器宕机，相信经历过早期国内双11的用户都深有体会，而伴随秒杀业务的火热，一系列的技术方案都火起来了，所以技术难度也随着生态的完善而降低。</p><p>​亚马逊的秒杀业务在2000年左右开始发展壮大，除了日常折扣和限时促销的<strong>Gold Box</strong>之外，还细分出了<strong>Lightning Deals（闪电交易）、Deal OF The Day（团购）、7-day Deals（7天优惠）</strong>，等等针对不同类型商品的秒杀活动，直到现在，相关业务依旧是亚马逊促销策略中重要的一环。</p><p>​相比于线下秒杀，线上秒杀只能说是：<strong>优雅，实在是太优雅了！</strong></p><p><img src="http://qiliu.vkcyan.top/FmWevXBSpQZGxXVCFA7xhqEY_oBR.png"></p><p>​</p><h2 id="国内为什么叫“秒杀”？"><a href="#国内为什么叫“秒杀”？" class="headerlink" title="国内为什么叫“秒杀”？"></a>国内为什么叫“秒杀”？</h2><p>​不知道大家注意到没有，我们上面谈论了很多秒杀，都是打引号的，国外这种模式不叫秒杀，电商领域的”秒杀“是一个本土词汇。</p><p>​<strong>以前的人怎么想到这个名字的？</strong>，为啥不叫限时抢购？</p><p>​秒杀这个词在电商之前高频出现在竞技、游戏中，在国内电商兴起的同时，网游也在蓬勃发展，众多RPG游戏进入中国市场，比如大名鼎鼎的《红月》；大概就是看起来像<strong>是兄弟就来砍我、一刀999</strong>的游戏。</p><p><img src="http://qiliu.vkcyan.top/FheXDA7WVgXxyPH_MIaJVsvxBCm4.png"></p><p>​这个游戏可以升级到1000级，每次升级会给技能点，有些玩家将这些技能点全部加到攻击上，几百级之后，就会出现极其脆弱的身板 + 极其变态的攻击力，要么自己秒死，要么对方秒死，玩的就是心跳。</p><p>​秒杀一词也慢慢在社区流行起来，而玩游戏的多半是年轻人，这部分年轻人与电商领域从业者产生交叉，电商从业者目睹限时限价低价商品在电商平台瞬间抢购一空，发出了惊呼：”<strong>一下子就没了，就秒了！</strong>“。</p><p>​这时候人们转念一想，抢购没有体现极致的速度与紧迫感，哎！<strong>秒杀</strong>这个词很不错，商品直接售空，与游戏中的血条消失场景非常类似。</p><p>​有了这样的先例后，<strong>9.9秒杀、限时秒杀，京东秒杀、秒杀专区、老板娘生日，全场秒杀</strong>….在电商领域犹如雨后春笋般出现，直到现在几乎成了电商平台的专用名词。</p><p>​</p><h2 id="从专业角度看，人们为何喜爱秒杀"><a href="#从专业角度看，人们为何喜爱秒杀" class="headerlink" title="从专业角度看，人们为何喜爱秒杀"></a>从专业角度看，人们为何喜爱秒杀</h2><p>​可能会有小伙伴说了，这个问题很简单，因为大家都喜欢物超所值！其实不仅仅是简单的价格对比，限时限量抢购活动能够被人类选择，是有他的底层逻辑的。</p><p>​<strong>收益不最大化（商家）</strong>：在秒杀的场景下，用户支付比心里预期更低的价格就可以获得商品，用户会自发性的通过已知渠道进入秒杀活动中，而目标用户的参与动机，与需要支付的金额数量成反比，对于商家来说，秒杀场景下收益肯定不最大化的，这也是秒杀的显性成本。</p><img src="http://qiliu.vkcyan.top/FuriXSVGpvjd68sn5RaNT3-gr6Xo.png" style="zoom:33%;" /><p>​<strong>厌恶损失</strong>：根据科学验证，失去的痛苦是的得到的快乐的2倍以上，丢掉100元的痛苦远高于捡到100元的快乐，人们聪明的脑瓜自然能推理出，如果不通过此刻稀缺的秒杀活动购买到商品，后续多支付的部分金额，就是我的损失，则会进一步强化用户参与秒杀的动机</p><p>​<strong>稀缺效应</strong>：秒杀的特征，都是在加强稀缺这一点，限时、限量、高值低价，用户对稀缺的感知直线上升，从而增加购买的兴奋度与成就感。</p><p>​<strong>从众效应</strong>：我们想象一个场景，你的面前有2家超市，一家门可罗雀，一家人人潮汹涌，你会选择哪一家店？我相信绝大多数人都会无意识的认为，人多的肯定好，其实秒杀的场景也是这样，只是换了舞台，从线下变成了互联网上，如果秒杀活动可以在一个圈子中被炫耀、宣传，人们就会被这种“火热场景”所“迷惑”。</p><h2 id="秒杀的目是什么？"><a href="#秒杀的目是什么？" class="headerlink" title="秒杀的目是什么？"></a>秒杀的目是什么？</h2><p>​聊了这么多，我们还是要回到最关键的问题上。</p><p>​为什么要秒杀，我们的目的是啥？线上秒杀与几十年前的线下秒杀还是一个东西吗？</p><p>​我们先看线下商超做秒杀的目的是什么？</p><p>​<strong>用限时限量低价把用户吸引过来，然后为用户提供消费空间，并让更多用户了解与记住产品。</strong></p><p>​几十年前线下秒杀受到现实世界的限制，无法发挥全部实力，而有了互联网加持之后，弥补了现实世界的缺陷，<strong>秒杀进化为完全体状态</strong>，其核心目的没有根本变化；</p><p>​很多新人产品只理解了前半句话，把用户吸引过来，让用户参与”秒杀“，人气确实吸引过来了，但是人家只秒杀，花钱赚吆喝，就是不挣钱，甚至羊毛党越来越多。</p><p>​线上商城不像线下商超，用户来线下商超参与秒杀活动，来都来了，大概率会消费，线上则不是这样，无论用户是否”秒杀“成功，没兴趣了会直接右划走人，这就达不到开展秒杀活动的目的了。</p><p>​所以线上秒杀的运营目的并非秒杀活动进行状态，而是<strong>秒杀活动开始前后的活动运营，以及产品的曝光与留存</strong>。</p><p>​<strong>等待秒杀的用户运营</strong></p><p>​店铺付出较高成本开展秒杀活动，吸引来的新老用户都是极其宝贵的，如何引导这些用户转化为店铺的忠实用户，如何引导用户增强与店铺的粘性都是极其重要的，在这段时间可以做的事情很多，社交互动、相关营销活动曝光、强化品牌价值等等；只要能加强与用户的粘性，用户强化用户认知的目的，营销方案的形态都是可以畅想的。</p><p>​<strong>秒杀之后的用户运营</strong></p><p>​秒杀之后有些用户抢到了，有些用户没抢到，抢到的用户必然会增加对店铺的信任，我们再引导用户多下单，并在下单过程中继续曝光产品能力，比如签到、会员、让用户发自内心的认可产品；</p><p>​而没抢到的用户呢？我们也不能白白浪费宝贵的流量，时刻记住我们秒杀的目的。</p><p>​猜测一下”秒杀“失败用户的心理，可能还对抢到抱有一丝希望，是否还有下一波?是否可以捡漏？这时候我们是否可以提示用户，没抢到没关系，预约下一次的秒杀，还有机会抢！或者贴出其他相对优惠的非秒杀的商品，来安慰用户；总之就是拉升用户的心情曲线，给予用户继续操作的空间，也是将用户留存下来。</p><p>​所以秒杀并不是简单的低价抢购，短期吸引巨量人气的活动，因为如果没有合理的运营策略，最后陷入只能花钱赚吆喝的虚假繁荣之中。</p><h2 id="一定是秒杀吗"><a href="#一定是秒杀吗" class="headerlink" title="一定是秒杀吗?"></a>一定是秒杀吗?</h2><p>​我们纵观人类发展史，无论是工业革命时代的路边小卖部，还是信息化时代的全球电商平台，总有时代的先驱者找到了当下时代的技术与底层逻辑的结合，归根结底其实研究的还是是<strong>人与组织、交易</strong>。</p><p>​互联网秒杀此类业务模式的出现是在特定历史阶段的产物，而我们真正要关注的是此类活动的底层逻辑以及我们的营销目的，最终以什么样的形态展示到用户面前，一定不是永恒不变的，<strong>秒杀是手段，不是目的</strong>。而在高速发展的当下，已经有了相对于传统秒杀更加有效的活动模式，以及电商突破物理限制后，能够触达的新业态。</p><p>​<strong>万变不离其宗</strong>，了解消费者，了解底层逻辑，与自身资源有机结合，形成可落地的面向用户的活动形式，最后落地的一定是秒杀吗？我想一定不是的。</p><p>​谢谢朋友们的观看，我是懂点技术的saas电商产品经理狗阿木，如果您觉得我的文章对您有帮助，记得点赞关注~</p><p>​</p><p>参考资料</p><p><a href="https://www.163.com/dy/article/GJ7AQT7E0526D7OK.html">曾将中文带火的韩国网游，却被自己搞凉，15年后又想复活捞一笔？</a></p><p><a href="https://www.itsiwei.com/2434.html">“秒杀起源”，电商年代告诉你什么是真正的秒杀</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;历史上的“秒杀”&quot;&gt;&lt;a href=&quot;#历史上的“秒杀”&quot; class=&quot;headerlink&quot; title=&quot;历史上的“秒杀”&quot;&gt;&lt;/a&gt;历史上的“秒杀”&lt;/h2&gt;&lt;p&gt;​	在1980美国的11月24号，这一天是美国最重要的传统节日&lt;strong&gt;感恩节&lt;/st</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="秒杀" scheme="https://bluedancers.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(2) - 细致解读,Saas商城必备的优惠券产品设计攻略</title>
    <link href="https://bluedancers.github.io/2023/10/20/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89%20-%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91/"/>
    <id>https://bluedancers.github.io/2023/10/20/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89%20-%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91/</id>
    <published>2023-10-19T16:00:00.000Z</published>
    <updated>2023-11-27T03:12:56.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​在上一篇文章中，我们了解了优惠券的起源，以及随着互联网的出现，优惠券的能力进一步被挖掘的发展历程；今天直接上干货，聊一聊<strong>Saas商城系统的优惠券产品逻辑究竟要如何设计</strong>。</p><h2 id="优惠券的框架设计"><a href="#优惠券的框架设计" class="headerlink" title="优惠券的框架设计"></a>优惠券的框架设计</h2><p>优惠券的生命周期如下</p><p><img src="http://qiliu.vkcyan.top/FtAcMuNyjljceuzGB871e9Zp3Xra.png"></p><p>我们的优惠券设计的目的，也就是解决生命周期每个环节的问题。</p><ol><li>店铺如何发布优惠券？</li><li>店铺中的用户如何领取到优惠券？</li><li>领取到优惠券的用户如何使用优惠券？</li><li>店铺通过那些维度去复盘优惠券的效果？</li></ol><p>​其中的问题1、2是放在一起考虑的，发布优惠券的时候，我们不仅需要考虑优惠券的基本信息，也需要<strong>提前思考优惠券通过什么渠道发放到目标用户手中</strong>。</p><p>​我们首先聚焦于发布优惠券的产品逻辑。</p><h2 id="发放优惠券"><a href="#发放优惠券" class="headerlink" title="发放优惠券"></a>发放优惠券</h2><p>发布优惠券中我们可以将其分为2个大类，<strong>基础设置</strong>与<strong>发放规则</strong>。</p><p>​<strong>基础设置</strong>包含优惠券名称、优惠券类型、发放数量，等的优惠券的基本信息，这样的<strong>基本信息在任何商城几乎都是通用的。</strong></p><p>​<strong>发放规则</strong>是发放渠道、定向发放、发布平台、领取限制，等等平台独特的，<strong>配合运营而存在的设置。</strong></p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>  <img src="http://qiliu.vkcyan.top/FtT9pjaAgxFwEuuCX-Omr6HCu-4l.png"></p><p>​这部分产品逻辑无论哪一家的saas都是大同小异的，都是对<strong>现实优惠券的抽象</strong>。</p><p>​有的saas系统中，将优惠券的设置单独抽出来，叫做<strong>优惠券模板</strong>，其产品流程为，首先发布优惠券模板，然后发布优惠券的时候再选择模板，随后设置发放规则，才算发放成功，比如微盟；</p><p>​绝大部分saas都没有这样做的必要，因为如果不是极其复杂的产品，过于细化产品逻辑，反而增加了技术、运营的使用难度。</p><h4 id="券名称（用户见）-券名称（店铺见）"><a href="#券名称（用户见）-券名称（店铺见）" class="headerlink" title="券名称（用户见） + 券名称（店铺见）"></a>券名称（用户见） + 券名称（店铺见）</h4><p>​券名称不仅需要设置用户可见的优惠券名称，还需要设置后台独有的优惠券名称</p><p>​为什么存在这样一个字段呢？</p><p>​因为<strong>同名称 + 规格的优惠券可能被发布在不同的渠道</strong>，如果不存在字段在后台进行区分，店铺运营人员就无法通过用户见的优惠券名称快速区分同名优惠券的具体渠道；</p><p>​<strong>为了满足运营人员快速区分渠道的目的，系统内部就需要针对优惠券增加一个内部可见的名字</strong></p><p>​也许有小伙伴会说，将不同的渠道信息写到优惠券备注里面不就好了，这样确实可以，但是优惠券备注字段一般是不支持搜索的，这就需要运营人员手动筛选，所以店铺见的券名称字段是非常有必要的。</p><p>​<strong>这2个字段在优惠券列表页面都需要支持搜索。</strong></p><h4 id="优惠券类型"><a href="#优惠券类型" class="headerlink" title="优惠券类型"></a>优惠券类型</h4><p>​尽管优惠金额千变万化，我们始终可以用满减券、折扣券这2个抽象纬度进行归纳；当然虽然场景的精细化，还可以衍生出更加细分的优惠券类型，我们先说通用的。</p><p>​折扣券除了设置<strong>具体折扣</strong>之外，一般还要设置<strong>门槛</strong>与<strong>优惠上限</strong>，我们归纳一下，一般这样设置</p><ul><li><strong>优惠内容</strong><ul><li>满xx元，打xx折</li><li>无门槛，打xx折</li></ul></li><li><strong>优惠上限</strong><ul><li>无优惠上限</li><li>最多优惠xx元</li></ul></li></ul><p>满减券的逻辑和折扣券类似，不过满减券已经设置了具体的优惠金额，所以不再需要设置优惠上限，一般存在以下设置</p><ul><li><strong>优惠内容</strong></li><li>满xx元，减xx元</li><li>无门槛，减xx元</li></ul><p>​以上2种类型几乎包含了<strong>通用saas商城90%以上的应用场景</strong>，所以如果不是非常重视用户运营，或者行业需要，增加额外的优惠券类型是不划算的。</p><p>​趣味性的包含<strong>随机金额券</strong>，则需要设置随机区间、<strong>商品兑换券</strong>，需要设置指定商品、<strong>买一送一券</strong>、<strong>赠品券</strong>，此类优惠券使用频率与场景相对低频，所有在开发优先级上，需要慎重考虑。</p><h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><p>​回想一下，我们拿到的线下优惠券，是不是基本都会指定单品或者指定类目，这样指定优惠范围的逻辑在saas商城系统的发布优惠券中是不可或缺的，一般应用范围存在以下几种纬度。</p><p><strong>指定商品、指定类目、指定供货商、全场通用</strong></p><p>注意一点，这里的指定都是可以指定多个的，并非只能指定一个，比如指定多个商品、指定多个类目。</p><p>另外就是关于全场通用，这个选项saas商城谨慎添加，因为该应用范围存在以下特点</p><ol><li>应用范围太大</li><li>同时使用频率不高</li><li>全场通用券容易被撸羊毛，偏离效果预期</li><li>一旦运营人员点错，后果不堪设想</li></ol><p>​所以如果全场通用类型优惠券在业务上不是必要的，则不进行添加。</p><h4 id="发放数量"><a href="#发放数量" class="headerlink" title="发放数量"></a>发放数量</h4><p>​这就是指优惠券具体的发放数量。</p><p>​要注意的是，发放数量在编辑的时候，一般只能添加，不允许减少，这是因为减少优惠券可能导致已领取的优惠券数量超出实际库存，也会对系统的稳定性造成风险。</p><h4 id="有效期与活动时间"><a href="#有效期与活动时间" class="headerlink" title="有效期与活动时间"></a>有效期与活动时间</h4><p>​在店铺后台发券的时候可以指定优惠券可使用时间，一般存在2种类型</p><ul><li><strong>用券时间</strong><ul><li>指定用券时间范围，比如指定xxxx - xxxx时间段可用</li><li>指定领券后有效期，比如领券后x天内有效</li></ul></li><li><strong>活动时间</strong><ul><li>执行之间端，优惠券是</li></ul></li></ul><p>​用券时间的限制，大家都比较好理解，存在时间限制的券，会增加用户的使用动机，存在有效期的优惠券也降低了程序的运行负担。</p><p>​而活动时间，我调研多数竞品看是不存在的，而我站在店铺运营者的角度来看，觉得这个字段是有存在的必要的。</p><p>​我们可以想象一个场景，在春节节假日期间运营需要发布了一张全场优惠券，用户领券后，30天内可用，春节之后无法领券。如果不存在活动时间，运营人员就需要在春节节假日结束的时候手动关闭优惠券，或者活动入口。</p><p>​这样的事情，完全可以交给程序完成，就是增加活动时间的概念。</p><p>​还有一点需要注意的是，当活动时间小于优惠券的使用时间的时候，优惠券不会随着活动时间的过期而过期，而是按照自己的使用有效期规则。</p><p>​到此为止，我们的发布优惠券的基础模块就完成了，这一部分的产品设计是比较简单的，大部分的产品逻辑都是类似的，无论是参考竞品，还是自行设计，最终都会走向类似的终点，将尽力聚焦于商家运营需求，或者用户需求才是重点；</p><h3 id="基础设置的示例图"><a href="#基础设置的示例图" class="headerlink" title="基础设置的示例图"></a>基础设置的示例图</h3><p><img src="http://qiliu.vkcyan.top/FvGjr5XHiv-c4_YuTqAV4SZkHHNo.png"></p><p>​完成了如何发布优惠券，下一步，我们就要看看用户如何获得优惠券。</p><h3 id="发放规则"><a href="#发放规则" class="headerlink" title="发放规则"></a>发放规则</h3><p><img src="http://qiliu.vkcyan.top/FjIjbcXN74Jae5Ahy4rT7aKB0Mgj.png"></p><h4 id="发放渠道（重点）"><a href="#发放渠道（重点）" class="headerlink" title="发放渠道（重点）"></a>发放渠道（重点）</h4><p>​我们可以想象一下，在我们的日常生活中，有多少种途径可以完成领券动作</p><ul><li>在商品详情页领券。</li><li>在社群中的优惠券链接完成领券。</li><li>在线下海报完成领券。</li><li>通过特定的卡密兑换优惠券。</li><li>在签到、抽奖活动中获取优惠券。</li><li>….</li></ul><p>​我们可以想到很多很多领券的途径，在我们发布优惠券的时候，需要控制优惠券可以在什么渠道被领取，如果没有渠道的概念，原本打算发给社群的优惠券，在商城类就可以领取，券就会被截胡了；后期的数据统计也无法细分查看不同渠道的转化率。</p><p>​另外优惠券有了渠道的区分，即使是同样规格的优惠券，在后期的优惠券数据统计上，也可以<strong>看到不同渠道的效果如何</strong>，总之，优惠券渠道的区分对于店铺运营来说都有很重要的意义。</p><p>​一般存在什么样的发放渠道呢？</p><h5 id="商城渠道"><a href="#商城渠道" class="headerlink" title="商城渠道"></a>商城渠道</h5><p>​用户可在商城内的优惠券集合页面、可用商品的商品详情页面领取优惠券</p><h5 id="手工渠道"><a href="#手工渠道" class="headerlink" title="手工渠道"></a>手工渠道</h5><p>​一般用于客服为用户补发优惠券，用户无法手动领取。</p><h5 id="外部渠道"><a href="#外部渠道" class="headerlink" title="外部渠道"></a>外部渠道</h5><p>​运营可以<strong>导出可兑换优惠券的券码</strong>，并分配给第三方，第三方的用户通过兑换、购买等等方式获取到指定券码，最后按照活动提示，回到商城中，将兑换码兑换成可使用的优惠券；一般用于异业合作。</p><blockquote><p>以上3个渠道为基本渠道，几乎每个saas商城都存在的，而下面的渠道则和具体的业务绑定，属于个性化的渠道</p></blockquote><h5 id="券包渠道"><a href="#券包渠道" class="headerlink" title="券包渠道"></a>券包渠道</h5><p>​券包渠道优惠券无法直接被用户领取，而是需要运营人员在后台的券包管理模块，选择多个该渠道的优惠券，发布成一个券包，用户再通过指定渠道、或者首页弹窗，领取券包，自动获取券包中的所有优惠券。</p><h5 id="抽奖渠道"><a href="#抽奖渠道" class="headerlink" title="抽奖渠道"></a>抽奖渠道</h5><p>​发布在抽奖渠道的优惠券，可以在发布抽奖活动的配置中，配置指定优惠券，用户即可通过抽奖获得该优惠券。</p><h5 id="签到渠道"><a href="#签到渠道" class="headerlink" title="签到渠道"></a>签到渠道</h5><p>​发布在签到渠道的优惠券，可以在发布签到活动的配置中，配置指定优惠券，用户即可通过指定的签到天数获取该优惠券。</p><h5 id="标签渠道"><a href="#标签渠道" class="headerlink" title="标签渠道"></a>标签渠道</h5><p>​发布在标签渠道的优惠券，可以在标签管理中配置指定优惠券，用户达成某种条件，自动获得标签的时候，也就会自动获取优惠券。</p><p>​自动标签可以有效的完成用户精细化运营的需求，我文中所写的方式是，先发券，再去标签管理中进行绑定，<strong>如果精细化运营要求比较高，可以在发布优惠券的时候就指定标签，这样操作上更加直观</strong>。</p><p>​关于 券包、抽奖、签到、标签与活动运营存在强关联的优惠券渠道，如果对运营不存在精细化的需求，可以不在进行划分，统称为<strong>自动渠道</strong>。</p><p>​细分的渠道虽然可以让系统更加稳健，让后期的统计更加简单直观，但是也不是没有缺点，增加了实际运营的理解难度，也增加了操作步骤，所以<strong>到底是精细化还是简单直观，需要根据自己的产品特性进行判断</strong>。</p><h4 id="领取限制"><a href="#领取限制" class="headerlink" title="领取限制"></a>领取限制</h4><p>​券的数量是有限的，一个用户可消费的量也是有限的，如果不对券的领取加一限制，会造成券的浪费，也会造成潜在订单的流失，所以发放优惠券的领取限制是很有必要的</p><p>​领取限制一般存在以下几种</p><ul><li>不限次数</li><li>每人限制x次</li><li>每人每天限制x次</li><li>每人每月限制x次</li></ul><p>​领取限制并非一成不变的，究竟是什么样的领取限制，在设计产品的时候，我们需要根据服务对象的需求来决定。</p><h4 id="领取与使用平台"><a href="#领取与使用平台" class="headerlink" title="领取与使用平台"></a>领取与使用平台</h4><p>​很多saas商城不仅支持微信小程序，可能还支持h5、微信公众号、xx小程序，等等。</p><p>​首先，不同平台的运营规则是不一样的，比如虚拟类商品就不允许在小程序中进行售卖，那么虚拟类商品的优惠券就不可以在微信小程序中被领取与使用；或者某些运营需求，我们希望用户在指定渠道领取与使用，这些运营需求的实现都需要再发布优惠券的时候限制领取与使用平台。</p><h4 id="是否加入微信券包"><a href="#是否加入微信券包" class="headerlink" title="是否加入微信券包"></a>是否加入微信券包</h4><p>​如果saas商城支持微信公众号、微信小程序，我们的ToC的商城用到微信的鉴权能力，技术上就没有阻碍了。</p><p>​开启该功能后，用户在商城中完成领券的时候，我们也可以将券<strong>加入到用户的微信券包</strong>，加入微信券包的券存在过期提醒，可以快过期的时候<strong>二次唤醒用户</strong>，也可以通过优惠券直达商城，是不错的功能。</p><p>​不过要注意的是，加入微信券包的券，尽量是高价值的，低价值的优惠券无法引起用户的兴趣，快过期了再提示用户使用，会加剧用户的反感，甚至导致用户的投诉，所以该功能也需要慎重使用。</p><p><img src="http://qiliu.vkcyan.top/FoD4PbIDLgrVTZs-O8FHiRC1742Z.png"></p><h2 id="外部优惠券的发放逻辑"><a href="#外部优惠券的发放逻辑" class="headerlink" title="外部优惠券的发放逻辑"></a>外部优惠券的发放逻辑</h2><p>​在上述优惠券发放渠道中，存在一个比较特殊的优惠券渠道，就是我们的外部渠道，外部渠道的券，是我们发放给第三方产品，或者公开区域，用户无法在站内获取的优惠券。</p><p>​因为站内无法获取，则需要我们导出券码，让用户可通过站外渠道进行领取，<strong>所有我们的后台需要支持导出优惠券的功能</strong>。</p><p>​为了更好的运营效果，优惠券也不是一股脑全部导出的，因为可能存在多个外部渠道，A渠道需要1000张，b渠道需要2000张，不能让运营人员去手动拆分做这种工作，所以<strong>我们需要先生成指定渠道，再导出优惠券。</strong></p><p>​外部优惠券在优惠券列表表格中会多出2个按钮，第一个是<strong>生成</strong>，第二个是<strong>导出</strong>。</p><p>​假设我发布了10000张优惠券，分别导出给A、B、C渠道，则发布完成后，点击生成，生成的时候填写<strong>生成数量、导出渠道</strong>，完成指定渠道的外部优惠券的生成，B、C同理。</p><p>​外部优惠券生成完成后，再点击导出，<strong>再选择上一步声明的指定渠道</strong>，即可导出指定渠道的所有优惠券兑换码，同时还可以在导出时设置券码状态，未领取、未使用、已使用或者全部，针对性导出。</p><p>​最后，我们将导出的csv文件，给到第三方的外部渠即可。</p><p>​到此为止，我们发放优惠券的全部功能就梳理完成了。</p><h2 id="用户使用优惠券"><a href="#用户使用优惠券" class="headerlink" title="用户使用优惠券"></a>用户使用优惠券</h2><p>​在C端用户使用优惠券的逻辑就非常简单了，为了更好的用户体验，领券页面到下单的产品路径一定是越短越好，一般存在如下特征</p><ul><li>商城内存在一个“我的优惠券”页面，我的优惠券页面需要有<strong>券码兑换功能</strong>，方便用户兑换发放出去的外部优惠券</li><li>如果优惠券是指定单商品，点击使用优惠券，则直接进入指定单商品，如果是多商品可用，则进入一个可用商品集合页面，<strong>确保最短产品路径</strong>。</li><li>在最终下单环节，自动帮助用户选择最便宜的优惠券，同时为用户提供切换可用优惠券的产品功能。</li></ul><p>关于ToC的产品逻辑可参考竞品非常多，也不是本文的重点，所以这里就不做过多赘述了。</p><h2 id="优惠券效果复盘"><a href="#优惠券效果复盘" class="headerlink" title="优惠券效果复盘"></a>优惠券效果复盘</h2><p>​每当我们的优惠券活动结束后，并且用户的券已经全部被使用，或者失效，我们便可以根据优惠券的多维数据建立漏斗模型。</p><p>​<strong>发券数量 - 领券数量 - 使用数量</strong></p><p>​另外还有<strong>优惠券成本、优惠券支付金额、优惠券新老用户数</strong>，等等偏向于业务维度的数据统计。</p><p>​假设数据分析发现，大量用户没有领券，我们则需要反思我们渠道是否存在问题，导致优惠券的曝光不足。</p><p>​亦或者领取到使用的转化低于预期，我们则需要考虑，领券用户是否对商品不感兴趣，或者券的价值过小，最终导致用户领券，但没有足够的下单动机。</p><p>​总之，在领券与使用2个环节的转化漏斗结合用户画像，以及渠道的，等相关影响因素，可以分析出一些宝贵的结论，再反哺下一次的优惠券营销活动。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​优惠券作为saas电商系统最常见的营销活动，在用户的拉新、促活、转化，等多个维度都可以发挥作用，是作用极大的，贯穿整个系统的功能，所以各位产品，一定要思考用户的需求，慎重做产品决策，构建出操作便捷、功能强大的优惠券模块。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	在上一篇文章中，我们了解了优惠券的起源，以及随着互联网的出现，优惠券的能力进一步被挖掘的发展历程；今天直接上干货，聊一聊&lt;strong&gt;</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="优惠券" scheme="https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>runtime运行时</title>
    <link href="https://bluedancers.github.io/2023/09/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/runtime%E7%9B%B8%E5%85%B3/"/>
    <id>https://bluedancers.github.io/2023/09/29/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/runtime%E7%9B%B8%E5%85%B3/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-11-27T02:44:34.885Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟dom存在2个非常核心的概念</p><ol><li>挂载：mount</li><li>更新：patch</li></ol><p>h函数作用，生成vnode</p><p>render函数的作用，解析vnode并生成真实dom</p><h1 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h1><p>源码地址在：<strong>packages&#x2F;runtime-core&#x2F;src&#x2F;h.ts</strong></p><p>首先进入<strong>h</strong>函数</p><p>h函数存在3个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type：当前节点类型</span><br><span class="line"></span><br><span class="line">propsOrChildren：props或者children</span><br><span class="line"></span><br><span class="line">children：子节点</span><br></pre></td></tr></table></figure><p>该函数的作用就是处理好以上三个函数的传参的多种情况。</p><p>然后再将处理好的<strong>type，props，children</strong>传入到<strong>createVNode</strong>函数中</p><p>createVNode最终会执行_createVNode函数，只不过开发环境会做一些额外的处理</p><p>对于初始化的组件来说，_createVNode的主要目的就是给当前组件增加组件类型标识shapeFlag</p><p>然后进入createBaseVNode，在该出构建了完成的VNode，并根据children的字段，重新计算shapeFlag，最终返回vnode</p><p>小结：<strong>h - createVNode - _createVNode - createBaseVNode</strong></p><ol><li>h函数 处理入参，使其标准化的进入到vnode创建流程</li><li>根据type类型预先赋值shapeFlag，并增强处理class与style</li><li>构建VNode基础数据</li><li>根据children的类型，再次刷新ShapeFalg，完成对组件类型的全部标识。</li></ol><p>h函数最终就是要生成可用于render函数渲染的vnode数据</p><h1 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h1><p>在h函数中处理过去的vnode，将会在render函数中被渲染为真实dom</p><p>render的核心代码在runtime-core中进行实现，核心代码与平台式无关的，runtime-dom中存放所有dom渲染相关的代码</p><p>在导出render之前，首先会将dom相关方法放入render函数，我们使用的render其实已经被处理过了</p><p>代码执行流程大概如下</p><p>render：传入vnode与挂载阶段</p><p>patch：判断阶段类型，进入对应渲染函数</p><p>processElement：文本组件进入这里，首先判断是更新还是新增</p><p>mountElement：新增文本组件进入该函数 （创建节点 填充数据 设置props 插入dom）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚拟dom存在2个非常核心的概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;挂载：mount&lt;/li&gt;
&lt;li&gt;更新：patch&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;h函数作用，生成vnode&lt;/p&gt;
&lt;p&gt;render函数的作用，解析vnode并生成真实dom&lt;/p&gt;
&lt;h1 id=&quot;h函数&quot;&gt;</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>营销工具(1) - 人人都爱用的优惠券，背后逻辑竟然这么复杂？</title>
    <link href="https://bluedancers.github.io/2023/09/29/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%881%EF%BC%89%20-%20%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%88%B1%E7%94%A8%E7%9A%84%E4%BC%98%E6%83%A0%E5%88%B8%EF%BC%8C%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F/"/>
    <id>https://bluedancers.github.io/2023/09/29/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7%EF%BC%881%EF%BC%89%20-%20%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%88%B1%E7%94%A8%E7%9A%84%E4%BC%98%E6%83%A0%E5%88%B8%EF%BC%8C%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F/</id>
    <published>2023-09-28T16:00:00.000Z</published>
    <updated>2023-11-27T03:03:54.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="带着问题思考"><a href="#带着问题思考" class="headerlink" title="带着问题思考"></a>带着问题思考</h2><ol><li>为什么淘宝要把优惠券规则设计的那么复杂？</li><li>为什么不直接降低价格，而是使用优惠券才可以优惠?</li><li>商家发放优惠券的目的究竟是什么？</li><li>为什么公司就算被消费者唾弃，也要大数据杀熟。</li></ol><p><strong>看完这篇文章，你将理解以上这些令人费解的事情。</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​最近负责的Saas商城系统中的优惠券模块开始重构，借此机会作者也打算深入学习与理解优惠券，了解优惠券的前世今生，为后续的产品功能设计环节做好知识储备，避免浅尝辄止的借鉴竞品。</p><p>​让我们搭乘时光机，先回到工业革命时代，看看优惠券是如何“诞生”与“破圈”的，成为人们生活中的一部分。</p><h2 id="时间的齿轮开始转动"><a href="#时间的齿轮开始转动" class="headerlink" title="时间的齿轮开始转动"></a>时间的齿轮开始转动</h2><blockquote><p>​根据广告学中目前公认的说法，全世界首张优惠券是美国著名广告文案撰写人<strong>克劳德.霍普金斯</strong>发明的，他为一款炼乳产品在报纸上设计了一张优惠券，消费者撕下报纸的优惠券，再凭借优惠券去购物便可以享受到优惠。</p></blockquote><p>​19世纪中后期，美国工业革命走向巅峰，随着工业化的兴起与城市化的快速发展，商店、百货公司的数量开始高速增加，购物流程上已经开始现代化，从早期的顾客将想要的商品告知店员，店员将商品从货架拿到顾客手中，演变成了<strong>自助选购模式</strong>。</p><p>​商店数量的增加以及早期供应链的完善，产品与服务开始同质化，竞争也随之变得越发激烈，百货公司与百货公司、品牌与品牌之间逐渐开始相互内卷；</p><p>​在19世纪后期，广告成本非常低廉，主要有以下原因</p><ol><li>由于科技水平的限制，广告多为报纸、海报，广告覆盖与传播的范围有限</li><li>19世纪后期并不是信息过载的时代，竞争不算激烈，消费者对广告的接受度较高。</li><li>电子印刷术进入普及阶段，同时简单的文字与配图被被用户广泛接受，制作成本低。</li><li>没有广告法的限制，进一步降低广告的制作成本</li></ol><p>​而一部分人已经看到了营销对产品的巨大影响，大批企业开始肆无忌惮的投放广告，巨幅墙体海报、有轨电车海报、报纸、促销宣传单，广告开始越来越多的，以各种各样的形式出现在大家的生活中，还有公开分发优惠券以及在用户消费后赠送固定折扣券的行为；</p><p>​不过19世纪末期，整个市场仍处于增量阶段，所以那时宣传依旧具有良好的效果，优惠券这样的营销方式还没有引起大家足够的注意。</p><p>​到这里，我们没法不谈谈这个世界上最伟大的公司之一Coca Cola，根据互联网现存资料的主流声音，优惠券模式通过可口可乐完成被更多人所了解。</p><p>​同样在19世纪末期，可口可乐的营销负责人非常相信广告曝光的巨大价值，他采用各种平面海报、免费饮品券的方式，来开展可口可乐的营销工作，后续靠产品的上瘾性形成复购（上瘾是因为那时候的可口可乐里面含有可卡因）。</p><p>​<strong>当时谁也没想到，那时候不受待见的免费饮品券综合下来竟然是效果最好的</strong>，因为早期彭伯顿（coca cola创始人）认为免费券不挣钱了，因为可口可乐的上瘾性，用户侧反映出极高复购率，<strong>让彭伯顿不禁相信，专业的事情还是应该专业的人来做</strong>。</p><p>​<strong>于是免费饮品券开始被大力使用，甚至通过邮寄的方式直接送到你家门口</strong>，优惠券玩法第一次出圈，当然可口可乐的成功是非常复杂的，优惠券仅仅是一段小小的佳话。</p><p>​非常幸运的是，这样的一张优惠券，目前在互联网上依旧可以找到</p><img src="http://qiliu.vkcyan.top/FutIDma1qVyyN0KukUeRmIJOv4AM.png" style="zoom:90%;" /><p>this card entitles you to one glass of free coca cola at the fountain of any dispense of genuine coca cola</p><p>图片的中文是：<strong>这张卡可以让您在任何出售真正可口可乐的饮料机处免费领取一杯可口可乐。</strong></p><p>我们来简单分析一下，coca cola免费饮品券发挥的作用是什么，或者说传统优惠券有何作用？</p><ol><li>极大降低用户的首次消费门槛，用户面对折扣与免费的优惠，倾向于立即行动，可快速刺激销量。</li><li>创新与新颖性，免费优惠券是新颖的概念，用户收到免费优惠券后，会存在兴趣与好奇心。</li></ol><p>其实除此之外，传统优惠券还有以下作用</p><ol><li>增加品牌忠诚度，用户通过优惠券获取额外的价值的时候，会对品牌产生积极的情感。</li><li>清除库存与滞销商品，通过该优惠券的方式来达到快速周转的目的。</li></ol><p>​<strong>总的来说，传统优惠券就一个点：无套路！真的优惠了！</strong></p><p>​虽然初代优惠券的方式很原始，但是<strong>已经符合大部分人对优惠券的认知了</strong>，而在美国19世纪前中期的大萧条阶段，消费者为了省钱，经常会收集各种优惠券，优惠券进一步受到用户的青睐。</p><p>​在后来的几十年中，互联网时代来临之前，优惠券早已被大众广泛接受，不过其核心玩法和概念没有变化，只不过是表现形式上会变的更加新颖，<strong>产品描述、售价</strong>依旧是重点、如果是免费的会写一个大大的<strong>FREE</strong>。</p><h2 id="在互联网时代优惠券发生变化了吗？"><a href="#在互联网时代优惠券发生变化了吗？" class="headerlink" title="在互联网时代优惠券发生变化了吗？"></a>在互联网时代优惠券发生变化了吗？</h2><p>​当我们了解了优惠券的历史后，现在让我们搭乘时光机器回到互联网时代，看看100多年后的出现的电子优惠券有何变化。</p><p>​<strong>先说结论：互联网的电子优惠券玩法相对传统优惠券是颠覆式的改变</strong></p><p>​到底改变了什么？我先卖个关子，这100年间发生了太多改变人类事情，所以在讲电子优惠券之前，我们首先了解一些极其重要又简单的经济学概念。</p><h3 id="需要提前了解的经济学概念"><a href="#需要提前了解的经济学概念" class="headerlink" title="需要提前了解的经济学概念"></a>需要提前了解的经济学概念</h3><h4 id="差别定价"><a href="#差别定价" class="headerlink" title="差别定价"></a>差别定价</h4><p>​差别定价又被称为价格歧视，<strong>表示生产者针对相同生产成本的产品，以不同的价格售予不同的买家</strong>，这并非是一个贬义词，只是商家为了利益最大化的一种方式。</p><p>  简单来说就是有钱多花点，没钱少花钱。</p><h4 id="消费者剩余"><a href="#消费者剩余" class="headerlink" title="消费者剩余"></a>消费者剩余</h4><p><strong>消费者剩余  &#x3D; 用户可接受最高价 - 实际售卖价</strong></p><p>比如一个手机，张三本来打算5000块钱买，但是这时候突然拿到了一个500块优惠券，张三最终以4500块就买下了的手机。</p><p>此时，<strong>消费者剩余就是5000 - 4500 &#x3D; 500</strong>，而商家的成本是3500，<strong>生产者剩余为4500 - 3500 &#x3D; 1000</strong>，虽然商家挣了1000块，但是他原本是可以挣消费者1500块，所以消费者剩余越大，商家越不赚钱。</p><img src="http://qiliu.vkcyan.top/Fnsl689q92YLLHdYEENXToxFQlSP.png" style="zoom:33%;" /><h4 id="利润最大化"><a href="#利润最大化" class="headerlink" title="利润最大化"></a>利润最大化</h4><p>​我们还是看上面的案例，张三可接受的最高价是5000元，实际消费了4500元，消费者剩余是500元，理想情况下，商家希望用户都通过<strong>可接受最高价进行购买</strong>，这样的情况下商家利润最大，消费者也依旧愿意购买。</p><p>​而针对这个5000的手机，张三消费能力强，5000块愿意购买，李四消费能力弱，最多愿意4500元购买，王五是个学生，最多愿意4000元购买，那么最理想的情况则是，大家分别按照自己的能接受的最高价进行购买。</p><p>​张三消费5000、李四消费4500、王五消费4000，张三、李四、王五的消费者剩余均为0，这样的情况下，<strong>商家看起似乎打折少挣钱了，实际上却是最挣钱的状态，也就是利润最大化。</strong></p><h3 id="线下优惠券的局限性"><a href="#线下优惠券的局限性" class="headerlink" title="线下优惠券的局限性"></a>线下优惠券的局限性</h3><p>​在互联网到来的前夕，企业就已经在讨论如何利用优惠券实现收益最大化。大家都发现了一个非常难以解决的问题，<strong>精准投放无法实现</strong>。</p><p>​比如同样在纽约的张三与李四，张三相对富裕，而李四是一个穷苦大学生，他们都喜欢吃肯德基的单人套餐。</p><p>​假设肯德基的单人套餐原价是30元，张三没有觉得原价贵，无论是否有券，他都会直接买，而李四不是，只有在打折到8折及以下的时候，他才会有消费动机。</p><p>​最后让我们假设，肯德基的单人套餐综合成本是15元</p><p>​<strong>在不发券的情况下</strong>，张三30元购买，消费者剩余是0，商家实现了收益最大化，但是李四不会买，没有收益；</p><p>​<strong>在发券的情况下</strong>，张三与李四都会获取优惠券，假设是8折券，此时张三和李四都会去消费了，张三平时30元也会买，但是现在他只需要花24元，而李四呢，8折优惠券达到了他可下单的最高价，他使用8折券进行下单了；</p><p>​现在在让我们看一下发券场景下，张三与李四的消费者剩余</p><p>​张三可接受最高价30，实际消费 24，商品成本价15，消费者剩余6元，没有实现收益最大化</p><p>​李四可接受最高价24，实际消费 24，商品成本价15，消费者剩余0元，实现了收益最大化</p><p>​虽然少挣了张三的钱，但是多获得了李四的钱，似乎比不发券的效果好；但是这依旧不是理想的效果，因为张三还存在消费者剩余。</p><p>​但是券也不能一直发，长时间这样会降低品牌形象，影响消费者对品牌的信心，并提升用户对价格的敏感度，造成不可逆的严重影响，到那时候再想提价就极其困难了。</p><p>​<strong>最理想的结果应该是让大家都按照自己可接受最高价购买，用户愿意购买，商家收益最大化</strong></p><p>​张三消费能力强，不应该给他发券，他使用原价30元进行消费，消费者剩余为0</p><p>​李四消费能力弱，从高折扣券陆续发到低折扣券，不断试探用户可接受的最高价，直到消费者剩余为0</p><p>​只有这样，商家才能实现收益最大化。</p><p>​但是线下优惠券由于投放不精准问题，是无法达到理想效果的，所以商家极难实现收益最大化。但是互联网的出现改变了这一切。</p><h3 id="线上优惠券的出现"><a href="#线上优惠券的出现" class="headerlink" title="线上优惠券的出现"></a>线上优惠券的出现</h3><p>​我们的主角终于要登场了，时间来到了21世纪初期，并将视野聚焦到我们身边的国家，日本。</p><p>​日本的移动互联网的发展在当时是全球领先的，2010年3G网络几乎就达到了100%的覆盖率，在这样的背景下，<strong>日本麦当劳找到了优惠券投放不精准的解法</strong>。</p><p>​日本麦当劳此前一直想尽量收集消费者信息，比如用户的性别、年龄，来为用户提供更加精准的优惠券，具体做法就是需要用户自行填写个人信息，但是收效甚微。</p><p>​但是如果大家都通过线上进行消费呢？通过交易系统的将可以准确的采集到每个人的消费信息，并记录在数据库。</p><p>​<strong>基于用户数据 + 用户信息挖掘系统，分析用户的消费频次、消费门店、消费金额、购买品种，便可以猜测出用户的消费水平与消费习惯，进而通过电子优惠券的方式实现精准营销</strong></p><ul><li>对于经常购买汉堡的用户，发放小食优惠券，增加用户消费上限</li><li>对于一段时间未关顾的用户发放以前经常购买产品的优惠券</li><li>对于价格敏感型用户，这发放更加大幅的优惠券刺激用户的消费</li></ul><p>​<strong>线上优惠券的出现完全改写了传统优惠券的定义，从商家决定优惠券是什么，变成由用户自己的消费习惯决定优惠券是什么</strong>，完全脱离了以前的单纯的打折促销的作用。</p><p>​而是经过数据分析、精准营销，再通过电子优惠券的方式，实现了不同用户的相同产品的差别定价，更大限度的实现消费者满意，商家利润最大化的理想状态。</p><p>​电子优惠券带着他无法取代的优势开始被大众所熟知，用户分群、基于用户的消费习惯动态给予优惠券的精准营销逻辑开始进入大家的生活，优惠券进入了全新的时代；</p><p>​那么问题来了，新时代的优惠券还可以为大家省钱吗？</p><p>​</p><h3 id="优惠券真的是为了给大家省钱吗？"><a href="#优惠券真的是为了给大家省钱吗？" class="headerlink" title="优惠券真的是为了给大家省钱吗？"></a>优惠券真的是为了给大家省钱吗？</h3><p>​电子优惠券的出现确实让消费者省钱了，但是商家也挣钱了，这看似不合理，<strong>买家更省钱，卖家更挣钱，钱还能凭空变出来不成？</strong></p><p>​只有一种可能，省钱的消费者和不省钱的消费者不是一拨人，而电子优惠券做到了用户分群。</p><p>​让我们看看这几年的双十一购物节，淘宝令人诟病的复杂优惠券机制，站在用户视角，一定是让大部分人不耐烦的，直接把优惠给我不就行了吗？站在淘宝的视角，给用户优惠，但是不能无脑给，给的同时要实现收益最大化，想要收益最大化就需要<strong>让尽可能多的人使用可接受的最高价下单</strong>，大家在淘宝花时间玩游戏也好，活跃也好，如果感觉价格合适了，一般就不存在足够的动机继续下去，于是为了商家、平台的利益最大化，淘宝设定了一套复杂的优惠机制，让消费者利用时间与精力换取优惠。</p><p>​当价格高于心理可接受的最高价的时候，时间与精力的价值小于优惠的价值，用户会自发性的参与活动，获取优惠。</p><p>​当价格低于心理可接受最高价的时候，用户则没有足够的动机继续参与活动获取优惠，而是进入下单流程。</p><p>​<strong>通过这样一个付出成本获取优惠的机制，实现了针对不同用户的动态优惠，完成了用户分层与针对每个用户的区别定价；最终不同消费能力的用户都认为省钱了，同时消费者剩余为0，商家+平台利润最大化状态。</strong></p><img src="http://qiliu.vkcyan.top/FmmnhC5ER69UigqsnSeWXFyVSE92.png" style="zoom:50%;" /><p>相比较与传统优惠券，电子优惠券有一些非常突出的优点</p><ul><li>电子优惠券实现了动态定价，让商品覆盖到了更多的维度，同时更大限度的实现了消费者剩余为0。</li><li>价格标高 + 复杂的优惠券规则，实现对用户的分层，动态实现利润最大化，这个本质上是<strong>优惠券 + 大数据 &#x3D; 卡用户心里最高价</strong>。</li></ul><h3 id="传统优惠券与现代优惠券"><a href="#传统优惠券与现代优惠券" class="headerlink" title="传统优惠券与现代优惠券"></a>传统优惠券与现代优惠券</h3><p>​当我们用传统的优惠券思维，去理解电子优惠券的时候，一切似乎都不合理，而看懂了基于互联网的优惠券的逻辑，我们才能解释现代世界中发生很多事情。</p><ul><li><p>为什么会存在大数据杀熟？</p></li><li><p>为什么不直接降价而是让用户通过优惠券的方式来购买？</p></li><li><p>为什么商家千方百计的想获取你的信息？</p></li><li><p>为什么现如今数据是极其宝贵的资源？</p></li></ul><p>​商家、平台在满足用户需求的情况下，都是为了收益最大化而努力，凭借消费者的用户信息、用户标签、消费习惯，等等信息，实现收益最大化；</p><p>​<strong>通过以上案例与分析，我们可以发现电子优惠券和传统优惠券早已经不是一种东西，虽然他们都叫优惠券</strong>，电子优惠券虽然很厉害，但是也存在很强的开发成本与技术壁垒，传统优惠券虽然能力有限，但是使用门槛很低，成本更低。所以也不能片面说电子优惠券就是好，传统优惠券就是差，<strong>思考自己拥有的资源与需求，理性判断最合适的产品方案</strong>即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​本来只是想回顾一下优惠券的历史，结果一不小心就写了一篇5000字的文章，无论是消费者还是商家，理解优惠券的规则都可以帮助大家更好的理解这个世界发生的事情。</p><p>​下一篇文章，我们将进入实战篇，谈谈<strong>营销工具 - 优惠券的产品设计逻辑</strong>。</p><p>​</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.foodtalks.cn/news/5374">2万字深度拆解可口可乐百年营销史：如何从冷启动到风靡全世界？</a></p><p><a href="https://mp.weixin.qq.com/s/u2nLG2dk3-BxqX8zVhg2mA">我无比怀念肯德基和麦当劳的纸质优惠券</a></p><p><a href="https://weibo.com/1721030600/zmFhXbyAy">艾瑞咨询</a></p><p><a href="http://tech.sina.com.cn/t/2008-05-10/03432187170.shtml">日本3G市场</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;带着问题思考&quot;&gt;&lt;a href=&quot;#带着问题思考&quot; class=&quot;headerlink&quot; title=&quot;带着问题思考&quot;&gt;&lt;/a&gt;带着问题思考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为什么淘宝要把优惠券规则设计的那么复杂？&lt;/li&gt;
&lt;li&gt;为什么不直接降低价格，而是使用优惠券</summary>
      
    
    
    
    <category term="产品" scheme="https://bluedancers.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="营销工具" scheme="https://bluedancers.github.io/tags/%E8%90%A5%E9%94%80%E5%B7%A5%E5%85%B7/"/>
    
    <category term="优惠券" scheme="https://bluedancers.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8/"/>
    
  </entry>
  
  <entry>
    <title>从读《微信背后的产品观》到思考前端工程师的“35岁”</title>
    <link href="https://bluedancers.github.io/2023/08/10/%E9%98%85%E8%AF%BB/%E4%BB%8E%E8%AF%BB%E3%80%8A%E5%BE%AE%E4%BF%A1%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E3%80%8B%E5%88%B0%E6%80%9D%E8%80%83%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E2%80%9C35%E5%B2%81%E2%80%9D/"/>
    <id>https://bluedancers.github.io/2023/08/10/%E9%98%85%E8%AF%BB/%E4%BB%8E%E8%AF%BB%E3%80%8A%E5%BE%AE%E4%BF%A1%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E3%80%8B%E5%88%B0%E6%80%9D%E8%80%83%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E2%80%9C35%E5%B2%81%E2%80%9D/</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2023-11-27T02:43:09.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://qiliu.vkcyan.top/FkbBqDq59Gu7Pjwi9xwN4P1Dz7fM.png"></p><p>​我是一名前端开发者，同时兼任pm职责，近半年在公司负责升级一直在开发与运营的一个B端的Saas商城系统；</p><p>​在对需求剖析、需求抽象、每个字段含义的推敲的时候，我越发对微信这样简洁、自然的产品产生兴趣与共鸣。</p><p>​也会情不自禁的赞叹微信清晰明了、谨慎内敛的结构化产品思路。</p><p>​虽然微信这么多年上线了如此多功能与特性，但是产品简洁而克制的灵魂从来没有改变，哪怕对于60岁的人来说，也几乎不存在用不好微信的情况。</p><p>​而我做为微信的使用者，广义技术上的开发者，无论是产品还是技术维度，都让我越加佩服与引起共鸣(恶心的小程序开发除外)。</p><p>​昨天终于行动了起来，把这本知名的<strong>《微信背后的产品观》</strong>找出来并读了起来，与其叫一本书，不如说是一个演讲的记录，很短，大约2小时就读完了，主要内容是2012年微信4.0发布时候，张小龙长达8个多小时的公开演讲的内容；</p><p>​不同于其他产品经理的书籍，他们会告诉你各种方法论、科学分析方法，张小龙截然相反的采用了一种极其浪漫的方式去看待产品，去理解所谓的用户需求，我认为这种产品思路的领先是微信这么多年在社交领域立于不败之地的根本。</p><p>​虽然在最后，张小龙看似补刀似的说：<strong>我所说的，都是错的</strong>；但是这恰恰就是他的产品理念，所谓产品没有任何科学方法，完全来自于对人，对人类群体的理解，对自己的拷问与质疑。</p><p>​我也斗胆推荐大家看看这本书，很快就能看完，人类之所以存在信息差，就是因<strong>为不知道</strong>，或许看完这本书，你会打开新的思路，某些问题也能豁然开朗。</p><p>​借此机会，我也想与大家分享一下，这几年我<strong>作为一名前端开发者的迷茫与努力</strong>。</p><h2 id="业务前端开发者的困境"><a href="#业务前端开发者的困境" class="headerlink" title="业务前端开发者的困境"></a>业务前端开发者的困境</h2><blockquote><p>我只是一名普通学历，普通的业务前端开发者，所以以下仅是我的个人感觉，不代表所有前端开发者。</p></blockquote><p>​目前在一个小型互联网公司的saas电商部门下，主要职责是前端开发组长，我们公司的主营业务不是saas电商，所以这几年算不上受到到很强的市场冲击，平时会管理几人的小团队，我18年毕业至今，一直在这家公司。</p><p>​而我大学毕业之后一直从事前端开发方向，在我工作1-3年的阶段，我都保持着对技术的热情，主要是因为尝到了学习技术的甜头，那时候我坚定的认为下一个阶段是<strong>全栈</strong>，在工作之余我花费了大量的精力学习技术；但是后面我就发现了一个很现实的问题，公司需要大家更好分工协作，所以高级别的项目后端是绝对轮不到一个前端去开发开发；并不是说能力不行，而是人的精力有限，前后端都干，还要管团队，是忙不过来的。</p><p>​在这样的环境下，关于全栈技术的学习，我也越发疑虑，逐渐走到了大多数业务前端开发者的临界点。</p><ul><li>业务前端的35岁危机在普通人身上是存在的，我们的年纪、精力、外部压力都不允许你永远征战一线，并始终保持高竞争力。</li><li>业务前端的上限很低，大多数努力的前端开发者可以在3 - 5年内触摸到业务前端的上限，职位也就是前端组长。</li><li>技术纵深是很好的选择，但是受限于综合实力（英语、计算机基础、天分），普通人可以达到的纵深远比想象的要浅。</li><li>技术学会了，但是用不上，也会慢慢被遗忘；demo级别的应用无法让开发者对某一项技术有深刻理解。</li><li>在业务开发场景下的前端，永远是<strong>没有灵魂的大头兵</strong>，上限低就意味着待遇相对较低、可替代性相对较强。</li><li>代码写的越多，与人交流的机会越少，对于几十年的人生而言，这是一件很没安全的事情。</li></ul><p>​总结一下，就是因为兴趣而走的前端技术路径开始越来越窄，前路开始越来越看不清，时间推着我向前，这不禁让我低头沉思，下一步究竟要怎么走？</p><h2 id="说回产品"><a href="#说回产品" class="headerlink" title="说回产品"></a>说回产品</h2><blockquote><p>到目前为止我也依旧不确定前路怎么走，接下来的一些结论，只是我的一些探索。</p></blockquote><p>​在大学后期，我隐约感觉技术路线并非我所擅长的时候，我有目的的学习了微观经济学、企业管理、竞争战略相关的知识，从而间接接触到了互联网产品，也就是pm。</p><p>​我很快就感受到了pm的魅力：<strong>创造</strong>，我恰好是一个喜欢新鲜事物的人，在技术上总喜欢优化、迭代、升级，亲手构建出优美并且有价值的产品极具满足感，而前端开发者与用户的距离比任何一个岗位都要近，甚至可以说：前端开发者决定了用户体验。</p><p>​如果一个人同时具备前端开发 + 产品的能力是不是还不错？</p><ul><li>消除技术与产品的认知壁垒，后续我们做到了，在我们公司，产品和技术从来不吵架</li><li>如果有能力决定产品走向，开发者就可以是一名有灵魂的大头兵，甚至晋升军衔。</li></ul><p>也就是说，我逐渐不再下探技术，而是<strong>走向用户</strong>。</p><p>​走向用户，并不意味着开发者要放弃对技术的学习，技术很重要，技术能力依旧是核心竞争力，而是随着我对技术的理解逐渐深入，开始越发清晰的了解到，究竟什么样的能力是前端开发者最需要的，什么样的能力边际收益是最高的。</p><img src="http://qiliu.vkcyan.top/Fj5ClfMkacFzfRYeT1ie06gkYNn8.png" style="zoom:30%;" /><p>​在我从事前端开发第2年至今，我一直都有在产品这方面作出努力与尝试。</p><p>​关于这几年产品的结果，大概可以用这句话来形容：</p><p>​100个想法中，80个想法死在在调研与分析阶段，15个想法死在在demo阶段，最后落地5个想法，其中4个反响平平，只有1个还算成功。</p><p>​虽然绝大部分都是失败，但是站在此刻回头来看，这几年的产品的学习将我的思维高度提升了很多，综合能力也提升了很多，因为很多想法初期是没有团队介入的，凡事都需要亲力亲为，需要思考需求、写最小demo、UI设计、沟通，而上线后，有需要又要为产品负责，就需要进行数据分析，线上数据的观察，等等….，这其实比写代码累多了。</p><p>​这些进步不像程序的学习有一个可量化的指标，这样的软实力很多的是一种感觉，虽然依旧是时而迷茫，但是也偶尔会有一些收获。</p><p>​虽然我做的产品决策越来越多，公司与同事给予的信任也越来越多，所以在产品上的舞台也是越来越大，而看了《微信背后的产品观》，里面的想法非常符合我对产品的理解，当然我的理解是相对浅显与张小龙没法比的，不过张小龙对产品的理念，以及他对需求的理解，这样一套浪漫的方法论，真的非常有魅力，这也是为什么，我看完最后决定写这篇文章。</p><h2 id="跨越“技术”思维"><a href="#跨越“技术”思维" class="headerlink" title="跨越“技术”思维"></a>跨越“技术”思维</h2><p>​这几年，我的老板经常会找我聊天，因为我和他提过对产品很有兴趣，在前两年，他反复和我提一句话<strong>技术为业务服务</strong>，我当时觉得我理解这句话了。</p><p>​我想，这不是废话，写代码最终都是为了公司的项目，为了更好更快的完成公司需求，我要狠狠的学习技术。</p><p>​之后来随着我写的代码越来越多，我对这句话逐渐有了新的理解。</p><p>​之前过于执着于<strong>技术</strong>，总是站在写代码的角度去理解，而这句话的侧重点是<strong>业务</strong>，或者我们换个词<strong>交付</strong>。</p><p>​并不是技术推动交付，而是在推动交付的因素中，技术是其中之一，我们可以衍生出很多类似的话；设计为业务服务、产品为业务服务….</p><p>​所以<strong>技术的目的并非技术，而是交付价值。</strong></p><p>​<strong>人们总是不自知的放大自己在团队中的价值</strong>，这样只会蒙蔽大家的视野，走到更高处，对很多事物将会有不一样的理解。</p><p><img src="http://qiliu.vkcyan.top/Fh1A7U86ZW-_I64VW8gr-hmg2Zd8.png"></p><p>低纬度的技术思维，走向高纬度的业务（交付）思维。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​其实我本来只是觉得读了还不错的一本书，不复盘、不留下点什么反思会达不到学习的目的，写着写着就想到了自己的职业，想到了这几年的经历；</p><p>​总结性的话不说太多，希望可以帮助到屏幕前你，我们共同成长，共同进步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://qiliu.vkcyan.top/FkbBqDq59Gu7Pjwi9xwN4P1Dz7fM.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	我是一名前端开发者，同时兼任pm职责，近半年在公司负责升级一直在开发与运营的一个B端的Saas商城系统；&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="书摘" scheme="https://bluedancers.github.io/categories/%E4%B9%A6%E6%91%98/"/>
    
    
    <category term="产品" scheme="https://bluedancers.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
    <category term="张小龙" scheme="https://bluedancers.github.io/tags/%E5%BC%A0%E5%B0%8F%E9%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>这是我写过的最简单的Vue3中后台动态路由 + 侧边栏渲染方案</title>
    <link href="https://bluedancers.github.io/2023/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BF%99%E6%98%AF%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Vue3%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%20+%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/"/>
    <id>https://bluedancers.github.io/2023/06/15/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BF%99%E6%98%AF%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Vue3%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%20+%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/</id>
    <published>2023-06-14T16:00:00.000Z</published>
    <updated>2023-11-27T03:16:52.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​在3年前发布了一篇<a href="https://juejin.cn/post/6844903816593145864">vue2后台管理系统动态路由方案</a>，时至今日，<strong>vue2</strong>已经升级到了<strong>vue3</strong>，动态路由的实现方案也同步做出了一些升级迭代，帮助开发者们更高效的完成业务需求，然后摸鱼🐟。</p><p>​本次逻辑的升级，主要聚焦于2点</p><ol><li><p><strong>更加简单的实现逻辑</strong></p></li><li><p><strong>更加便捷的路由配置</strong></p></li></ol><h2 id="之前的动态路由方案"><a href="#之前的动态路由方案" class="headerlink" title="之前的动态路由方案"></a>之前的动态路由方案</h2><ul><li><p>前端只存储基础的路由（<strong>登录、首页、404</strong>）</p></li><li><p>根据不同的登录角色，返回其对应的可访问路由树</p></li><li><p>从服务端获取路由树（<strong>JSON</strong>）并递归处理成<strong>vue-router</strong>可使用的数据结构，并通过<strong>addRouters</strong>拼接到基础路由树，完成动态路由</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>相当安全，项目里面只有基础路由，业务路由全部来自接口</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>代码中只保存了基础路由，<strong>业务路由的全部字段需要前端开发人员手动录入到超级管理系统之中，维护业务路由非常繁琐。</strong></li><li>客户端逻辑相对复杂，<strong>addRouters</strong>的逻辑必须在路由钩子<strong>beforeRouter</strong>中完成，这部分逻辑比较烧脑。</li></ul><p>有没有一种办法，可以<strong>既保留动态路由的特性，也保证代码逻辑的简单性，同时将路由配置回归前端项目呢？</strong></p><h2 id="转变解决思路"><a href="#转变解决思路" class="headerlink" title="转变解决思路"></a>转变解决思路</h2><p>​通过以上分析，我们首先可以明确一点，动态路由的配置数据还是<strong>需要放在前端项目</strong>中，而不是将路由的配置录入到系统中。所以，我们可以简化系统后台的权限配置，由之前的超多字段简化为两个字段 <strong>路由名称、路由标识，仅服务于为角色勾选路由，路由配置交还给前端项目</strong>。</p><p>​<strong>路由的树形结构还是需要录入到系统中</strong>，因为我们还需要<strong>保留动态路由的核心逻辑</strong>，给（角色&#x2F;用户）勾选指定路由。</p><img src="http://qiliu.vkcyan.top/Fmtj-mmyZ6NTcHap9GnkgQ6_YXSE.png" style="zoom:50%;" /><p>​<strong>Vue2</strong>版本，我们通过<strong>addRouters为项目路由树“做加法”实现动态路由</strong>。</p><p>​<strong>Vue3</strong>版本，我们则为项目路由树手动<strong>“做减法”实现动态路由</strong>。</p><h2 id="做“减法”实现动态路由"><a href="#做“减法”实现动态路由" class="headerlink" title="做“减法”实现动态路由"></a>做“减法”实现动态路由</h2><p>首先依旧将我们的全部路由分成2部分，<strong>基础路由数组，动态路由数组</strong></p><p>基础路由：无论什么角色都可以访问的路由（登录后的公共页面，比如工作台，没有可以为空）</p><p>动态路由：拥有权限的角色才可进行访问的路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础业务路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">baseRouter</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态业务路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">asyncRouter</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 这一层的路由除了dashboard，其他都是业务无关的路由，比如登录 注册 404 500，不属于动态路由</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/login/index.vue&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;baseDashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;根路径&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">component</span>: layout,</span><br><span class="line">      <span class="attr">children</span>: [...baseRouter, ...asyncRouter], <span class="comment">// 全部注册到vue-router中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们直接将全部路由都注册到<strong>Vue</strong>中，如果不存在鉴权，此时任意角色都可以访问所有页面。</p><p>为了实现动态路由的需求，我们只要解决两个问题</p><ol><li><strong>如何实现路由拦截，拦截不允许被访问的页面。</strong></li><li><strong>如何做减法，筛选出指定的权限树，用于侧边菜单栏的展示。</strong></li></ol><h3 id="如何实现路由拦截"><a href="#如何实现路由拦截" class="headerlink" title="如何实现路由拦截"></a>如何实现路由拦截</h3><p>在用户登录的时候，我们会调用服务端的**<code>获取当前用户权限</code>**接口，获取到当前用户的权限数据</p><p>无论后端给我们返回的什么样的接口，嵌套也好、一维数组也罢，我们都将其处理成一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;index&quot;</span>, <span class="string">&quot;dashboard&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;goods&quot;</span>, <span class="string">&quot;goodsList&quot;</span>, <span class="string">&quot;goodsClass&quot;</span>]</span><br></pre></td></tr></table></figure><p>并将这样的一维数组，保存到我们全局状态库<strong>pinia</strong>中，我们假设变量名称为<strong>authList</strong>。</p><p>然后我们再增加路由钩子的逻辑，每次跳转之前，都判断<strong>next</strong>的页面<strong>name</strong>在<strong>authList</strong>中是否存在，如果不存在，则直接<strong>404</strong>，如果存在，则<strong>允许访问</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> auth = <span class="title function_">useAuthStore</span>()</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// 登录后逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (auth.<span class="property">isLogin</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断权限是否通过</span></span><br><span class="line">    <span class="keyword">if</span> (auth.<span class="property">asyncRouter</span>.<span class="title function_">includes</span>(<span class="title class_">String</span>(to.<span class="property">name</span>))) &#123;</span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未登录逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>经过beforeEach的逻辑之后，我们现在就已经实现了基本的鉴权，不允许访问的页面，都将404</strong>。</p><h3 id="递归筛选出菜单树"><a href="#递归筛选出菜单树" class="headerlink" title="递归筛选出菜单树"></a>递归筛选出菜单树</h3><p>​接下来，我们考虑第二个问题，用户登录之后，自身权限获取完毕，用户进入到管理系统内部，右侧显示功能侧边栏，<strong>我们不能将不属于该用户的动态路由都显示出来</strong>，所以我们需要根据服务端返回的权限数据，实现项目中的动态路由<strong>asyncRouter</strong>的筛选。</p><p>​因为我们路由层级理论上是无限的，所以这里使用<strong>递归</strong>进行实现比较合理。</p><img src="http://qiliu.vkcyan.top/Fjpi98MtbL0irT1Va_-kNy2BXSfw.png" style="zoom:50%;" /><p>实现思路如下</p><ol><li>递归遍历<strong>asyncRouter</strong>路由树，如果路由的<strong>name</strong>在权限数组内，并且该菜单可显示，则继续递归<strong>children</strong>，如果没有<strong>children</strong>则不做处理</li><li>如果路由的<strong>name</strong>不在权限数组中，则将其<strong>splice</strong>，也就是<strong>做减法</strong>，并且循环下标后退一位，防止跳过下一个。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取可访问路由树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">tree</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">loopRouter</span>(<span class="params">tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = tree.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = tree[i]</span><br><span class="line">    <span class="keyword">if</span> (asyncRouter.<span class="title function_">includes</span>(item.<span class="property">name</span>!) &amp;&amp; item.<span class="property">meta</span>!.<span class="property">showMenu</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">children</span>) &#123;</span><br><span class="line">        item.<span class="property">children</span> = <span class="title function_">loopRouter</span>(item.<span class="property">children</span>!, asyncRouter)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tree.<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">      len = tree.<span class="property">length</span> <span class="comment">// 刷新循环长度</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; tree.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除后,数组长度-1,数组的下一位前进了一位,所以一旦splice掉不存在的权限,便需要i--,否则会跳过下一位</span></span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上代码后，我们的路由树便会过滤掉那些不允许被访问的路由</p><p>接下来，我们便可以进行菜单的渲染工作了，前端基操我就不做过多赘述了，大家可以看看我精心为大家准备的<a href="https://github.com/BlueDancers/vue3-dynamic-routing-admin">源码案例</a>。</p><p>到此为止，我们的动态路由就实现了，是不是非常简单~</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>有经验的小伙伴会问，用户登录后，刷新页面再访问的时候，我们如何处理权限呢？</p><p>在我看来这有2个方案</p><p><strong>方案1（相对简单）</strong>：使用<strong>pinia</strong>的持久化插件<strong>pinia-plugin-persistedstate</strong>来持久化我们存储<strong>pinia</strong>的权限数据，无论用户如何刷新，我们的权限数据都一直有效，这样的实现非常简单，但是存在一定的安全隐患，就是心怀不轨的某些人，知道了不允许访问的菜单路由名称之后，可以通过手动修改当前页面的<strong>localStorage</strong>实现权限的突破。</p><p><strong>方案2（更加安全）</strong>：在<strong>pinia</strong>中创建一个变量<strong>isRouterInit</strong>标识权限是否已经被初始化，如果没获取过权限数据，则为<strong>false</strong>，如果获取过则为<strong>true</strong>；每次<strong>beforeEach</strong>的时候，登录情况下都判断该值是否为<strong>false</strong>，如果为<strong>false</strong>，则请求当前角色的权限数据，并在请求完毕后，再进行相关路由拦截逻辑，并将变量<strong>isRouterInit</strong>改为<strong>true</strong>，表明权限已经被初始化。</p><p>​以上2种方案都可以用，如果安全性要求不是特别高，建议方案1，如果对安全性、实时性要求比较高，则建议方案2。</p><p><img src="http://qiliu.vkcyan.top/Fq4pwPLiWUPmGhd34tSFDfd8x4Ag.png"></p><h2 id="菜单的排序问题"><a href="#菜单的排序问题" class="headerlink" title="菜单的排序问题"></a>菜单的排序问题</h2><p>​经过实操的小伙伴还会发现一个问题，在项目中的路由排序也许是个麻烦事。</p><p>​可能角色A说：我要<strong>acb</strong>，角色b说：我要<strong>bac</strong>，但是我们路由表放在项目中，其排序是固定不变的，有什么办法可以实现项目左侧路由树按照后台返回的权限字段数据进行渲染呢？</p><p>​其实这个问题很简单，我们针对递归后的动态路由的结果，加一个<strong>sort</strong>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取可访问路由树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">tree</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">loopRouter</span>(<span class="params">tree: RouteRecordRaw[], asyncRouter: RouteRecordName[]</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="comment">// 将菜单按照当前拥有权限asyncRouter的顺序排序</span></span><br><span class="line">  <span class="keyword">return</span> tree.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> asyncRouter.<span class="title function_">indexOf</span>(a.<span class="property">name</span>) - asyncRouter.<span class="title function_">indexOf</span>(b.<span class="property">name</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样项目的右侧菜单树就会按照我们后端返回的顺序进行排序了。</p><h2 id="不需要的路由可以删除吗？"><a href="#不需要的路由可以删除吗？" class="headerlink" title="不需要的路由可以删除吗？"></a>不需要的路由可以删除吗？</h2><p>​vue3提供了动态路由的相关<a href="https://router.vuejs.org/zh/guide/advanced/dynamic-routing.html">API</a>，其中有一个<strong>removeRoute</strong>，可以删除不需要的路由，那么，我们在根据登录角色动态删除剔除不需要在侧边栏显示的路由的时候，是否也同步将不需要的路由进行删除呢？</p><p>​关于这个问题，我的建议是，不建议删除，首先我们的路由模块均为异步加载的，是否删除一定不会访问的路由，都不会影响项目的加载。而一旦真的删除了，用户在推出登录切换账号的时候，一定要<strong>重载当前页面</strong>，因为我们不知道用户下一次登录的角色是什么，会不会用到已经被删除的路由。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​B端项目通过动态路由实现角色鉴权，已经是一个非常成熟的方案，无论是使用<strong>“加法方案”</strong>实现，还是使用<strong>“减法方案”</strong>，都是可行的，理论上都是对权限的一次递归筛选。</p><p>​大家主要根据项目规模、要求合理选择最适合的方案，在安全、便捷、开发难度、稳定性，等多角度做好权衡利弊。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	在3年前发布了一篇&lt;a href=&quot;https://juejin.cn/post/6844903816593145864&quot;&gt;vue2后台</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="动态路由 - vue3" scheme="https://bluedancers.github.io/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 笛卡尔积算法构建SKU最佳实践！看完不会来打我</title>
    <link href="https://bluedancers.github.io/2023/06/03/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BASKU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%81%E7%9C%8B%E5%AE%8C%E4%B8%8D%E4%BC%9A%E6%9D%A5%E6%89%93%E6%88%91/"/>
    <id>https://bluedancers.github.io/2023/06/03/%E6%8A%80%E6%9C%AF%E7%B1%BB%E6%96%87%E7%AB%A0/Vue3%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95%E6%9E%84%E5%BB%BASKU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%81%E7%9C%8B%E5%AE%8C%E4%B8%8D%E4%BC%9A%E6%9D%A5%E6%89%93%E6%88%91/</id>
    <published>2023-06-02T16:00:00.000Z</published>
    <updated>2023-11-27T02:38:00.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​商城一直都是平台研发类的高频项目，也存在诸多含金量与难度非常大的功能点，比如<strong>购物车模块、支付模块、装修模块、商品模块</strong>、以及很多与业务相关的模块，主导此类复杂需求的开发与落地不仅可以<strong>升职加薪</strong>，也是面试中的<strong>展示肌肉</strong>的时刻，</p><p>​所以今天，我和大家分享一个在正式项目中沉淀出来的<strong>Vue3版发布商品 - 构建sku的思路以及具体实现方案</strong>；附带源码与案例，点赞收藏不迷路，接下来进入正文~</p><p>源码：<a href="https://github.com/BlueDancers/vue3-sku-demo/blob/main/src/views/goods/add/index.vue">https://github.com/BlueDancers/vue3-sku-demo/blob/main/src/views/goods/add/index.vue</a></p><p>案例：<a href="https://bluedancers.github.io/vue3-sku-demo">https://bluedancers.github.io/vue3-sku-demo</a></p><h2 id="什么是SKU"><a href="#什么是SKU" class="headerlink" title="什么是SKU"></a>什么是SKU</h2><p>​在开始正文之前，首先要做一次扫盲，那就是我们说的电商项目中的SKU，究竟是什么？</p><p>​SKU的全称是<strong>Stock Keeping Units</strong>，我们可以理解为<strong>商家用于管理商品库存和销售的一种方式</strong>。</p><p>​每个 SKU 对应着一个若干<strong>属性</strong>的组合，例如一个商品存在<strong>颜色、尺寸、款式</strong>等属性。商家可以根据商品的不同属性设置不同的 SKU，并对每个 SKU 进行价格、库存若干信息的管理。</p><p>​举个例子，假设商家有一件衬衫商品，有<strong>红色、蓝色</strong>两种颜色、<strong>S、M、L</strong> 三种尺码可选。那么该商品便存在 <strong>6 个 SKU</strong> ，分别为：</p><ul><li>红色 S 号</li><li>红色 M 号</li><li>红色 L 号</li><li>蓝色 S 号</li><li>蓝色 M 号</li><li>蓝色 L 号</li></ul><p>在这里我们就要明确一下概念了，<strong>颜色、尺码</strong>都是我们的商品属性中的<strong>销售属性</strong>，而生成的 <strong>红色 S 号 红色 M 号 等等</strong> 就是我们的<strong>SKU</strong>。</p><p>再让我们在看看某宝的SKU选择弹窗</p><img src="http://qiliu.vkcyan.top/FnoRiGevwfyWw1iDnZu5FD_mNrQi.png" style="zoom:33%;" /><p>​这个商品的<strong>销售属性</strong>：尺码（6个） 颜色分类（6个），那么通过销售属性，最终将会生成<strong>6*6&#x3D;36个SKU</strong>，而用户选择任意尺码 + 颜色分类的搭配都可以匹配到具体的价格与库存等信息。</p><p>​以上提到的功能点，就设计到电商后台的商品模块的SKU构建知识点，接下来让我们看看，如何使用Vue3构建SKU。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="构建销售属性"><a href="#构建销售属性" class="headerlink" title="构建销售属性"></a>构建销售属性</h3><p>​通过上面的案例，我们得知了SKU并非凭空捏造出来的，而是由<strong>销售属性</strong>动态生成。</p><p>​那么根据某宝的SKU信息，我们反向推导一下，他的销售属性的数据结构可能是这样</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果，不考虑SKU的图片，我们的每个销售属性的数据结构都这样，存在一个销售属性的名称，以及若干个属性值。</p><p>​我们继续观察某宝，发现无论如何修改尺码，白色的图片都是同一张，不会随着尺码的变化而变化，因此我们可以推断出，<strong>sku的图片是由着销售属性进行设置的</strong>；</p><p>​另外还要注意一个细节，一个商品无论存在多少个销售属性，最终只能为其中一个销售属性设定图片，所以我们优化一下我们的销售属性数据结构，增加销售属性图片的字段。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">isAddImage</span>: <span class="built_in">boolean</span> <span class="comment">// 是否上传图片（最多只能打开一个）</span></span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">    thumbnailUrl?: <span class="built_in">string</span> <span class="comment">// 属性图片</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​于是，我们便可以得出我们案例的数据结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> skuAttrItemType = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;尺码&#x27;</span>,</span><br><span class="line">    <span class="attr">isAddImage</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">values</span>: [</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;S&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;M&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;颜色分类&#x27;</span>,</span><br><span class="line">    <span class="attr">isAddImage</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">values</span>: [</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;白色&#x27;</span>, <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">attributeValue</span>: <span class="string">&#x27;黑色&#x27;</span>, <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​这样的数据结构便满足了我们客户端渲染商品SKU，用户可以将不同的尺码与颜色分类进行搭配，但是我们目前仅能实现SKU的选择，还无法满足用户选择任意尺码 + 颜色分类的搭配后，立刻得知价格的场景。</p><p>这也是我们下一步需要解决的问题，就是基于销售属性构建商品SKU。</p><h3 id="使用笛卡尔积算法实现商品SKU的构建"><a href="#使用笛卡尔积算法实现商品SKU的构建" class="headerlink" title="使用笛卡尔积算法实现商品SKU的构建"></a>使用笛卡尔积算法实现商品SKU的构建</h3><p>基于以上销售属性，我们的目标是构建一个如下的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑色&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="comment">// ... 价格 库存 等等信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>SKU的生成是存在明确的运算规则的，<strong>销售属性的属性名称的数量的乘积等于SKU的数量</strong>。</p><p>比如我们上线的销售属性是 两个尺码 两个颜色分类，则生成的SKU数量2 * 2 &#x3D; 4个</p><p>假如我们存在三个尺码 三个颜色分类，则生成的SKU数量3 * 3 &#x3D; 9个</p><p>假如我们再多一个销售属性 两个尺码 三个颜色 四个风格，则生成的SKU数量为 2 * 3 * 4 &#x3D; 24个</p><p>​我们程序如何实现以上逻辑呢？大部分小伙伴面对这样的诉求的第一反应应该都是递归，因为销售属性的数量是未知的，写死循环实现是不现实的，不过在SKU生成上，我们一般使用更加简单的<strong>笛卡尔积算法</strong>。</p><p>​<strong>笛卡尔积：笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积，又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 。</strong></p><img src="http://qiliu.vkcyan.top/Fmr0wr2qWAEvldYISLN3RLzcK6zt.png" style="zoom:30%;" /><p>接下来，我们就来实现这一部分的逻辑</p><p>sku的生成是实时的，销售属性的变化会引发sku的变化，所以我们需要监听销售属性的变化，这里我们通过watch进行实现</p><blockquote><p>笛卡尔积本身不复杂，熟练了解reduce即可，如果有点忘记了，请去<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">MDN</a>复习一下~</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> skuAttrItemType = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> <span class="comment">// 销售属性名称</span></span><br><span class="line">  <span class="attr">isAddImage</span>: <span class="built_in">boolean</span> 是否上传图片（限制最多只能打开一个）</span><br><span class="line">  <span class="attr">values</span>: &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="built_in">string</span> <span class="comment">// 属性名称</span></span><br><span class="line">    thumbnailUrl?: <span class="built_in">string</span> <span class="comment">// 属性图片</span></span><br><span class="line">  &#125;[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听销售属性的变化,并构建sku</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> skuAttributes.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">generateSku</span>(<span class="title function_">deepClone</span>(value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新销售属性构建sku</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">skuAttribute</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateSku</span>(<span class="params">skuAttribute: skuAttrItemType[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">attrValue</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  skuAttribute.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> attrValue.<span class="title function_">push</span>(item.<span class="property">values</span>)) <span class="comment">// 获取所有属性名称 =&gt; [[&#x27;S&#x27;,&#x27;M&#x27;], [&#x27;白&#x27;,&#x27;黑&#x27;]]</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始构建sku </span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">skus</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  <span class="comment">// 笛卡尔积算法（注意，我们的reduce没有指定第二个参数，则第一次循环中，col是数组第一位，set是数组第二位）</span></span><br><span class="line">  skus = attrValue.<span class="title function_">reduce</span>(<span class="function">(<span class="params">col: <span class="built_in">any</span>[], set</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">res</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">    <span class="comment">// 对于每个属性值集合，依次与当前已有的结果集做笛卡尔积</span></span><br><span class="line">    col.<span class="title function_">forEach</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">// 将两个属性值合并为一个字符串，并存入结果集中</span></span><br><span class="line">        <span class="keyword">let</span> t = c.<span class="property">attributeValue</span> + <span class="string">&#x27;,&#x27;</span> + s.<span class="property">attributeValue</span></span><br><span class="line">         <span class="comment">// 寻找销售属性指定的图片</span></span><br><span class="line">        res.<span class="title function_">push</span>(&#123; <span class="attr">attributeValue</span>: t, <span class="attr">thumbnailUrl</span>: c.<span class="property">thumbnailUrl</span> || s.<span class="property">thumbnailUrl</span> || <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">// 将笛卡尔积后的结果集返回，作为下一轮的结果集</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="comment">// 将结果存储起来</span></span><br><span class="line">  stockKeepUnits.<span class="property">value</span> = skus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上的代码，我们变化销售属性，就会得出以下的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这便实现了我们的sku算法，无论是多么复杂的销售属性，都可以通过该函数，输出符合预期的SKU。</p><p>这时候有同学要说了，哎，我SKU的价格，库存等等属性呢？</p><p>这还不简单？赋值之前再循环一遍，增加字段即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">skus.<span class="title function_">map</span>(<span class="function">(<span class="params">e: skuType</span>) =&gt;</span> &#123;</span><br><span class="line">  e.<span class="property">price</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 价格</span></span><br><span class="line">  e.<span class="property">marketPrice</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 市场价</span></span><br><span class="line">  e.<span class="property">stock</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 库存</span></span><br><span class="line">  e.<span class="property">specificationBarCode</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 销售规格</span></span><br><span class="line">  <span class="keyword">return</span> e</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 将结果存储起来</span></span><br><span class="line">stockKeepUnits.<span class="property">value</span> = skus</span><br></pre></td></tr></table></figure><p>最终我们得到了这样的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sku = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;S,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,白&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...白.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">attributeValue</span>: <span class="string">&#x27;M,黑&#x27;</span>,</span><br><span class="line">    <span class="attr">thumbnailUrl</span>: <span class="string">&#x27;...黑.png&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">marketPrice</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">stock</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">specificationBarCode</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>数据准备妥当后，接下来我们就可以渲染表格了，这都是前端基操，我就不做过多赘述，有兴趣的朋友，可以看看<a href="https://github.com/BlueDancers/vue3-sku-demo">源码</a>以及我精心为大家准备的案例。</p><h3 id="实现SKU数据缓存"><a href="#实现SKU数据缓存" class="headerlink" title="实现SKU数据缓存"></a>实现SKU数据缓存</h3><p>如果大家仔细想以上代码，会发现一个问题</p><p>​假设，运营人员在发布商品的时候漏填了一个销售属性，尺码L，但是这时候运营已经填写好了SKU表格中的信息，如果这时候运营想增加字段，根据我们上面的代码，会触发skuAttributes.value的watch，进而运行generateSku，<strong>开始重新构建SKU，导致运营人员之前的数据全部被重置了</strong>。</p><img src="http://qiliu.vkcyan.top/FtwTwzykFR8qzHJwZFVsHIA2XYug.png" style="zoom:50%;" /><p>​而以上提到的场景是项目实际运营期间非常常见的场景，那么有没有办法，可以实现SKU的变动，不影响已经填写好的SKU呢。</p><p>​实现起来其实也很简单，那就是，我们保存每一次生成的SKU的副本，然后在下一次SKU重新构建的时候，对比副本，再回填信息。</p><p>思路如下：</p><ol><li>实时保存SKU的副本</li><li>SKU重新构建的时候对比副本</li><li>销售规格一致的SKU回填副本数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">afterSku</span>: skuType[] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听sku本身的变化,并将当前sku进行备份</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> stockKeepUnits.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    afterSku = <span class="title function_">deepClone</span>(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新销售属性构建sku</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">skuAttribute</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateSku</span>(<span class="params">skuAttribute: skuAttrItemType[]</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line"> <span class="comment">// 增加,回显相关字段</span></span><br><span class="line">  skus.<span class="title function_">map</span>(<span class="function">(<span class="params">e: skuType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找销售规格一致的副本数据</span></span><br><span class="line">    <span class="keyword">let</span> old = afterSku.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">attributeValue</span> == e.<span class="property">attributeValue</span>)</span><br><span class="line">    e.<span class="property">id</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">id</span></span><br><span class="line">    e.<span class="property">price</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">price</span></span><br><span class="line">    e.<span class="property">marketPrice</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">marketPrice</span></span><br><span class="line">    e.<span class="property">stock</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">stock</span></span><br><span class="line">    e.<span class="property">specificationBarCode</span> = old == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : old.<span class="property">specificationBarCode</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">  &#125;)</span><br><span class="line">  stockKeepUnits.<span class="property">value</span> = skus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以是其他回填规则，比如按照下标的方式回填，这就看具体业务的要求了，基于副本我们便完成了SKU的变动后数据的缓存功能。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们vue3版本的商城项目的SKU核心实现到此就全部结束了，如果你想了解全部代码，请点击<a href="https://github.com/BlueDancers/vue3-sku-demo">这里</a>，如果你想测试案例，请点击这里</p><p>作为一名Vue3开发者，你可能对这个专栏感兴趣</p><p><a href="https://juejin.cn/column/7124246398278565895">Pinia 源码分析专栏</a></p><p><a href="https://juejin.cn/column/7199826518570172472">Vue3 硬核源码解析系列</a></p><p><a href="https://juejin.cn/post/7052952117425733663">写给前端nginx教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	商城一直都是平台研发类的高频项目，也存在诸多含金量与难度非常大的功能点，比如&lt;strong&gt;购物车模块、支付模块、装修模块、商品模块&lt;/</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="vue3" scheme="https://bluedancers.github.io/tags/vue3/"/>
    
    <category term="sku" scheme="https://bluedancers.github.io/tags/sku/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（7）watch源码解析.md</title>
    <link href="https://bluedancers.github.io/2023/05/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://bluedancers.github.io/2023/05/18/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89watch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-17T16:00:00.000Z</published>
    <updated>2023-11-27T02:40:13.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​原本打算本章讲讲<strong>computed</strong>，但是<strong>computed</strong>的源码相当复杂，使用文章的形式说清楚，难度真的很大，所以暂时跳过<strong>computed</strong>，先说说<strong>watch</strong>。</p><p>​<strong>watch</strong>即为监听的意思：<strong>监听响应式数据，每当状态发生变化，就会触发回调函数</strong>。</p><p>​如果大家对之前的源码分析有所理解的话，我相信大家可以猜到watch实现原理，<strong>一定是初始化的时候进行依赖收集，依赖项发生变化的时候依赖触发</strong>。</p><p>​如果能领悟到这一层，那么对vue3的核心实现你已经有所理解啦。</p><p>​接下来就让我们走进watch的世界，让我们看看，vue3是如何实现他的吧。</p><p>首先还是放出watch的逻辑图，watch的逻辑相对简单，因为对于watch而言，响应式是其一部分逻辑。</p><p><img src="https://www.vkcyan.top/FmR0g8twA5yVrokQ-uXkSNKqD5Cn.png"></p><h2 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h2><p>在我刚刚使用Vue3 watch的时候，经常出现以下让我无法解释的情况。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactive的案例</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span> &#125;)</span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">name</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三&#x27;</span>, value))<span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">name</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第四&#x27;</span>, value))<span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&#x27;狂飙强&#x27;</span> <span class="comment">// 修改reactive 期望触发watch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ref案例</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">ref</span>(<span class="string">&#x27;卖鱼强&#x27;</span>)</span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个watch&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">value</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个watch&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三次watch&#x27;</span>, value)) <span class="comment">// 无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">value</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第四次watch&#x27;</span>, value)) <span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">value</span> = <span class="string">&#x27;狂飙强&#x27;</span> <span class="comment">// 修改reactive 期望触发watch</span></span><br></pre></td></tr></table></figure><p>以上案例，我相信大部分写vue的同学，都很难在第一时间准确判断其watch是否有效无效，接下来就让我们一起从源码中寻找答案。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>watch</strong>的源码并不在<strong>reactivity</strong>中，而是在<strong>runtime-core</strong>中</p><blockquote><p>关于这一点我会谈谈我的想法，讨论一下为什么不在<strong>reactivity</strong>中，而在<strong>runtime-core</strong>中。</p></blockquote><h3 id="watch初始化"><a href="#watch初始化" class="headerlink" title="watch初始化"></a>watch初始化</h3><p>当我们使用<strong>watch</strong>的时候，其执行的具体源码位置为<code>packages/runtime-core/src/apiWatch.ts</code> <strong>line131</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> watch&lt;T = <span class="built_in">any</span>, <span class="title class_">Immediate</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="built_in">boolean</span>&gt; = <span class="literal">false</span>&gt;(</span><br><span class="line">  <span class="attr">source</span>: T | <span class="title class_">WatchSource</span>&lt;T&gt;,</span><br><span class="line">  <span class="attr">cb</span>: <span class="built_in">any</span>,</span><br><span class="line">  options?: <span class="title class_">WatchOptions</span></span><br><span class="line">): <span class="title class_">WatchStopHandle</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(source <span class="keyword">as</span> <span class="built_in">any</span>, cb, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WatchOptions</span> &#123;</span><br><span class="line">  immediate?: <span class="built_in">boolean</span></span><br><span class="line">  deep?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以了解到，<strong>watch</strong>是存在三个参数的</p><ol><li><strong>source</strong> ：监听项</li><li><strong>cb</strong>：watch的回调函数</li><li><strong>options</strong>： 关于watch的设置，内部存在2个参数<ol><li><strong>immediate</strong>  首次是否运行</li><li><strong>deep</strong>  是否深度监听</li></ol></li></ol><p>这些消息和我们通过Vue文档了解到的信息完全一致，最终我们会发现，其实际返回了一个<strong>doWatch</strong>函数，并将<strong>watch</strong>的三个参数传递了进去。</p><p><strong>doWatch内部的逻辑就是watch实现的核心逻辑了</strong>，我们从三个阶段分析<strong>doWatch</strong>的代码。</p><p><strong>第一阶段：处理source，监听项分析</strong></p><p><strong>第二阶段：构建响应式模块，完成依赖收集</strong></p><p><strong>第三阶段：明确依赖触发方式</strong></p><h2 id="第一阶段：处理source，监听项分析"><a href="#第一阶段：处理source，监听项分析" class="headerlink" title="第一阶段：处理source，监听项分析"></a>第一阶段：处理source，监听项分析</h2><p>我们在使用<strong>watch</strong>的时候，第一个参数，也就是被监听项，是可以传入很多类型的，<strong>ref reactive function array</strong>，在<strong>doWatch</strong>函数中，我们可以看到，针对不同类型与属性的<strong>source</strong>，都做了个性化的依赖处理。</p><p>接下来就让我们看看，<strong>doWatch</strong>都是如何处理这些变量的吧。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote><p>后续getter函数一旦执行，将会访问ref，<strong>触发 ref本身的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// 如果当前source的值是ref, 则处理为() =&gt; source.value</span></span><br><span class="line">  <span class="comment">// 这里注意const num = ref(1) num是ref，num.value并不是ref而是基础类型</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.<span class="property">value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><blockquote><p>后续getter函数一旦执行，将会访问reactive，<strong>触发 ReactiveEffect 完成依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// 如果是reactive则,直接处理成() =&gt; source</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> source</span><br><span class="line">  <span class="comment">// 同时将deep赋值为true 因为reactive为object，一般为多层嵌套，需要深度递归</span></span><br><span class="line">  deep = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><blockquote><p> 后续getter函数一旦执行，将会运行fn，访问函数返回值，如果fn返回的是ref 或者reactive 就会<strong>触发相应的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">  <span class="comment">// callWithErrorHandling函数比较复杂，这里就不做展示了</span></span><br><span class="line">  <span class="comment">// 函数效果为：返回 () =&gt; fn()</span></span><br><span class="line">  <span class="comment">// 后续getter</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> <span class="title function_">callWithErrorHandling</span>(source, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><blockquote><p> 后续getter函数一旦执行，将会访问getter中的所有的访问值，如果fn返回的是ref 或者reactive 就会<strong>触发相应的依赖收集</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isArray</span>(source)) &#123;</span><br><span class="line">  isMultiSource = <span class="literal">true</span> <span class="comment">// 标识为多个监听项</span></span><br><span class="line">  <span class="comment">// array类型的source，可能包含ref reactive Function 所以都需要进行处理</span></span><br><span class="line">  <span class="comment">// 其中reactive比较复杂，需要通过traverse函数，递归触发所有依赖项，也可以说array类型的source，默认deep参数就是true</span></span><br><span class="line">  getter = <span class="function">() =&gt;</span> </span><br><span class="line">    source.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isRef</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="property">value</span> <span class="comment">// </span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">traverse</span>(s)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callWithErrorHandling</span>(s, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">callWithErrorHandling</span>(<span class="params">fn,instance,<span class="keyword">type</span>,</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未知类型"><a href="#未知类型" class="headerlink" title="未知类型"></a>未知类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">NOOP</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">getter = <span class="variable constant_">NOOP</span> <span class="comment">// 如果watch的第一个参数不是以上类型，这起getter函数为空</span></span><br></pre></td></tr></table></figure><p>以上就是<strong>watch</strong>针对所有类型的<strong>source</strong>的处理。</p><p>我们可以发现其实就做了一件事，就是将其包装为<strong>getter</strong>函数，<strong>getter</strong>函数一旦运行，便可以触发相关<strong>依赖收集</strong>。</p><p>完成第一阶段的分析，其实我们文章开头提出的问题已经有了明确答案，我们回过头来继续看看</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;卖鱼强&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// user是reactive，将会被处理为（）=&gt; user，同时deep参数默认设置为true，reactive中的所有依赖都将会触发依赖收集，watch有效</span></span><br><span class="line"><span class="title function_">watch</span>(user.<span class="property">name</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// name是reactive内的基础对象，将会被识别为未知类型，所以watch无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 函数返回，并未访问proxy的属性，无法完成依赖收集，所以watch无效</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> user.<span class="property">name</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 函数返回 而user.name是proxy下的属性，将会触发依赖收集，所以watch有效</span></span><br></pre></td></tr></table></figure><p>以上就是<strong>reactive + watch</strong>不同使用方式的效果解读。</p><p>有兴趣的小伙伴可以试试解读一下<strong>ref + watch</strong>的结果。</p><p>如果真的记不住，我们就记住下面的这句话：<strong>watch 监听对象本身，使用对象的形式；watch监听对象内部属性，使用函数形式。</strong></p><h2 id="第二阶段：构建响应式模块，完成依赖收集"><a href="#第二阶段：构建响应式模块，完成依赖收集" class="headerlink" title="第二阶段：构建响应式模块，完成依赖收集"></a>第二阶段：构建响应式模块，完成依赖收集</h2><blockquote><p>这上小节，我们完成<strong>getter</strong>函数的构建，这一步我们需要进行依赖触发，与依赖收集，使<strong>watch</strong>的监听功能正式生效。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">  <span class="comment">// 如果deep为true, 则将getter函数再通过traverse进一步处理，使其可以被深度监听</span></span><br><span class="line">  <span class="comment">// traverse的作用前面说过，目的就是递归触发对象所有属性的get。</span></span><br><span class="line">  <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">  getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(<span class="title function_">baseGetter</span>()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化oldValue，如果source是数组isMultiSource为true，否则为false</span></span><br><span class="line"><span class="keyword">let</span> oldValue = isMultiSource ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch的核心实现，注意一下，此刻我们还没有执行</span></span><br><span class="line"><span class="comment">// 内部逻辑非常复杂，我们这里简化处理</span></span><br><span class="line"><span class="comment">// 简单来说就是每次watch的属性或者字段发生变化，都会触发该方法，可以触发的原因是我们getter函数完成了依赖收集的必要逻辑</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">job</span>: <span class="title class_">SchedulerJob</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>() <span class="comment">// 获取被监听项的最新值</span></span><br><span class="line">  <span class="comment">// 如果deep为true 或者新旧值不一致, 则会执行watch的cb，也就是我们需要触发的函数</span></span><br><span class="line">  <span class="keyword">if</span> (deep || <span class="title function_">hasChange</span>(newValue, oldValue)) &#123;</span><br><span class="line">    <span class="title function_">cb</span>(newValue, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">scheduler</span>: <span class="title class_">EffectScheduler</span></span><br><span class="line"><span class="comment">// flush：回调的刷新时机 </span></span><br><span class="line"><span class="comment">// queuePreFlushCb  queuePostRenderEffect 后续再说，我们先假设flush就是async</span></span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">  scheduler = job</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class="property">suspense</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePreFlushCb</span>(job) <span class="comment">// queuePreFlushCb 暂时先忽略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter是第一步处理的，可以访问到响应式字段的函数</span></span><br><span class="line"><span class="comment">// scheduler是watch监听字段发生变化，实际需要执行的回调函数，我们可以理解为scheduler = job = getter</span></span><br><span class="line"><span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, scheduler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cb) &#123;</span><br><span class="line">  <span class="comment">// 如果immediate为true,则代表默认watch初始化阶段自动执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">    <span class="comment">// job中的effect.run运行，完成依赖收集，建立其了变量与cb函数之间的联系。</span></span><br><span class="line">    <span class="comment">// 同时也执行了cb函数，首次watchcb被执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果immediate为false，则直接运行effect.run()，完成依赖收集，建立其了变量与cb函数之间的联系。</span></span><br><span class="line">    oldValue = effect.<span class="title function_">run</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回了effect的stop函数，则意味着，watch api存在返回值，只需要执行一下返回值 就会结束掉watch的监听</span></span><br><span class="line">  effect.<span class="title function_">stop</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​到此为止，我们可以明确了解到，在<strong>Vue</strong>的初始化阶段，<strong>watch</strong>其内部通过<strong>ReactiveEffect</strong>，以及<strong>effect.run()<strong>的触发，完成了</strong>watch</strong>需要监听的变量与触发函数的绑定，<strong>ReactiveEffect</strong>逻辑在<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>可以了解其具体实现。</p><p>​<strong>也就是相当于说，watch内部通过手动访问source，触发source的get事件</strong>，<strong>source</strong>依赖一旦触发，就会开始依赖收集，就会<strong>收集到watch的第二个参数cb</strong>，经进而完成<strong>watch</strong>的依赖收集；<strong>只要source发生改变，一定会触发cb函数。</strong></p><p>​其实到这里<strong>watch</strong>的核心源码就已经结束了，依赖已经完成收集；</p><p>​当被监听变量或者属性发生变化的时候，<strong>cb</strong>函数一定会执行，但是<strong>watch</strong>的执行时机是非常有讲究的；</p><p>​<strong>所以接下来就要讲讲watch第三个参数的flush，该字段就是控制cb函数的执行时机。</strong></p><h2 id="第三阶段：依赖触发"><a href="#第三阶段：依赖触发" class="headerlink" title="第三阶段：依赖触发"></a>第三阶段：依赖触发</h2><p>当我们<strong>watch</strong>监听的字段发生变化的时候，<strong>watch</strong>的第二个参数，<strong>cb</strong>会被触发，但是并不是监听字段发生变化的下一步就立刻触发。</p><p>这里我们回顾一下<strong>watch</strong>源码中变量<strong>scheduler</strong>的相关逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">  scheduler = job</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">  scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePreFlushCb</span>(job)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 为了便于理解，暂时认为__FEATURE_SUSPENSE__为false，此处一定等于queuePostFlushCb</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> queuePostRenderEffect = __FEATURE_SUSPENSE__</span><br><span class="line">  ? queueEffectWithSuspense</span><br><span class="line">  : queuePostFlushCb</span><br></pre></td></tr></table></figure><p>我们可以看到，<strong>flush</strong>参数不同的时候<strong>scheduler</strong>的值也是不同的</p><p>如果我们指定了<strong>flush</strong>是<strong>sync</strong>，则<strong>source</strong>发生变化下一个同步任务就是执行<strong>watch</strong>的<strong>cb</strong>函数，</p><p>如果我们不进行指定，默认将是<strong>pre</strong>，则会触发<strong>queuePreFlushCb(job)</strong></p><p>如果指定为<strong>post</strong>，则会触发<strong>queuePostFlushCb(job)</strong></p><p>根据文档我们可以了解到当<strong>flush</strong>为<strong>pre</strong>的时候，<strong>watch</strong>第二个参数<strong>cb</strong>，将会在<strong>Vue</strong>组件更新之前被调用，<strong>post</strong>则会让<strong>cb</strong>函数在<strong>Vue</strong>组件更新之后被调用</p><p>接下来就让我们看看<strong>queuePreFlushCb</strong>与<strong>queuePostFlushCb</strong>内部是如何实现的吧！</p><h3 id="queuePreFlushCb与queuePostFlushCb"><a href="#queuePreFlushCb与queuePostFlushCb" class="headerlink" title="queuePreFlushCb与queuePostFlushCb"></a>queuePreFlushCb与queuePostFlushCb</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedPromise =  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line"><span class="keyword">let</span> currentFlushPromise = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">pendingPreFlushCbs</span>: <span class="title class_">SchedulerJob</span>[] = []</span><br><span class="line"><span class="keyword">let</span> <span class="attr">activePreFlushCbs</span>: <span class="title class_">SchedulerJob</span>[] | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> preFlushIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cb传入到queueCb中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePreFlushCb</span>(<span class="params">cb: SchedulerJob</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行方法附带一些关于pre队列的全局变量</span></span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cb传入到queueCb中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queuePostFlushCb</span>(<span class="params">cb: SchedulerJobs</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行方法附带一些关于post队列的全局变量</span></span><br><span class="line">  <span class="title function_">queueCb</span>(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将cb加入到全局变量pendingPreFlushCbs或者pendingPostFlushCbs中，我们可以理解为缓存了cb函数，并执行了queueFlush</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueCb</span>(<span class="params"></span></span><br><span class="line"><span class="params">  cb: SchedulerJobs,</span></span><br><span class="line"><span class="params">  activeQueue: SchedulerJob[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  pendingQueue: SchedulerJob[],</span></span><br><span class="line"><span class="params">  index: number</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  pendingQueue.<span class="title function_">push</span>(cb)</span><br><span class="line">  <span class="title function_">queueFlush</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数最终将缓存的cb函数访问到Promise的.then中，resolvedPromise已经是resolve状态，则意味着，将会在下一次微任务的时候触发flushJobs</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若干时间后watch被触发，然后一轮事件循环结束，开始触发flushJobs</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  isFlushPending = <span class="literal">false</span></span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">      <span class="keyword">if</span> (job &amp;&amp; job.<span class="property">active</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title function_">flushPostFlushCbs</span>(seen)</span><br><span class="line">    isFlushing = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次触发之前存储的所有cb函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushPreFlushCbs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pendingPreFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> activePreFlushCbs = [...<span class="keyword">new</span> <span class="title class_">Set</span>(pendingPreFlushCbs)]</span><br><span class="line">    </span><br><span class="line">    pendingPreFlushCbs.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; activePreFlushCbs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      activePreFlushCbs[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次触发之前存储的所有cb函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushPostFlushCbs</span>(<span class="params">seen?: CountMap</span>) &#123;</span><br><span class="line">  <span class="title function_">flushPreFlushCbs</span>()</span><br><span class="line">  <span class="keyword">if</span> (pendingPostFlushCbs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> deduped = [...<span class="keyword">new</span> <span class="title class_">Set</span>(pendingPostFlushCbs)]</span><br><span class="line">    pendingPostFlushCbs.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    activePostFlushCbs = deduped</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (postFlushIndex = <span class="number">0</span>; postFlushIndex &lt; activePostFlushCbs.<span class="property">length</span>; postFlushIndex++) &#123;</span><br><span class="line">      activePostFlushCbs[postFlushIndex]()</span><br><span class="line">    &#125;</span><br><span class="line">    activePostFlushCbs = <span class="literal">null</span></span><br><span class="line">    postFlushIndex = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码看起来似乎比较复杂，但是执行的逻辑其实非常简单，<strong>Vue3的更新队列存在三种分别是pre，queue，post，这三个队列按照顺序执行相应代码</strong></p><ol><li>执行<strong>pre</strong>队列中的代码</li><li>执行<strong>queue</strong>队列中的代码，（<strong>queue为组件update的相关逻辑</strong>）</li><li>执行<strong>post</strong>队列中的代码</li></ol><p>这里对照<strong>vue3</strong>文档，我们可以发现，我们的分析是符合文档描述的。</p><blockquote><p>因为涉及到<strong>vue3</strong>的更新队列，这并非<strong>watch</strong>关联的知识，为了方便源码阅读，可以假设<strong>watch</strong>的<strong>flush</strong>的参数为<strong>async</strong>，这样是最好理解的。</p></blockquote><p>到此为止，我们的<strong>watch</strong>核心源码分析就全部完毕了。</p><h2 id="关于ref的一些问题"><a href="#关于ref的一些问题" class="headerlink" title="关于ref的一些问题"></a>关于ref的一些问题</h2><h3 id="watch的源码为什么在runtime-core中？"><a href="#watch的源码为什么在runtime-core中？" class="headerlink" title="watch的源码为什么在runtime-core中？"></a>watch的源码为什么在runtime-core中？</h3><p>关于这一点我是这么理解的，watch不仅仅是一个响应式组件，他涉及到了组件的生命周期，更新渲染等等逻辑，放在runtime中更好与组件系统进行集成，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​通过以上源码分析我们可以发现，watch的响应式原理相对来说是比较简单的，完全依赖我们的之前说过的ReactiveEffect，所以如果小伙伴了解reactive的源码，相信看watch的源码的响应式部分是非常轻松的</p><p>​相对于其他api，watch的响应式实现具备一下2个特点</p><ol><li>watch的依赖收集是<strong>被动触发</strong>的</li><li>watch的依赖触发，实际上是调度器scheduler，然后通过不同的flush，达到控制执行顺序、规则的目的。</li></ol><p>​watch的源码分析就到这里，我们下期再见吧~👋🏻</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d7fdd1b1a44560ae1fd052db6e37e0~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:151</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vue3硬核源码解析系列（6） 100行代码 实现mini版ref</title>
    <link href="https://bluedancers.github.io/2023/03/22/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/"/>
    <id>https://bluedancers.github.io/2023/03/22/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20100%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88ref/</id>
    <published>2023-03-21T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:55.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>​在上一节，我们完成了<strong>vue3</strong>的<strong>ref</strong>核心源码解读，其实<strong>基础类型的ref的核心逻辑还是非常简单的</strong>，所以在我们的简易版源码环节，我们直接切入基础类型，复杂类型仅做支持，不做讲解。</p><blockquote><p>注：单基础类型场景的ref源码，几乎可以说是整个vue3源码中最简单的一部分，所以这一节的学习难度是最小的</p></blockquote><p><a href="https://github.com/BlueDancers/vue3-mini/tree/ref">mini版vue3仓库地址</a>，还请大家不要吝啬star，下次不迷路~</p><p><strong>仅保留最核心逻辑，极大减低阅读难度，80行代码实现vue3 ref</strong>，让我们直接进入源码实现环节！</p><h2 id="逻辑图（基础类型）"><a href="#逻辑图（基础类型）" class="headerlink" title="逻辑图（基础类型）"></a>逻辑图（基础类型）</h2><blockquote><p>完整版ref逻辑图，请看 Vue3硬核源码解析系列（5） ref源码解析</p></blockquote><p><img src="https://www.vkcyan.top/FjE3zqx5l7zpmv0is0_Fusim1mhf.png"></p><h2 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h2><blockquote><p>如同逻辑图所示，我们简易版源码的具体实现也从 <strong>初始化 依赖收集 依赖触发</strong>三个角度来进行实现</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>ref</strong>的初始化非常简单，逻辑流程如下</p><ol><li>判断传入对象是否已经是<strong>ref</strong>，如果是，这直接返回，如果不是，则继续运行代码</li><li><strong>ref</strong>的本质就是一个<strong>Class RefImpl</strong></li><li>初始化<strong>RefImpl</strong>的时候，将ref的参数保存到<code>_value</code>，同时将参数的原始值保存到<code>_rawValue</code></li><li>通过<strong>get value</strong>，实现<strong>ref.value</strong>的访问</li><li>使用<strong>set value</strong>，实现<strong>ref.value &#x3D; xx</strong>的更新逻辑</li></ol><p>确定实现逻辑的同时，我们也仿照vue3的源码结构开始输出吧~</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue: <span class="built_in">unknown</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否已经是ref,如果是直接返回其本身</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ref本质上就是RefImpl的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_value</span>: T <span class="comment">// ref每次读取与返回的属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T <span class="comment">// ref中value的原始属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">dep</span>: <span class="title class_">Dep</span> | <span class="literal">undefined</span> <span class="comment">// 当前ref相关effect</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">__v_isRef</span>: <span class="built_in">boolean</span> = <span class="literal">true</span> <span class="comment">// 标记__v_isRef为true,以后将无法在通过isRef()的判断</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = value     <span class="comment">// 赋值原始值</span></span><br><span class="line">    <span class="comment">// ref API中 __v_isShallow,一定为false （__v_isShallow 表示是否浅层代理）</span></span><br><span class="line">    <span class="comment">// value是基础类型,则toReactive返回原值，value是复杂类型,则toReactive会将其处理成为reactive(proxy)再返回,这就意味着,此时的value是一个proxy</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现ref.value能力</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 配合effect阶段保存的activeEffect,将依赖收集到this.dep中（依赖收集）</span></span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 返回最新value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现ref.value = xx能力</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前set的value是否存在变化, 有变化则进入if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChange</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="comment">// 保存最新的参数原始值，便于下次hasChange判断</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">      <span class="comment">// 如果value是基础类型, 则toReactive返回value本身，否则返回通过toReactive生成的proxy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="comment">// 触发get阶段收集在this.dep中的依赖（依赖触发）</span></span><br><span class="line">      <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><blockquote><p>ref &#x3D; Class RefImpl</p></blockquote><p>​经过我们上一章的<strong>ref</strong>源码分析我们可以了解到，<strong>ref</strong>的依赖收集，并不是依赖<strong>WeakMap</strong>进行完成，而是其自行完成依赖收集，收集在自身<strong>class</strong>的<strong>dep</strong>中，逻辑大概是这样的</p><ol><li>每次触发<strong>ref</strong>的<strong>get</strong>的时候，都会执行一次<strong>trackRefValue</strong>（trackRefValue的作用是完成依赖收集）</li><li>每次执行<strong>effect</strong>的时候，都会将<strong>effect</strong>本身保存到变量<strong>activeEffect</strong>中（具体请看<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>）</li><li>如果<strong>RefImpl</strong>的<strong>dep</strong>不存在，则说明是第一次进行依赖收集，将通过<strong>createDep</strong>将<strong>RefImpl.dep</strong>赋值为<strong>Set</strong></li><li>将<strong>activeEffect</strong>，也就是当前正在运行的<strong>effect</strong>，<strong>push</strong>到<strong>RefImpl</strong>的<strong>dep</strong>中，<strong>ref</strong>完成依赖收集</li></ol><p>明确了逻辑之后，我们依旧结合vue3的源码结构，来完成ref依赖收集的代码输出。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">  <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref 依赖收集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref: RefImpl</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断当前是否存在需要收集的依赖</span></span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 判断RefImpl的实例中的dep是否被初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (!ref.<span class="property">dep</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有, 则赋值为Set</span></span><br><span class="line">      ref.<span class="property">dep</span> = <span class="title function_">createDep</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前effect收集到当前RefImpl实例的dep中, 完成依赖收集</span></span><br><span class="line">    <span class="title function_">trackEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">dep</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p>若干时间后，<strong>ref</strong>的<strong>value</strong>被更新，触发<strong>RefImpl</strong>的<strong>set value</strong>，在更新<strong>value</strong>的同时，也会执行其内部的<strong>triggerRefValue</strong>，开始依赖触发逻辑</p><ol><li>获取到当前ref，也就是class <strong>RefImpl</strong>本身的<strong>dep</strong></li><li>循环<strong>dep</strong>中存储的所有<strong>effect</strong>，并执行其<strong>fn</strong>，完成依赖触发。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref 依赖触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref: RefImpl</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前当前RefImpl实例中是否存在收集的依赖</span></span><br><span class="line">  <span class="keyword">if</span> (ref.<span class="property">dep</span>) &#123;</span><br><span class="line">    <span class="comment">// 触发依赖</span></span><br><span class="line">    <span class="title function_">triggerEffects</span>(ref.<span class="property">dep</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理所有待触发依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="comment">// const effects = isArray(dep) ? dep : [...dep]</span></span><br><span class="line">  <span class="keyword">const</span> effects = [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发执行依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们的<strong>ref</strong>就具备响应式的能力了，是不是很简单~</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​这时候肯定有同学要说了，<strong>你这ref不保熟啊</strong>，仅支持基础类型，不支持复杂类型啊，这不是阉割版ref吗？</p><p>​这里必须澄清一下，虽然简易版ref 100行代码不到，但是他是支持复杂类型的响应式的，因为复杂类型的响应式是依赖<strong>reactive</strong>进行完成的，不过<strong>reactive</strong>的源码解读，并不是本文的重点，所以，这里就跳过了，有兴趣的同学，请看这里<a href="https://juejin.cn/post/7202132390549553211">Vue3硬核源码解析系列（3） reactive + effect源码解析</a>，了解<strong>reactive</strong>的响应式实现，再看<a href="https://juejin.cn/post/7212910997778350136">Vue3硬核源码解析系列（5）ref源码解析</a>，了解复杂类型场景下的源码执行逻辑吧。</p><p>​最后，建议大家<a href="https://github.com/BlueDancers/vue3-mini/tree/ref">clone</a>源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，在简历上留下浓墨重彩的一笔~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;​	在上一节，我们完成了&lt;strong&gt;vue3&lt;/strong&gt;的&lt;strong&gt;ref&lt;/strong&gt;核心源码解读，其</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>chatGPT一些学习记录</title>
    <link href="https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://bluedancers.github.io/2023/03/21/%E6%97%A5%E5%B8%B8/chatGPT%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-03-20T16:00:00.000Z</published>
    <updated>2023-03-22T03:17:16.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最早"><a href="#最早" class="headerlink" title="最早"></a>最早</h2><p>​自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段文本做到深入的理解与分析，并生成高质量的语言表达。</p><p>​那他究竟是什么原理呢？</p><p>​从一段文本中，随机扣掉一部分字，然后模型不断学习此处到底应该填写什么，<strong>所谓学习与训练就是从大量的数据中学习理解复杂的上下文关系。</strong></p><p>​注：学习 无监督学习 训练 有监督学习</p><p>​bert的出现推动了自然语言处理领域的发展，在bert出现之前，我们都是基于规则与浅层神经网络（关键字理解）去解决，bert的出现使得深度学习在自然语言处理上得到了更加广泛的使用。</p><p>​在bert出现之前，openid就出版了GPT1，GPT1也是基于Transformers进行实现，但是gpt没有走双向Transformers的方向，而是走类似单字接龙的方向，由长文单字接龙的自回归所生成，不过GPT1并没有出现bert的惊人效果，所以早期的GPT没啥热度。</p><h2 id="GPT2-GPT3"><a href="#GPT2-GPT3" class="headerlink" title="GPT2 GPT3"></a>GPT2 GPT3</h2><p>​基于bert的成就，大家都看到深度学习在语言模型上的可行性，于是大家都开始各种预训练模型，完形填空，判断题，改错题，GPT2、3也确实是这个思路，开始提升训练数据量，这个成果我们称之为开卷有益（无监督学习）。</p><p>​让chatGPT对海量互联网文本做单字接龙，以扩充模型的词汇量、语言只是、世界的信息与知识。是chatGPT从哑巴鹦鹉变成了脑容量超大的懂王鹦鹉，这个和人类的学习其实很相似，小孩刚刚来到这个解释，就是不断的输入信息。</p><p>​经过巨量的数据训练之后，我们下一步就需要情景学习（<strong>in-context learning</strong>），这两个阶段是NLP模型的基础工作流程，简单来说，就是让chatGPT对优质对话范例做单字接龙，以规范回答的对话模式和对话内容。是chatGPT变成懂规矩的博学鹦鹉，这里的场景标记几个就够了，机器一旦学会了规范，便可以应对此类所有问题。</p><h2 id="关于强化学习（RL）"><a href="#关于强化学习（RL）" class="headerlink" title="关于强化学习（RL）"></a>关于强化学习（RL）</h2><p>​几年前，alpha go击败了柯洁，几乎说明了，经过强化学习，机器可以做到近乎人类极限的程度，但是这样的场景有一个前提，一个非常明确的奖惩机制，alpha go并不理解围棋规则，但是他可以接收到成功、失败的反馈，模型会根据反馈不断调整策略，已达到更多次成功的目的。</p><p>​我们可以看到alpha go的强化学习规则书相对简单的，因为目标明确，而在NLP领域强化学习却很难实现。</p><p>​因为NLP是语言，语言是没有固定的对错，这就意味着无法设定奖惩机制，除非人工来做反馈。</p><p>​openid还就这么干了，这被称之为 <strong>RLHF（Reinforcement Learning from Human Feedback）</strong></p><p>​openid公司找了40家外包公司，不断帮助gpt筛选什么是好的，什么是坏的，通过这种方式构建了一个奖励（reward）模型。</p><p>​这样训练是为了让他学会举一反三的规律，开始出现类似人类的价值价值观与思考模式。</p><p>​于是gpt通过这样奖励模型，开始感知到真实世界，开始了与真实世界的拟合。甚至可以说奖励模型就是gpt的母体，他对人类的理解不取决于世界，而是取决于模型。</p><p>​这样引导学习的方式，在超大模型上出现惊人的效果，gpt在巨量的数据与规范 + 手动标注引导下，变成了看起来有心智的超级人工智能，甚至出现了理解、例子、思维链的能力。</p><p>​这样的方式也是存在缺点的，比如缺点是可能混淆记忆，无法直接查看个更新所学，并且高度依赖学习材料</p><img src="https://www.vkcyan.top/FgOCZQEw2fTJZsn40Q_b5KP5EvZy.png" style="zoom:50%;" /><h2 id="GPT对现今社会的可能影响"><a href="#GPT对现今社会的可能影响" class="headerlink" title="GPT对现今社会的可能影响"></a>GPT对现今社会的可能影响</h2><p>​chatGPT是里程碑的产品，就像流浪地球里面的行星发动机，刚开始大家都都不知道其潜力，经过验证后，地球上迅速出现了几万座行星发动机，并完成了最后的流浪地球，chatGPT这样大语言模型就像最开始几座行星发动机 ，最终也将会形成改变我们生活的推力</p><p>​合理的使用大预言模型，就可以让一个普通人快速准确的触及各行各业的平均知识， 以及具体解法</p><p>​所以我们可以畅想，未来我们也许不在需要学习如何打架，只需要对gpt发号施令，让机器去具体的做事即可</p><p>​除了chatGPT本身具备对人类的能力输出，chatGPT具备我们人类不具备的一点，那就是他可以在语言中学会世界知识。</p><p>​人脑是有限的，寿命是有限，个体死亡，一切都会消失，直到语言的发明，打通了过去与未来，知识以文字作为载体传承至今，一直以来我们通过纸质、或者其他物理形式进行存储，其效率是有限的，直到计算机的出现，我们开始用电子文档替代纸质， 信息传递的效率飞速提升，但是同时也带来了信息处理的巨大成本。</p><p>​所以人工智能领域的自然语言技术应运而生（NLP），其目标就是让机器理解人类的语言，协助人类处理工作，这是人工智能领域非常重要的发展方向，虽然这些年发展缓慢，但是依旧被很多公司加以厚望，因为机器不需要作息，没有情绪，效率极高，可以为企业节省大量的成本。</p><h2 id="与行业结合的可能性"><a href="#与行业结合的可能性" class="headerlink" title="与行业结合的可能性"></a>与行业结合的可能性</h2><ul><li>搜索引擎，帮助用户更加精准的筛选信息</li><li>笔记工作结合，辅助阅读与写作</li><li>办公软件结合，辅助文字处理，数据分析，演示制作</li><li>教育培训结合，指定学习计划，寻找学习资料</li><li>开发工具结合，辅助编写业务代码，调试纠错</li><li>客服系统结合，全天候问答，</li><li>视频会议结合，会议记录，总结，谈话查找</li><li>审核机制结合，少选评论，统计舆论，给出提醒</li><li>行业顾问，提供法律，医疗，健身等等建议</li><li>社交媒体结合，帮助寻找兴趣相投的用户与话题</li><li>与视频音乐结合，个性化推荐视频、音乐、小说、动漫</li><li>游戏剧情结合，让NPC给玩家带来更加灵活的对话体验</li></ul><h2 id="GPT具备对文字行业巨大的改造潜力"><a href="#GPT具备对文字行业巨大的改造潜力" class="headerlink" title="GPT具备对文字行业巨大的改造潜力"></a>GPT具备对文字行业巨大的改造潜力</h2><ul><li>学术界 创造知识</li><li>教育行业 传承知识</li><li>新闻行业 传播知识</li></ul><p>​还有对传统教育行业的巨大挑战，不是GPT可以给学生写作业，而是对现有的人才教育模式存在很大的冲击。</p><p>​按照现在的教育模式（应试教育，传授既有知识）出来的学生，还能应对未来的5-10年的社会需求吗？</p><p>​其实现在已经不太符合了，因为社会变化太快了，以前人们可以通过学习的知识终生受益，现在能满足毕业后5年其实都比较难了，因为知识过时的太快了，人们就需要不断学习新的知识。</p><p>​正因如此，随着互联网时代的到来，终生学习的理念开始被人们推崇，同时教育模式也开始以【培养学习能力与创造能力】为主了，只有这样才能适应不断变化的时代。</p><pre><code> 试想一下你学习了20年，掌握了一些知识，但是GPT却可以瞬间替代你完成你的能力，怎么办？以后人人都有一个熟读人类既有知识的超级大脑，市场不会因为学校的禁用，而集体不使用。</code></pre><p>​任何事物都存在两面性，好的一面是，GPT将方便人来对既有知识进行集成，推进教育去培养高层次人才</p><h2 id="GPT对网络安全的巨大挑战"><a href="#GPT对网络安全的巨大挑战" class="headerlink" title="GPT对网络安全的巨大挑战"></a>GPT对网络安全的巨大挑战</h2><p>​因为GPT的第一阶段，需要大量录入信息，这其中的信息难免会存在一个坏的信息，亦或者军事机密等等信息，所以国家与国家之间很难愿意共享数据，这也意味着，在不就得将来每个有实力的国家都会自己研发大语言模型</p><p>​同时在应用层面，大预言模型将会像口语、文字、电脑、互联网对社会进行再一次改造。</p><h2 id="社会影响"><a href="#社会影响" class="headerlink" title="社会影响"></a>社会影响</h2><p>​只有会工具的人取代不会使用工具的人，没有工具取代人的说法，所以真正需要害怕的是，我们成为无法成为使用工具的人，时代的车轮势不可挡，抵触新工具就意味着落后，学20年干一辈子的时代已经逐渐远去，我们身处加速时期，必须学会终生学习</p><p>​GPT正在改变人类群体应用知识的方式与继承知识的方式，甚至未来可能会形成人机合作的科研，改变人类创造知识的方式，甚至步入下一个文明形态。</p><p>​每个人的学习能力与理解能力，将是驾驭这项技术的瓶颈，也意味着是否可以充分发挥这一技术的优势，</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>bert（Bidirectional Encoder Representations from Transformers 双向编码变换器）</strong></p><p>​BERT 基于 Transformers 模型架构，使用双向编码器来训练深度双向表示，并在多项自然语言处理任务上实现了最先进的性能</p><p><strong>浅层神经网络（Shallow Neural Network）</strong></p><p>​浅层神经网络是一种神经网络，它只有一层或几层隐层，通常用于浅层特征学习和分类任务。与深层神经网络相比，浅层神经网络的参数量少，计算速度较快，但也可能会受到学习能力和表示能力的限制。</p><p><strong>【UL】无监督学习（Unsupervised Learning）</strong></p><p>​无监督学习是一种机器学习的范畴，其目的是在没有明确的标签或目标函数的情况下，从数据中发现隐藏的结构和规律。在无监督学习中，模型需要从数据中学习如何将数据分组、降维、聚类等。</p><p><strong>【SL】有监督学习（Supervised Learning）</strong></p><p>​有监督学习是一种机器学习的范畴，其目的是在有标签的训练数据上学习一个模型，使其能够预测新的数据。在有监督学习中，模型需要学习如何将输入映射到输出，并根据标签调整模型参数以提高预测性能。（特定的任务上进行微调，例如情感分析、文本分类、命名实体识别）</p><p><strong>【RL】情景学习（Reinforcement Learning）</strong></p><p>​情景学习是一种机器学习的范畴，其目的是通过试错来学习如何在特定的情景下做出正确的决策。在情景学习中，模型需要学习如何在不断尝试和反馈的过程中最大化累计奖励。</p><p><strong>【NLP】自然语言处理技术（Natural Language Processing）</strong></p><p>​自然语言处理技术是一种人工智能技术，旨在让计算机能够理解和生成自然语言。NLP 技术可以应用于文本分类、情感分析、机器翻译、问答系统等领域。</p><p><strong>【LLM】大语言模型（Large Language Model）</strong></p><p>​大语言模型是一种基于神经网络的自然语言处理模型，它可以处理大量的文本数据，并学习语言的语法和语义。目前的大语言模型通常使用预训练加微调的方式进行训练，并在各种自然语言处理任务中取得了很好的表现。</p><p><strong>【MLLM】多模态大语言模型（Multi modal Large Language Model）</strong></p><p>​多模态大语言模型是一种结合了自然语言处理和计算机视觉等多种模态的模型，旨在解决多模态数据的处理和理解问题。与传统的大语言模型不同，多模态大语言模型可以同时处理文字、图片、声音等不同类型的数据，并学习它们之间的交互和关联，从而提高自然语言处理和视觉任务的性能。</p><p><strong>RLHF（Reinforcement Learning from Human Feedback 从人类反馈中强化学习）</strong></p><p>​这是一种机器学习的方法，旨在通过与人类交互来提高强化学习算法的性能。在 RLHF 中，算法会在执行任务的过程中接收人类反馈，并将其作为一种奖励信号来调整自己的策略。与传统的强化学习不同，RLHF 可以在学习过程中快速地获得关于任务的准确信息，并且更容易被应用于实际场景中，如自动驾驶、机器人控制等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最早&quot;&gt;&lt;a href=&quot;#最早&quot; class=&quot;headerlink&quot; title=&quot;最早&quot;&gt;&lt;/a&gt;最早&lt;/h2&gt;&lt;p&gt;​	自然语言处理模型，最早出圈的是2018年google发布的bert，他是一个双向Transformer编码的过程（完形填空），可以对一段</summary>
      
    
    
    
    <category term="日常" scheme="https://bluedancers.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="chatGPT" scheme="https://bluedancers.github.io/tags/chatGPT/"/>
    
  </entry>
  
  <entry>
    <title>（3.1）vue3 手摸手实现mini版reactive.md</title>
    <link href="https://bluedancers.github.io/2023/03/13/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/"/>
    <id>https://bluedancers.github.io/2023/03/13/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vue3%E7%A1%AC%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20200%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E5%AE%9E%E7%8E%B0mini%E7%89%88reactive%20+%20effect/</id>
    <published>2023-03-12T16:00:00.000Z</published>
    <updated>2023-11-27T02:39:41.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专栏前言"><a href="#专栏前言" class="headerlink" title="专栏前言"></a>专栏前言</h2><p>​在上一节，我们完成了<strong>vue3</strong>的<strong>reactive</strong>的核心源码解读，总的来说还是非常复杂，文章的表现能力有限，我想可能有很多同学无法完全理解其精髓，所以在本节，我将带领大家完成mini版本源码的输出。</p><p>​<strong>仅保留最核心逻辑，极大减低阅读难度，200行代码实现reactive + effect</strong>，话不多说，我们直接开始！</p><p><a href="https://github.com/BlueDancers/vue3-mini/tree/reactive">简易版vue3仓库地址</a>，<strong>还请大家不要吝啬star，留个标记，下次迷路~</strong></p><h2 id="逻辑图"><a href="#逻辑图" class="headerlink" title="逻辑图"></a>逻辑图</h2><p><img src="https://www.vkcyan.top/FmPJt0I04Cs834SauJHg3WgJgy5O.png"></p><h2 id="逻辑流程"><a href="#逻辑流程" class="headerlink" title="逻辑流程"></a>逻辑流程</h2><h3 id="reative初始化"><a href="#reative初始化" class="headerlink" title="reative初始化"></a>reative初始化</h3><p>​将<strong>reactive</strong>处理为<strong>proxy</strong>，同时预先声明<strong>set</strong> <strong>get</strong>方法，赋值、取值均通过<strong>Reflect</strong>完成，<strong>get</strong>中存在<strong>track</strong>（依赖收集），<strong>set</strong>中存在<strong>trigger</strong>（依赖触发），完成<strong>reactive</strong>的初始化。</p><h3 id="effect初始化（依赖收集）"><a href="#effect初始化（依赖收集）" class="headerlink" title="effect初始化（依赖收集）"></a>effect初始化（依赖收集）</h3><blockquote><p>cb  &#x3D; callback &#x3D; 回调函数 effect(() &#x3D;&gt; {})   &#x2F;&#x2F; () &#x3D;&gt; {} 就是cb</p></blockquote><p>​初始化<strong>effect</strong>函数，通过一个类<strong>ReactiveEffect</strong>运行其<strong>cb</strong>，同时将当前<strong>cb</strong>存储到公共变量，<strong>cb</strong>中读取了<strong>reactive</strong>的属性，进而触发<strong>proxy</strong>的<strong>get</strong>，同时完成<strong>track</strong>（依赖收集），让<strong>reative</strong>收集到存储在公共变量中的<strong>effect</strong>的<strong>cb</strong>，至此完成依赖收集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重点：reactive - key - effect // 依赖收集完成后，将会形成这样的从上到下的可追溯关系</span><br></pre></td></tr></table></figure><h3 id="reactive改变（依赖触发）"><a href="#reactive改变（依赖触发）" class="headerlink" title="reactive改变（依赖触发）"></a>reactive改变（依赖触发）</h3><p>​若干时间后，<strong>reactive</strong>属性发生变化，触发<strong>reactive</strong>属性的赋值操作，进而触发<strong>proxy</strong>的<strong>set</strong>事件，同时完成trigger（依赖触发），根据指定的<strong>reative + key</strong>，找到特定<strong>effect</strong>运行，完成依赖触发，形成响应式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重点：reactive + key 找到指定effect，进而完成触发</span><br></pre></td></tr></table></figure><h2 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h2><h3 id="proxy处理"><a href="#proxy处理" class="headerlink" title="proxy处理"></a>proxy处理</h3><p>​经过真实的源码分析之后，我们都知道<strong>reactive</strong>实际上就是<strong>proxy</strong>，我们仿照源码的格式，将<strong>reactive</strong>经过<strong>proxy</strong>处理后返回就好了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存proxy</span></span><br><span class="line"><span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">object</span>, <span class="built_in">any</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(target, mutableHandlers, reactiveMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理被代理对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;<span class="built_in">object</span>&gt;,</span></span><br><span class="line"><span class="params">  proxyMap: <span class="built_in">WeakMap</span>&lt;<span class="built_in">object</span>, <span class="built_in">any</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果已经被代理过,这直接返回结果</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, baseHandlers)</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-set函数编写"><a href="#get-set函数编写" class="headerlink" title="get set函数编写"></a>get set函数编写</h3><p>​以上代码我们完成了变量的<strong>proxy</strong>处理，为了完成后续的响应式，我们需要预先声明好<strong>get set</strong>函数，我们依旧仿照源码格式，并只保留核心逻辑，<strong>get</strong>阶段返回结果，并触发<strong>（依赖收集）track</strong>，<strong>set</strong>阶段通过<strong>Reflect</strong>完成赋值，并触发<strong>（依赖触发）trigger</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> get = <span class="title function_">createGetter</span>()</span><br><span class="line"><span class="keyword">const</span> set = <span class="title function_">createSetter</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    <span class="comment">// 核心逻辑: 依赖收集</span></span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, newValue: <span class="built_in">unknown</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    <span class="comment">// 核心逻辑: 依赖触发</span></span><br><span class="line">    <span class="title function_">trigger</span>(target, key, newValue)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="effect实现"><a href="#effect实现" class="headerlink" title="effect实现"></a>effect实现</h3><p><strong>effect</strong>的核心的实现，就是在运行<strong>effect</strong>的时候<strong>保存当前的this</strong>，以便于后续流程中的<strong>依赖收集</strong>，所以其核心代码非常简单，保证一下2点即可。</p><ul><li>运行effect本身</li><li>保存effect的fn到activeEffect即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> effect&lt;T = any&gt;(<span class="attr">fn</span>: <span class="function">() =&gt;</span> T) &#123;</span><br><span class="line">  <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn)</span><br><span class="line">  _effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">activeEffect</span>: <span class="title class_">ReactiveEffect</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span>&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public fn: () =&gt; T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeEffect = <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeEffect = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集（track）"><a href="#依赖收集（track）" class="headerlink" title="依赖收集（track）"></a>依赖收集（track）</h3><p>按照时序，<strong>effect</strong>函数初始化阶段会执行，<strong>effect</strong>函数本身也会被保存到<strong>activeEffect</strong>中，同时触发<strong>effect</strong>中的<strong>reactive</strong>中的<strong>get</strong>事件，进而触发<strong>track</strong>，我们在<strong>track</strong>中完成 <strong>reactive- key - effect之间关系的构建</strong>，确保以后可以在<strong>set</strong>阶段找到<strong>指定的effet的fn</strong>即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="title function_">createDep</span>()</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">trackEffects</span>(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖触发（trigger）"><a href="#依赖触发（trigger）" class="headerlink" title="依赖触发（trigger）"></a>依赖触发（trigger）</h3><p>若干时间后，<strong>reative</strong>中的某个属性发生了变化，也就会发生<strong>set</strong>事件，这时候其实就很简单了，我们只需要通过<strong>reactive - key</strong>找到对应的<strong>effect的fn</strong>，然后执行即可。</p><p><strong>这就形成了我们看到的“响应式”</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span>, newValue: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dep</span>: <span class="title class_">Dep</span> | <span class="literal">undefined</span> = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">triggerEffects</span>(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effects = [...dep]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">    <span class="title function_">triggerEffect</span>(effect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffect</span>(<span class="params">effect: ReactiveEffect</span>) &#123;</span><br><span class="line">  effect.<span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​到此为止，我们简易版的<strong>reactive + effect</strong>的全部源码就完成了，虽然<strong>vue3</strong>的源码很复杂，但是我们抽丝剥茧，仅保留核心逻辑，大幅降低<strong>vue3</strong>源码阅读的难度，让绝大多数的前端开发者都可以读懂核心实现~</p><p>​最后，建议大家<a href="https://github.com/BlueDancers/vue3-mini/tree/reactive">clone</a>源码到本地实际运行一下，静下心来一步一步调试，将简易版逻辑弄明白，有兴趣的可以在看看正式的vue3源码，然后在简历上留下浓墨重彩的一笔~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专栏前言&quot;&gt;&lt;a href=&quot;#专栏前言&quot; class=&quot;headerlink&quot; title=&quot;专栏前言&quot;&gt;&lt;/a&gt;专栏前言&lt;/h2&gt;&lt;p&gt;​	在上一节，我们完成了&lt;strong&gt;vue3&lt;/strong&gt;的&lt;strong&gt;reactive&lt;/strong&gt;的核心</summary>
      
    
    
    
    <category term="JavaScript-2023" scheme="https://bluedancers.github.io/categories/JavaScript-2023/"/>
    
    
    <category term="Vue" scheme="https://bluedancers.github.io/tags/Vue/"/>
    
    <category term="源码解读" scheme="https://bluedancers.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
</feed>
